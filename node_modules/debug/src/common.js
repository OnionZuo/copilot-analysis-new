var require_common = __commonJSMin((exports, module) => {
  function setup(env) {
    createDebug.debug = createDebug, createDebug.default = createDebug, createDebug.coerce = coerce, createDebug.disable = disable, createDebug.enable = enable, createDebug.enabled = enabled, createDebug.humanize = Kxe(), createDebug.destroy = destroy, Object.keys(env).forEach(key => {
      createDebug[key] = env[key];
    }), createDebug.names = [], createDebug.skips = [], createDebug.formatters = {};
    function selectColor(namespace) {
      let hash = 0;
      for (let i = 0; i < namespace.length; i++) hash = (hash << 5) - hash + namespace.charCodeAt(i), hash |= 0;
      return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
    }
    __name(selectColor, "selectColor"), createDebug.selectColor = selectColor;
    function createDebug(namespace) {
      let prevTime,
        enableOverride = null,
        namespacesCache,
        enabledCache;
      function debug(...args) {
        if (!debug.enabled) return;
        let self = debug,
          curr = Number(new Date()),
          ms = curr - (prevTime || curr);
        self.diff = ms, self.prev = prevTime, self.curr = curr, prevTime = curr, args[0] = createDebug.coerce(args[0]), typeof args[0] != "string" && args.unshift("%O");
        let index = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
          if (match === "%%") return "%";
          index++;
          let formatter = createDebug.formatters[format];
          if (typeof formatter == "function") {
            let val = args[index];
            match = formatter.call(self, val), args.splice(index, 1), index--;
          }
          return match;
        }), createDebug.formatArgs.call(self, args), (self.log || createDebug.log).apply(self, args);
      }
      return __name(debug, "debug"), debug.namespace = namespace, debug.useColors = createDebug.useColors(), debug.color = createDebug.selectColor(namespace), debug.extend = extend, debug.destroy = createDebug.destroy, Object.defineProperty(debug, "enabled", {
        enumerable: !0,
        configurable: !1,
        get: __name(() => enableOverride !== null ? enableOverride : (namespacesCache !== createDebug.namespaces && (namespacesCache = createDebug.namespaces, enabledCache = createDebug.enabled(namespace)), enabledCache), "get"),
        set: __name(v => {
          enableOverride = v;
        }, "set")
      }), typeof createDebug.init == "function" && createDebug.init(debug), debug;
    }
    __name(createDebug, "createDebug");
    function extend(namespace, delimiter) {
      let newDebug = createDebug(this.namespace + (typeof delimiter > "u" ? ":" : delimiter) + namespace);
      return newDebug.log = this.log, newDebug;
    }
    __name(extend, "extend");
    function enable(namespaces) {
      createDebug.save(namespaces), createDebug.namespaces = namespaces, createDebug.names = [], createDebug.skips = [];
      let i,
        split = (typeof namespaces == "string" ? namespaces : "").split(/[\s,]+/),
        len = split.length;
      for (i = 0; i < len; i++) split[i] && (namespaces = split[i].replace(/\*/g, ".*?"), namespaces[0] === "-" ? createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$")) : createDebug.names.push(new RegExp("^" + namespaces + "$")));
    }
    __name(enable, "enable");
    function disable() {
      let namespaces = [...createDebug.names.map(toNamespace), ...createDebug.skips.map(toNamespace).map(namespace => "-" + namespace)].join(",");
      return createDebug.enable(""), namespaces;
    }
    __name(disable, "disable");
    function enabled(name) {
      if (name[name.length - 1] === "*") return !0;
      let i, len;
      for (i = 0, len = createDebug.skips.length; i < len; i++) if (createDebug.skips[i].test(name)) return !1;
      for (i = 0, len = createDebug.names.length; i < len; i++) if (createDebug.names[i].test(name)) return !0;
      return !1;
    }
    __name(enabled, "enabled");
    function toNamespace(regexp) {
      return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
    }
    __name(toNamespace, "toNamespace");
    function coerce(val) {
      return val instanceof Error ? val.stack || val.message : val;
    }
    __name(coerce, "coerce");
    function destroy() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }
    return __name(destroy, "destroy"), createDebug.enable(createDebug.load()), createDebug;
  }
  __name(setup, "setup");
  module.exports = setup;
});