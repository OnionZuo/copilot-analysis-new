var require_x509 = __commonJSMin((exports, module) => {
  var forge = Ja();
  Fw();
  Md();
  J9();
  Cf();
  d7e();
  Tw();
  Ux();
  sz();
  eS();
  Ki();
  var asn1 = forge.asn1,
    pki = module.exports = forge.pki = forge.pki || {},
    oids = pki.oids,
    _shortNames = {};
  _shortNames.CN = oids.commonName;
  _shortNames.commonName = "CN";
  _shortNames.C = oids.countryName;
  _shortNames.countryName = "C";
  _shortNames.L = oids.localityName;
  _shortNames.localityName = "L";
  _shortNames.ST = oids.stateOrProvinceName;
  _shortNames.stateOrProvinceName = "ST";
  _shortNames.O = oids.organizationName;
  _shortNames.organizationName = "O";
  _shortNames.OU = oids.organizationalUnitName;
  _shortNames.organizationalUnitName = "OU";
  _shortNames.E = oids.emailAddress;
  _shortNames.emailAddress = "E";
  var publicKeyValidator = forge.pki.rsa.publicKeyValidator,
    x509CertificateValidator = {
      name: "Certificate",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: !0,
      value: [{
        name: "Certificate.TBSCertificate",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: !0,
        captureAsn1: "tbsCertificate",
        value: [{
          name: "Certificate.TBSCertificate.version",
          tagClass: asn1.Class.CONTEXT_SPECIFIC,
          type: 0,
          constructed: !0,
          optional: !0,
          value: [{
            name: "Certificate.TBSCertificate.version.integer",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.INTEGER,
            constructed: !1,
            capture: "certVersion"
          }]
        }, {
          name: "Certificate.TBSCertificate.serialNumber",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.INTEGER,
          constructed: !1,
          capture: "certSerialNumber"
        }, {
          name: "Certificate.TBSCertificate.signature",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: !0,
          value: [{
            name: "Certificate.TBSCertificate.signature.algorithm",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.OID,
            constructed: !1,
            capture: "certinfoSignatureOid"
          }, {
            name: "Certificate.TBSCertificate.signature.parameters",
            tagClass: asn1.Class.UNIVERSAL,
            optional: !0,
            captureAsn1: "certinfoSignatureParams"
          }]
        }, {
          name: "Certificate.TBSCertificate.issuer",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: !0,
          captureAsn1: "certIssuer"
        }, {
          name: "Certificate.TBSCertificate.validity",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: !0,
          value: [{
            name: "Certificate.TBSCertificate.validity.notBefore (utc)",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.UTCTIME,
            constructed: !1,
            optional: !0,
            capture: "certValidity1UTCTime"
          }, {
            name: "Certificate.TBSCertificate.validity.notBefore (generalized)",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.GENERALIZEDTIME,
            constructed: !1,
            optional: !0,
            capture: "certValidity2GeneralizedTime"
          }, {
            name: "Certificate.TBSCertificate.validity.notAfter (utc)",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.UTCTIME,
            constructed: !1,
            optional: !0,
            capture: "certValidity3UTCTime"
          }, {
            name: "Certificate.TBSCertificate.validity.notAfter (generalized)",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.GENERALIZEDTIME,
            constructed: !1,
            optional: !0,
            capture: "certValidity4GeneralizedTime"
          }]
        }, {
          name: "Certificate.TBSCertificate.subject",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: !0,
          captureAsn1: "certSubject"
        }, publicKeyValidator, {
          name: "Certificate.TBSCertificate.issuerUniqueID",
          tagClass: asn1.Class.CONTEXT_SPECIFIC,
          type: 1,
          constructed: !0,
          optional: !0,
          value: [{
            name: "Certificate.TBSCertificate.issuerUniqueID.id",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.BITSTRING,
            constructed: !1,
            captureBitStringValue: "certIssuerUniqueId"
          }]
        }, {
          name: "Certificate.TBSCertificate.subjectUniqueID",
          tagClass: asn1.Class.CONTEXT_SPECIFIC,
          type: 2,
          constructed: !0,
          optional: !0,
          value: [{
            name: "Certificate.TBSCertificate.subjectUniqueID.id",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.BITSTRING,
            constructed: !1,
            captureBitStringValue: "certSubjectUniqueId"
          }]
        }, {
          name: "Certificate.TBSCertificate.extensions",
          tagClass: asn1.Class.CONTEXT_SPECIFIC,
          type: 3,
          constructed: !0,
          captureAsn1: "certExtensions",
          optional: !0
        }]
      }, {
        name: "Certificate.signatureAlgorithm",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: !0,
        value: [{
          name: "Certificate.signatureAlgorithm.algorithm",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: !1,
          capture: "certSignatureOid"
        }, {
          name: "Certificate.TBSCertificate.signature.parameters",
          tagClass: asn1.Class.UNIVERSAL,
          optional: !0,
          captureAsn1: "certSignatureParams"
        }]
      }, {
        name: "Certificate.signatureValue",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.BITSTRING,
        constructed: !1,
        captureBitStringValue: "certSignature"
      }]
    },
    rsassaPssParameterValidator = {
      name: "rsapss",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: !0,
      value: [{
        name: "rsapss.hashAlgorithm",
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        type: 0,
        constructed: !0,
        value: [{
          name: "rsapss.hashAlgorithm.AlgorithmIdentifier",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Class.SEQUENCE,
          constructed: !0,
          optional: !0,
          value: [{
            name: "rsapss.hashAlgorithm.AlgorithmIdentifier.algorithm",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.OID,
            constructed: !1,
            capture: "hashOid"
          }]
        }]
      }, {
        name: "rsapss.maskGenAlgorithm",
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        type: 1,
        constructed: !0,
        value: [{
          name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Class.SEQUENCE,
          constructed: !0,
          optional: !0,
          value: [{
            name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier.algorithm",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.OID,
            constructed: !1,
            capture: "maskGenOid"
          }, {
            name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier.params",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SEQUENCE,
            constructed: !0,
            value: [{
              name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier.params.algorithm",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.OID,
              constructed: !1,
              capture: "maskGenHashOid"
            }]
          }]
        }]
      }, {
        name: "rsapss.saltLength",
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        type: 2,
        optional: !0,
        value: [{
          name: "rsapss.saltLength.saltLength",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Class.INTEGER,
          constructed: !1,
          capture: "saltLength"
        }]
      }, {
        name: "rsapss.trailerField",
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        type: 3,
        optional: !0,
        value: [{
          name: "rsapss.trailer.trailer",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Class.INTEGER,
          constructed: !1,
          capture: "trailer"
        }]
      }]
    },
    certificationRequestInfoValidator = {
      name: "CertificationRequestInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: !0,
      captureAsn1: "certificationRequestInfo",
      value: [{
        name: "CertificationRequestInfo.integer",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: !1,
        capture: "certificationRequestInfoVersion"
      }, {
        name: "CertificationRequestInfo.subject",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: !0,
        captureAsn1: "certificationRequestInfoSubject"
      }, publicKeyValidator, {
        name: "CertificationRequestInfo.attributes",
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        type: 0,
        constructed: !0,
        optional: !0,
        capture: "certificationRequestInfoAttributes",
        value: [{
          name: "CertificationRequestInfo.attributes",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: !0,
          value: [{
            name: "CertificationRequestInfo.attributes.type",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.OID,
            constructed: !1
          }, {
            name: "CertificationRequestInfo.attributes.value",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SET,
            constructed: !0
          }]
        }]
      }]
    },
    certificationRequestValidator = {
      name: "CertificationRequest",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: !0,
      captureAsn1: "csr",
      value: [certificationRequestInfoValidator, {
        name: "CertificationRequest.signatureAlgorithm",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: !0,
        value: [{
          name: "CertificationRequest.signatureAlgorithm.algorithm",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: !1,
          capture: "csrSignatureOid"
        }, {
          name: "CertificationRequest.signatureAlgorithm.parameters",
          tagClass: asn1.Class.UNIVERSAL,
          optional: !0,
          captureAsn1: "csrSignatureParams"
        }]
      }, {
        name: "CertificationRequest.signature",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.BITSTRING,
        constructed: !1,
        captureBitStringValue: "csrSignature"
      }]
    };
  pki.RDNAttributesAsArray = function (rdn, md) {
    for (var rval = [], set, attr, obj, si = 0; si < rdn.value.length; ++si) {
      set = rdn.value[si];
      for (var i = 0; i < set.value.length; ++i) obj = {}, attr = set.value[i], obj.type = asn1.derToOid(attr.value[0].value), obj.value = attr.value[1].value, obj.valueTagClass = attr.value[1].type, obj.type in oids && (obj.name = oids[obj.type], obj.name in _shortNames && (obj.shortName = _shortNames[obj.name])), md && (md.update(obj.type), md.update(obj.value)), rval.push(obj);
    }
    return rval;
  };
  pki.CRIAttributesAsArray = function (attributes) {
    for (var rval = [], si = 0; si < attributes.length; ++si) for (var seq = attributes[si], type = asn1.derToOid(seq.value[0].value), values = seq.value[1].value, vi = 0; vi < values.length; ++vi) {
      var obj = {};
      if (obj.type = type, obj.value = values[vi].value, obj.valueTagClass = values[vi].type, obj.type in oids && (obj.name = oids[obj.type], obj.name in _shortNames && (obj.shortName = _shortNames[obj.name])), obj.type === oids.extensionRequest) {
        obj.extensions = [];
        for (var ei = 0; ei < obj.value.length; ++ei) obj.extensions.push(pki.certificateExtensionFromAsn1(obj.value[ei]));
      }
      rval.push(obj);
    }
    return rval;
  };
  function _getAttribute(obj, options) {
    typeof options == "string" && (options = {
      shortName: options
    });
    for (var rval = null, attr, i = 0; rval === null && i < obj.attributes.length; ++i) attr = obj.attributes[i], (options.type && options.type === attr.type || options.name && options.name === attr.name || options.shortName && options.shortName === attr.shortName) && (rval = attr);
    return rval;
  }
  __name(_getAttribute, "_getAttribute");
  var _readSignatureParameters = __name(function (oid, obj, fillDefaults) {
      var params = {};
      if (oid !== oids["RSASSA-PSS"]) return params;
      fillDefaults && (params = {
        hash: {
          algorithmOid: oids.sha1
        },
        mgf: {
          algorithmOid: oids.mgf1,
          hash: {
            algorithmOid: oids.sha1
          }
        },
        saltLength: 20
      });
      var capture = {},
        errors = [];
      if (!asn1.validate(obj, rsassaPssParameterValidator, capture, errors)) {
        var error = new Error("Cannot read RSASSA-PSS parameter block.");
        throw error.errors = errors, error;
      }
      return capture.hashOid !== void 0 && (params.hash = params.hash || {}, params.hash.algorithmOid = asn1.derToOid(capture.hashOid)), capture.maskGenOid !== void 0 && (params.mgf = params.mgf || {}, params.mgf.algorithmOid = asn1.derToOid(capture.maskGenOid), params.mgf.hash = params.mgf.hash || {}, params.mgf.hash.algorithmOid = asn1.derToOid(capture.maskGenHashOid)), capture.saltLength !== void 0 && (params.saltLength = capture.saltLength.charCodeAt(0)), params;
    }, "_readSignatureParameters"),
    _createSignatureDigest = __name(function (options) {
      switch (oids[options.signatureOid]) {
        case "sha1WithRSAEncryption":
        case "sha1WithRSASignature":
          return forge.md.sha1.create();
        case "md5WithRSAEncryption":
          return forge.md.md5.create();
        case "sha256WithRSAEncryption":
          return forge.md.sha256.create();
        case "sha384WithRSAEncryption":
          return forge.md.sha384.create();
        case "sha512WithRSAEncryption":
          return forge.md.sha512.create();
        case "RSASSA-PSS":
          return forge.md.sha256.create();
        default:
          var error = new Error("Could not compute " + options.type + " digest. Unknown signature OID.");
          throw error.signatureOid = options.signatureOid, error;
      }
    }, "_createSignatureDigest"),
    _verifySignature = __name(function (options) {
      var cert = options.certificate,
        scheme;
      switch (cert.signatureOid) {
        case oids.sha1WithRSAEncryption:
        case oids.sha1WithRSASignature:
          break;
        case oids["RSASSA-PSS"]:
          var hash, mgf;
          if (hash = oids[cert.signatureParameters.mgf.hash.algorithmOid], hash === void 0 || forge.md[hash] === void 0) {
            var error = new Error("Unsupported MGF hash function.");
            throw error.oid = cert.signatureParameters.mgf.hash.algorithmOid, error.name = hash, error;
          }
          if (mgf = oids[cert.signatureParameters.mgf.algorithmOid], mgf === void 0 || forge.mgf[mgf] === void 0) {
            var error = new Error("Unsupported MGF function.");
            throw error.oid = cert.signatureParameters.mgf.algorithmOid, error.name = mgf, error;
          }
          if (mgf = forge.mgf[mgf].create(forge.md[hash].create()), hash = oids[cert.signatureParameters.hash.algorithmOid], hash === void 0 || forge.md[hash] === void 0) {
            var error = new Error("Unsupported RSASSA-PSS hash function.");
            throw error.oid = cert.signatureParameters.hash.algorithmOid, error.name = hash, error;
          }
          scheme = forge.pss.create(forge.md[hash].create(), mgf, cert.signatureParameters.saltLength);
          break;
      }
      return cert.publicKey.verify(options.md.digest().getBytes(), options.signature, scheme);
    }, "_verifySignature");
  pki.certificateFromPem = function (pem, computeHash, strict) {
    var msg = forge.pem.decode(pem)[0];
    if (msg.type !== "CERTIFICATE" && msg.type !== "X509 CERTIFICATE" && msg.type !== "TRUSTED CERTIFICATE") {
      var error = new Error('Could not convert certificate from PEM; PEM header type is not "CERTIFICATE", "X509 CERTIFICATE", or "TRUSTED CERTIFICATE".');
      throw error.headerType = msg.type, error;
    }
    if (msg.procType && msg.procType.type === "ENCRYPTED") throw new Error("Could not convert certificate from PEM; PEM is encrypted.");
    var obj = asn1.fromDer(msg.body, strict);
    return pki.certificateFromAsn1(obj, computeHash);
  };
  pki.certificateToPem = function (cert, maxline) {
    var msg = {
      type: "CERTIFICATE",
      body: asn1.toDer(pki.certificateToAsn1(cert)).getBytes()
    };
    return forge.pem.encode(msg, {
      maxline: maxline
    });
  };
  pki.publicKeyFromPem = function (pem) {
    var msg = forge.pem.decode(pem)[0];
    if (msg.type !== "PUBLIC KEY" && msg.type !== "RSA PUBLIC KEY") {
      var error = new Error('Could not convert public key from PEM; PEM header type is not "PUBLIC KEY" or "RSA PUBLIC KEY".');
      throw error.headerType = msg.type, error;
    }
    if (msg.procType && msg.procType.type === "ENCRYPTED") throw new Error("Could not convert public key from PEM; PEM is encrypted.");
    var obj = asn1.fromDer(msg.body);
    return pki.publicKeyFromAsn1(obj);
  };
  pki.publicKeyToPem = function (key, maxline) {
    var msg = {
      type: "PUBLIC KEY",
      body: asn1.toDer(pki.publicKeyToAsn1(key)).getBytes()
    };
    return forge.pem.encode(msg, {
      maxline: maxline
    });
  };
  pki.publicKeyToRSAPublicKeyPem = function (key, maxline) {
    var msg = {
      type: "RSA PUBLIC KEY",
      body: asn1.toDer(pki.publicKeyToRSAPublicKey(key)).getBytes()
    };
    return forge.pem.encode(msg, {
      maxline: maxline
    });
  };
  pki.getPublicKeyFingerprint = function (key, options) {
    options = options || {};
    var md = options.md || forge.md.sha1.create(),
      type = options.type || "RSAPublicKey",
      bytes;
    switch (type) {
      case "RSAPublicKey":
        bytes = asn1.toDer(pki.publicKeyToRSAPublicKey(key)).getBytes();
        break;
      case "SubjectPublicKeyInfo":
        bytes = asn1.toDer(pki.publicKeyToAsn1(key)).getBytes();
        break;
      default:
        throw new Error('Unknown fingerprint type "' + options.type + '".');
    }
    md.start(), md.update(bytes);
    var digest = md.digest();
    if (options.encoding === "hex") {
      var hex = digest.toHex();
      return options.delimiter ? hex.match(/.{2}/g).join(options.delimiter) : hex;
    } else {
      if (options.encoding === "binary") return digest.getBytes();
      if (options.encoding) throw new Error('Unknown encoding "' + options.encoding + '".');
    }
    return digest;
  };
  pki.certificationRequestFromPem = function (pem, computeHash, strict) {
    var msg = forge.pem.decode(pem)[0];
    if (msg.type !== "CERTIFICATE REQUEST") {
      var error = new Error('Could not convert certification request from PEM; PEM header type is not "CERTIFICATE REQUEST".');
      throw error.headerType = msg.type, error;
    }
    if (msg.procType && msg.procType.type === "ENCRYPTED") throw new Error("Could not convert certification request from PEM; PEM is encrypted.");
    var obj = asn1.fromDer(msg.body, strict);
    return pki.certificationRequestFromAsn1(obj, computeHash);
  };
  pki.certificationRequestToPem = function (csr, maxline) {
    var msg = {
      type: "CERTIFICATE REQUEST",
      body: asn1.toDer(pki.certificationRequestToAsn1(csr)).getBytes()
    };
    return forge.pem.encode(msg, {
      maxline: maxline
    });
  };
  pki.createCertificate = function () {
    var cert = {};
    return cert.version = 2, cert.serialNumber = "00", cert.signatureOid = null, cert.signature = null, cert.siginfo = {}, cert.siginfo.algorithmOid = null, cert.validity = {}, cert.validity.notBefore = new Date(), cert.validity.notAfter = new Date(), cert.issuer = {}, cert.issuer.getField = function (sn) {
      return _getAttribute(cert.issuer, sn);
    }, cert.issuer.addField = function (attr) {
      _fillMissingFields([attr]), cert.issuer.attributes.push(attr);
    }, cert.issuer.attributes = [], cert.issuer.hash = null, cert.subject = {}, cert.subject.getField = function (sn) {
      return _getAttribute(cert.subject, sn);
    }, cert.subject.addField = function (attr) {
      _fillMissingFields([attr]), cert.subject.attributes.push(attr);
    }, cert.subject.attributes = [], cert.subject.hash = null, cert.extensions = [], cert.publicKey = null, cert.md = null, cert.setSubject = function (attrs, uniqueId) {
      _fillMissingFields(attrs), cert.subject.attributes = attrs, delete cert.subject.uniqueId, uniqueId && (cert.subject.uniqueId = uniqueId), cert.subject.hash = null;
    }, cert.setIssuer = function (attrs, uniqueId) {
      _fillMissingFields(attrs), cert.issuer.attributes = attrs, delete cert.issuer.uniqueId, uniqueId && (cert.issuer.uniqueId = uniqueId), cert.issuer.hash = null;
    }, cert.setExtensions = function (exts) {
      for (var i = 0; i < exts.length; ++i) _fillMissingExtensionFields(exts[i], {
        cert: cert
      });
      cert.extensions = exts;
    }, cert.getExtension = function (options) {
      typeof options == "string" && (options = {
        name: options
      });
      for (var rval = null, ext, i = 0; rval === null && i < cert.extensions.length; ++i) ext = cert.extensions[i], (options.id && ext.id === options.id || options.name && ext.name === options.name) && (rval = ext);
      return rval;
    }, cert.sign = function (key, md) {
      cert.md = md || forge.md.sha1.create();
      var algorithmOid = oids[cert.md.algorithm + "WithRSAEncryption"];
      if (!algorithmOid) {
        var error = new Error("Could not compute certificate digest. Unknown message digest algorithm OID.");
        throw error.algorithm = cert.md.algorithm, error;
      }
      cert.signatureOid = cert.siginfo.algorithmOid = algorithmOid, cert.tbsCertificate = pki.getTBSCertificate(cert);
      var bytes = asn1.toDer(cert.tbsCertificate);
      cert.md.update(bytes.getBytes()), cert.signature = key.sign(cert.md);
    }, cert.verify = function (child) {
      var rval = !1;
      if (!cert.issued(child)) {
        var issuer = child.issuer,
          subject = cert.subject,
          error = new Error("The parent certificate did not issue the given child certificate; the child certificate's issuer does not match the parent's subject.");
        throw error.expectedIssuer = subject.attributes, error.actualIssuer = issuer.attributes, error;
      }
      var md = child.md;
      if (md === null) {
        md = _createSignatureDigest({
          signatureOid: child.signatureOid,
          type: "certificate"
        });
        var tbsCertificate = child.tbsCertificate || pki.getTBSCertificate(child),
          bytes = asn1.toDer(tbsCertificate);
        md.update(bytes.getBytes());
      }
      return md !== null && (rval = _verifySignature({
        certificate: cert,
        md: md,
        signature: child.signature
      })), rval;
    }, cert.isIssuer = function (parent) {
      var rval = !1,
        i = cert.issuer,
        s = parent.subject;
      if (i.hash && s.hash) rval = i.hash === s.hash;else if (i.attributes.length === s.attributes.length) {
        rval = !0;
        for (var iattr, sattr, n = 0; rval && n < i.attributes.length; ++n) iattr = i.attributes[n], sattr = s.attributes[n], (iattr.type !== sattr.type || iattr.value !== sattr.value) && (rval = !1);
      }
      return rval;
    }, cert.issued = function (child) {
      return child.isIssuer(cert);
    }, cert.generateSubjectKeyIdentifier = function () {
      return pki.getPublicKeyFingerprint(cert.publicKey, {
        type: "RSAPublicKey"
      });
    }, cert.verifySubjectKeyIdentifier = function () {
      for (var oid = oids.subjectKeyIdentifier, i = 0; i < cert.extensions.length; ++i) {
        var ext = cert.extensions[i];
        if (ext.id === oid) {
          var ski = cert.generateSubjectKeyIdentifier().getBytes();
          return forge.util.hexToBytes(ext.subjectKeyIdentifier) === ski;
        }
      }
      return !1;
    }, cert;
  };
  pki.certificateFromAsn1 = function (obj, computeHash) {
    var capture = {},
      errors = [];
    if (!asn1.validate(obj, x509CertificateValidator, capture, errors)) {
      var error = new Error("Cannot read X.509 certificate. ASN.1 object is not an X509v3 Certificate.");
      throw error.errors = errors, error;
    }
    var oid = asn1.derToOid(capture.publicKeyOid);
    if (oid !== pki.oids.rsaEncryption) throw new Error("Cannot read public key. OID is not RSA.");
    var cert = pki.createCertificate();
    cert.version = capture.certVersion ? capture.certVersion.charCodeAt(0) : 0;
    var serial = forge.util.createBuffer(capture.certSerialNumber);
    cert.serialNumber = serial.toHex(), cert.signatureOid = forge.asn1.derToOid(capture.certSignatureOid), cert.signatureParameters = _readSignatureParameters(cert.signatureOid, capture.certSignatureParams, !0), cert.siginfo.algorithmOid = forge.asn1.derToOid(capture.certinfoSignatureOid), cert.siginfo.parameters = _readSignatureParameters(cert.siginfo.algorithmOid, capture.certinfoSignatureParams, !1), cert.signature = capture.certSignature;
    var validity = [];
    if (capture.certValidity1UTCTime !== void 0 && validity.push(asn1.utcTimeToDate(capture.certValidity1UTCTime)), capture.certValidity2GeneralizedTime !== void 0 && validity.push(asn1.generalizedTimeToDate(capture.certValidity2GeneralizedTime)), capture.certValidity3UTCTime !== void 0 && validity.push(asn1.utcTimeToDate(capture.certValidity3UTCTime)), capture.certValidity4GeneralizedTime !== void 0 && validity.push(asn1.generalizedTimeToDate(capture.certValidity4GeneralizedTime)), validity.length > 2) throw new Error("Cannot read notBefore/notAfter validity times; more than two times were provided in the certificate.");
    if (validity.length < 2) throw new Error("Cannot read notBefore/notAfter validity times; they were not provided as either UTCTime or GeneralizedTime.");
    if (cert.validity.notBefore = validity[0], cert.validity.notAfter = validity[1], cert.tbsCertificate = capture.tbsCertificate, computeHash) {
      cert.md = _createSignatureDigest({
        signatureOid: cert.signatureOid,
        type: "certificate"
      });
      var bytes = asn1.toDer(cert.tbsCertificate);
      cert.md.update(bytes.getBytes());
    }
    var imd = forge.md.sha1.create(),
      ibytes = asn1.toDer(capture.certIssuer);
    imd.update(ibytes.getBytes()), cert.issuer.getField = function (sn) {
      return _getAttribute(cert.issuer, sn);
    }, cert.issuer.addField = function (attr) {
      _fillMissingFields([attr]), cert.issuer.attributes.push(attr);
    }, cert.issuer.attributes = pki.RDNAttributesAsArray(capture.certIssuer), capture.certIssuerUniqueId && (cert.issuer.uniqueId = capture.certIssuerUniqueId), cert.issuer.hash = imd.digest().toHex();
    var smd = forge.md.sha1.create(),
      sbytes = asn1.toDer(capture.certSubject);
    return smd.update(sbytes.getBytes()), cert.subject.getField = function (sn) {
      return _getAttribute(cert.subject, sn);
    }, cert.subject.addField = function (attr) {
      _fillMissingFields([attr]), cert.subject.attributes.push(attr);
    }, cert.subject.attributes = pki.RDNAttributesAsArray(capture.certSubject), capture.certSubjectUniqueId && (cert.subject.uniqueId = capture.certSubjectUniqueId), cert.subject.hash = smd.digest().toHex(), capture.certExtensions ? cert.extensions = pki.certificateExtensionsFromAsn1(capture.certExtensions) : cert.extensions = [], cert.publicKey = pki.publicKeyFromAsn1(capture.subjectPublicKeyInfo), cert;
  };
  pki.certificateExtensionsFromAsn1 = function (exts) {
    for (var rval = [], i = 0; i < exts.value.length; ++i) for (var extseq = exts.value[i], ei = 0; ei < extseq.value.length; ++ei) rval.push(pki.certificateExtensionFromAsn1(extseq.value[ei]));
    return rval;
  };
  pki.certificateExtensionFromAsn1 = function (ext) {
    var e = {};
    if (e.id = asn1.derToOid(ext.value[0].value), e.critical = !1, ext.value[1].type === asn1.Type.BOOLEAN ? (e.critical = ext.value[1].value.charCodeAt(0) !== 0, e.value = ext.value[2].value) : e.value = ext.value[1].value, e.id in oids) {
      if (e.name = oids[e.id], e.name === "keyUsage") {
        var ev = asn1.fromDer(e.value),
          b2 = 0,
          b3 = 0;
        ev.value.length > 1 && (b2 = ev.value.charCodeAt(1), b3 = ev.value.length > 2 ? ev.value.charCodeAt(2) : 0), e.digitalSignature = (b2 & 128) === 128, e.nonRepudiation = (b2 & 64) === 64, e.keyEncipherment = (b2 & 32) === 32, e.dataEncipherment = (b2 & 16) === 16, e.keyAgreement = (b2 & 8) === 8, e.keyCertSign = (b2 & 4) === 4, e.cRLSign = (b2 & 2) === 2, e.encipherOnly = (b2 & 1) === 1, e.decipherOnly = (b3 & 128) === 128;
      } else if (e.name === "basicConstraints") {
        var ev = asn1.fromDer(e.value);
        ev.value.length > 0 && ev.value[0].type === asn1.Type.BOOLEAN ? e.cA = ev.value[0].value.charCodeAt(0) !== 0 : e.cA = !1;
        var value = null;
        ev.value.length > 0 && ev.value[0].type === asn1.Type.INTEGER ? value = ev.value[0].value : ev.value.length > 1 && (value = ev.value[1].value), value !== null && (e.pathLenConstraint = asn1.derToInteger(value));
      } else if (e.name === "extKeyUsage") for (var ev = asn1.fromDer(e.value), vi = 0; vi < ev.value.length; ++vi) {
        var oid = asn1.derToOid(ev.value[vi].value);
        oid in oids ? e[oids[oid]] = !0 : e[oid] = !0;
      } else if (e.name === "nsCertType") {
        var ev = asn1.fromDer(e.value),
          b2 = 0;
        ev.value.length > 1 && (b2 = ev.value.charCodeAt(1)), e.client = (b2 & 128) === 128, e.server = (b2 & 64) === 64, e.email = (b2 & 32) === 32, e.objsign = (b2 & 16) === 16, e.reserved = (b2 & 8) === 8, e.sslCA = (b2 & 4) === 4, e.emailCA = (b2 & 2) === 2, e.objCA = (b2 & 1) === 1;
      } else if (e.name === "subjectAltName" || e.name === "issuerAltName") {
        e.altNames = [];
        for (var gn, ev = asn1.fromDer(e.value), n = 0; n < ev.value.length; ++n) {
          gn = ev.value[n];
          var altName = {
            type: gn.type,
            value: gn.value
          };
          switch (e.altNames.push(altName), gn.type) {
            case 1:
            case 2:
            case 6:
              break;
            case 7:
              altName.ip = forge.util.bytesToIP(gn.value);
              break;
            case 8:
              altName.oid = asn1.derToOid(gn.value);
              break;
            default:
          }
        }
      } else if (e.name === "subjectKeyIdentifier") {
        var ev = asn1.fromDer(e.value);
        e.subjectKeyIdentifier = forge.util.bytesToHex(ev.value);
      }
    }
    return e;
  };
  pki.certificationRequestFromAsn1 = function (obj, computeHash) {
    var capture = {},
      errors = [];
    if (!asn1.validate(obj, certificationRequestValidator, capture, errors)) {
      var error = new Error("Cannot read PKCS#10 certificate request. ASN.1 object is not a PKCS#10 CertificationRequest.");
      throw error.errors = errors, error;
    }
    var oid = asn1.derToOid(capture.publicKeyOid);
    if (oid !== pki.oids.rsaEncryption) throw new Error("Cannot read public key. OID is not RSA.");
    var csr = pki.createCertificationRequest();
    if (csr.version = capture.csrVersion ? capture.csrVersion.charCodeAt(0) : 0, csr.signatureOid = forge.asn1.derToOid(capture.csrSignatureOid), csr.signatureParameters = _readSignatureParameters(csr.signatureOid, capture.csrSignatureParams, !0), csr.siginfo.algorithmOid = forge.asn1.derToOid(capture.csrSignatureOid), csr.siginfo.parameters = _readSignatureParameters(csr.siginfo.algorithmOid, capture.csrSignatureParams, !1), csr.signature = capture.csrSignature, csr.certificationRequestInfo = capture.certificationRequestInfo, computeHash) {
      csr.md = _createSignatureDigest({
        signatureOid: csr.signatureOid,
        type: "certification request"
      });
      var bytes = asn1.toDer(csr.certificationRequestInfo);
      csr.md.update(bytes.getBytes());
    }
    var smd = forge.md.sha1.create();
    return csr.subject.getField = function (sn) {
      return _getAttribute(csr.subject, sn);
    }, csr.subject.addField = function (attr) {
      _fillMissingFields([attr]), csr.subject.attributes.push(attr);
    }, csr.subject.attributes = pki.RDNAttributesAsArray(capture.certificationRequestInfoSubject, smd), csr.subject.hash = smd.digest().toHex(), csr.publicKey = pki.publicKeyFromAsn1(capture.subjectPublicKeyInfo), csr.getAttribute = function (sn) {
      return _getAttribute(csr, sn);
    }, csr.addAttribute = function (attr) {
      _fillMissingFields([attr]), csr.attributes.push(attr);
    }, csr.attributes = pki.CRIAttributesAsArray(capture.certificationRequestInfoAttributes || []), csr;
  };
  pki.createCertificationRequest = function () {
    var csr = {};
    return csr.version = 0, csr.signatureOid = null, csr.signature = null, csr.siginfo = {}, csr.siginfo.algorithmOid = null, csr.subject = {}, csr.subject.getField = function (sn) {
      return _getAttribute(csr.subject, sn);
    }, csr.subject.addField = function (attr) {
      _fillMissingFields([attr]), csr.subject.attributes.push(attr);
    }, csr.subject.attributes = [], csr.subject.hash = null, csr.publicKey = null, csr.attributes = [], csr.getAttribute = function (sn) {
      return _getAttribute(csr, sn);
    }, csr.addAttribute = function (attr) {
      _fillMissingFields([attr]), csr.attributes.push(attr);
    }, csr.md = null, csr.setSubject = function (attrs) {
      _fillMissingFields(attrs), csr.subject.attributes = attrs, csr.subject.hash = null;
    }, csr.setAttributes = function (attrs) {
      _fillMissingFields(attrs), csr.attributes = attrs;
    }, csr.sign = function (key, md) {
      csr.md = md || forge.md.sha1.create();
      var algorithmOid = oids[csr.md.algorithm + "WithRSAEncryption"];
      if (!algorithmOid) {
        var error = new Error("Could not compute certification request digest. Unknown message digest algorithm OID.");
        throw error.algorithm = csr.md.algorithm, error;
      }
      csr.signatureOid = csr.siginfo.algorithmOid = algorithmOid, csr.certificationRequestInfo = pki.getCertificationRequestInfo(csr);
      var bytes = asn1.toDer(csr.certificationRequestInfo);
      csr.md.update(bytes.getBytes()), csr.signature = key.sign(csr.md);
    }, csr.verify = function () {
      var rval = !1,
        md = csr.md;
      if (md === null) {
        md = _createSignatureDigest({
          signatureOid: csr.signatureOid,
          type: "certification request"
        });
        var cri = csr.certificationRequestInfo || pki.getCertificationRequestInfo(csr),
          bytes = asn1.toDer(cri);
        md.update(bytes.getBytes());
      }
      return md !== null && (rval = _verifySignature({
        certificate: csr,
        md: md,
        signature: csr.signature
      })), rval;
    }, csr;
  };
  function _dnToAsn1(obj) {
    for (var rval = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, !0, []), attr, set, attrs = obj.attributes, i = 0; i < attrs.length; ++i) {
      attr = attrs[i];
      var value = attr.value,
        valueTagClass = asn1.Type.PRINTABLESTRING;
      "valueTagClass" in attr && (valueTagClass = attr.valueTagClass, valueTagClass === asn1.Type.UTF8 && (value = forge.util.encodeUtf8(value))), set = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, !0, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, !0, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, !1, asn1.oidToDer(attr.type).getBytes()), asn1.create(asn1.Class.UNIVERSAL, valueTagClass, !1, value)])]), rval.value.push(set);
    }
    return rval;
  }
  __name(_dnToAsn1, "_dnToAsn1");
  function _fillMissingFields(attrs) {
    for (var attr, i = 0; i < attrs.length; ++i) {
      if (attr = attrs[i], typeof attr.name > "u" && (attr.type && attr.type in pki.oids ? attr.name = pki.oids[attr.type] : attr.shortName && attr.shortName in _shortNames && (attr.name = pki.oids[_shortNames[attr.shortName]])), typeof attr.type > "u") if (attr.name && attr.name in pki.oids) attr.type = pki.oids[attr.name];else {
        var error = new Error("Attribute type not specified.");
        throw error.attribute = attr, error;
      }
      if (typeof attr.shortName > "u" && attr.name && attr.name in _shortNames && (attr.shortName = _shortNames[attr.name]), attr.type === oids.extensionRequest && (attr.valueConstructed = !0, attr.valueTagClass = asn1.Type.SEQUENCE, !attr.value && attr.extensions)) {
        attr.value = [];
        for (var ei = 0; ei < attr.extensions.length; ++ei) attr.value.push(pki.certificateExtensionToAsn1(_fillMissingExtensionFields(attr.extensions[ei])));
      }
      if (typeof attr.value > "u") {
        var error = new Error("Attribute value not specified.");
        throw error.attribute = attr, error;
      }
    }
  }
  __name(_fillMissingFields, "_fillMissingFields");
  function _fillMissingExtensionFields(e, options) {
    if (options = options || {}, typeof e.name > "u" && e.id && e.id in pki.oids && (e.name = pki.oids[e.id]), typeof e.id > "u") if (e.name && e.name in pki.oids) e.id = pki.oids[e.name];else {
      var error = new Error("Extension ID not specified.");
      throw error.extension = e, error;
    }
    if (typeof e.value < "u") return e;
    if (e.name === "keyUsage") {
      var unused = 0,
        b2 = 0,
        b3 = 0;
      e.digitalSignature && (b2 |= 128, unused = 7), e.nonRepudiation && (b2 |= 64, unused = 6), e.keyEncipherment && (b2 |= 32, unused = 5), e.dataEncipherment && (b2 |= 16, unused = 4), e.keyAgreement && (b2 |= 8, unused = 3), e.keyCertSign && (b2 |= 4, unused = 2), e.cRLSign && (b2 |= 2, unused = 1), e.encipherOnly && (b2 |= 1, unused = 0), e.decipherOnly && (b3 |= 128, unused = 7);
      var value = String.fromCharCode(unused);
      b3 !== 0 ? value += String.fromCharCode(b2) + String.fromCharCode(b3) : b2 !== 0 && (value += String.fromCharCode(b2)), e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, !1, value);
    } else if (e.name === "basicConstraints") e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, !0, []), e.cA && e.value.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BOOLEAN, !1, "\xFF")), "pathLenConstraint" in e && e.value.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, !1, asn1.integerToDer(e.pathLenConstraint).getBytes()));else if (e.name === "extKeyUsage") {
      e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, !0, []);
      var seq = e.value.value;
      for (var key in e) e[key] === !0 && (key in oids ? seq.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, !1, asn1.oidToDer(oids[key]).getBytes())) : key.indexOf(".") !== -1 && seq.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, !1, asn1.oidToDer(key).getBytes())));
    } else if (e.name === "nsCertType") {
      var unused = 0,
        b2 = 0;
      e.client && (b2 |= 128, unused = 7), e.server && (b2 |= 64, unused = 6), e.email && (b2 |= 32, unused = 5), e.objsign && (b2 |= 16, unused = 4), e.reserved && (b2 |= 8, unused = 3), e.sslCA && (b2 |= 4, unused = 2), e.emailCA && (b2 |= 2, unused = 1), e.objCA && (b2 |= 1, unused = 0);
      var value = String.fromCharCode(unused);
      b2 !== 0 && (value += String.fromCharCode(b2)), e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, !1, value);
    } else if (e.name === "subjectAltName" || e.name === "issuerAltName") {
      e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, !0, []);
      for (var altName, n = 0; n < e.altNames.length; ++n) {
        altName = e.altNames[n];
        var value = altName.value;
        if (altName.type === 7 && altName.ip) {
          if (value = forge.util.bytesFromIP(altName.ip), value === null) {
            var error = new Error('Extension "ip" value is not a valid IPv4 or IPv6 address.');
            throw error.extension = e, error;
          }
        } else altName.type === 8 && (altName.oid ? value = asn1.oidToDer(asn1.oidToDer(altName.oid)) : value = asn1.oidToDer(value));
        e.value.value.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, altName.type, !1, value));
      }
    } else if (e.name === "nsComment" && options.cert) {
      if (!/^[\x00-\x7F]*$/.test(e.comment) || e.comment.length < 1 || e.comment.length > 128) throw new Error('Invalid "nsComment" content.');
      e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.IA5STRING, !1, e.comment);
    } else if (e.name === "subjectKeyIdentifier" && options.cert) {
      var ski = options.cert.generateSubjectKeyIdentifier();
      e.subjectKeyIdentifier = ski.toHex(), e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, !1, ski.getBytes());
    } else if (e.name === "authorityKeyIdentifier" && options.cert) {
      e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, !0, []);
      var seq = e.value.value;
      if (e.keyIdentifier) {
        var keyIdentifier = e.keyIdentifier === !0 ? options.cert.generateSubjectKeyIdentifier().getBytes() : e.keyIdentifier;
        seq.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, !1, keyIdentifier));
      }
      if (e.authorityCertIssuer) {
        var authorityCertIssuer = [asn1.create(asn1.Class.CONTEXT_SPECIFIC, 4, !0, [_dnToAsn1(e.authorityCertIssuer === !0 ? options.cert.issuer : e.authorityCertIssuer)])];
        seq.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, !0, authorityCertIssuer));
      }
      if (e.serialNumber) {
        var serialNumber = forge.util.hexToBytes(e.serialNumber === !0 ? options.cert.serialNumber : e.serialNumber);
        seq.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 2, !1, serialNumber));
      }
    } else if (e.name === "cRLDistributionPoints") {
      e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, !0, []);
      for (var seq = e.value.value, subSeq = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, !0, []), fullNameGeneralNames = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, !0, []), altName, n = 0; n < e.altNames.length; ++n) {
        altName = e.altNames[n];
        var value = altName.value;
        if (altName.type === 7 && altName.ip) {
          if (value = forge.util.bytesFromIP(altName.ip), value === null) {
            var error = new Error('Extension "ip" value is not a valid IPv4 or IPv6 address.');
            throw error.extension = e, error;
          }
        } else altName.type === 8 && (altName.oid ? value = asn1.oidToDer(asn1.oidToDer(altName.oid)) : value = asn1.oidToDer(value));
        fullNameGeneralNames.value.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, altName.type, !1, value));
      }
      subSeq.value.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, !0, [fullNameGeneralNames])), seq.push(subSeq);
    }
    if (typeof e.value > "u") {
      var error = new Error("Extension value not specified.");
      throw error.extension = e, error;
    }
    return e;
  }
  __name(_fillMissingExtensionFields, "_fillMissingExtensionFields");
  function _signatureParametersToAsn1(oid, params) {
    switch (oid) {
      case oids["RSASSA-PSS"]:
        var parts = [];
        return params.hash.algorithmOid !== void 0 && parts.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, !0, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, !0, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, !1, asn1.oidToDer(params.hash.algorithmOid).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, !1, "")])])), params.mgf.algorithmOid !== void 0 && parts.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, !0, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, !0, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, !1, asn1.oidToDer(params.mgf.algorithmOid).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, !0, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, !1, asn1.oidToDer(params.mgf.hash.algorithmOid).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, !1, "")])])])), params.saltLength !== void 0 && parts.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 2, !0, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, !1, asn1.integerToDer(params.saltLength).getBytes())])), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, !0, parts);
      default:
        return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, !1, "");
    }
  }
  __name(_signatureParametersToAsn1, "_signatureParametersToAsn1");
  function _CRIAttributesToAsn1(csr) {
    var rval = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, !0, []);
    if (csr.attributes.length === 0) return rval;
    for (var attrs = csr.attributes, i = 0; i < attrs.length; ++i) {
      var attr = attrs[i],
        value = attr.value,
        valueTagClass = asn1.Type.UTF8;
      "valueTagClass" in attr && (valueTagClass = attr.valueTagClass), valueTagClass === asn1.Type.UTF8 && (value = forge.util.encodeUtf8(value));
      var valueConstructed = !1;
      "valueConstructed" in attr && (valueConstructed = attr.valueConstructed);
      var seq = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, !0, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, !1, asn1.oidToDer(attr.type).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, !0, [asn1.create(asn1.Class.UNIVERSAL, valueTagClass, valueConstructed, value)])]);
      rval.value.push(seq);
    }
    return rval;
  }
  __name(_CRIAttributesToAsn1, "_CRIAttributesToAsn1");
  var jan_1_1950 = new Date("1950-01-01T00:00:00Z"),
    jan_1_2050 = new Date("2050-01-01T00:00:00Z");
  function _dateToAsn1(date) {
    return date >= jan_1_1950 && date < jan_1_2050 ? asn1.create(asn1.Class.UNIVERSAL, asn1.Type.UTCTIME, !1, asn1.dateToUtcTime(date)) : asn1.create(asn1.Class.UNIVERSAL, asn1.Type.GENERALIZEDTIME, !1, asn1.dateToGeneralizedTime(date));
  }
  __name(_dateToAsn1, "_dateToAsn1");
  pki.getTBSCertificate = function (cert) {
    var notBefore = _dateToAsn1(cert.validity.notBefore),
      notAfter = _dateToAsn1(cert.validity.notAfter),
      tbs = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, !0, [asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, !0, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, !1, asn1.integerToDer(cert.version).getBytes())]), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, !1, forge.util.hexToBytes(cert.serialNumber)), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, !0, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, !1, asn1.oidToDer(cert.siginfo.algorithmOid).getBytes()), _signatureParametersToAsn1(cert.siginfo.algorithmOid, cert.siginfo.parameters)]), _dnToAsn1(cert.issuer), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, !0, [notBefore, notAfter]), _dnToAsn1(cert.subject), pki.publicKeyToAsn1(cert.publicKey)]);
    return cert.issuer.uniqueId && tbs.value.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, !0, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, !1, "\0" + cert.issuer.uniqueId)])), cert.subject.uniqueId && tbs.value.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 2, !0, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, !1, "\0" + cert.subject.uniqueId)])), cert.extensions.length > 0 && tbs.value.push(pki.certificateExtensionsToAsn1(cert.extensions)), tbs;
  };
  pki.getCertificationRequestInfo = function (csr) {
    var cri = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, !0, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, !1, asn1.integerToDer(csr.version).getBytes()), _dnToAsn1(csr.subject), pki.publicKeyToAsn1(csr.publicKey), _CRIAttributesToAsn1(csr)]);
    return cri;
  };
  pki.distinguishedNameToAsn1 = function (dn) {
    return _dnToAsn1(dn);
  };
  pki.certificateToAsn1 = function (cert) {
    var tbsCertificate = cert.tbsCertificate || pki.getTBSCertificate(cert);
    return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, !0, [tbsCertificate, asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, !0, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, !1, asn1.oidToDer(cert.signatureOid).getBytes()), _signatureParametersToAsn1(cert.signatureOid, cert.signatureParameters)]), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, !1, "\0" + cert.signature)]);
  };
  pki.certificateExtensionsToAsn1 = function (exts) {
    var rval = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 3, !0, []),
      seq = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, !0, []);
    rval.value.push(seq);
    for (var i = 0; i < exts.length; ++i) seq.value.push(pki.certificateExtensionToAsn1(exts[i]));
    return rval;
  };
  pki.certificateExtensionToAsn1 = function (ext) {
    var extseq = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, !0, []);
    extseq.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, !1, asn1.oidToDer(ext.id).getBytes())), ext.critical && extseq.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BOOLEAN, !1, "\xFF"));
    var value = ext.value;
    return typeof ext.value != "string" && (value = asn1.toDer(value).getBytes()), extseq.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, !1, value)), extseq;
  };
  pki.certificationRequestToAsn1 = function (csr) {
    var cri = csr.certificationRequestInfo || pki.getCertificationRequestInfo(csr);
    return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, !0, [cri, asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, !0, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, !1, asn1.oidToDer(csr.signatureOid).getBytes()), _signatureParametersToAsn1(csr.signatureOid, csr.signatureParameters)]), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, !1, "\0" + csr.signature)]);
  };
  pki.createCaStore = function (certs) {
    var caStore = {
      certs: {}
    };
    caStore.getIssuer = function (cert) {
      var rval = getBySubject(cert.issuer);
      return rval;
    }, caStore.addCertificate = function (cert) {
      if (typeof cert == "string" && (cert = forge.pki.certificateFromPem(cert)), ensureSubjectHasHash(cert.subject), !caStore.hasCertificate(cert)) if (cert.subject.hash in caStore.certs) {
        var tmp = caStore.certs[cert.subject.hash];
        forge.util.isArray(tmp) || (tmp = [tmp]), tmp.push(cert), caStore.certs[cert.subject.hash] = tmp;
      } else caStore.certs[cert.subject.hash] = cert;
    }, caStore.hasCertificate = function (cert) {
      typeof cert == "string" && (cert = forge.pki.certificateFromPem(cert));
      var match = getBySubject(cert.subject);
      if (!match) return !1;
      forge.util.isArray(match) || (match = [match]);
      for (var der1 = asn1.toDer(pki.certificateToAsn1(cert)).getBytes(), i = 0; i < match.length; ++i) {
        var der2 = asn1.toDer(pki.certificateToAsn1(match[i])).getBytes();
        if (der1 === der2) return !0;
      }
      return !1;
    }, caStore.listAllCertificates = function () {
      var certList = [];
      for (var hash in caStore.certs) if (caStore.certs.hasOwnProperty(hash)) {
        var value = caStore.certs[hash];
        if (!forge.util.isArray(value)) certList.push(value);else for (var i = 0; i < value.length; ++i) certList.push(value[i]);
      }
      return certList;
    }, caStore.removeCertificate = function (cert) {
      var result;
      if (typeof cert == "string" && (cert = forge.pki.certificateFromPem(cert)), ensureSubjectHasHash(cert.subject), !caStore.hasCertificate(cert)) return null;
      var match = getBySubject(cert.subject);
      if (!forge.util.isArray(match)) return result = caStore.certs[cert.subject.hash], delete caStore.certs[cert.subject.hash], result;
      for (var der1 = asn1.toDer(pki.certificateToAsn1(cert)).getBytes(), i = 0; i < match.length; ++i) {
        var der2 = asn1.toDer(pki.certificateToAsn1(match[i])).getBytes();
        der1 === der2 && (result = match[i], match.splice(i, 1));
      }
      return match.length === 0 && delete caStore.certs[cert.subject.hash], result;
    };
    function getBySubject(subject) {
      return ensureSubjectHasHash(subject), caStore.certs[subject.hash] || null;
    }
    __name(getBySubject, "getBySubject");
    function ensureSubjectHasHash(subject) {
      if (!subject.hash) {
        var md = forge.md.sha1.create();
        subject.attributes = pki.RDNAttributesAsArray(_dnToAsn1(subject), md), subject.hash = md.digest().toHex();
      }
    }
    if (__name(ensureSubjectHasHash, "ensureSubjectHasHash"), certs) for (var i = 0; i < certs.length; ++i) {
      var cert = certs[i];
      caStore.addCertificate(cert);
    }
    return caStore;
  };
  pki.certificateError = {
    bad_certificate: "forge.pki.BadCertificate",
    unsupported_certificate: "forge.pki.UnsupportedCertificate",
    certificate_revoked: "forge.pki.CertificateRevoked",
    certificate_expired: "forge.pki.CertificateExpired",
    certificate_unknown: "forge.pki.CertificateUnknown",
    unknown_ca: "forge.pki.UnknownCertificateAuthority"
  };
  pki.verifyCertificateChain = function (caStore, chain, options) {
    typeof options == "function" && (options = {
      verify: options
    }), options = options || {}, chain = chain.slice(0);
    var certs = chain.slice(0),
      validityCheckDate = options.validityCheckDate;
    typeof validityCheckDate > "u" && (validityCheckDate = new Date());
    var first = !0,
      error = null,
      depth = 0;
    do {
      var cert = chain.shift(),
        parent = null,
        selfSigned = !1;
      if (validityCheckDate && (validityCheckDate < cert.validity.notBefore || validityCheckDate > cert.validity.notAfter) && (error = {
        message: "Certificate is not valid yet or has expired.",
        error: pki.certificateError.certificate_expired,
        notBefore: cert.validity.notBefore,
        notAfter: cert.validity.notAfter,
        now: validityCheckDate
      }), error === null) {
        if (parent = chain[0] || caStore.getIssuer(cert), parent === null && cert.isIssuer(cert) && (selfSigned = !0, parent = cert), parent) {
          var parents = parent;
          forge.util.isArray(parents) || (parents = [parents]);
          for (var verified = !1; !verified && parents.length > 0;) {
            parent = parents.shift();
            try {
              verified = parent.verify(cert);
            } catch {}
          }
          verified || (error = {
            message: "Certificate signature is invalid.",
            error: pki.certificateError.bad_certificate
          });
        }
        error === null && (!parent || selfSigned) && !caStore.hasCertificate(cert) && (error = {
          message: "Certificate is not trusted.",
          error: pki.certificateError.unknown_ca
        });
      }
      if (error === null && parent && !cert.isIssuer(parent) && (error = {
        message: "Certificate issuer is invalid.",
        error: pki.certificateError.bad_certificate
      }), error === null) for (var se = {
          keyUsage: !0,
          basicConstraints: !0
        }, i = 0; error === null && i < cert.extensions.length; ++i) {
        var ext = cert.extensions[i];
        ext.critical && !(ext.name in se) && (error = {
          message: "Certificate has an unsupported critical extension.",
          error: pki.certificateError.unsupported_certificate
        });
      }
      if (error === null && (!first || chain.length === 0 && (!parent || selfSigned))) {
        var bcExt = cert.getExtension("basicConstraints"),
          keyUsageExt = cert.getExtension("keyUsage");
        if (keyUsageExt !== null && (!keyUsageExt.keyCertSign || bcExt === null) && (error = {
          message: "Certificate keyUsage or basicConstraints conflict or indicate that the certificate is not a CA. If the certificate is the only one in the chain or isn't the first then the certificate must be a valid CA.",
          error: pki.certificateError.bad_certificate
        }), error === null && bcExt !== null && !bcExt.cA && (error = {
          message: "Certificate basicConstraints indicates the certificate is not a CA.",
          error: pki.certificateError.bad_certificate
        }), error === null && keyUsageExt !== null && "pathLenConstraint" in bcExt) {
          var pathLen = depth - 1;
          pathLen > bcExt.pathLenConstraint && (error = {
            message: "Certificate basicConstraints pathLenConstraint violated.",
            error: pki.certificateError.bad_certificate
          });
        }
      }
      var vfd = error === null ? !0 : error.error,
        ret = options.verify ? options.verify(vfd, depth, certs) : vfd;
      if (ret === !0) error = null;else throw vfd === !0 && (error = {
        message: "The application rejected the certificate.",
        error: pki.certificateError.bad_certificate
      }), (ret || ret === 0) && (typeof ret == "object" && !forge.util.isArray(ret) ? (ret.message && (error.message = ret.message), ret.error && (error.error = ret.error)) : typeof ret == "string" && (error.error = ret)), error;
      first = !1, ++depth;
    } while (chain.length > 0);
    return !0;
  };
});