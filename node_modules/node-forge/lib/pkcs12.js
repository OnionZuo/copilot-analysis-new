var require_pkcs12 = __commonJSMin((exports, module) => {
  var forge = Ja();
  Md();
  WI();
  Tw();
  lce();
  cce();
  lp();
  eS();
  VI();
  Ki();
  Az();
  var asn1 = forge.asn1,
    pki = forge.pki,
    p12 = module.exports = forge.pkcs12 = forge.pkcs12 || {},
    contentInfoValidator = {
      name: "ContentInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: !0,
      value: [{
        name: "ContentInfo.contentType",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OID,
        constructed: !1,
        capture: "contentType"
      }, {
        name: "ContentInfo.content",
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        constructed: !0,
        captureAsn1: "content"
      }]
    },
    pfxValidator = {
      name: "PFX",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: !0,
      value: [{
        name: "PFX.version",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: !1,
        capture: "version"
      }, contentInfoValidator, {
        name: "PFX.macData",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: !0,
        optional: !0,
        captureAsn1: "mac",
        value: [{
          name: "PFX.macData.mac",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: !0,
          value: [{
            name: "PFX.macData.mac.digestAlgorithm",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SEQUENCE,
            constructed: !0,
            value: [{
              name: "PFX.macData.mac.digestAlgorithm.algorithm",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.OID,
              constructed: !1,
              capture: "macAlgorithm"
            }, {
              name: "PFX.macData.mac.digestAlgorithm.parameters",
              tagClass: asn1.Class.UNIVERSAL,
              captureAsn1: "macAlgorithmParameters"
            }]
          }, {
            name: "PFX.macData.mac.digest",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.OCTETSTRING,
            constructed: !1,
            capture: "macDigest"
          }]
        }, {
          name: "PFX.macData.macSalt",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OCTETSTRING,
          constructed: !1,
          capture: "macSalt"
        }, {
          name: "PFX.macData.iterations",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.INTEGER,
          constructed: !1,
          optional: !0,
          capture: "macIterations"
        }]
      }]
    },
    safeBagValidator = {
      name: "SafeBag",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: !0,
      value: [{
        name: "SafeBag.bagId",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OID,
        constructed: !1,
        capture: "bagId"
      }, {
        name: "SafeBag.bagValue",
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        constructed: !0,
        captureAsn1: "bagValue"
      }, {
        name: "SafeBag.bagAttributes",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SET,
        constructed: !0,
        optional: !0,
        capture: "bagAttributes"
      }]
    },
    attributeValidator = {
      name: "Attribute",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: !0,
      value: [{
        name: "Attribute.attrId",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OID,
        constructed: !1,
        capture: "oid"
      }, {
        name: "Attribute.attrValues",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SET,
        constructed: !0,
        capture: "values"
      }]
    },
    certBagValidator = {
      name: "CertBag",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: !0,
      value: [{
        name: "CertBag.certId",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OID,
        constructed: !1,
        capture: "certId"
      }, {
        name: "CertBag.certValue",
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        constructed: !0,
        value: [{
          name: "CertBag.certValue[0]",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Class.OCTETSTRING,
          constructed: !1,
          capture: "cert"
        }]
      }]
    };
  function _getBagsByAttribute(safeContents, attrName, attrValue, bagType) {
    for (var result = [], i = 0; i < safeContents.length; i++) for (var j = 0; j < safeContents[i].safeBags.length; j++) {
      var bag = safeContents[i].safeBags[j];
      if (!(bagType !== void 0 && bag.type !== bagType)) {
        if (attrName === null) {
          result.push(bag);
          continue;
        }
        bag.attributes[attrName] !== void 0 && bag.attributes[attrName].indexOf(attrValue) >= 0 && result.push(bag);
      }
    }
    return result;
  }
  __name(_getBagsByAttribute, "_getBagsByAttribute");
  p12.pkcs12FromAsn1 = function (obj, strict, password) {
    typeof strict == "string" ? (password = strict, strict = !0) : strict === void 0 && (strict = !0);
    var capture = {},
      errors = [];
    if (!asn1.validate(obj, pfxValidator, capture, errors)) {
      var error = new Error("Cannot read PKCS#12 PFX. ASN.1 object is not an PKCS#12 PFX.");
      throw error.errors = error, error;
    }
    var pfx = {
      version: capture.version.charCodeAt(0),
      safeContents: [],
      getBags: __name(function (filter) {
        var rval = {},
          localKeyId;
        return "localKeyId" in filter ? localKeyId = filter.localKeyId : "localKeyIdHex" in filter && (localKeyId = forge.util.hexToBytes(filter.localKeyIdHex)), localKeyId === void 0 && !("friendlyName" in filter) && "bagType" in filter && (rval[filter.bagType] = _getBagsByAttribute(pfx.safeContents, null, null, filter.bagType)), localKeyId !== void 0 && (rval.localKeyId = _getBagsByAttribute(pfx.safeContents, "localKeyId", localKeyId, filter.bagType)), "friendlyName" in filter && (rval.friendlyName = _getBagsByAttribute(pfx.safeContents, "friendlyName", filter.friendlyName, filter.bagType)), rval;
      }, "getBags"),
      getBagsByFriendlyName: __name(function (friendlyName, bagType) {
        return _getBagsByAttribute(pfx.safeContents, "friendlyName", friendlyName, bagType);
      }, "getBagsByFriendlyName"),
      getBagsByLocalKeyId: __name(function (localKeyId, bagType) {
        return _getBagsByAttribute(pfx.safeContents, "localKeyId", localKeyId, bagType);
      }, "getBagsByLocalKeyId")
    };
    if (capture.version.charCodeAt(0) !== 3) {
      var error = new Error("PKCS#12 PFX of version other than 3 not supported.");
      throw error.version = capture.version.charCodeAt(0), error;
    }
    if (asn1.derToOid(capture.contentType) !== pki.oids.data) {
      var error = new Error("Only PKCS#12 PFX in password integrity mode supported.");
      throw error.oid = asn1.derToOid(capture.contentType), error;
    }
    var data = capture.content.value[0];
    if (data.tagClass !== asn1.Class.UNIVERSAL || data.type !== asn1.Type.OCTETSTRING) throw new Error("PKCS#12 authSafe content data is not an OCTET STRING.");
    if (data = _decodePkcs7Data(data), capture.mac) {
      var md = null,
        macKeyBytes = 0,
        macAlgorithm = asn1.derToOid(capture.macAlgorithm);
      switch (macAlgorithm) {
        case pki.oids.sha1:
          md = forge.md.sha1.create(), macKeyBytes = 20;
          break;
        case pki.oids.sha256:
          md = forge.md.sha256.create(), macKeyBytes = 32;
          break;
        case pki.oids.sha384:
          md = forge.md.sha384.create(), macKeyBytes = 48;
          break;
        case pki.oids.sha512:
          md = forge.md.sha512.create(), macKeyBytes = 64;
          break;
        case pki.oids.md5:
          md = forge.md.md5.create(), macKeyBytes = 16;
          break;
      }
      if (md === null) throw new Error("PKCS#12 uses unsupported MAC algorithm: " + macAlgorithm);
      var macSalt = new forge.util.ByteBuffer(capture.macSalt),
        macIterations = "macIterations" in capture ? parseInt(forge.util.bytesToHex(capture.macIterations), 16) : 1,
        macKey = p12.generateKey(password, macSalt, 3, macIterations, macKeyBytes, md),
        mac = forge.hmac.create();
      mac.start(md, macKey), mac.update(data.value);
      var macValue = mac.getMac();
      if (macValue.getBytes() !== capture.macDigest) throw new Error("PKCS#12 MAC could not be verified. Invalid password?");
    }
    return _decodeAuthenticatedSafe(pfx, data.value, strict, password), pfx;
  };
  function _decodePkcs7Data(data) {
    if (data.composed || data.constructed) {
      for (var value = forge.util.createBuffer(), i = 0; i < data.value.length; ++i) value.putBytes(data.value[i].value);
      data.composed = data.constructed = !1, data.value = value.getBytes();
    }
    return data;
  }
  __name(_decodePkcs7Data, "_decodePkcs7Data");
  function _decodeAuthenticatedSafe(pfx, authSafe, strict, password) {
    if (authSafe = asn1.fromDer(authSafe, strict), authSafe.tagClass !== asn1.Class.UNIVERSAL || authSafe.type !== asn1.Type.SEQUENCE || authSafe.constructed !== !0) throw new Error("PKCS#12 AuthenticatedSafe expected to be a SEQUENCE OF ContentInfo");
    for (var i = 0; i < authSafe.value.length; i++) {
      var contentInfo = authSafe.value[i],
        capture = {},
        errors = [];
      if (!asn1.validate(contentInfo, contentInfoValidator, capture, errors)) {
        var error = new Error("Cannot read ContentInfo.");
        throw error.errors = errors, error;
      }
      var obj = {
          encrypted: !1
        },
        safeContents = null,
        data = capture.content.value[0];
      switch (asn1.derToOid(capture.contentType)) {
        case pki.oids.data:
          if (data.tagClass !== asn1.Class.UNIVERSAL || data.type !== asn1.Type.OCTETSTRING) throw new Error("PKCS#12 SafeContents Data is not an OCTET STRING.");
          safeContents = _decodePkcs7Data(data).value;
          break;
        case pki.oids.encryptedData:
          safeContents = _decryptSafeContents(data, password), obj.encrypted = !0;
          break;
        default:
          var error = new Error("Unsupported PKCS#12 contentType.");
          throw error.contentType = asn1.derToOid(capture.contentType), error;
      }
      obj.safeBags = _decodeSafeContents(safeContents, strict, password), pfx.safeContents.push(obj);
    }
  }
  __name(_decodeAuthenticatedSafe, "_decodeAuthenticatedSafe");
  function _decryptSafeContents(data, password) {
    var capture = {},
      errors = [];
    if (!asn1.validate(data, forge.pkcs7.asn1.encryptedDataValidator, capture, errors)) {
      var error = new Error("Cannot read EncryptedContentInfo.");
      throw error.errors = errors, error;
    }
    var oid = asn1.derToOid(capture.contentType);
    if (oid !== pki.oids.data) {
      var error = new Error("PKCS#12 EncryptedContentInfo ContentType is not Data.");
      throw error.oid = oid, error;
    }
    oid = asn1.derToOid(capture.encAlgorithm);
    var cipher = pki.pbe.getCipher(oid, capture.encParameter, password),
      encryptedContentAsn1 = _decodePkcs7Data(capture.encryptedContentAsn1),
      encrypted = forge.util.createBuffer(encryptedContentAsn1.value);
    if (cipher.update(encrypted), !cipher.finish()) throw new Error("Failed to decrypt PKCS#12 SafeContents.");
    return cipher.output.getBytes();
  }
  __name(_decryptSafeContents, "_decryptSafeContents");
  function _decodeSafeContents(safeContents, strict, password) {
    if (!strict && safeContents.length === 0) return [];
    if (safeContents = asn1.fromDer(safeContents, strict), safeContents.tagClass !== asn1.Class.UNIVERSAL || safeContents.type !== asn1.Type.SEQUENCE || safeContents.constructed !== !0) throw new Error("PKCS#12 SafeContents expected to be a SEQUENCE OF SafeBag.");
    for (var res = [], i = 0; i < safeContents.value.length; i++) {
      var safeBag = safeContents.value[i],
        capture = {},
        errors = [];
      if (!asn1.validate(safeBag, safeBagValidator, capture, errors)) {
        var error = new Error("Cannot read SafeBag.");
        throw error.errors = errors, error;
      }
      var bag = {
        type: asn1.derToOid(capture.bagId),
        attributes: _decodeBagAttributes(capture.bagAttributes)
      };
      res.push(bag);
      var validator,
        decoder,
        bagAsn1 = capture.bagValue.value[0];
      switch (bag.type) {
        case pki.oids.pkcs8ShroudedKeyBag:
          if (bagAsn1 = pki.decryptPrivateKeyInfo(bagAsn1, password), bagAsn1 === null) throw new Error("Unable to decrypt PKCS#8 ShroudedKeyBag, wrong password?");
        case pki.oids.keyBag:
          try {
            bag.key = pki.privateKeyFromAsn1(bagAsn1);
          } catch {
            bag.key = null, bag.asn1 = bagAsn1;
          }
          continue;
        case pki.oids.certBag:
          validator = certBagValidator, decoder = __name(function () {
            if (asn1.derToOid(capture.certId) !== pki.oids.x509Certificate) {
              var error = new Error("Unsupported certificate type, only X.509 supported.");
              throw error.oid = asn1.derToOid(capture.certId), error;
            }
            var certAsn1 = asn1.fromDer(capture.cert, strict);
            try {
              bag.cert = pki.certificateFromAsn1(certAsn1, !0);
            } catch {
              bag.cert = null, bag.asn1 = certAsn1;
            }
          }, "decoder");
          break;
        default:
          var error = new Error("Unsupported PKCS#12 SafeBag type.");
          throw error.oid = bag.type, error;
      }
      if (validator !== void 0 && !asn1.validate(bagAsn1, validator, capture, errors)) {
        var error = new Error("Cannot read PKCS#12 " + validator.name);
        throw error.errors = errors, error;
      }
      decoder();
    }
    return res;
  }
  __name(_decodeSafeContents, "_decodeSafeContents");
  function _decodeBagAttributes(attributes) {
    var decodedAttrs = {};
    if (attributes !== void 0) for (var i = 0; i < attributes.length; ++i) {
      var capture = {},
        errors = [];
      if (!asn1.validate(attributes[i], attributeValidator, capture, errors)) {
        var error = new Error("Cannot read PKCS#12 BagAttribute.");
        throw error.errors = errors, error;
      }
      var oid = asn1.derToOid(capture.oid);
      if (pki.oids[oid] !== void 0) {
        decodedAttrs[pki.oids[oid]] = [];
        for (var j = 0; j < capture.values.length; ++j) decodedAttrs[pki.oids[oid]].push(capture.values[j].value);
      }
    }
    return decodedAttrs;
  }
  __name(_decodeBagAttributes, "_decodeBagAttributes");
  p12.toPkcs12Asn1 = function (key, cert, password, options) {
    options = options || {}, options.saltSize = options.saltSize || 8, options.count = options.count || 2048, options.algorithm = options.algorithm || options.encAlgorithm || "aes128", "useMac" in options || (options.useMac = !0), "localKeyId" in options || (options.localKeyId = null), "generateLocalKeyId" in options || (options.generateLocalKeyId = !0);
    var localKeyId = options.localKeyId,
      bagAttrs;
    if (localKeyId !== null) localKeyId = forge.util.hexToBytes(localKeyId);else if (options.generateLocalKeyId) if (cert) {
      var pairedCert = forge.util.isArray(cert) ? cert[0] : cert;
      typeof pairedCert == "string" && (pairedCert = pki.certificateFromPem(pairedCert));
      var sha1 = forge.md.sha1.create();
      sha1.update(asn1.toDer(pki.certificateToAsn1(pairedCert)).getBytes()), localKeyId = sha1.digest().getBytes();
    } else localKeyId = forge.random.getBytes(20);
    var attrs = [];
    localKeyId !== null && attrs.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, !0, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, !1, asn1.oidToDer(pki.oids.localKeyId).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, !0, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, !1, localKeyId)])])), "friendlyName" in options && attrs.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, !0, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, !1, asn1.oidToDer(pki.oids.friendlyName).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, !0, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BMPSTRING, !1, options.friendlyName)])])), attrs.length > 0 && (bagAttrs = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, !0, attrs));
    var contents = [],
      chain = [];
    cert !== null && (forge.util.isArray(cert) ? chain = cert : chain = [cert]);
    for (var certSafeBags = [], i = 0; i < chain.length; ++i) {
      cert = chain[i], typeof cert == "string" && (cert = pki.certificateFromPem(cert));
      var certBagAttrs = i === 0 ? bagAttrs : void 0,
        certAsn1 = pki.certificateToAsn1(cert),
        certSafeBag = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, !0, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, !1, asn1.oidToDer(pki.oids.certBag).getBytes()), asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, !0, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, !0, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, !1, asn1.oidToDer(pki.oids.x509Certificate).getBytes()), asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, !0, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, !1, asn1.toDer(certAsn1).getBytes())])])]), certBagAttrs]);
      certSafeBags.push(certSafeBag);
    }
    if (certSafeBags.length > 0) {
      var certSafeContents = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, !0, certSafeBags),
        certCI = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, !0, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, !1, asn1.oidToDer(pki.oids.data).getBytes()), asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, !0, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, !1, asn1.toDer(certSafeContents).getBytes())])]);
      contents.push(certCI);
    }
    var keyBag = null;
    if (key !== null) {
      var pkAsn1 = pki.wrapRsaPrivateKey(pki.privateKeyToAsn1(key));
      password === null ? keyBag = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, !0, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, !1, asn1.oidToDer(pki.oids.keyBag).getBytes()), asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, !0, [pkAsn1]), bagAttrs]) : keyBag = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, !0, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, !1, asn1.oidToDer(pki.oids.pkcs8ShroudedKeyBag).getBytes()), asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, !0, [pki.encryptPrivateKeyInfo(pkAsn1, password, options)]), bagAttrs]);
      var keySafeContents = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, !0, [keyBag]),
        keyCI = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, !0, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, !1, asn1.oidToDer(pki.oids.data).getBytes()), asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, !0, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, !1, asn1.toDer(keySafeContents).getBytes())])]);
      contents.push(keyCI);
    }
    var safe = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, !0, contents),
      macData;
    if (options.useMac) {
      var sha1 = forge.md.sha1.create(),
        macSalt = new forge.util.ByteBuffer(forge.random.getBytes(options.saltSize)),
        count = options.count,
        key = p12.generateKey(password, macSalt, 3, count, 20),
        mac = forge.hmac.create();
      mac.start(sha1, key), mac.update(asn1.toDer(safe).getBytes());
      var macValue = mac.getMac();
      macData = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, !0, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, !0, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, !0, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, !1, asn1.oidToDer(pki.oids.sha1).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, !1, "")]), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, !1, macValue.getBytes())]), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, !1, macSalt.getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, !1, asn1.integerToDer(count).getBytes())]);
    }
    return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, !0, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, !1, asn1.integerToDer(3).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, !0, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, !1, asn1.oidToDer(pki.oids.data).getBytes()), asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, !0, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, !1, asn1.toDer(safe).getBytes())])]), macData]);
  };
  p12.generateKey = forge.pbe.generatePkcs12Key;
});