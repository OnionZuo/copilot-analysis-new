var require_aesCipherSuites = __commonJSMin((exports, module) => {
  var forge = Ja();
  Fw();
  Cce();
  var tls = module.exports = forge.tls;
  tls.CipherSuites.TLS_RSA_WITH_AES_128_CBC_SHA = {
    id: [0, 47],
    name: "TLS_RSA_WITH_AES_128_CBC_SHA",
    initSecurityParameters: __name(function (sp) {
      sp.bulk_cipher_algorithm = tls.BulkCipherAlgorithm.aes, sp.cipher_type = tls.CipherType.block, sp.enc_key_length = 16, sp.block_length = 16, sp.fixed_iv_length = 16, sp.record_iv_length = 16, sp.mac_algorithm = tls.MACAlgorithm.hmac_sha1, sp.mac_length = 20, sp.mac_key_length = 20;
    }, "initSecurityParameters"),
    initConnectionState: initConnectionState
  };
  tls.CipherSuites.TLS_RSA_WITH_AES_256_CBC_SHA = {
    id: [0, 53],
    name: "TLS_RSA_WITH_AES_256_CBC_SHA",
    initSecurityParameters: __name(function (sp) {
      sp.bulk_cipher_algorithm = tls.BulkCipherAlgorithm.aes, sp.cipher_type = tls.CipherType.block, sp.enc_key_length = 32, sp.block_length = 16, sp.fixed_iv_length = 16, sp.record_iv_length = 16, sp.mac_algorithm = tls.MACAlgorithm.hmac_sha1, sp.mac_length = 20, sp.mac_key_length = 20;
    }, "initSecurityParameters"),
    initConnectionState: initConnectionState
  };
  function initConnectionState(state, c, sp) {
    var client = c.entity === forge.tls.ConnectionEnd.client;
    state.read.cipherState = {
      init: !1,
      cipher: forge.cipher.createDecipher("AES-CBC", client ? sp.keys.server_write_key : sp.keys.client_write_key),
      iv: client ? sp.keys.server_write_IV : sp.keys.client_write_IV
    }, state.write.cipherState = {
      init: !1,
      cipher: forge.cipher.createCipher("AES-CBC", client ? sp.keys.client_write_key : sp.keys.server_write_key),
      iv: client ? sp.keys.client_write_IV : sp.keys.server_write_IV
    }, state.read.cipherFunction = decrypt_aes_cbc_sha1, state.write.cipherFunction = encrypt_aes_cbc_sha1, state.read.macLength = state.write.macLength = sp.mac_length, state.read.macFunction = state.write.macFunction = tls.hmac_sha1;
  }
  __name(initConnectionState, "initConnectionState");
  function encrypt_aes_cbc_sha1(record, s) {
    var rval = !1,
      mac = s.macFunction(s.macKey, s.sequenceNumber, record);
    record.fragment.putBytes(mac), s.updateSequenceNumber();
    var iv;
    record.version.minor === tls.Versions.TLS_1_0.minor ? iv = s.cipherState.init ? null : s.cipherState.iv : iv = forge.random.getBytesSync(16), s.cipherState.init = !0;
    var cipher = s.cipherState.cipher;
    return cipher.start({
      iv: iv
    }), record.version.minor >= tls.Versions.TLS_1_1.minor && cipher.output.putBytes(iv), cipher.update(record.fragment), cipher.finish(encrypt_aes_cbc_sha1_padding) && (record.fragment = cipher.output, record.length = record.fragment.length(), rval = !0), rval;
  }
  __name(encrypt_aes_cbc_sha1, "encrypt_aes_cbc_sha1");
  function encrypt_aes_cbc_sha1_padding(blockSize, input, decrypt) {
    if (!decrypt) {
      var padding = blockSize - input.length() % blockSize;
      input.fillWithByte(padding - 1, padding);
    }
    return !0;
  }
  __name(encrypt_aes_cbc_sha1_padding, "encrypt_aes_cbc_sha1_padding");
  function decrypt_aes_cbc_sha1_padding(blockSize, output, decrypt) {
    var rval = !0;
    if (decrypt) {
      for (var len = output.length(), paddingLength = output.last(), i = len - 1 - paddingLength; i < len - 1; ++i) rval = rval && output.at(i) == paddingLength;
      rval && output.truncate(paddingLength + 1);
    }
    return rval;
  }
  __name(decrypt_aes_cbc_sha1_padding, "decrypt_aes_cbc_sha1_padding");
  function decrypt_aes_cbc_sha1(record, s) {
    var rval = !1,
      iv;
    record.version.minor === tls.Versions.TLS_1_0.minor ? iv = s.cipherState.init ? null : s.cipherState.iv : iv = record.fragment.getBytes(16), s.cipherState.init = !0;
    var cipher = s.cipherState.cipher;
    cipher.start({
      iv: iv
    }), cipher.update(record.fragment), rval = cipher.finish(decrypt_aes_cbc_sha1_padding);
    var macLen = s.macLength,
      mac = forge.random.getBytesSync(macLen),
      len = cipher.output.length();
    len >= macLen ? (record.fragment = cipher.output.getBytes(len - macLen), mac = cipher.output.getBytes(macLen)) : record.fragment = cipher.output.getBytes(), record.fragment = forge.util.createBuffer(record.fragment), record.length = record.fragment.length();
    var mac2 = s.macFunction(s.macKey, s.sequenceNumber, record);
    return s.updateSequenceNumber(), rval = compareMacs(s.macKey, mac, mac2) && rval, rval;
  }
  __name(decrypt_aes_cbc_sha1, "decrypt_aes_cbc_sha1");
  function compareMacs(key, mac1, mac2) {
    var hmac = forge.hmac.create();
    return hmac.start("SHA1", key), hmac.update(mac1), mac1 = hmac.digest().getBytes(), hmac.start(null, null), hmac.update(mac2), mac2 = hmac.digest().getBytes(), mac1 === mac2;
  }
  __name(compareMacs, "compareMacs");
});