var require_baseN = __commonJSMin((exports, module) => {
  var api = {};
  module.exports = api;
  var _reverseAlphabets = {};
  api.encode = function (input, alphabet, maxline) {
    if (typeof alphabet != "string") throw new TypeError('"alphabet" must be a string.');
    if (maxline !== void 0 && typeof maxline != "number") throw new TypeError('"maxline" must be a number.');
    var output = "";
    if (!(input instanceof Uint8Array)) output = _encodeWithByteBuffer(input, alphabet);else {
      var i = 0,
        base = alphabet.length,
        first = alphabet.charAt(0),
        digits = [0];
      for (i = 0; i < input.length; ++i) {
        for (var j = 0, carry = input[i]; j < digits.length; ++j) carry += digits[j] << 8, digits[j] = carry % base, carry = carry / base | 0;
        for (; carry > 0;) digits.push(carry % base), carry = carry / base | 0;
      }
      for (i = 0; input[i] === 0 && i < input.length - 1; ++i) output += first;
      for (i = digits.length - 1; i >= 0; --i) output += alphabet[digits[i]];
    }
    if (maxline) {
      var regex = new RegExp(".{1," + maxline + "}", "g");
      output = output.match(regex).join(`\r
`);
    }
    return output;
  };
  api.decode = function (input, alphabet) {
    if (typeof input != "string") throw new TypeError('"input" must be a string.');
    if (typeof alphabet != "string") throw new TypeError('"alphabet" must be a string.');
    var table = _reverseAlphabets[alphabet];
    if (!table) {
      table = _reverseAlphabets[alphabet] = [];
      for (var i = 0; i < alphabet.length; ++i) table[alphabet.charCodeAt(i)] = i;
    }
    input = input.replace(/\s/g, "");
    for (var base = alphabet.length, first = alphabet.charAt(0), bytes = [0], i = 0; i < input.length; i++) {
      var value = table[input.charCodeAt(i)];
      if (value === void 0) return;
      for (var j = 0, carry = value; j < bytes.length; ++j) carry += bytes[j] * base, bytes[j] = carry & 255, carry >>= 8;
      for (; carry > 0;) bytes.push(carry & 255), carry >>= 8;
    }
    for (var k = 0; input[k] === first && k < input.length - 1; ++k) bytes.push(0);
    return typeof Buffer < "u" ? Buffer.from(bytes.reverse()) : new Uint8Array(bytes.reverse());
  };
  function _encodeWithByteBuffer(input, alphabet) {
    var i = 0,
      base = alphabet.length,
      first = alphabet.charAt(0),
      digits = [0];
    for (i = 0; i < input.length(); ++i) {
      for (var j = 0, carry = input.at(i); j < digits.length; ++j) carry += digits[j] << 8, digits[j] = carry % base, carry = carry / base | 0;
      for (; carry > 0;) digits.push(carry % base), carry = carry / base | 0;
    }
    var output = "";
    for (i = 0; input.at(i) === 0 && i < input.length() - 1; ++i) output += first;
    for (i = digits.length - 1; i >= 0; --i) output += alphabet[digits[i]];
    return output;
  }
  __name(_encodeWithByteBuffer, "_encodeWithByteBuffer");
});