var require_pbe = __commonJSMin((exports, module) => {
  var forge = Ja();
  Fw();
  Md();
  J9();
  Cf();
  Tw();
  ez();
  Ux();
  lp();
  Xse();
  eS();
  Ki();
  typeof BigInteger > "u" && (BigInteger = forge.jsbn.BigInteger);
  var BigInteger,
    asn1 = forge.asn1,
    pki = forge.pki = forge.pki || {};
  module.exports = pki.pbe = forge.pbe = forge.pbe || {};
  var oids = pki.oids,
    encryptedPrivateKeyValidator = {
      name: "EncryptedPrivateKeyInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: !0,
      value: [{
        name: "EncryptedPrivateKeyInfo.encryptionAlgorithm",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: !0,
        value: [{
          name: "AlgorithmIdentifier.algorithm",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: !1,
          capture: "encryptionOid"
        }, {
          name: "AlgorithmIdentifier.parameters",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: !0,
          captureAsn1: "encryptionParams"
        }]
      }, {
        name: "EncryptedPrivateKeyInfo.encryptedData",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OCTETSTRING,
        constructed: !1,
        capture: "encryptedData"
      }]
    },
    PBES2AlgorithmsValidator = {
      name: "PBES2Algorithms",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: !0,
      value: [{
        name: "PBES2Algorithms.keyDerivationFunc",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: !0,
        value: [{
          name: "PBES2Algorithms.keyDerivationFunc.oid",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: !1,
          capture: "kdfOid"
        }, {
          name: "PBES2Algorithms.params",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: !0,
          value: [{
            name: "PBES2Algorithms.params.salt",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.OCTETSTRING,
            constructed: !1,
            capture: "kdfSalt"
          }, {
            name: "PBES2Algorithms.params.iterationCount",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.INTEGER,
            constructed: !1,
            capture: "kdfIterationCount"
          }, {
            name: "PBES2Algorithms.params.keyLength",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.INTEGER,
            constructed: !1,
            optional: !0,
            capture: "keyLength"
          }, {
            name: "PBES2Algorithms.params.prf",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SEQUENCE,
            constructed: !0,
            optional: !0,
            value: [{
              name: "PBES2Algorithms.params.prf.algorithm",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.OID,
              constructed: !1,
              capture: "prfOid"
            }]
          }]
        }]
      }, {
        name: "PBES2Algorithms.encryptionScheme",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: !0,
        value: [{
          name: "PBES2Algorithms.encryptionScheme.oid",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: !1,
          capture: "encOid"
        }, {
          name: "PBES2Algorithms.encryptionScheme.iv",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OCTETSTRING,
          constructed: !1,
          capture: "encIv"
        }]
      }]
    },
    pkcs12PbeParamsValidator = {
      name: "pkcs-12PbeParams",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: !0,
      value: [{
        name: "pkcs-12PbeParams.salt",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OCTETSTRING,
        constructed: !1,
        capture: "salt"
      }, {
        name: "pkcs-12PbeParams.iterations",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: !1,
        capture: "iterations"
      }]
    };
  pki.encryptPrivateKeyInfo = function (obj, password, options) {
    options = options || {}, options.saltSize = options.saltSize || 8, options.count = options.count || 2048, options.algorithm = options.algorithm || "aes128", options.prfAlgorithm = options.prfAlgorithm || "sha1";
    var salt = forge.random.getBytesSync(options.saltSize),
      count = options.count,
      countBytes = asn1.integerToDer(count),
      dkLen,
      encryptionAlgorithm,
      encryptedData;
    if (options.algorithm.indexOf("aes") === 0 || options.algorithm === "des") {
      var ivLen, encOid, cipherFn;
      switch (options.algorithm) {
        case "aes128":
          dkLen = 16, ivLen = 16, encOid = oids["aes128-CBC"], cipherFn = forge.aes.createEncryptionCipher;
          break;
        case "aes192":
          dkLen = 24, ivLen = 16, encOid = oids["aes192-CBC"], cipherFn = forge.aes.createEncryptionCipher;
          break;
        case "aes256":
          dkLen = 32, ivLen = 16, encOid = oids["aes256-CBC"], cipherFn = forge.aes.createEncryptionCipher;
          break;
        case "des":
          dkLen = 8, ivLen = 8, encOid = oids.desCBC, cipherFn = forge.des.createEncryptionCipher;
          break;
        default:
          var error = new Error("Cannot encrypt private key. Unknown encryption algorithm.");
          throw error.algorithm = options.algorithm, error;
      }
      var prfAlgorithm = "hmacWith" + options.prfAlgorithm.toUpperCase(),
        md = prfAlgorithmToMessageDigest(prfAlgorithm),
        dk = forge.pkcs5.pbkdf2(password, salt, count, dkLen, md),
        iv = forge.random.getBytesSync(ivLen),
        cipher = cipherFn(dk);
      cipher.start(iv), cipher.update(asn1.toDer(obj)), cipher.finish(), encryptedData = cipher.output.getBytes();
      var params = createPbkdf2Params(salt, countBytes, dkLen, prfAlgorithm);
      encryptionAlgorithm = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, !0, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, !1, asn1.oidToDer(oids.pkcs5PBES2).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, !0, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, !0, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, !1, asn1.oidToDer(oids.pkcs5PBKDF2).getBytes()), params]), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, !0, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, !1, asn1.oidToDer(encOid).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, !1, iv)])])]);
    } else if (options.algorithm === "3des") {
      dkLen = 24;
      var saltBytes = new forge.util.ByteBuffer(salt),
        dk = pki.pbe.generatePkcs12Key(password, saltBytes, 1, count, dkLen),
        iv = pki.pbe.generatePkcs12Key(password, saltBytes, 2, count, dkLen),
        cipher = forge.des.createEncryptionCipher(dk);
      cipher.start(iv), cipher.update(asn1.toDer(obj)), cipher.finish(), encryptedData = cipher.output.getBytes(), encryptionAlgorithm = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, !0, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, !1, asn1.oidToDer(oids["pbeWithSHAAnd3-KeyTripleDES-CBC"]).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, !0, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, !1, salt), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, !1, countBytes.getBytes())])]);
    } else {
      var error = new Error("Cannot encrypt private key. Unknown encryption algorithm.");
      throw error.algorithm = options.algorithm, error;
    }
    var rval = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, !0, [encryptionAlgorithm, asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, !1, encryptedData)]);
    return rval;
  };
  pki.decryptPrivateKeyInfo = function (obj, password) {
    var rval = null,
      capture = {},
      errors = [];
    if (!asn1.validate(obj, encryptedPrivateKeyValidator, capture, errors)) {
      var error = new Error("Cannot read encrypted private key. ASN.1 object is not a supported EncryptedPrivateKeyInfo.");
      throw error.errors = errors, error;
    }
    var oid = asn1.derToOid(capture.encryptionOid),
      cipher = pki.pbe.getCipher(oid, capture.encryptionParams, password),
      encrypted = forge.util.createBuffer(capture.encryptedData);
    return cipher.update(encrypted), cipher.finish() && (rval = asn1.fromDer(cipher.output)), rval;
  };
  pki.encryptedPrivateKeyToPem = function (epki, maxline) {
    var msg = {
      type: "ENCRYPTED PRIVATE KEY",
      body: asn1.toDer(epki).getBytes()
    };
    return forge.pem.encode(msg, {
      maxline: maxline
    });
  };
  pki.encryptedPrivateKeyFromPem = function (pem) {
    var msg = forge.pem.decode(pem)[0];
    if (msg.type !== "ENCRYPTED PRIVATE KEY") {
      var error = new Error('Could not convert encrypted private key from PEM; PEM header type is "ENCRYPTED PRIVATE KEY".');
      throw error.headerType = msg.type, error;
    }
    if (msg.procType && msg.procType.type === "ENCRYPTED") throw new Error("Could not convert encrypted private key from PEM; PEM is encrypted.");
    return asn1.fromDer(msg.body);
  };
  pki.encryptRsaPrivateKey = function (rsaKey, password, options) {
    if (options = options || {}, !options.legacy) {
      var rval = pki.wrapRsaPrivateKey(pki.privateKeyToAsn1(rsaKey));
      return rval = pki.encryptPrivateKeyInfo(rval, password, options), pki.encryptedPrivateKeyToPem(rval);
    }
    var algorithm, iv, dkLen, cipherFn;
    switch (options.algorithm) {
      case "aes128":
        algorithm = "AES-128-CBC", dkLen = 16, iv = forge.random.getBytesSync(16), cipherFn = forge.aes.createEncryptionCipher;
        break;
      case "aes192":
        algorithm = "AES-192-CBC", dkLen = 24, iv = forge.random.getBytesSync(16), cipherFn = forge.aes.createEncryptionCipher;
        break;
      case "aes256":
        algorithm = "AES-256-CBC", dkLen = 32, iv = forge.random.getBytesSync(16), cipherFn = forge.aes.createEncryptionCipher;
        break;
      case "3des":
        algorithm = "DES-EDE3-CBC", dkLen = 24, iv = forge.random.getBytesSync(8), cipherFn = forge.des.createEncryptionCipher;
        break;
      case "des":
        algorithm = "DES-CBC", dkLen = 8, iv = forge.random.getBytesSync(8), cipherFn = forge.des.createEncryptionCipher;
        break;
      default:
        var error = new Error('Could not encrypt RSA private key; unsupported encryption algorithm "' + options.algorithm + '".');
        throw error.algorithm = options.algorithm, error;
    }
    var dk = forge.pbe.opensslDeriveBytes(password, iv.substr(0, 8), dkLen),
      cipher = cipherFn(dk);
    cipher.start(iv), cipher.update(asn1.toDer(pki.privateKeyToAsn1(rsaKey))), cipher.finish();
    var msg = {
      type: "RSA PRIVATE KEY",
      procType: {
        version: "4",
        type: "ENCRYPTED"
      },
      dekInfo: {
        algorithm: algorithm,
        parameters: forge.util.bytesToHex(iv).toUpperCase()
      },
      body: cipher.output.getBytes()
    };
    return forge.pem.encode(msg);
  };
  pki.decryptRsaPrivateKey = function (pem, password) {
    var rval = null,
      msg = forge.pem.decode(pem)[0];
    if (msg.type !== "ENCRYPTED PRIVATE KEY" && msg.type !== "PRIVATE KEY" && msg.type !== "RSA PRIVATE KEY") {
      var error = new Error('Could not convert private key from PEM; PEM header type is not "ENCRYPTED PRIVATE KEY", "PRIVATE KEY", or "RSA PRIVATE KEY".');
      throw error.headerType = error, error;
    }
    if (msg.procType && msg.procType.type === "ENCRYPTED") {
      var dkLen, cipherFn;
      switch (msg.dekInfo.algorithm) {
        case "DES-CBC":
          dkLen = 8, cipherFn = forge.des.createDecryptionCipher;
          break;
        case "DES-EDE3-CBC":
          dkLen = 24, cipherFn = forge.des.createDecryptionCipher;
          break;
        case "AES-128-CBC":
          dkLen = 16, cipherFn = forge.aes.createDecryptionCipher;
          break;
        case "AES-192-CBC":
          dkLen = 24, cipherFn = forge.aes.createDecryptionCipher;
          break;
        case "AES-256-CBC":
          dkLen = 32, cipherFn = forge.aes.createDecryptionCipher;
          break;
        case "RC2-40-CBC":
          dkLen = 5, cipherFn = __name(function (key) {
            return forge.rc2.createDecryptionCipher(key, 40);
          }, "cipherFn");
          break;
        case "RC2-64-CBC":
          dkLen = 8, cipherFn = __name(function (key) {
            return forge.rc2.createDecryptionCipher(key, 64);
          }, "cipherFn");
          break;
        case "RC2-128-CBC":
          dkLen = 16, cipherFn = __name(function (key) {
            return forge.rc2.createDecryptionCipher(key, 128);
          }, "cipherFn");
          break;
        default:
          var error = new Error('Could not decrypt private key; unsupported encryption algorithm "' + msg.dekInfo.algorithm + '".');
          throw error.algorithm = msg.dekInfo.algorithm, error;
      }
      var iv = forge.util.hexToBytes(msg.dekInfo.parameters),
        dk = forge.pbe.opensslDeriveBytes(password, iv.substr(0, 8), dkLen),
        cipher = cipherFn(dk);
      if (cipher.start(iv), cipher.update(forge.util.createBuffer(msg.body)), cipher.finish()) rval = cipher.output.getBytes();else return rval;
    } else rval = msg.body;
    return msg.type === "ENCRYPTED PRIVATE KEY" ? rval = pki.decryptPrivateKeyInfo(asn1.fromDer(rval), password) : rval = asn1.fromDer(rval), rval !== null && (rval = pki.privateKeyFromAsn1(rval)), rval;
  };
  pki.pbe.generatePkcs12Key = function (password, salt, id, iter, n, md) {
    var j, l;
    if (typeof md > "u" || md === null) {
      if (!("sha1" in forge.md)) throw new Error('"sha1" hash algorithm unavailable.');
      md = forge.md.sha1.create();
    }
    var u = md.digestLength,
      v = md.blockLength,
      result = new forge.util.ByteBuffer(),
      passBuf = new forge.util.ByteBuffer();
    if (password != null) {
      for (l = 0; l < password.length; l++) passBuf.putInt16(password.charCodeAt(l));
      passBuf.putInt16(0);
    }
    var p = passBuf.length(),
      s = salt.length(),
      D = new forge.util.ByteBuffer();
    D.fillWithByte(id, v);
    var Slen = v * Math.ceil(s / v),
      S = new forge.util.ByteBuffer();
    for (l = 0; l < Slen; l++) S.putByte(salt.at(l % s));
    var Plen = v * Math.ceil(p / v),
      P = new forge.util.ByteBuffer();
    for (l = 0; l < Plen; l++) P.putByte(passBuf.at(l % p));
    var I = S;
    I.putBuffer(P);
    for (var c = Math.ceil(n / u), i = 1; i <= c; i++) {
      var buf = new forge.util.ByteBuffer();
      buf.putBytes(D.bytes()), buf.putBytes(I.bytes());
      for (var round = 0; round < iter; round++) md.start(), md.update(buf.getBytes()), buf = md.digest();
      var B = new forge.util.ByteBuffer();
      for (l = 0; l < v; l++) B.putByte(buf.at(l % u));
      var k = Math.ceil(s / v) + Math.ceil(p / v),
        Inew = new forge.util.ByteBuffer();
      for (j = 0; j < k; j++) {
        var chunk = new forge.util.ByteBuffer(I.getBytes(v)),
          x = 511;
        for (l = B.length() - 1; l >= 0; l--) x = x >> 8, x += B.at(l) + chunk.at(l), chunk.setAt(l, x & 255);
        Inew.putBuffer(chunk);
      }
      I = Inew, result.putBuffer(buf);
    }
    return result.truncate(result.length() - n), result;
  };
  pki.pbe.getCipher = function (oid, params, password) {
    switch (oid) {
      case pki.oids.pkcs5PBES2:
        return pki.pbe.getCipherForPBES2(oid, params, password);
      case pki.oids["pbeWithSHAAnd3-KeyTripleDES-CBC"]:
      case pki.oids["pbewithSHAAnd40BitRC2-CBC"]:
        return pki.pbe.getCipherForPKCS12PBE(oid, params, password);
      default:
        var error = new Error("Cannot read encrypted PBE data block. Unsupported OID.");
        throw error.oid = oid, error.supportedOids = ["pkcs5PBES2", "pbeWithSHAAnd3-KeyTripleDES-CBC", "pbewithSHAAnd40BitRC2-CBC"], error;
    }
  };
  pki.pbe.getCipherForPBES2 = function (oid, params, password) {
    var capture = {},
      errors = [];
    if (!asn1.validate(params, PBES2AlgorithmsValidator, capture, errors)) {
      var error = new Error("Cannot read password-based-encryption algorithm parameters. ASN.1 object is not a supported EncryptedPrivateKeyInfo.");
      throw error.errors = errors, error;
    }
    if (oid = asn1.derToOid(capture.kdfOid), oid !== pki.oids.pkcs5PBKDF2) {
      var error = new Error("Cannot read encrypted private key. Unsupported key derivation function OID.");
      throw error.oid = oid, error.supportedOids = ["pkcs5PBKDF2"], error;
    }
    if (oid = asn1.derToOid(capture.encOid), oid !== pki.oids["aes128-CBC"] && oid !== pki.oids["aes192-CBC"] && oid !== pki.oids["aes256-CBC"] && oid !== pki.oids["des-EDE3-CBC"] && oid !== pki.oids.desCBC) {
      var error = new Error("Cannot read encrypted private key. Unsupported encryption scheme OID.");
      throw error.oid = oid, error.supportedOids = ["aes128-CBC", "aes192-CBC", "aes256-CBC", "des-EDE3-CBC", "desCBC"], error;
    }
    var salt = capture.kdfSalt,
      count = forge.util.createBuffer(capture.kdfIterationCount);
    count = count.getInt(count.length() << 3);
    var dkLen, cipherFn;
    switch (pki.oids[oid]) {
      case "aes128-CBC":
        dkLen = 16, cipherFn = forge.aes.createDecryptionCipher;
        break;
      case "aes192-CBC":
        dkLen = 24, cipherFn = forge.aes.createDecryptionCipher;
        break;
      case "aes256-CBC":
        dkLen = 32, cipherFn = forge.aes.createDecryptionCipher;
        break;
      case "des-EDE3-CBC":
        dkLen = 24, cipherFn = forge.des.createDecryptionCipher;
        break;
      case "desCBC":
        dkLen = 8, cipherFn = forge.des.createDecryptionCipher;
        break;
    }
    var md = prfOidToMessageDigest(capture.prfOid),
      dk = forge.pkcs5.pbkdf2(password, salt, count, dkLen, md),
      iv = capture.encIv,
      cipher = cipherFn(dk);
    return cipher.start(iv), cipher;
  };
  pki.pbe.getCipherForPKCS12PBE = function (oid, params, password) {
    var capture = {},
      errors = [];
    if (!asn1.validate(params, pkcs12PbeParamsValidator, capture, errors)) {
      var error = new Error("Cannot read password-based-encryption algorithm parameters. ASN.1 object is not a supported EncryptedPrivateKeyInfo.");
      throw error.errors = errors, error;
    }
    var salt = forge.util.createBuffer(capture.salt),
      count = forge.util.createBuffer(capture.iterations);
    count = count.getInt(count.length() << 3);
    var dkLen, dIvLen, cipherFn;
    switch (oid) {
      case pki.oids["pbeWithSHAAnd3-KeyTripleDES-CBC"]:
        dkLen = 24, dIvLen = 8, cipherFn = forge.des.startDecrypting;
        break;
      case pki.oids["pbewithSHAAnd40BitRC2-CBC"]:
        dkLen = 5, dIvLen = 8, cipherFn = __name(function (key, iv) {
          var cipher = forge.rc2.createDecryptionCipher(key, 40);
          return cipher.start(iv, null), cipher;
        }, "cipherFn");
        break;
      default:
        var error = new Error("Cannot read PKCS #12 PBE data block. Unsupported OID.");
        throw error.oid = oid, error;
    }
    var md = prfOidToMessageDigest(capture.prfOid),
      key = pki.pbe.generatePkcs12Key(password, salt, 1, count, dkLen, md);
    md.start();
    var iv = pki.pbe.generatePkcs12Key(password, salt, 2, count, dIvLen, md);
    return cipherFn(key, iv);
  };
  pki.pbe.opensslDeriveBytes = function (password, salt, dkLen, md) {
    if (typeof md > "u" || md === null) {
      if (!("md5" in forge.md)) throw new Error('"md5" hash algorithm unavailable.');
      md = forge.md.md5.create();
    }
    salt === null && (salt = "");
    for (var digests = [hash(md, password + salt)], length = 16, i = 1; length < dkLen; ++i, length += 16) digests.push(hash(md, digests[i - 1] + password + salt));
    return digests.join("").substr(0, dkLen);
  };
  function hash(md, bytes) {
    return md.start().update(bytes).digest().getBytes();
  }
  __name(hash, "hash");
  function prfOidToMessageDigest(prfOid) {
    var prfAlgorithm;
    if (!prfOid) prfAlgorithm = "hmacWithSHA1";else if (prfAlgorithm = pki.oids[asn1.derToOid(prfOid)], !prfAlgorithm) {
      var error = new Error("Unsupported PRF OID.");
      throw error.oid = prfOid, error.supported = ["hmacWithSHA1", "hmacWithSHA224", "hmacWithSHA256", "hmacWithSHA384", "hmacWithSHA512"], error;
    }
    return prfAlgorithmToMessageDigest(prfAlgorithm);
  }
  __name(prfOidToMessageDigest, "prfOidToMessageDigest");
  function prfAlgorithmToMessageDigest(prfAlgorithm) {
    var factory = forge.md;
    switch (prfAlgorithm) {
      case "hmacWithSHA224":
        factory = forge.md.sha512;
      case "hmacWithSHA1":
      case "hmacWithSHA256":
      case "hmacWithSHA384":
      case "hmacWithSHA512":
        prfAlgorithm = prfAlgorithm.substr(8).toLowerCase();
        break;
      default:
        var error = new Error("Unsupported PRF algorithm.");
        throw error.algorithm = prfAlgorithm, error.supported = ["hmacWithSHA1", "hmacWithSHA224", "hmacWithSHA256", "hmacWithSHA384", "hmacWithSHA512"], error;
    }
    if (!factory || !(prfAlgorithm in factory)) throw new Error("Unknown hash algorithm: " + prfAlgorithm);
    return factory[prfAlgorithm].create();
  }
  __name(prfAlgorithmToMessageDigest, "prfAlgorithmToMessageDigest");
  function createPbkdf2Params(salt, countBytes, dkLen, prfAlgorithm) {
    var params = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, !0, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, !1, salt), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, !1, countBytes.getBytes())]);
    return prfAlgorithm !== "hmacWithSHA1" && params.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, !1, forge.util.hexToBytes(dkLen.toString(16))), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, !0, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, !1, asn1.oidToDer(pki.oids[prfAlgorithm]).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, !1, "")])), params;
  }
  __name(createPbkdf2Params, "createPbkdf2Params");
});