var require_pem = __commonJSMin((exports, module) => {
  var forge = Ja();
  Ki();
  var pem = module.exports = forge.pem = forge.pem || {};
  pem.encode = function (msg, options) {
    options = options || {};
    var rval = "-----BEGIN " + msg.type + `-----\r
`,
      header;
    if (msg.procType && (header = {
      name: "Proc-Type",
      values: [String(msg.procType.version), msg.procType.type]
    }, rval += foldHeader(header)), msg.contentDomain && (header = {
      name: "Content-Domain",
      values: [msg.contentDomain]
    }, rval += foldHeader(header)), msg.dekInfo && (header = {
      name: "DEK-Info",
      values: [msg.dekInfo.algorithm]
    }, msg.dekInfo.parameters && header.values.push(msg.dekInfo.parameters), rval += foldHeader(header)), msg.headers) for (var i = 0; i < msg.headers.length; ++i) rval += foldHeader(msg.headers[i]);
    return msg.procType && (rval += `\r
`), rval += forge.util.encode64(msg.body, options.maxline || 64) + `\r
`, rval += "-----END " + msg.type + `-----\r
`, rval;
  };
  pem.decode = function (str) {
    for (var rval = [], rMessage = /\s*-----BEGIN ([A-Z0-9- ]+)-----\r?\n?([\x21-\x7e\s]+?(?:\r?\n\r?\n))?([:A-Za-z0-9+\/=\s]+?)-----END \1-----/g, rHeader = /([\x21-\x7e]+):\s*([\x21-\x7e\s^:]+)/, rCRLF = /\r?\n/, match; match = rMessage.exec(str), !!match;) {
      var type = match[1];
      type === "NEW CERTIFICATE REQUEST" && (type = "CERTIFICATE REQUEST");
      var msg = {
        type: type,
        procType: null,
        contentDomain: null,
        dekInfo: null,
        headers: [],
        body: forge.util.decode64(match[3])
      };
      if (rval.push(msg), !!match[2]) {
        for (var lines = match[2].split(rCRLF), li = 0; match && li < lines.length;) {
          for (var line = lines[li].replace(/\s+$/, ""), nl = li + 1; nl < lines.length; ++nl) {
            var next = lines[nl];
            if (!/\s/.test(next[0])) break;
            line += next, li = nl;
          }
          if (match = line.match(rHeader), match) {
            for (var header = {
                name: match[1],
                values: []
              }, values = match[2].split(","), vi = 0; vi < values.length; ++vi) header.values.push(ltrim(values[vi]));
            if (msg.procType) {
              if (!msg.contentDomain && header.name === "Content-Domain") msg.contentDomain = values[0] || "";else if (!msg.dekInfo && header.name === "DEK-Info") {
                if (header.values.length === 0) throw new Error('Invalid PEM formatted message. The "DEK-Info" header must have at least one subfield.');
                msg.dekInfo = {
                  algorithm: values[0],
                  parameters: values[1] || null
                };
              } else msg.headers.push(header);
            } else {
              if (header.name !== "Proc-Type") throw new Error('Invalid PEM formatted message. The first encapsulated header must be "Proc-Type".');
              if (header.values.length !== 2) throw new Error('Invalid PEM formatted message. The "Proc-Type" header must have two subfields.');
              msg.procType = {
                version: values[0],
                type: values[1]
              };
            }
          }
          ++li;
        }
        if (msg.procType === "ENCRYPTED" && !msg.dekInfo) throw new Error('Invalid PEM formatted message. The "DEK-Info" header must be present if "Proc-Type" is "ENCRYPTED".');
      }
    }
    if (rval.length === 0) throw new Error("Invalid PEM formatted message.");
    return rval;
  };
  function foldHeader(header) {
    for (var rval = header.name + ": ", values = [], insertSpace = __name(function (match, $1) {
        return " " + $1;
      }, "insertSpace"), i = 0; i < header.values.length; ++i) values.push(header.values[i].replace(/^(\S+\r\n)/, insertSpace));
    rval += values.join(",") + `\r
`;
    for (var length = 0, candidate = -1, i = 0; i < rval.length; ++i, ++length) if (length > 65 && candidate !== -1) {
      var insert = rval[candidate];
      insert === "," ? (++candidate, rval = rval.substr(0, candidate) + `\r
 ` + rval.substr(candidate)) : rval = rval.substr(0, candidate) + `\r
` + insert + rval.substr(candidate + 1), length = i - candidate - 1, candidate = -1, ++i;
    } else (rval[i] === " " || rval[i] === "	" || rval[i] === ",") && (candidate = i);
    return rval;
  }
  __name(foldHeader, "foldHeader");
  function ltrim(str) {
    return str.replace(/^\s+/, "");
  }
  __name(ltrim, "ltrim");
});