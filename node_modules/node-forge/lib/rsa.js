var require_rsa = __commonJSMin((exports, module) => {
  var forge = Ja();
  Md();
  X9();
  Tw();
  ice();
  oce();
  lp();
  Ki();
  typeof BigInteger > "u" && (BigInteger = forge.jsbn.BigInteger);
  var BigInteger,
    _crypto = forge.util.isNodejs ? require("crypto") : null,
    asn1 = forge.asn1,
    util = forge.util;
  forge.pki = forge.pki || {};
  module.exports = forge.pki.rsa = forge.rsa = forge.rsa || {};
  var pki = forge.pki,
    GCD_30_DELTA = [6, 4, 2, 4, 2, 4, 6, 2],
    privateKeyValidator = {
      name: "PrivateKeyInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: !0,
      value: [{
        name: "PrivateKeyInfo.version",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: !1,
        capture: "privateKeyVersion"
      }, {
        name: "PrivateKeyInfo.privateKeyAlgorithm",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: !0,
        value: [{
          name: "AlgorithmIdentifier.algorithm",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: !1,
          capture: "privateKeyOid"
        }]
      }, {
        name: "PrivateKeyInfo",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OCTETSTRING,
        constructed: !1,
        capture: "privateKey"
      }]
    },
    rsaPrivateKeyValidator = {
      name: "RSAPrivateKey",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: !0,
      value: [{
        name: "RSAPrivateKey.version",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: !1,
        capture: "privateKeyVersion"
      }, {
        name: "RSAPrivateKey.modulus",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: !1,
        capture: "privateKeyModulus"
      }, {
        name: "RSAPrivateKey.publicExponent",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: !1,
        capture: "privateKeyPublicExponent"
      }, {
        name: "RSAPrivateKey.privateExponent",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: !1,
        capture: "privateKeyPrivateExponent"
      }, {
        name: "RSAPrivateKey.prime1",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: !1,
        capture: "privateKeyPrime1"
      }, {
        name: "RSAPrivateKey.prime2",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: !1,
        capture: "privateKeyPrime2"
      }, {
        name: "RSAPrivateKey.exponent1",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: !1,
        capture: "privateKeyExponent1"
      }, {
        name: "RSAPrivateKey.exponent2",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: !1,
        capture: "privateKeyExponent2"
      }, {
        name: "RSAPrivateKey.coefficient",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: !1,
        capture: "privateKeyCoefficient"
      }]
    },
    rsaPublicKeyValidator = {
      name: "RSAPublicKey",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: !0,
      value: [{
        name: "RSAPublicKey.modulus",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: !1,
        capture: "publicKeyModulus"
      }, {
        name: "RSAPublicKey.exponent",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: !1,
        capture: "publicKeyExponent"
      }]
    },
    publicKeyValidator = forge.pki.rsa.publicKeyValidator = {
      name: "SubjectPublicKeyInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: !0,
      captureAsn1: "subjectPublicKeyInfo",
      value: [{
        name: "SubjectPublicKeyInfo.AlgorithmIdentifier",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: !0,
        value: [{
          name: "AlgorithmIdentifier.algorithm",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: !1,
          capture: "publicKeyOid"
        }]
      }, {
        name: "SubjectPublicKeyInfo.subjectPublicKey",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.BITSTRING,
        constructed: !1,
        value: [{
          name: "SubjectPublicKeyInfo.subjectPublicKey.RSAPublicKey",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: !0,
          optional: !0,
          captureAsn1: "rsaPublicKey"
        }]
      }]
    },
    digestInfoValidator = {
      name: "DigestInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: !0,
      value: [{
        name: "DigestInfo.DigestAlgorithm",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: !0,
        value: [{
          name: "DigestInfo.DigestAlgorithm.algorithmIdentifier",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: !1,
          capture: "algorithmIdentifier"
        }, {
          name: "DigestInfo.DigestAlgorithm.parameters",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.NULL,
          capture: "parameters",
          optional: !0,
          constructed: !1
        }]
      }, {
        name: "DigestInfo.digest",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OCTETSTRING,
        constructed: !1,
        capture: "digest"
      }]
    },
    emsaPkcs1v15encode = __name(function (md) {
      var oid;
      if (md.algorithm in pki.oids) oid = pki.oids[md.algorithm];else {
        var error = new Error("Unknown message digest algorithm.");
        throw error.algorithm = md.algorithm, error;
      }
      var oidBytes = asn1.oidToDer(oid).getBytes(),
        digestInfo = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, !0, []),
        digestAlgorithm = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, !0, []);
      digestAlgorithm.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, !1, oidBytes)), digestAlgorithm.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, !1, ""));
      var digest = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, !1, md.digest().getBytes());
      return digestInfo.value.push(digestAlgorithm), digestInfo.value.push(digest), asn1.toDer(digestInfo).getBytes();
    }, "emsaPkcs1v15encode"),
    _modPow = __name(function (x, key, pub) {
      if (pub) return x.modPow(key.e, key.n);
      if (!key.p || !key.q) return x.modPow(key.d, key.n);
      key.dP || (key.dP = key.d.mod(key.p.subtract(BigInteger.ONE))), key.dQ || (key.dQ = key.d.mod(key.q.subtract(BigInteger.ONE))), key.qInv || (key.qInv = key.q.modInverse(key.p));
      var r;
      do r = new BigInteger(forge.util.bytesToHex(forge.random.getBytes(key.n.bitLength() / 8)), 16); while (r.compareTo(key.n) >= 0 || !r.gcd(key.n).equals(BigInteger.ONE));
      x = x.multiply(r.modPow(key.e, key.n)).mod(key.n);
      for (var xp = x.mod(key.p).modPow(key.dP, key.p), xq = x.mod(key.q).modPow(key.dQ, key.q); xp.compareTo(xq) < 0;) xp = xp.add(key.p);
      var y = xp.subtract(xq).multiply(key.qInv).mod(key.p).multiply(key.q).add(xq);
      return y = y.multiply(r.modInverse(key.n)).mod(key.n), y;
    }, "_modPow");
  pki.rsa.encrypt = function (m, key, bt) {
    var pub = bt,
      eb,
      k = Math.ceil(key.n.bitLength() / 8);
    bt !== !1 && bt !== !0 ? (pub = bt === 2, eb = _encodePkcs1_v1_5(m, key, bt)) : (eb = forge.util.createBuffer(), eb.putBytes(m));
    for (var x = new BigInteger(eb.toHex(), 16), y = _modPow(x, key, pub), yhex = y.toString(16), ed = forge.util.createBuffer(), zeros = k - Math.ceil(yhex.length / 2); zeros > 0;) ed.putByte(0), --zeros;
    return ed.putBytes(forge.util.hexToBytes(yhex)), ed.getBytes();
  };
  pki.rsa.decrypt = function (ed, key, pub, ml) {
    var k = Math.ceil(key.n.bitLength() / 8);
    if (ed.length !== k) {
      var error = new Error("Encrypted message length is invalid.");
      throw error.length = ed.length, error.expected = k, error;
    }
    var y = new BigInteger(forge.util.createBuffer(ed).toHex(), 16);
    if (y.compareTo(key.n) >= 0) throw new Error("Encrypted message is invalid.");
    for (var x = _modPow(y, key, pub), xhex = x.toString(16), eb = forge.util.createBuffer(), zeros = k - Math.ceil(xhex.length / 2); zeros > 0;) eb.putByte(0), --zeros;
    return eb.putBytes(forge.util.hexToBytes(xhex)), ml !== !1 ? _decodePkcs1_v1_5(eb.getBytes(), key, pub) : eb.getBytes();
  };
  pki.rsa.createKeyPairGenerationState = function (bits, e, options) {
    typeof bits == "string" && (bits = parseInt(bits, 10)), bits = bits || 2048, options = options || {};
    var prng = options.prng || forge.random,
      rng = {
        nextBytes: __name(function (x) {
          for (var b = prng.getBytesSync(x.length), i = 0; i < x.length; ++i) x[i] = b.charCodeAt(i);
        }, "nextBytes")
      },
      algorithm = options.algorithm || "PRIMEINC",
      rval;
    if (algorithm === "PRIMEINC") rval = {
      algorithm: algorithm,
      state: 0,
      bits: bits,
      rng: rng,
      eInt: e || 65537,
      e: new BigInteger(null),
      p: null,
      q: null,
      qBits: bits >> 1,
      pBits: bits - (bits >> 1),
      pqState: 0,
      num: null,
      keys: null
    }, rval.e.fromInt(rval.eInt);else throw new Error("Invalid key generation algorithm: " + algorithm);
    return rval;
  };
  pki.rsa.stepKeyPairGenerationState = function (state, n) {
    "algorithm" in state || (state.algorithm = "PRIMEINC");
    var THIRTY = new BigInteger(null);
    THIRTY.fromInt(30);
    for (var deltaIdx = 0, op_or = __name(function (x, y) {
        return x | y;
      }, "op_or"), t1 = +new Date(), t2, total = 0; state.keys === null && (n <= 0 || total < n);) {
      if (state.state === 0) {
        var bits = state.p === null ? state.pBits : state.qBits,
          bits1 = bits - 1;
        state.pqState === 0 ? (state.num = new BigInteger(bits, state.rng), state.num.testBit(bits1) || state.num.bitwiseTo(BigInteger.ONE.shiftLeft(bits1), op_or, state.num), state.num.dAddOffset(31 - state.num.mod(THIRTY).byteValue(), 0), deltaIdx = 0, ++state.pqState) : state.pqState === 1 ? state.num.bitLength() > bits ? state.pqState = 0 : state.num.isProbablePrime(_getMillerRabinTests(state.num.bitLength())) ? ++state.pqState : state.num.dAddOffset(GCD_30_DELTA[deltaIdx++ % 8], 0) : state.pqState === 2 ? state.pqState = state.num.subtract(BigInteger.ONE).gcd(state.e).compareTo(BigInteger.ONE) === 0 ? 3 : 0 : state.pqState === 3 && (state.pqState = 0, state.p === null ? state.p = state.num : state.q = state.num, state.p !== null && state.q !== null && ++state.state, state.num = null);
      } else if (state.state === 1) state.p.compareTo(state.q) < 0 && (state.num = state.p, state.p = state.q, state.q = state.num), ++state.state;else if (state.state === 2) state.p1 = state.p.subtract(BigInteger.ONE), state.q1 = state.q.subtract(BigInteger.ONE), state.phi = state.p1.multiply(state.q1), ++state.state;else if (state.state === 3) state.phi.gcd(state.e).compareTo(BigInteger.ONE) === 0 ? ++state.state : (state.p = null, state.q = null, state.state = 0);else if (state.state === 4) state.n = state.p.multiply(state.q), state.n.bitLength() === state.bits ? ++state.state : (state.q = null, state.state = 0);else if (state.state === 5) {
        var d = state.e.modInverse(state.phi);
        state.keys = {
          privateKey: pki.rsa.setPrivateKey(state.n, state.e, d, state.p, state.q, d.mod(state.p1), d.mod(state.q1), state.q.modInverse(state.p)),
          publicKey: pki.rsa.setPublicKey(state.n, state.e)
        };
      }
      t2 = +new Date(), total += t2 - t1, t1 = t2;
    }
    return state.keys !== null;
  };
  pki.rsa.generateKeyPair = function (bits, e, options, callback) {
    if (arguments.length === 1 ? typeof bits == "object" ? (options = bits, bits = void 0) : typeof bits == "function" && (callback = bits, bits = void 0) : arguments.length === 2 ? typeof bits == "number" ? typeof e == "function" ? (callback = e, e = void 0) : typeof e != "number" && (options = e, e = void 0) : (options = bits, callback = e, bits = void 0, e = void 0) : arguments.length === 3 && (typeof e == "number" ? typeof options == "function" && (callback = options, options = void 0) : (callback = options, options = e, e = void 0)), options = options || {}, bits === void 0 && (bits = options.bits || 2048), e === void 0 && (e = options.e || 65537), !forge.options.usePureJavaScript && !options.prng && bits >= 256 && bits <= 16384 && (e === 65537 || e === 3)) {
      if (callback) {
        if (_detectNodeCrypto("generateKeyPair")) return _crypto.generateKeyPair("rsa", {
          modulusLength: bits,
          publicExponent: e,
          publicKeyEncoding: {
            type: "spki",
            format: "pem"
          },
          privateKeyEncoding: {
            type: "pkcs8",
            format: "pem"
          }
        }, function (err, pub, priv) {
          if (err) return callback(err);
          callback(null, {
            privateKey: pki.privateKeyFromPem(priv),
            publicKey: pki.publicKeyFromPem(pub)
          });
        });
        if (_detectSubtleCrypto("generateKey") && _detectSubtleCrypto("exportKey")) return util.globalScope.crypto.subtle.generateKey({
          name: "RSASSA-PKCS1-v1_5",
          modulusLength: bits,
          publicExponent: _intToUint8Array(e),
          hash: {
            name: "SHA-256"
          }
        }, !0, ["sign", "verify"]).then(function (pair) {
          return util.globalScope.crypto.subtle.exportKey("pkcs8", pair.privateKey);
        }).then(void 0, function (err) {
          callback(err);
        }).then(function (pkcs8) {
          if (pkcs8) {
            var privateKey = pki.privateKeyFromAsn1(asn1.fromDer(forge.util.createBuffer(pkcs8)));
            callback(null, {
              privateKey: privateKey,
              publicKey: pki.setRsaPublicKey(privateKey.n, privateKey.e)
            });
          }
        });
        if (_detectSubtleMsCrypto("generateKey") && _detectSubtleMsCrypto("exportKey")) {
          var genOp = util.globalScope.msCrypto.subtle.generateKey({
            name: "RSASSA-PKCS1-v1_5",
            modulusLength: bits,
            publicExponent: _intToUint8Array(e),
            hash: {
              name: "SHA-256"
            }
          }, !0, ["sign", "verify"]);
          genOp.oncomplete = function (e) {
            var pair = e.target.result,
              exportOp = util.globalScope.msCrypto.subtle.exportKey("pkcs8", pair.privateKey);
            exportOp.oncomplete = function (e) {
              var pkcs8 = e.target.result,
                privateKey = pki.privateKeyFromAsn1(asn1.fromDer(forge.util.createBuffer(pkcs8)));
              callback(null, {
                privateKey: privateKey,
                publicKey: pki.setRsaPublicKey(privateKey.n, privateKey.e)
              });
            }, exportOp.onerror = function (err) {
              callback(err);
            };
          }, genOp.onerror = function (err) {
            callback(err);
          };
          return;
        }
      } else if (_detectNodeCrypto("generateKeyPairSync")) {
        var keypair = _crypto.generateKeyPairSync("rsa", {
          modulusLength: bits,
          publicExponent: e,
          publicKeyEncoding: {
            type: "spki",
            format: "pem"
          },
          privateKeyEncoding: {
            type: "pkcs8",
            format: "pem"
          }
        });
        return {
          privateKey: pki.privateKeyFromPem(keypair.privateKey),
          publicKey: pki.publicKeyFromPem(keypair.publicKey)
        };
      }
    }
    var state = pki.rsa.createKeyPairGenerationState(bits, e, options);
    if (!callback) return pki.rsa.stepKeyPairGenerationState(state, 0), state.keys;
    _generateKeyPair(state, options, callback);
  };
  pki.setRsaPublicKey = pki.rsa.setPublicKey = function (n, e) {
    var key = {
      n: n,
      e: e
    };
    return key.encrypt = function (data, scheme, schemeOptions) {
      if (typeof scheme == "string" ? scheme = scheme.toUpperCase() : scheme === void 0 && (scheme = "RSAES-PKCS1-V1_5"), scheme === "RSAES-PKCS1-V1_5") scheme = {
        encode: __name(function (m, key, pub) {
          return _encodePkcs1_v1_5(m, key, 2).getBytes();
        }, "encode")
      };else if (scheme === "RSA-OAEP" || scheme === "RSAES-OAEP") scheme = {
        encode: __name(function (m, key) {
          return forge.pkcs1.encode_rsa_oaep(key, m, schemeOptions);
        }, "encode")
      };else if (["RAW", "NONE", "NULL", null].indexOf(scheme) !== -1) scheme = {
        encode: __name(function (e) {
          return e;
        }, "encode")
      };else if (typeof scheme == "string") throw new Error('Unsupported encryption scheme: "' + scheme + '".');
      var e = scheme.encode(data, key, !0);
      return pki.rsa.encrypt(e, key, !0);
    }, key.verify = function (digest, signature, scheme, options) {
      typeof scheme == "string" ? scheme = scheme.toUpperCase() : scheme === void 0 && (scheme = "RSASSA-PKCS1-V1_5"), options === void 0 && (options = {
        _parseAllDigestBytes: !0
      }), "_parseAllDigestBytes" in options || (options._parseAllDigestBytes = !0), scheme === "RSASSA-PKCS1-V1_5" ? scheme = {
        verify: __name(function (digest, d) {
          d = _decodePkcs1_v1_5(d, key, !0);
          var obj = asn1.fromDer(d, {
              parseAllBytes: options._parseAllDigestBytes
            }),
            capture = {},
            errors = [];
          if (!asn1.validate(obj, digestInfoValidator, capture, errors)) {
            var error = new Error("ASN.1 object does not contain a valid RSASSA-PKCS1-v1_5 DigestInfo value.");
            throw error.errors = errors, error;
          }
          var oid = asn1.derToOid(capture.algorithmIdentifier);
          if (!(oid === forge.oids.md2 || oid === forge.oids.md5 || oid === forge.oids.sha1 || oid === forge.oids.sha224 || oid === forge.oids.sha256 || oid === forge.oids.sha384 || oid === forge.oids.sha512 || oid === forge.oids["sha512-224"] || oid === forge.oids["sha512-256"])) {
            var error = new Error("Unknown RSASSA-PKCS1-v1_5 DigestAlgorithm identifier.");
            throw error.oid = oid, error;
          }
          if ((oid === forge.oids.md2 || oid === forge.oids.md5) && !("parameters" in capture)) throw new Error("ASN.1 object does not contain a valid RSASSA-PKCS1-v1_5 DigestInfo value. Missing algorithm identifer NULL parameters.");
          return digest === capture.digest;
        }, "verify")
      } : (scheme === "NONE" || scheme === "NULL" || scheme === null) && (scheme = {
        verify: __name(function (digest, d) {
          return d = _decodePkcs1_v1_5(d, key, !0), digest === d;
        }, "verify")
      });
      var d = pki.rsa.decrypt(signature, key, !0, !1);
      return scheme.verify(digest, d, key.n.bitLength());
    }, key;
  };
  pki.setRsaPrivateKey = pki.rsa.setPrivateKey = function (n, e, d, p, q, dP, dQ, qInv) {
    var key = {
      n: n,
      e: e,
      d: d,
      p: p,
      q: q,
      dP: dP,
      dQ: dQ,
      qInv: qInv
    };
    return key.decrypt = function (data, scheme, schemeOptions) {
      typeof scheme == "string" ? scheme = scheme.toUpperCase() : scheme === void 0 && (scheme = "RSAES-PKCS1-V1_5");
      var d = pki.rsa.decrypt(data, key, !1, !1);
      if (scheme === "RSAES-PKCS1-V1_5") scheme = {
        decode: _decodePkcs1_v1_5
      };else if (scheme === "RSA-OAEP" || scheme === "RSAES-OAEP") scheme = {
        decode: __name(function (d, key) {
          return forge.pkcs1.decode_rsa_oaep(key, d, schemeOptions);
        }, "decode")
      };else if (["RAW", "NONE", "NULL", null].indexOf(scheme) !== -1) scheme = {
        decode: __name(function (d) {
          return d;
        }, "decode")
      };else throw new Error('Unsupported encryption scheme: "' + scheme + '".');
      return scheme.decode(d, key, !1);
    }, key.sign = function (md, scheme) {
      var bt = !1;
      typeof scheme == "string" && (scheme = scheme.toUpperCase()), scheme === void 0 || scheme === "RSASSA-PKCS1-V1_5" ? (scheme = {
        encode: emsaPkcs1v15encode
      }, bt = 1) : (scheme === "NONE" || scheme === "NULL" || scheme === null) && (scheme = {
        encode: __name(function () {
          return md;
        }, "encode")
      }, bt = 1);
      var d = scheme.encode(md, key.n.bitLength());
      return pki.rsa.encrypt(d, key, bt);
    }, key;
  };
  pki.wrapRsaPrivateKey = function (rsaKey) {
    return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, !0, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, !1, asn1.integerToDer(0).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, !0, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, !1, asn1.oidToDer(pki.oids.rsaEncryption).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, !1, "")]), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, !1, asn1.toDer(rsaKey).getBytes())]);
  };
  pki.privateKeyFromAsn1 = function (obj) {
    var capture = {},
      errors = [];
    if (asn1.validate(obj, privateKeyValidator, capture, errors) && (obj = asn1.fromDer(forge.util.createBuffer(capture.privateKey))), capture = {}, errors = [], !asn1.validate(obj, rsaPrivateKeyValidator, capture, errors)) {
      var error = new Error("Cannot read private key. ASN.1 object does not contain an RSAPrivateKey.");
      throw error.errors = errors, error;
    }
    var n, e, d, p, q, dP, dQ, qInv;
    return n = forge.util.createBuffer(capture.privateKeyModulus).toHex(), e = forge.util.createBuffer(capture.privateKeyPublicExponent).toHex(), d = forge.util.createBuffer(capture.privateKeyPrivateExponent).toHex(), p = forge.util.createBuffer(capture.privateKeyPrime1).toHex(), q = forge.util.createBuffer(capture.privateKeyPrime2).toHex(), dP = forge.util.createBuffer(capture.privateKeyExponent1).toHex(), dQ = forge.util.createBuffer(capture.privateKeyExponent2).toHex(), qInv = forge.util.createBuffer(capture.privateKeyCoefficient).toHex(), pki.setRsaPrivateKey(new BigInteger(n, 16), new BigInteger(e, 16), new BigInteger(d, 16), new BigInteger(p, 16), new BigInteger(q, 16), new BigInteger(dP, 16), new BigInteger(dQ, 16), new BigInteger(qInv, 16));
  };
  pki.privateKeyToAsn1 = pki.privateKeyToRSAPrivateKey = function (key) {
    return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, !0, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, !1, asn1.integerToDer(0).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, !1, _bnToBytes(key.n)), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, !1, _bnToBytes(key.e)), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, !1, _bnToBytes(key.d)), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, !1, _bnToBytes(key.p)), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, !1, _bnToBytes(key.q)), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, !1, _bnToBytes(key.dP)), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, !1, _bnToBytes(key.dQ)), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, !1, _bnToBytes(key.qInv))]);
  };
  pki.publicKeyFromAsn1 = function (obj) {
    var capture = {},
      errors = [];
    if (asn1.validate(obj, publicKeyValidator, capture, errors)) {
      var oid = asn1.derToOid(capture.publicKeyOid);
      if (oid !== pki.oids.rsaEncryption) {
        var error = new Error("Cannot read public key. Unknown OID.");
        throw error.oid = oid, error;
      }
      obj = capture.rsaPublicKey;
    }
    if (errors = [], !asn1.validate(obj, rsaPublicKeyValidator, capture, errors)) {
      var error = new Error("Cannot read public key. ASN.1 object does not contain an RSAPublicKey.");
      throw error.errors = errors, error;
    }
    var n = forge.util.createBuffer(capture.publicKeyModulus).toHex(),
      e = forge.util.createBuffer(capture.publicKeyExponent).toHex();
    return pki.setRsaPublicKey(new BigInteger(n, 16), new BigInteger(e, 16));
  };
  pki.publicKeyToAsn1 = pki.publicKeyToSubjectPublicKeyInfo = function (key) {
    return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, !0, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, !0, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, !1, asn1.oidToDer(pki.oids.rsaEncryption).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, !1, "")]), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, !1, [pki.publicKeyToRSAPublicKey(key)])]);
  };
  pki.publicKeyToRSAPublicKey = function (key) {
    return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, !0, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, !1, _bnToBytes(key.n)), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, !1, _bnToBytes(key.e))]);
  };
  function _encodePkcs1_v1_5(m, key, bt) {
    var eb = forge.util.createBuffer(),
      k = Math.ceil(key.n.bitLength() / 8);
    if (m.length > k - 11) {
      var error = new Error("Message is too long for PKCS#1 v1.5 padding.");
      throw error.length = m.length, error.max = k - 11, error;
    }
    eb.putByte(0), eb.putByte(bt);
    var padNum = k - 3 - m.length,
      padByte;
    if (bt === 0 || bt === 1) {
      padByte = bt === 0 ? 0 : 255;
      for (var i = 0; i < padNum; ++i) eb.putByte(padByte);
    } else for (; padNum > 0;) {
      for (var numZeros = 0, padBytes = forge.random.getBytes(padNum), i = 0; i < padNum; ++i) padByte = padBytes.charCodeAt(i), padByte === 0 ? ++numZeros : eb.putByte(padByte);
      padNum = numZeros;
    }
    return eb.putByte(0), eb.putBytes(m), eb;
  }
  __name(_encodePkcs1_v1_5, "_encodePkcs1_v1_5");
  function _decodePkcs1_v1_5(em, key, pub, ml) {
    var k = Math.ceil(key.n.bitLength() / 8),
      eb = forge.util.createBuffer(em),
      first = eb.getByte(),
      bt = eb.getByte();
    if (first !== 0 || pub && bt !== 0 && bt !== 1 || !pub && bt != 2 || pub && bt === 0 && typeof ml > "u") throw new Error("Encryption block is invalid.");
    var padNum = 0;
    if (bt === 0) {
      padNum = k - 3 - ml;
      for (var i = 0; i < padNum; ++i) if (eb.getByte() !== 0) throw new Error("Encryption block is invalid.");
    } else if (bt === 1) for (padNum = 0; eb.length() > 1;) {
      if (eb.getByte() !== 255) {
        --eb.read;
        break;
      }
      ++padNum;
    } else if (bt === 2) for (padNum = 0; eb.length() > 1;) {
      if (eb.getByte() === 0) {
        --eb.read;
        break;
      }
      ++padNum;
    }
    var zero = eb.getByte();
    if (zero !== 0 || padNum !== k - 3 - eb.length()) throw new Error("Encryption block is invalid.");
    return eb.getBytes();
  }
  __name(_decodePkcs1_v1_5, "_decodePkcs1_v1_5");
  function _generateKeyPair(state, options, callback) {
    typeof options == "function" && (callback = options, options = {}), options = options || {};
    var opts = {
      algorithm: {
        name: options.algorithm || "PRIMEINC",
        options: {
          workers: options.workers || 2,
          workLoad: options.workLoad || 100,
          workerScript: options.workerScript
        }
      }
    };
    "prng" in options && (opts.prng = options.prng), generate();
    function generate() {
      getPrime(state.pBits, function (err, num) {
        if (err) return callback(err);
        if (state.p = num, state.q !== null) return finish(err, state.q);
        getPrime(state.qBits, finish);
      });
    }
    __name(generate, "generate");
    function getPrime(bits, callback) {
      forge.prime.generateProbablePrime(bits, opts, callback);
    }
    __name(getPrime, "getPrime");
    function finish(err, num) {
      if (err) return callback(err);
      if (state.q = num, state.p.compareTo(state.q) < 0) {
        var tmp = state.p;
        state.p = state.q, state.q = tmp;
      }
      if (state.p.subtract(BigInteger.ONE).gcd(state.e).compareTo(BigInteger.ONE) !== 0) {
        state.p = null, generate();
        return;
      }
      if (state.q.subtract(BigInteger.ONE).gcd(state.e).compareTo(BigInteger.ONE) !== 0) {
        state.q = null, getPrime(state.qBits, finish);
        return;
      }
      if (state.p1 = state.p.subtract(BigInteger.ONE), state.q1 = state.q.subtract(BigInteger.ONE), state.phi = state.p1.multiply(state.q1), state.phi.gcd(state.e).compareTo(BigInteger.ONE) !== 0) {
        state.p = state.q = null, generate();
        return;
      }
      if (state.n = state.p.multiply(state.q), state.n.bitLength() !== state.bits) {
        state.q = null, getPrime(state.qBits, finish);
        return;
      }
      var d = state.e.modInverse(state.phi);
      state.keys = {
        privateKey: pki.rsa.setPrivateKey(state.n, state.e, d, state.p, state.q, d.mod(state.p1), d.mod(state.q1), state.q.modInverse(state.p)),
        publicKey: pki.rsa.setPublicKey(state.n, state.e)
      }, callback(null, state.keys);
    }
    __name(finish, "finish");
  }
  __name(_generateKeyPair, "_generateKeyPair");
  function _bnToBytes(b) {
    var hex = b.toString(16);
    hex[0] >= "8" && (hex = "00" + hex);
    var bytes = forge.util.hexToBytes(hex);
    return bytes.length > 1 && (bytes.charCodeAt(0) === 0 && (bytes.charCodeAt(1) & 128) === 0 || bytes.charCodeAt(0) === 255 && (bytes.charCodeAt(1) & 128) === 128) ? bytes.substr(1) : bytes;
  }
  __name(_bnToBytes, "_bnToBytes");
  function _getMillerRabinTests(bits) {
    return bits <= 100 ? 27 : bits <= 150 ? 18 : bits <= 200 ? 15 : bits <= 250 ? 12 : bits <= 300 ? 9 : bits <= 350 ? 8 : bits <= 400 ? 7 : bits <= 500 ? 6 : bits <= 600 ? 5 : bits <= 800 ? 4 : bits <= 1250 ? 3 : 2;
  }
  __name(_getMillerRabinTests, "_getMillerRabinTests");
  function _detectNodeCrypto(fn) {
    return forge.util.isNodejs && typeof _crypto[fn] == "function";
  }
  __name(_detectNodeCrypto, "_detectNodeCrypto");
  function _detectSubtleCrypto(fn) {
    return typeof util.globalScope < "u" && typeof util.globalScope.crypto == "object" && typeof util.globalScope.crypto.subtle == "object" && typeof util.globalScope.crypto.subtle[fn] == "function";
  }
  __name(_detectSubtleCrypto, "_detectSubtleCrypto");
  function _detectSubtleMsCrypto(fn) {
    return typeof util.globalScope < "u" && typeof util.globalScope.msCrypto == "object" && typeof util.globalScope.msCrypto.subtle == "object" && typeof util.globalScope.msCrypto.subtle[fn] == "function";
  }
  __name(_detectSubtleMsCrypto, "_detectSubtleMsCrypto");
  function _intToUint8Array(x) {
    for (var bytes = forge.util.hexToBytes(x.toString(16)), buffer = new Uint8Array(bytes.length), i = 0; i < bytes.length; ++i) buffer[i] = bytes.charCodeAt(i);
    return buffer;
  }
  __name(_intToUint8Array, "_intToUint8Array");
});