var require_pbkdf2 = __commonJSMin((exports, module) => {
  var forge = Ja();
  WI();
  Cf();
  Ki();
  var pkcs5 = forge.pkcs5 = forge.pkcs5 || {},
    crypto;
  forge.util.isNodejs && !forge.options.usePureJavaScript && (crypto = require("crypto"));
  module.exports = forge.pbkdf2 = pkcs5.pbkdf2 = function (p, s, c, dkLen, md, callback) {
    if (typeof md == "function" && (callback = md, md = null), forge.util.isNodejs && !forge.options.usePureJavaScript && crypto.pbkdf2 && (md === null || typeof md != "object") && (crypto.pbkdf2Sync.length > 4 || !md || md === "sha1")) return typeof md != "string" && (md = "sha1"), p = Buffer.from(p, "binary"), s = Buffer.from(s, "binary"), callback ? crypto.pbkdf2Sync.length === 4 ? crypto.pbkdf2(p, s, c, dkLen, function (err, key) {
      if (err) return callback(err);
      callback(null, key.toString("binary"));
    }) : crypto.pbkdf2(p, s, c, dkLen, md, function (err, key) {
      if (err) return callback(err);
      callback(null, key.toString("binary"));
    }) : crypto.pbkdf2Sync.length === 4 ? crypto.pbkdf2Sync(p, s, c, dkLen).toString("binary") : crypto.pbkdf2Sync(p, s, c, dkLen, md).toString("binary");
    if ((typeof md > "u" || md === null) && (md = "sha1"), typeof md == "string") {
      if (!(md in forge.md.algorithms)) throw new Error("Unknown hash algorithm: " + md);
      md = forge.md[md].create();
    }
    var hLen = md.digestLength;
    if (dkLen > 4294967295 * hLen) {
      var err = new Error("Derived key is too long.");
      if (callback) return callback(err);
      throw err;
    }
    var len = Math.ceil(dkLen / hLen),
      r = dkLen - (len - 1) * hLen,
      prf = forge.hmac.create();
    prf.start(md, p);
    var dk = "",
      xor,
      u_c,
      u_c1;
    if (!callback) {
      for (var i = 1; i <= len; ++i) {
        prf.start(null, null), prf.update(s), prf.update(forge.util.int32ToBytes(i)), xor = u_c1 = prf.digest().getBytes();
        for (var j = 2; j <= c; ++j) prf.start(null, null), prf.update(u_c1), u_c = prf.digest().getBytes(), xor = forge.util.xorBytes(xor, u_c, hLen), u_c1 = u_c;
        dk += i < len ? xor : xor.substr(0, r);
      }
      return dk;
    }
    var i = 1,
      j;
    function outer() {
      if (i > len) return callback(null, dk);
      prf.start(null, null), prf.update(s), prf.update(forge.util.int32ToBytes(i)), xor = u_c1 = prf.digest().getBytes(), j = 2, inner();
    }
    __name(outer, "outer");
    function inner() {
      if (j <= c) return prf.start(null, null), prf.update(u_c1), u_c = prf.digest().getBytes(), xor = forge.util.xorBytes(xor, u_c, hLen), u_c1 = u_c, ++j, forge.util.setImmediate(inner);
      dk += i < len ? xor : xor.substr(0, r), ++i, outer();
    }
    __name(inner, "inner"), outer();
  };
});