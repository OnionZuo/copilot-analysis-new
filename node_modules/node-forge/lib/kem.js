var require_kem = __commonJSMin((exports, module) => {
  var forge = Ja();
  Ki();
  lp();
  X9();
  module.exports = forge.kem = forge.kem || {};
  var BigInteger = forge.jsbn.BigInteger;
  forge.kem.rsa = {};
  forge.kem.rsa.create = function (kdf, options) {
    options = options || {};
    var prng = options.prng || forge.random,
      kem = {};
    return kem.encrypt = function (publicKey, keyLength) {
      var byteLength = Math.ceil(publicKey.n.bitLength() / 8),
        r;
      do r = new BigInteger(forge.util.bytesToHex(prng.getBytesSync(byteLength)), 16).mod(publicKey.n); while (r.compareTo(BigInteger.ONE) <= 0);
      r = forge.util.hexToBytes(r.toString(16));
      var zeros = byteLength - r.length;
      zeros > 0 && (r = forge.util.fillString("\0", zeros) + r);
      var encapsulation = publicKey.encrypt(r, "NONE"),
        key = kdf.generate(r, keyLength);
      return {
        encapsulation: encapsulation,
        key: key
      };
    }, kem.decrypt = function (privateKey, encapsulation, keyLength) {
      var r = privateKey.decrypt(encapsulation, "NONE");
      return kdf.generate(r, keyLength);
    }, kem;
  };
  forge.kem.kdf1 = function (md, digestLength) {
    _createKDF(this, md, 0, digestLength || md.digestLength);
  };
  forge.kem.kdf2 = function (md, digestLength) {
    _createKDF(this, md, 1, digestLength || md.digestLength);
  };
  function _createKDF(kdf, md, counterStart, digestLength) {
    kdf.generate = function (x, length) {
      for (var key = new forge.util.ByteBuffer(), k = Math.ceil(length / digestLength) + counterStart, c = new forge.util.ByteBuffer(), i = counterStart; i < k; ++i) {
        c.putInt32(i), md.start(), md.update(x + c.getBytes());
        var hash = md.digest();
        key.putBytes(hash.getBytes(digestLength));
      }
      return key.truncate(key.length() - length), key.getBytes();
    };
  }
  __name(_createKDF, "_createKDF");
});