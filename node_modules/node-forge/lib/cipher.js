var require_cipher = __commonJSMin((exports, module) => {
  var forge = Ja();
  Ki();
  module.exports = forge.cipher = forge.cipher || {};
  forge.cipher.algorithms = forge.cipher.algorithms || {};
  forge.cipher.createCipher = function (algorithm, key) {
    var api = algorithm;
    if (typeof api == "string" && (api = forge.cipher.getAlgorithm(api), api && (api = api())), !api) throw new Error("Unsupported algorithm: " + algorithm);
    return new forge.cipher.BlockCipher({
      algorithm: api,
      key: key,
      decrypt: !1
    });
  };
  forge.cipher.createDecipher = function (algorithm, key) {
    var api = algorithm;
    if (typeof api == "string" && (api = forge.cipher.getAlgorithm(api), api && (api = api())), !api) throw new Error("Unsupported algorithm: " + algorithm);
    return new forge.cipher.BlockCipher({
      algorithm: api,
      key: key,
      decrypt: !0
    });
  };
  forge.cipher.registerAlgorithm = function (name, algorithm) {
    name = name.toUpperCase(), forge.cipher.algorithms[name] = algorithm;
  };
  forge.cipher.getAlgorithm = function (name) {
    return name = name.toUpperCase(), name in forge.cipher.algorithms ? forge.cipher.algorithms[name] : null;
  };
  var BlockCipher = forge.cipher.BlockCipher = function (options) {
    this.algorithm = options.algorithm, this.mode = this.algorithm.mode, this.blockSize = this.mode.blockSize, this._finish = !1, this._input = null, this.output = null, this._op = options.decrypt ? this.mode.decrypt : this.mode.encrypt, this._decrypt = options.decrypt, this.algorithm.initialize(options);
  };
  BlockCipher.prototype.start = function (options) {
    options = options || {};
    var opts = {};
    for (var key in options) opts[key] = options[key];
    opts.decrypt = this._decrypt, this._finish = !1, this._input = forge.util.createBuffer(), this.output = options.output || forge.util.createBuffer(), this.mode.start(opts);
  };
  BlockCipher.prototype.update = function (input) {
    for (input && this._input.putBuffer(input); !this._op.call(this.mode, this._input, this.output, this._finish) && !this._finish;);
    this._input.compact();
  };
  BlockCipher.prototype.finish = function (pad) {
    pad && (this.mode.name === "ECB" || this.mode.name === "CBC") && (this.mode.pad = function (input) {
      return pad(this.blockSize, input, !1);
    }, this.mode.unpad = function (output) {
      return pad(this.blockSize, output, !0);
    });
    var options = {};
    return options.decrypt = this._decrypt, options.overflow = this._input.length() % this.blockSize, !(!this._decrypt && this.mode.pad && !this.mode.pad(this._input, options) || (this._finish = !0, this.update(), this._decrypt && this.mode.unpad && !this.mode.unpad(this.output, options)) || this.mode.afterFinish && !this.mode.afterFinish(this.output, options));
  };
});