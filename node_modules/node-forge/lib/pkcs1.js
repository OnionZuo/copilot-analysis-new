var require_pkcs1 = __commonJSMin((exports, module) => {
  var forge = Ja();
  Ki();
  lp();
  VI();
  var pkcs1 = module.exports = forge.pkcs1 = forge.pkcs1 || {};
  pkcs1.encode_rsa_oaep = function (key, message, options) {
    var label, seed, md, mgf1Md;
    typeof options == "string" ? (label = options, seed = arguments[3] || void 0, md = arguments[4] || void 0) : options && (label = options.label || void 0, seed = options.seed || void 0, md = options.md || void 0, options.mgf1 && options.mgf1.md && (mgf1Md = options.mgf1.md)), md ? md.start() : md = forge.md.sha1.create(), mgf1Md || (mgf1Md = md);
    var keyLength = Math.ceil(key.n.bitLength() / 8),
      maxLength = keyLength - 2 * md.digestLength - 2;
    if (message.length > maxLength) {
      var error = new Error("RSAES-OAEP input message length is too long.");
      throw error.length = message.length, error.maxLength = maxLength, error;
    }
    label || (label = ""), md.update(label, "raw");
    for (var lHash = md.digest(), PS = "", PS_length = maxLength - message.length, i = 0; i < PS_length; i++) PS += "\0";
    var DB = lHash.getBytes() + PS + "" + message;
    if (!seed) seed = forge.random.getBytes(md.digestLength);else if (seed.length !== md.digestLength) {
      var error = new Error("Invalid RSAES-OAEP seed. The seed length must match the digest length.");
      throw error.seedLength = seed.length, error.digestLength = md.digestLength, error;
    }
    var dbMask = rsa_mgf1(seed, keyLength - md.digestLength - 1, mgf1Md),
      maskedDB = forge.util.xorBytes(DB, dbMask, DB.length),
      seedMask = rsa_mgf1(maskedDB, md.digestLength, mgf1Md),
      maskedSeed = forge.util.xorBytes(seed, seedMask, seed.length);
    return "\0" + maskedSeed + maskedDB;
  };
  pkcs1.decode_rsa_oaep = function (key, em, options) {
    var label, md, mgf1Md;
    typeof options == "string" ? (label = options, md = arguments[3] || void 0) : options && (label = options.label || void 0, md = options.md || void 0, options.mgf1 && options.mgf1.md && (mgf1Md = options.mgf1.md));
    var keyLength = Math.ceil(key.n.bitLength() / 8);
    if (em.length !== keyLength) {
      var error = new Error("RSAES-OAEP encoded message length is invalid.");
      throw error.length = em.length, error.expectedLength = keyLength, error;
    }
    if (md === void 0 ? md = forge.md.sha1.create() : md.start(), mgf1Md || (mgf1Md = md), keyLength < 2 * md.digestLength + 2) throw new Error("RSAES-OAEP key is too short for the hash function.");
    label || (label = ""), md.update(label, "raw");
    for (var lHash = md.digest().getBytes(), y = em.charAt(0), maskedSeed = em.substring(1, md.digestLength + 1), maskedDB = em.substring(1 + md.digestLength), seedMask = rsa_mgf1(maskedDB, md.digestLength, mgf1Md), seed = forge.util.xorBytes(maskedSeed, seedMask, maskedSeed.length), dbMask = rsa_mgf1(seed, keyLength - md.digestLength - 1, mgf1Md), db = forge.util.xorBytes(maskedDB, dbMask, maskedDB.length), lHashPrime = db.substring(0, md.digestLength), error = y !== "\0", i = 0; i < md.digestLength; ++i) error |= lHash.charAt(i) !== lHashPrime.charAt(i);
    for (var in_ps = 1, index = md.digestLength, j = md.digestLength; j < db.length; j++) {
      var code = db.charCodeAt(j),
        is_0 = code & 1 ^ 1,
        error_mask = in_ps ? 65534 : 0;
      error |= code & error_mask, in_ps = in_ps & is_0, index += in_ps;
    }
    if (error || db.charCodeAt(index) !== 1) throw new Error("Invalid RSAES-OAEP padding.");
    return db.substring(index + 1);
  };
  function rsa_mgf1(seed, maskLength, hash) {
    hash || (hash = forge.md.sha1.create());
    for (var t = "", count = Math.ceil(maskLength / hash.digestLength), i = 0; i < count; ++i) {
      var c = String.fromCharCode(i >> 24 & 255, i >> 16 & 255, i >> 8 & 255, i & 255);
      hash.start(), hash.update(seed + c), t += hash.digest().getBytes();
    }
    return t.substring(0, maskLength);
  }
  __name(rsa_mgf1, "rsa_mgf1");
});