var require_log = __commonJSMin((exports, module) => {
  var forge = Ja();
  Ki();
  module.exports = forge.log = forge.log || {};
  forge.log.levels = ["none", "error", "warning", "info", "debug", "verbose", "max"];
  var sLevelInfo = {},
    sLoggers = [],
    sConsoleLogger = null;
  forge.log.LEVEL_LOCKED = 2;
  forge.log.NO_LEVEL_CHECK = 4;
  forge.log.INTERPOLATE = 8;
  for (i = 0; i < forge.log.levels.length; ++i) level = forge.log.levels[i], sLevelInfo[level] = {
    index: i,
    name: level.toUpperCase()
  };
  var level, i;
  forge.log.logMessage = function (message) {
    for (var messageLevelIndex = sLevelInfo[message.level].index, i = 0; i < sLoggers.length; ++i) {
      var logger = sLoggers[i];
      if (logger.flags & forge.log.NO_LEVEL_CHECK) logger.f(message);else {
        var loggerLevelIndex = sLevelInfo[logger.level].index;
        messageLevelIndex <= loggerLevelIndex && logger.f(logger, message);
      }
    }
  };
  forge.log.prepareStandard = function (message) {
    "standard" in message || (message.standard = sLevelInfo[message.level].name + " [" + message.category + "] " + message.message);
  };
  forge.log.prepareFull = function (message) {
    if (!("full" in message)) {
      var args = [message.message];
      args = args.concat([]), message.full = forge.util.format.apply(this, args);
    }
  };
  forge.log.prepareStandardFull = function (message) {
    "standardFull" in message || (forge.log.prepareStandard(message), message.standardFull = message.standard);
  };
  for (levels = ["error", "warning", "info", "debug", "verbose"], i = 0; i < levels.length; ++i) (function (level) {
    forge.log[level] = function (category, message) {
      var args = Array.prototype.slice.call(arguments).slice(2),
        msg = {
          timestamp: new Date(),
          level: level,
          category: category,
          message: message,
          arguments: args
        };
      forge.log.logMessage(msg);
    };
  })(levels[i]);
  var levels, i;
  forge.log.makeLogger = function (logFunction) {
    var logger = {
      flags: 0,
      f: logFunction
    };
    return forge.log.setLevel(logger, "none"), logger;
  };
  forge.log.setLevel = function (logger, level) {
    var rval = !1;
    if (logger && !(logger.flags & forge.log.LEVEL_LOCKED)) for (var i = 0; i < forge.log.levels.length; ++i) {
      var aValidLevel = forge.log.levels[i];
      if (level == aValidLevel) {
        logger.level = level, rval = !0;
        break;
      }
    }
    return rval;
  };
  forge.log.lock = function (logger, lock) {
    typeof lock > "u" || lock ? logger.flags |= forge.log.LEVEL_LOCKED : logger.flags &= ~forge.log.LEVEL_LOCKED;
  };
  forge.log.addLogger = function (logger) {
    sLoggers.push(logger);
  };
  typeof console < "u" && "log" in console ? (console.error && console.warn && console.info && console.debug ? (levelHandlers = {
    error: console.error,
    warning: console.warn,
    info: console.info,
    debug: console.debug,
    verbose: console.debug
  }, f = __name(function (logger, message) {
    forge.log.prepareStandard(message);
    var handler = levelHandlers[message.level],
      args = [message.standard];
    args = args.concat(message.arguments.slice()), handler.apply(console, args);
  }, "f"), logger = forge.log.makeLogger(f)) : (f = __name(function (logger, message) {
    forge.log.prepareStandardFull(message), console.log(message.standardFull);
  }, "f"), logger = forge.log.makeLogger(f)), forge.log.setLevel(logger, "debug"), forge.log.addLogger(logger), sConsoleLogger = logger) : console = {
    log: __name(function () {}, "log")
  };
  var logger, levelHandlers, f;
  sConsoleLogger !== null && typeof window < "u" && window.location && (query = new URL(window.location.href).searchParams, query.has("console.level") && forge.log.setLevel(sConsoleLogger, query.get("console.level").slice(-1)[0]), query.has("console.lock") && (lock = query.get("console.lock").slice(-1)[0], lock == "true" && forge.log.lock(sConsoleLogger)));
  var query, lock;
  forge.log.consoleLogger = sConsoleLogger;
});