var require_formatter = __commonJSMin(exports => {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: !0
  });
  exports.convert = exports.Format = void 0;
  var forge = gze(),
    Format;
  (function (Format) {
    Format.der = "der", Format.pem = "pem", Format.txt = "txt", Format.asn1 = "asn1", Format.x509 = "x509", Format.fingerprint = "fingerprint";
  })(Format = exports.Format || (exports.Format = {}));
  function myASN(pem) {
    var der = forge.pki.pemToDer(pem),
      asn1 = forge.asn1,
      crt = asn1.fromDer(der.data.toString("binary")).value[0].value,
      serial = crt[0],
      hasSerial = serial.tagClass === asn1.Class.CONTEXT_SPECIFIC && serial.type === 0 && serial.constructed,
      slicedCrt = crt.slice(hasSerial);
    return {
      serial: slicedCrt[0],
      issuer: slicedCrt[2],
      valid: slicedCrt[3],
      subject: slicedCrt[4]
    };
  }
  __name(myASN, "myASN");
  function txtFormat(pem) {
    var crt = myASN(pem),
      subject = crt.subject.value.map(function (rdn) {
        return rdn.value[0].value[1].value;
      }).join("/"),
      valid = crt.valid.value.map(function (date) {
        return date.value;
      }).join(" - ");
    return ["Subject	".concat(subject), "Valid	".concat(valid), String(pem)].join(`
`);
  }
  __name(txtFormat, "txtFormat");
  function convert(pem, format) {
    switch (format) {
      case Format.der:
        return forge.pki.pemToDer(pem);
      case Format.pem:
        return pem;
      case Format.txt:
        return txtFormat(pem);
      case Format.asn1:
        return myASN(pem);
      case Format.fingerprint:
        var md = forge.md.sha1.create(),
          der = convert(pem, Format.der);
        return md.update(der.getBytes()), md.digest().toHex();
      case Format.x509:
        return forge.pki.certificateFromPem(pem);
      default:
        throw new Error("unknown format ".concat(format));
    }
  }
  __name(convert, "convert");
  exports.convert = convert;
});