var require_util = __commonJSMin((exports, module) => {
  "use strict";

  function validateParameter(parameter, specs, specIndex) {
    let spec = specs[specIndex];
    if (parameter == null && spec.required === !1) return;
    if (parameter == null) throw new TypeError(`Required parameter \`${spec.name}\` missing`);
    let paramType = typeof parameter;
    if (spec.type && paramType !== spec.type) {
      if (spec.required === !1 && specs.slice(specIndex).some(def => def.type === paramType)) return !1;
      throw new TypeError(`Invalid type for parameter \`${spec.name}\`, expected \`${spec.type}\` but found \`${typeof parameter}\``);
    }
    return !0;
  }
  __name(validateParameter, "validateParameter");
  function hasOwnProperty(object, property) {
    return Object.prototype.hasOwnProperty.call(object, property);
  }
  __name(hasOwnProperty, "hasOwnProperty");
  function defineOperation(fn, paramDefs) {
    return function () {
      let args = Array.prototype.slice.call(arguments),
        params = [];
      for (let i = 0, argIdx = 0; i < paramDefs.length; ++i, ++argIdx) {
        let def = paramDefs[i],
          arg = args[argIdx];
        hasOwnProperty(def, "default") && arg == null && (arg = def.default), def.type === "object" && def.default != null && (arg = Object.assign({}, def.default, arg)), def.name === "options" && (typeof arg == "function" || arg == null) && (arg = {}), validateParameter(arg, paramDefs, i) ? params.push(arg) : argIdx--;
      }
      if (typeof arguments[arguments.length - 1] != "function") return new Promise((resolve, reject) => {
        params.push((err, response) => {
          if (err) return reject(err);
          resolve(response);
        }), fn.apply(this, params);
      });
      fn.apply(this, params);
    };
  }
  __name(defineOperation, "defineOperation");
  module.exports = {
    defineOperation: defineOperation,
    validateParameter: validateParameter
  };
});