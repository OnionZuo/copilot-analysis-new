function Diff() {},__name(Diff, "Diff");,Diff.prototype = {
  diff: __name(function (oldString, newString) {
    var _options$timeout,
      options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {},
      callback = options.callback;
    typeof options == "function" && (callback = options, options = {});
    var self = this;
    function done(value) {
      return value = self.postProcess(value, options), callback ? (setTimeout(function () {
        callback(value);
      }, 0), !0) : value;
    }
    __name(done, "done"), oldString = this.castInput(oldString, options), newString = this.castInput(newString, options), oldString = this.removeEmpty(this.tokenize(oldString, options)), newString = this.removeEmpty(this.tokenize(newString, options));
    var newLen = newString.length,
      oldLen = oldString.length,
      editLength = 1,
      maxEditLength = newLen + oldLen;
    options.maxEditLength != null && (maxEditLength = Math.min(maxEditLength, options.maxEditLength));
    var maxExecutionTime = (_options$timeout = options.timeout) !== null && _options$timeout !== void 0 ? _options$timeout : 1 / 0,
      abortAfterTimestamp = Date.now() + maxExecutionTime,
      bestPath = [{
        oldPos: -1,
        lastComponent: void 0
      }],
      newPos = this.extractCommon(bestPath[0], newString, oldString, 0, options);
    if (bestPath[0].oldPos + 1 >= oldLen && newPos + 1 >= newLen) return done(buildValues(self, bestPath[0].lastComponent, newString, oldString, self.useLongestToken));
    var minDiagonalToConsider = -1 / 0,
      maxDiagonalToConsider = 1 / 0;
    function execEditLength() {
      for (var diagonalPath = Math.max(minDiagonalToConsider, -editLength); diagonalPath <= Math.min(maxDiagonalToConsider, editLength); diagonalPath += 2) {
        var basePath = void 0,
          removePath = bestPath[diagonalPath - 1],
          addPath = bestPath[diagonalPath + 1];
        removePath && (bestPath[diagonalPath - 1] = void 0);
        var canAdd = !1;
        if (addPath) {
          var addPathNewPos = addPath.oldPos - diagonalPath;
          canAdd = addPath && 0 <= addPathNewPos && addPathNewPos < newLen;
        }
        var canRemove = removePath && removePath.oldPos + 1 < oldLen;
        if (!canAdd && !canRemove) {
          bestPath[diagonalPath] = void 0;
          continue;
        }
        if (!canRemove || canAdd && removePath.oldPos < addPath.oldPos ? basePath = self.addToPath(addPath, !0, !1, 0, options) : basePath = self.addToPath(removePath, !1, !0, 1, options), newPos = self.extractCommon(basePath, newString, oldString, diagonalPath, options), basePath.oldPos + 1 >= oldLen && newPos + 1 >= newLen) return done(buildValues(self, basePath.lastComponent, newString, oldString, self.useLongestToken));
        bestPath[diagonalPath] = basePath, basePath.oldPos + 1 >= oldLen && (maxDiagonalToConsider = Math.min(maxDiagonalToConsider, diagonalPath - 1)), newPos + 1 >= newLen && (minDiagonalToConsider = Math.max(minDiagonalToConsider, diagonalPath + 1));
      }
      editLength++;
    }
    if (__name(execEditLength, "execEditLength"), callback) __name(function exec() {
      setTimeout(function () {
        if (editLength > maxEditLength || Date.now() > abortAfterTimestamp) return callback();
        execEditLength() || exec();
      }, 0);
    }, "exec")();else for (; editLength <= maxEditLength && Date.now() <= abortAfterTimestamp;) {
      var ret = execEditLength();
      if (ret) return ret;
    }
  }, "diff"),
  addToPath: __name(function (path, added, removed, oldPosInc, options) {
    var last = path.lastComponent;
    return last && !options.oneChangePerToken && last.added === added && last.removed === removed ? {
      oldPos: path.oldPos + oldPosInc,
      lastComponent: {
        count: last.count + 1,
        added: added,
        removed: removed,
        previousComponent: last.previousComponent
      }
    } : {
      oldPos: path.oldPos + oldPosInc,
      lastComponent: {
        count: 1,
        added: added,
        removed: removed,
        previousComponent: last
      }
    };
  }, "addToPath"),
  extractCommon: __name(function (basePath, newString, oldString, diagonalPath, options) {
    for (var newLen = newString.length, oldLen = oldString.length, oldPos = basePath.oldPos, newPos = oldPos - diagonalPath, commonCount = 0; newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(oldString[oldPos + 1], newString[newPos + 1], options);) newPos++, oldPos++, commonCount++, options.oneChangePerToken && (basePath.lastComponent = {
      count: 1,
      previousComponent: basePath.lastComponent,
      added: !1,
      removed: !1
    });
    return commonCount && !options.oneChangePerToken && (basePath.lastComponent = {
      count: commonCount,
      previousComponent: basePath.lastComponent,
      added: !1,
      removed: !1
    }), basePath.oldPos = oldPos, newPos;
  }, "extractCommon"),
  equals: __name(function (left, right, options) {
    return options.comparator ? options.comparator(left, right) : left === right || options.ignoreCase && left.toLowerCase() === right.toLowerCase();
  }, "equals"),
  removeEmpty: __name(function (array) {
    for (var ret = [], i = 0; i < array.length; i++) array[i] && ret.push(array[i]);
    return ret;
  }, "removeEmpty"),
  castInput: __name(function (value) {
    return value;
  }, "castInput"),
  tokenize: __name(function (value) {
    return Array.from(value);
  }, "tokenize"),
  join: __name(function (chars) {
    return chars.join("");
  }, "join"),
  postProcess: __name(function (changeObjects) {
    return changeObjects;
  }, "postProcess")
};,function buildValues(diff, lastComponent, newString, oldString, useLongestToken) {
  for (var components = [], nextComponent; lastComponent;) components.push(lastComponent), nextComponent = lastComponent.previousComponent, delete lastComponent.previousComponent, lastComponent = nextComponent;
  components.reverse();
  for (var componentPos = 0, componentLen = components.length, newPos = 0, oldPos = 0; componentPos < componentLen; componentPos++) {
    var component = components[componentPos];
    if (component.removed) component.value = diff.join(oldString.slice(oldPos, oldPos + component.count)), oldPos += component.count;else {
      if (!component.added && useLongestToken) {
        var value = newString.slice(newPos, newPos + component.count);
        value = value.map(function (value, i) {
          var oldValue = oldString[oldPos + i];
          return oldValue.length > value.length ? oldValue : value;
        }), component.value = diff.join(value);
      } else component.value = diff.join(newString.slice(newPos, newPos + component.count));
      newPos += component.count, component.added || (oldPos += component.count);
    }
  }
  return components;
},__name(buildValues, "buildValues");,var characterDiff = new Diff();,function longestCommonPrefix(str1, str2) {
  var i;
  for (i = 0; i < str1.length && i < str2.length; i++) if (str1[i] != str2[i]) return str1.slice(0, i);
  return str1.slice(0, i);
},__name(longestCommonPrefix, "longestCommonPrefix");,function longestCommonSuffix(str1, str2) {
  var i;
  if (!str1 || !str2 || str1[str1.length - 1] != str2[str2.length - 1]) return "";
  for (i = 0; i < str1.length && i < str2.length; i++) if (str1[str1.length - (i + 1)] != str2[str2.length - (i + 1)]) return str1.slice(-i);
  return str1.slice(-i);
},__name(longestCommonSuffix, "longestCommonSuffix");,function replacePrefix(string, oldPrefix, newPrefix) {
  if (string.slice(0, oldPrefix.length) != oldPrefix) throw Error("string ".concat(JSON.stringify(string), " doesn't start with prefix ").concat(JSON.stringify(oldPrefix), "; this is a bug"));
  return newPrefix + string.slice(oldPrefix.length);
},__name(replacePrefix, "replacePrefix");,function replaceSuffix(string, oldSuffix, newSuffix) {
  if (!oldSuffix) return string + newSuffix;
  if (string.slice(-oldSuffix.length) != oldSuffix) throw Error("string ".concat(JSON.stringify(string), " doesn't end with suffix ").concat(JSON.stringify(oldSuffix), "; this is a bug"));
  return string.slice(0, -oldSuffix.length) + newSuffix;
},__name(replaceSuffix, "replaceSuffix");,function removePrefix(string, oldPrefix) {
  return replacePrefix(string, oldPrefix, "");
},__name(removePrefix, "removePrefix");,function removeSuffix(string, oldSuffix) {
  return replaceSuffix(string, oldSuffix, "");
},__name(removeSuffix, "removeSuffix");,function maximumOverlap(string1, string2) {
  return string2.slice(0, overlapCount(string1, string2));
},__name(maximumOverlap, "maximumOverlap");,function overlapCount(a, b) {
  var startA = 0;
  a.length > b.length && (startA = a.length - b.length);
  var endB = b.length;
  a.length < b.length && (endB = a.length);
  var map = Array(endB),
    k = 0;
  map[0] = 0;
  for (var j = 1; j < endB; j++) {
    for (b[j] == b[k] ? map[j] = map[k] : map[j] = k; k > 0 && b[j] != b[k];) k = map[k];
    b[j] == b[k] && k++;
  }
  k = 0;
  for (var i = startA; i < a.length; i++) {
    for (; k > 0 && a[i] != b[k];) k = map[k];
    a[i] == b[k] && k++;
  }
  return k;
},__name(overlapCount, "overlapCount");,var extendedWordChars = "a-zA-Z0-9_\\u{C0}-\\u{FF}\\u{D8}-\\u{F6}\\u{F8}-\\u{2C6}\\u{2C8}-\\u{2D7}\\u{2DE}-\\u{2FF}\\u{1E00}-\\u{1EFF}",
  tokenizeIncludingWhitespace = new RegExp("[".concat(extendedWordChars, "]+|\\s+|[^").concat(extendedWordChars, "]"), "ug"),
  wordDiff = new Diff();,wordDiff.equals = function (left, right, options) {
  return options.ignoreCase && (left = left.toLowerCase(), right = right.toLowerCase()), left.trim() === right.trim();
};,wordDiff.tokenize = function (value) {
  var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
    parts;
  if (options.intlSegmenter) {
    if (options.intlSegmenter.resolvedOptions().granularity != "word") throw new Error('The segmenter passed must have a granularity of "word"');
    parts = Array.from(options.intlSegmenter.segment(value), function (segment) {
      return segment.segment;
    });
  } else parts = value.match(tokenizeIncludingWhitespace) || [];
  var tokens = [],
    prevPart = null;
  return parts.forEach(function (part) {
    /\s/.test(part) ? prevPart == null ? tokens.push(part) : tokens.push(tokens.pop() + part) : /\s/.test(prevPart) ? tokens[tokens.length - 1] == prevPart ? tokens.push(tokens.pop() + part) : tokens.push(prevPart + part) : tokens.push(part), prevPart = part;
  }), tokens;
};,wordDiff.join = function (tokens) {
  return tokens.map(function (token, i) {
    return i == 0 ? token : token.replace(/^\s+/, "");
  }).join("");
};,wordDiff.postProcess = function (changes, options) {
  if (!changes || options.oneChangePerToken) return changes;
  var lastKeep = null,
    insertion = null,
    deletion = null;
  return changes.forEach(function (change) {
    change.added ? insertion = change : change.removed ? deletion = change : ((insertion || deletion) && dedupeWhitespaceInChangeObjects(lastKeep, deletion, insertion, change), lastKeep = change, insertion = null, deletion = null);
  }), (insertion || deletion) && dedupeWhitespaceInChangeObjects(lastKeep, deletion, insertion, null), changes;
};,function dedupeWhitespaceInChangeObjects(startKeep, deletion, insertion, endKeep) {
  if (deletion && insertion) {
    var oldWsPrefix = deletion.value.match(/^\s*/)[0],
      oldWsSuffix = deletion.value.match(/\s*$/)[0],
      newWsPrefix = insertion.value.match(/^\s*/)[0],
      newWsSuffix = insertion.value.match(/\s*$/)[0];
    if (startKeep) {
      var commonWsPrefix = longestCommonPrefix(oldWsPrefix, newWsPrefix);
      startKeep.value = replaceSuffix(startKeep.value, newWsPrefix, commonWsPrefix), deletion.value = removePrefix(deletion.value, commonWsPrefix), insertion.value = removePrefix(insertion.value, commonWsPrefix);
    }
    if (endKeep) {
      var commonWsSuffix = longestCommonSuffix(oldWsSuffix, newWsSuffix);
      endKeep.value = replacePrefix(endKeep.value, newWsSuffix, commonWsSuffix), deletion.value = removeSuffix(deletion.value, commonWsSuffix), insertion.value = removeSuffix(insertion.value, commonWsSuffix);
    }
  } else if (insertion) startKeep && (insertion.value = insertion.value.replace(/^\s*/, "")), endKeep && (endKeep.value = endKeep.value.replace(/^\s*/, ""));else if (startKeep && endKeep) {
    var newWsFull = endKeep.value.match(/^\s*/)[0],
      delWsStart = deletion.value.match(/^\s*/)[0],
      delWsEnd = deletion.value.match(/\s*$/)[0],
      newWsStart = longestCommonPrefix(newWsFull, delWsStart);
    deletion.value = removePrefix(deletion.value, newWsStart);
    var newWsEnd = longestCommonSuffix(removePrefix(newWsFull, newWsStart), delWsEnd);
    deletion.value = removeSuffix(deletion.value, newWsEnd), endKeep.value = replacePrefix(endKeep.value, newWsFull, newWsEnd), startKeep.value = replaceSuffix(startKeep.value, newWsFull, newWsFull.slice(0, newWsFull.length - newWsEnd.length));
  } else if (endKeep) {
    var endKeepWsPrefix = endKeep.value.match(/^\s*/)[0],
      deletionWsSuffix = deletion.value.match(/\s*$/)[0],
      overlap = maximumOverlap(deletionWsSuffix, endKeepWsPrefix);
    deletion.value = removeSuffix(deletion.value, overlap);
  } else if (startKeep) {
    var startKeepWsSuffix = startKeep.value.match(/\s*$/)[0],
      deletionWsPrefix = deletion.value.match(/^\s*/)[0],
      _overlap = maximumOverlap(startKeepWsSuffix, deletionWsPrefix);
    deletion.value = removePrefix(deletion.value, _overlap);
  }
},__name(dedupeWhitespaceInChangeObjects, "dedupeWhitespaceInChangeObjects");,var wordWithSpaceDiff = new Diff();,wordWithSpaceDiff.tokenize = function (value) {
  var regex = new RegExp("(\\r?\\n)|[".concat(extendedWordChars, "]+|[^\\S\\n\\r]+|[^").concat(extendedWordChars, "]"), "ug");
  return value.match(regex) || [];
};,var lineDiff = new Diff();,lineDiff.tokenize = function (value, options) {
  options.stripTrailingCr && (value = value.replace(/\r\n/g, `
`));
  var retLines = [],
    linesAndNewlines = value.split(/(\n|\r\n)/);
  linesAndNewlines[linesAndNewlines.length - 1] || linesAndNewlines.pop();
  for (var i = 0; i < linesAndNewlines.length; i++) {
    var line = linesAndNewlines[i];
    i % 2 && !options.newlineIsToken ? retLines[retLines.length - 1] += line : retLines.push(line);
  }
  return retLines;
};,lineDiff.equals = function (left, right, options) {
  return options.ignoreWhitespace ? ((!options.newlineIsToken || !left.includes(`
`)) && (left = left.trim()), (!options.newlineIsToken || !right.includes(`
`)) && (right = right.trim())) : options.ignoreNewlineAtEof && !options.newlineIsToken && (left.endsWith(`
`) && (left = left.slice(0, -1)), right.endsWith(`
`) && (right = right.slice(0, -1))), Diff.prototype.equals.call(this, left, right, options);
};,function diffLines(oldStr, newStr, callback) {
  return lineDiff.diff(oldStr, newStr, callback);
},__name(diffLines, "diffLines");,var sentenceDiff = new Diff();,sentenceDiff.tokenize = function (value) {
  return value.split(/(\S.+?[.!?])(?=\s+|$)/);
};,var cssDiff = new Diff();,cssDiff.tokenize = function (value) {
  return value.split(/([{}:;,]|\s+)/);
};,function ownKeys(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function (r) {
      return Object.getOwnPropertyDescriptor(e, r).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
},__name(ownKeys, "ownKeys");,function _objectSpread2(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = arguments[r] != null ? arguments[r] : {};
    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {
      _defineProperty(e, r, t[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
    });
  }
  return e;
},__name(_objectSpread2, "_objectSpread2");,function _toPrimitive(t, r) {
  if (typeof t != "object" || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (e !== void 0) {
    var i = e.call(t, r || "default");
    if (typeof i != "object") return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (r === "string" ? String : Number)(t);
},__name(_toPrimitive, "_toPrimitive");,function _toPropertyKey(t) {
  var i = _toPrimitive(t, "string");
  return typeof i == "symbol" ? i : i + "";
},__name(_toPropertyKey, "_toPropertyKey");,function _typeof(o) {
  "@babel/helpers - typeof";

  return _typeof = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function (o) {
    return typeof o;
  } : function (o) {
    return o && typeof Symbol == "function" && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
  }, _typeof(o);
},__name(_typeof, "_typeof");,function _defineProperty(obj, key, value) {
  return key = _toPropertyKey(key), key in obj ? Object.defineProperty(obj, key, {
    value: value,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : obj[key] = value, obj;
},__name(_defineProperty, "_defineProperty");,function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
},__name(_toConsumableArray, "_toConsumableArray");,function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
},__name(_arrayWithoutHoles, "_arrayWithoutHoles");,function _iterableToArray(iter) {
  if (typeof Symbol < "u" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
},__name(_iterableToArray, "_iterableToArray");,function _unsupportedIterableToArray(o, minLen) {
  if (o) {
    if (typeof o == "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor && (n = o.constructor.name), n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
  }
},__name(_unsupportedIterableToArray, "_unsupportedIterableToArray");,function _arrayLikeToArray(arr, len) {
  (len == null || len > arr.length) && (len = arr.length);
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
},__name(_arrayLikeToArray, "_arrayLikeToArray");,function _nonIterableSpread() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
},__name(_nonIterableSpread, "_nonIterableSpread");,var jsonDiff = new Diff();,jsonDiff.useLongestToken = !0;,jsonDiff.tokenize = lineDiff.tokenize;,jsonDiff.castInput = function (value, options) {
  var undefinedReplacement = options.undefinedReplacement,
    _options$stringifyRep = options.stringifyReplacer,
    stringifyReplacer = _options$stringifyRep === void 0 ? function (k, v) {
      return typeof v > "u" ? undefinedReplacement : v;
    } : _options$stringifyRep;
  return typeof value == "string" ? value : JSON.stringify(canonicalize(value, null, null, stringifyReplacer), stringifyReplacer, "  ");
};,jsonDiff.equals = function (left, right, options) {
  return Diff.prototype.equals.call(jsonDiff, left.replace(/,([\r\n])/g, "$1"), right.replace(/,([\r\n])/g, "$1"), options);
};,function canonicalize(obj, stack, replacementStack, replacer, key) {
  stack = stack || [], replacementStack = replacementStack || [], replacer && (obj = replacer(key, obj));
  var i;
  for (i = 0; i < stack.length; i += 1) if (stack[i] === obj) return replacementStack[i];
  var canonicalizedObj;
  if (Object.prototype.toString.call(obj) === "[object Array]") {
    for (stack.push(obj), canonicalizedObj = new Array(obj.length), replacementStack.push(canonicalizedObj), i = 0; i < obj.length; i += 1) canonicalizedObj[i] = canonicalize(obj[i], stack, replacementStack, replacer, key);
    return stack.pop(), replacementStack.pop(), canonicalizedObj;
  }
  if (obj && obj.toJSON && (obj = obj.toJSON()), _typeof(obj) === "object" && obj !== null) {
    stack.push(obj), canonicalizedObj = {}, replacementStack.push(canonicalizedObj);
    var sortedKeys = [],
      _key;
    for (_key in obj) Object.prototype.hasOwnProperty.call(obj, _key) && sortedKeys.push(_key);
    for (sortedKeys.sort(), i = 0; i < sortedKeys.length; i += 1) _key = sortedKeys[i], canonicalizedObj[_key] = canonicalize(obj[_key], stack, replacementStack, replacer, _key);
    stack.pop(), replacementStack.pop();
  } else canonicalizedObj = obj;
  return canonicalizedObj;
},__name(canonicalize, "canonicalize");,var arrayDiff = new Diff();,arrayDiff.tokenize = function (value) {
  return value.slice();
};,arrayDiff.join = arrayDiff.removeEmpty = function (value) {
  return value;
};,function structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {
  if (options || (options = {}), typeof options == "function" && (options = {
    callback: options
  }), typeof options.context > "u" && (options.context = 4), options.newlineIsToken) throw new Error("newlineIsToken may not be used with patch-generation functions, only with diffing functions");
  if (options.callback) {
    var _options = options,
      _callback = _options.callback;
    diffLines(oldStr, newStr, _objectSpread2(_objectSpread2({}, options), {}, {
      callback: __name(function (diff) {
        var patch = diffLinesResultToPatch(diff);
        _callback(patch);
      }, "callback")
    }));
  } else return diffLinesResultToPatch(diffLines(oldStr, newStr, options));
  function diffLinesResultToPatch(diff) {
    if (!diff) return;
    diff.push({
      value: "",
      lines: []
    });
    function contextLines(lines) {
      return lines.map(function (entry) {
        return " " + entry;
      });
    }
    __name(contextLines, "contextLines");
    for (var hunks = [], oldRangeStart = 0, newRangeStart = 0, curRange = [], oldLine = 1, newLine = 1, _loop = __name(function () {
        var current = diff[i],
          lines = current.lines || splitLines(current.value);
        if (current.lines = lines, current.added || current.removed) {
          var _curRange;
          if (!oldRangeStart) {
            var prev = diff[i - 1];
            oldRangeStart = oldLine, newRangeStart = newLine, prev && (curRange = options.context > 0 ? contextLines(prev.lines.slice(-options.context)) : [], oldRangeStart -= curRange.length, newRangeStart -= curRange.length);
          }
          (_curRange = curRange).push.apply(_curRange, _toConsumableArray(lines.map(function (entry) {
            return (current.added ? "+" : "-") + entry;
          }))), current.added ? newLine += lines.length : oldLine += lines.length;
        } else {
          if (oldRangeStart) if (lines.length <= options.context * 2 && i < diff.length - 2) {
            var _curRange2;
            (_curRange2 = curRange).push.apply(_curRange2, _toConsumableArray(contextLines(lines)));
          } else {
            var _curRange3,
              contextSize = Math.min(lines.length, options.context);
            (_curRange3 = curRange).push.apply(_curRange3, _toConsumableArray(contextLines(lines.slice(0, contextSize))));
            var _hunk = {
              oldStart: oldRangeStart,
              oldLines: oldLine - oldRangeStart + contextSize,
              newStart: newRangeStart,
              newLines: newLine - newRangeStart + contextSize,
              lines: curRange
            };
            hunks.push(_hunk), oldRangeStart = 0, newRangeStart = 0, curRange = [];
          }
          oldLine += lines.length, newLine += lines.length;
        }
      }, "_loop"), i = 0; i < diff.length; i++) _loop();
    for (var _i = 0, _hunks = hunks; _i < _hunks.length; _i++) for (var hunk = _hunks[_i], _i2 = 0; _i2 < hunk.lines.length; _i2++) hunk.lines[_i2].endsWith(`
`) ? hunk.lines[_i2] = hunk.lines[_i2].slice(0, -1) : (hunk.lines.splice(_i2 + 1, 0, "\\ No newline at end of file"), _i2++);
    return {
      oldFileName: oldFileName,
      newFileName: newFileName,
      oldHeader: oldHeader,
      newHeader: newHeader,
      hunks: hunks
    };
  }
  __name(diffLinesResultToPatch, "diffLinesResultToPatch");
},__name(structuredPatch, "structuredPatch");,function splitLines(text) {
  var hasTrailingNl = text.endsWith(`
`),
    result = text.split(`
`).map(function (line) {
      return line + `
`;
    });
  return hasTrailingNl ? result.pop() : result.push(result.pop().slice(0, -1)), result;
},__name(splitLines, "splitLines");