var require_buffer_from = __commonJSMin((exports, module) => {
  var toString = Object.prototype.toString,
    isModern = typeof Buffer < "u" && typeof Buffer.alloc == "function" && typeof Buffer.allocUnsafe == "function" && typeof Buffer.from == "function";
  function isArrayBuffer(input) {
    return toString.call(input).slice(8, -1) === "ArrayBuffer";
  }
  __name(isArrayBuffer, "isArrayBuffer");
  function fromArrayBuffer(obj, byteOffset, length) {
    byteOffset >>>= 0;
    var maxLength = obj.byteLength - byteOffset;
    if (maxLength < 0) throw new RangeError("'offset' is out of bounds");
    if (length === void 0) length = maxLength;else if (length >>>= 0, length > maxLength) throw new RangeError("'length' is out of bounds");
    return isModern ? Buffer.from(obj.slice(byteOffset, byteOffset + length)) : new Buffer(new Uint8Array(obj.slice(byteOffset, byteOffset + length)));
  }
  __name(fromArrayBuffer, "fromArrayBuffer");
  function fromString(string, encoding) {
    if ((typeof encoding != "string" || encoding === "") && (encoding = "utf8"), !Buffer.isEncoding(encoding)) throw new TypeError('"encoding" must be a valid string encoding');
    return isModern ? Buffer.from(string, encoding) : new Buffer(string, encoding);
  }
  __name(fromString, "fromString");
  function bufferFrom(value, encodingOrOffset, length) {
    if (typeof value == "number") throw new TypeError('"value" argument must not be a number');
    return isArrayBuffer(value) ? fromArrayBuffer(value, encodingOrOffset, length) : typeof value == "string" ? fromString(value, encodingOrOffset) : isModern ? Buffer.from(value) : new Buffer(value);
  }
  __name(bufferFrom, "bufferFrom");
  module.exports = bufferFrom;
});