function FromRest(types, key) {
  return types.map(type => IndexFromPropertyKey(type, key));
},__name(FromRest, "FromRest");,function FromIntersectRest(types) {
  return types.filter(type => !IsNever(type));
},__name(FromIntersectRest, "FromIntersectRest");,function FromIntersect(types, key) {
  return IntersectEvaluated(FromIntersectRest(FromRest(types, key)));
},__name(FromIntersect, "FromIntersect");,function FromUnionRest(types) {
  return types.some(L => IsNever(L)) ? [] : types;
},__name(FromUnionRest, "FromUnionRest");,function FromUnion(types, key) {
  return UnionEvaluated(FromUnionRest(FromRest(types, key)));
},__name(FromUnion, "FromUnion");,function FromTuple(types, key) {
  return key in types ? types[key] : key === "[number]" ? UnionEvaluated(types) : Never();
},__name(FromTuple, "FromTuple");,function FromArray(type, key) {
  return key === "[number]" ? type : Never();
},__name(FromArray, "FromArray");,function FromProperty(properties, propertyKey) {
  return propertyKey in properties ? properties[propertyKey] : Never();
},__name(FromProperty, "FromProperty");,function IndexFromPropertyKey(type, propertyKey) {
  var _a;
  return IsIntersect(type) ? FromIntersect(type.allOf, propertyKey) : IsUnion(type) ? FromUnion(type.anyOf, propertyKey) : IsTuple(type) ? FromTuple((_a = type.items) != null ? _a : [], propertyKey) : IsArray(type) ? FromArray(type.items, propertyKey) : IsObject(type) ? FromProperty(type.properties, propertyKey) : Never();
},__name(IndexFromPropertyKey, "IndexFromPropertyKey");,function IndexFromPropertyKeys(type, propertyKeys) {
  return propertyKeys.map(propertyKey => IndexFromPropertyKey(type, propertyKey));
},__name(IndexFromPropertyKeys, "IndexFromPropertyKeys");,function FromSchema(type, propertyKeys) {
  return UnionEvaluated(IndexFromPropertyKeys(type, propertyKeys));
},__name(FromSchema, "FromSchema");,function Index(type, key, options) {
  if (IsRef(type) || IsRef(key)) {
    let error = "Index types using Ref parameters require both Type and Key to be of TSchema";
    if (!IsSchema(type) || !IsSchema(key)) throw new TypeBoxError(error);
    return Computed("Index", [type, key]);
  }
  return IsMappedResult(key) ? IndexFromMappedResult(type, key, options) : IsMappedKey(key) ? IndexFromMappedKey(type, key, options) : CreateType(IsSchema(key) ? FromSchema(type, IndexPropertyKeys(key)) : FromSchema(type, key), options);
},__name(Index, "Index");