function FromComputed(target, parameters) {
  return Computed("Required", [Computed(target, parameters)]);
},__name(FromComputed, "FromComputed");,function FromRef($ref) {
  return Computed("Required", [Ref($ref)]);
},__name(FromRef, "FromRef");,function FromProperties(properties) {
  let requiredProperties = {};
  for (let K of globalThis.Object.getOwnPropertyNames(properties)) requiredProperties[K] = Discard(properties[K], [OptionalKind]);
  return requiredProperties;
},__name(FromProperties, "FromProperties");,function FromObject(type) {
  let options = Discard(type, [TransformKind, "$id", "required", "properties"]),
    properties = FromProperties(type.properties);
  return Object(properties, options);
},__name(FromObject, "FromObject");,function FromRest(types) {
  return types.map(type => RequiredResolve(type));
},__name(FromRest, "FromRest");,function RequiredResolve(type) {
  return IsComputed(type) ? FromComputed(type.target, type.parameters) : IsRef(type) ? FromRef(type.$ref) : IsIntersect(type) ? Intersect(FromRest(type.allOf)) : IsUnion(type) ? Union(FromRest(type.anyOf)) : IsObject(type) ? FromObject(type) : IsBigInt(type) || IsBoolean(type) || IsInteger(type) || IsLiteral(type) || IsNull(type) || IsNumber(type) || IsString(type) || IsSymbol(type) || IsUndefined(type) ? type : Object({});
},__name(RequiredResolve, "RequiredResolve");,function Required(type, options) {
  return IsMappedResult(type) ? RequiredFromMappedResult(type, options) : CreateType({
    ...RequiredResolve(type),
    ...options
  });
},__name(Required, "Required");