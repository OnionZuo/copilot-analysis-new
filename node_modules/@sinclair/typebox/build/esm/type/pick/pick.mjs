function FromIntersect(types, propertyKeys) {
  return types.map(type => PickResolve(type, propertyKeys));
},__name(FromIntersect, "FromIntersect");,function FromUnion(types, propertyKeys) {
  return types.map(type => PickResolve(type, propertyKeys));
},__name(FromUnion, "FromUnion");,function FromProperties(properties, propertyKeys) {
  let result = {};
  for (let K2 of propertyKeys) K2 in properties && (result[K2] = properties[K2]);
  return result;
},__name(FromProperties, "FromProperties");,function FromObject(T, K) {
  let options = Discard(T, [TransformKind, "$id", "required", "properties"]),
    properties = FromProperties(T.properties, K);
  return Object(properties, options);
},__name(FromObject, "FromObject");,function UnionFromPropertyKeys(propertyKeys) {
  let result = propertyKeys.reduce((result, key) => IsLiteralValue(key) ? [...result, Literal(key)] : result, []);
  return Union(result);
},__name(UnionFromPropertyKeys, "UnionFromPropertyKeys");,function PickResolve(properties, propertyKeys) {
  return IsIntersect(properties) ? Intersect(FromIntersect(properties.allOf, propertyKeys)) : IsUnion(properties) ? Union(FromUnion(properties.anyOf, propertyKeys)) : IsObject(properties) ? FromObject(properties, propertyKeys) : Object({});
},__name(PickResolve, "PickResolve");,function Pick(type, key, options) {
  let typeKey = IsArray(key) ? UnionFromPropertyKeys(key) : key,
    propertyKeys = IsSchema(key) ? IndexPropertyKeys(key) : key,
    isTypeRef = IsRef(type),
    isKeyRef = IsRef(key);
  return IsMappedResult(type) ? PickFromMappedResult(type, propertyKeys, options) : IsMappedKey(key) ? PickFromMappedKey(type, key, options) : isTypeRef && isKeyRef ? Computed("Pick", [type, typeKey], options) : !isTypeRef && isKeyRef ? Computed("Pick", [type, typeKey], options) : isTypeRef && !isKeyRef ? Computed("Pick", [type, typeKey], options) : CreateType({
    ...PickResolve(type, propertyKeys),
    ...options
  });
},__name(Pick, "Pick");