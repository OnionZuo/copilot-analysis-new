var _TemplateLiteralParserError = class _TemplateLiteralParserError extends TypeBoxError {};,__name(_TemplateLiteralParserError, "TemplateLiteralParserError");,var TemplateLiteralParserError = _TemplateLiteralParserError;,function Unescape(pattern) {
  return pattern.replace(/\\\$/g, "$").replace(/\\\*/g, "*").replace(/\\\^/g, "^").replace(/\\\|/g, "|").replace(/\\\(/g, "(").replace(/\\\)/g, ")");
},__name(Unescape, "Unescape");,function IsNonEscaped(pattern, index, char) {
  return pattern[index] === char && pattern.charCodeAt(index - 1) !== 92;
},__name(IsNonEscaped, "IsNonEscaped");,function IsOpenParen(pattern, index) {
  return IsNonEscaped(pattern, index, "(");
},__name(IsOpenParen, "IsOpenParen");,function IsCloseParen(pattern, index) {
  return IsNonEscaped(pattern, index, ")");
},__name(IsCloseParen, "IsCloseParen");,function IsSeparator(pattern, index) {
  return IsNonEscaped(pattern, index, "|");
},__name(IsSeparator, "IsSeparator");,function IsGroup(pattern) {
  if (!(IsOpenParen(pattern, 0) && IsCloseParen(pattern, pattern.length - 1))) return !1;
  let count = 0;
  for (let index = 0; index < pattern.length; index++) if (IsOpenParen(pattern, index) && (count += 1), IsCloseParen(pattern, index) && (count -= 1), count === 0 && index !== pattern.length - 1) return !1;
  return !0;
},__name(IsGroup, "IsGroup");,function InGroup(pattern) {
  return pattern.slice(1, pattern.length - 1);
},__name(InGroup, "InGroup");,function IsPrecedenceOr(pattern) {
  let count = 0;
  for (let index = 0; index < pattern.length; index++) if (IsOpenParen(pattern, index) && (count += 1), IsCloseParen(pattern, index) && (count -= 1), IsSeparator(pattern, index) && count === 0) return !0;
  return !1;
},__name(IsPrecedenceOr, "IsPrecedenceOr");,function IsPrecedenceAnd(pattern) {
  for (let index = 0; index < pattern.length; index++) if (IsOpenParen(pattern, index)) return !0;
  return !1;
},__name(IsPrecedenceAnd, "IsPrecedenceAnd");,function Or(pattern) {
  let [count, start] = [0, 0],
    expressions = [];
  for (let index = 0; index < pattern.length; index++) if (IsOpenParen(pattern, index) && (count += 1), IsCloseParen(pattern, index) && (count -= 1), IsSeparator(pattern, index) && count === 0) {
    let range = pattern.slice(start, index);
    range.length > 0 && expressions.push(TemplateLiteralParse(range)), start = index + 1;
  }
  let range = pattern.slice(start);
  return range.length > 0 && expressions.push(TemplateLiteralParse(range)), expressions.length === 0 ? {
    type: "const",
    const: ""
  } : expressions.length === 1 ? expressions[0] : {
    type: "or",
    expr: expressions
  };
},__name(Or, "Or");,function And(pattern) {
  function Group(value, index) {
    if (!IsOpenParen(value, index)) throw new TemplateLiteralParserError("TemplateLiteralParser: Index must point to open parens");
    let count = 0;
    for (let scan = index; scan < value.length; scan++) if (IsOpenParen(value, scan) && (count += 1), IsCloseParen(value, scan) && (count -= 1), count === 0) return [index, scan];
    throw new TemplateLiteralParserError("TemplateLiteralParser: Unclosed group parens in expression");
  }
  __name(Group, "Group");
  function Range(pattern, index) {
    for (let scan = index; scan < pattern.length; scan++) if (IsOpenParen(pattern, scan)) return [index, scan];
    return [index, pattern.length];
  }
  __name(Range, "Range");
  let expressions = [];
  for (let index = 0; index < pattern.length; index++) if (IsOpenParen(pattern, index)) {
    let [start, end] = Group(pattern, index),
      range = pattern.slice(start, end + 1);
    expressions.push(TemplateLiteralParse(range)), index = end;
  } else {
    let [start, end] = Range(pattern, index),
      range = pattern.slice(start, end);
    range.length > 0 && expressions.push(TemplateLiteralParse(range)), index = end - 1;
  }
  return expressions.length === 0 ? {
    type: "const",
    const: ""
  } : expressions.length === 1 ? expressions[0] : {
    type: "and",
    expr: expressions
  };
},__name(And, "And");,function TemplateLiteralParse(pattern) {
  return IsGroup(pattern) ? TemplateLiteralParse(InGroup(pattern)) : IsPrecedenceOr(pattern) ? Or(pattern) : IsPrecedenceAnd(pattern) ? And(pattern) : {
    type: "const",
    const: Unescape(pattern)
  };
},__name(TemplateLiteralParse, "TemplateLiteralParse");,function TemplateLiteralParseExact(pattern) {
  return TemplateLiteralParse(pattern.slice(1, pattern.length - 1));
},__name(TemplateLiteralParseExact, "TemplateLiteralParseExact");