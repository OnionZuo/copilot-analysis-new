function DereferenceParameters(moduleProperties, types) {
  return types.map(type => IsRef(type) ? Dereference(moduleProperties, type.$ref) : FromType(moduleProperties, type));
},__name(DereferenceParameters, "DereferenceParameters");,function Dereference(moduleProperties, ref) {
  return ref in moduleProperties ? IsRef(moduleProperties[ref]) ? Dereference(moduleProperties, moduleProperties[ref].$ref) : FromType(moduleProperties, moduleProperties[ref]) : Never();
},__name(Dereference, "Dereference");,function FromAwaited(parameters) {
  return Awaited(parameters[0]);
},__name(FromAwaited, "FromAwaited");,function FromIndex(parameters) {
  return Index(parameters[0], parameters[1]);
},__name(FromIndex, "FromIndex");,function FromKeyOf(parameters) {
  return KeyOf(parameters[0]);
},__name(FromKeyOf, "FromKeyOf");,function FromPartial(parameters) {
  return Partial(parameters[0]);
},__name(FromPartial, "FromPartial");,function FromOmit(parameters) {
  return Omit(parameters[0], parameters[1]);
},__name(FromOmit, "FromOmit");,function FromPick(parameters) {
  return Pick(parameters[0], parameters[1]);
},__name(FromPick, "FromPick");,function FromRequired(parameters) {
  return Required(parameters[0]);
},__name(FromRequired, "FromRequired");,function FromComputed(moduleProperties, target, parameters) {
  let dereferenced = DereferenceParameters(moduleProperties, parameters);
  return target === "Awaited" ? FromAwaited(dereferenced) : target === "Index" ? FromIndex(dereferenced) : target === "KeyOf" ? FromKeyOf(dereferenced) : target === "Partial" ? FromPartial(dereferenced) : target === "Omit" ? FromOmit(dereferenced) : target === "Pick" ? FromPick(dereferenced) : target === "Required" ? FromRequired(dereferenced) : Never();
},__name(FromComputed, "FromComputed");,function FromArray(moduleProperties, type) {
  return Array(FromType(moduleProperties, type));
},__name(FromArray, "FromArray");,function FromAsyncIterator(moduleProperties, type) {
  return AsyncIterator(FromType(moduleProperties, type));
},__name(FromAsyncIterator, "FromAsyncIterator");,function FromConstructor(moduleProperties, parameters, instanceType) {
  return Constructor(FromTypes(moduleProperties, parameters), FromType(moduleProperties, instanceType));
},__name(FromConstructor, "FromConstructor");,function FromFunction(moduleProperties, parameters, returnType) {
  return Function(FromTypes(moduleProperties, parameters), FromType(moduleProperties, returnType));
},__name(FromFunction, "FromFunction");,function FromIntersect(moduleProperties, types) {
  return Intersect(FromTypes(moduleProperties, types));
},__name(FromIntersect, "FromIntersect");,function FromIterator(moduleProperties, type) {
  return Iterator(FromType(moduleProperties, type));
},__name(FromIterator, "FromIterator");,function FromObject(moduleProperties, properties) {
  return Object(globalThis.Object.keys(properties).reduce((result, key) => ({
    ...result,
    [key]: FromType(moduleProperties, properties[key])
  }), {}));
},__name(FromObject, "FromObject");,function FromRecord(moduleProperties, type) {
  let [value, pattern] = [FromType(moduleProperties, RecordValue(type)), RecordPattern(type)],
    result = CloneType(type);
  return result.patternProperties[pattern] = value, result;
},__name(FromRecord, "FromRecord");,function FromTransform(moduleProperties, transform) {
  return IsRef(transform) ? {
    ...Dereference(moduleProperties, transform.$ref),
    [TransformKind]: transform[TransformKind]
  } : transform;
},__name(FromTransform, "FromTransform");,function FromTuple(moduleProperties, types) {
  return Tuple(FromTypes(moduleProperties, types));
},__name(FromTuple, "FromTuple");,function FromUnion(moduleProperties, types) {
  return Union(FromTypes(moduleProperties, types));
},__name(FromUnion, "FromUnion");,function FromTypes(moduleProperties, types) {
  return types.map(type => FromType(moduleProperties, type));
},__name(FromTypes, "FromTypes");,function FromType(moduleProperties, type) {
  return IsOptional(type) ? CreateType(FromType(moduleProperties, Discard(type, [OptionalKind])), type) : IsReadonly(type) ? CreateType(FromType(moduleProperties, Discard(type, [ReadonlyKind])), type) : IsTransform(type) ? CreateType(FromTransform(moduleProperties, type), type) : IsArray(type) ? CreateType(FromArray(moduleProperties, type.items), type) : IsAsyncIterator(type) ? CreateType(FromAsyncIterator(moduleProperties, type.items), type) : IsComputed(type) ? CreateType(FromComputed(moduleProperties, type.target, type.parameters)) : IsConstructor(type) ? CreateType(FromConstructor(moduleProperties, type.parameters, type.returns), type) : IsFunction(type) ? CreateType(FromFunction(moduleProperties, type.parameters, type.returns), type) : IsIntersect(type) ? CreateType(FromIntersect(moduleProperties, type.allOf), type) : IsIterator(type) ? CreateType(FromIterator(moduleProperties, type.items), type) : IsObject(type) ? CreateType(FromObject(moduleProperties, type.properties), type) : IsRecord(type) ? CreateType(FromRecord(moduleProperties, type)) : IsTuple(type) ? CreateType(FromTuple(moduleProperties, type.items || []), type) : IsUnion(type) ? CreateType(FromUnion(moduleProperties, type.anyOf), type) : type;
},__name(FromType, "FromType");,function ComputeType(moduleProperties, key) {
  return key in moduleProperties ? FromType(moduleProperties, moduleProperties[key]) : Never();
},__name(ComputeType, "ComputeType");,function ComputeModuleProperties(moduleProperties) {
  return globalThis.Object.getOwnPropertyNames(moduleProperties).reduce((result, key) => ({
    ...result,
    [key]: ComputeType(moduleProperties, key)
  }), {});
},__name(ComputeModuleProperties, "ComputeModuleProperties");