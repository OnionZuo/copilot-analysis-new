var ValueErrorType;,(function (ValueErrorType) {
  ValueErrorType[ValueErrorType.ArrayContains = 0] = "ArrayContains", ValueErrorType[ValueErrorType.ArrayMaxContains = 1] = "ArrayMaxContains", ValueErrorType[ValueErrorType.ArrayMaxItems = 2] = "ArrayMaxItems", ValueErrorType[ValueErrorType.ArrayMinContains = 3] = "ArrayMinContains", ValueErrorType[ValueErrorType.ArrayMinItems = 4] = "ArrayMinItems", ValueErrorType[ValueErrorType.ArrayUniqueItems = 5] = "ArrayUniqueItems", ValueErrorType[ValueErrorType.Array = 6] = "Array", ValueErrorType[ValueErrorType.AsyncIterator = 7] = "AsyncIterator", ValueErrorType[ValueErrorType.BigIntExclusiveMaximum = 8] = "BigIntExclusiveMaximum", ValueErrorType[ValueErrorType.BigIntExclusiveMinimum = 9] = "BigIntExclusiveMinimum", ValueErrorType[ValueErrorType.BigIntMaximum = 10] = "BigIntMaximum", ValueErrorType[ValueErrorType.BigIntMinimum = 11] = "BigIntMinimum", ValueErrorType[ValueErrorType.BigIntMultipleOf = 12] = "BigIntMultipleOf", ValueErrorType[ValueErrorType.BigInt = 13] = "BigInt", ValueErrorType[ValueErrorType.Boolean = 14] = "Boolean", ValueErrorType[ValueErrorType.DateExclusiveMaximumTimestamp = 15] = "DateExclusiveMaximumTimestamp", ValueErrorType[ValueErrorType.DateExclusiveMinimumTimestamp = 16] = "DateExclusiveMinimumTimestamp", ValueErrorType[ValueErrorType.DateMaximumTimestamp = 17] = "DateMaximumTimestamp", ValueErrorType[ValueErrorType.DateMinimumTimestamp = 18] = "DateMinimumTimestamp", ValueErrorType[ValueErrorType.DateMultipleOfTimestamp = 19] = "DateMultipleOfTimestamp", ValueErrorType[ValueErrorType.Date = 20] = "Date", ValueErrorType[ValueErrorType.Function = 21] = "Function", ValueErrorType[ValueErrorType.IntegerExclusiveMaximum = 22] = "IntegerExclusiveMaximum", ValueErrorType[ValueErrorType.IntegerExclusiveMinimum = 23] = "IntegerExclusiveMinimum", ValueErrorType[ValueErrorType.IntegerMaximum = 24] = "IntegerMaximum", ValueErrorType[ValueErrorType.IntegerMinimum = 25] = "IntegerMinimum", ValueErrorType[ValueErrorType.IntegerMultipleOf = 26] = "IntegerMultipleOf", ValueErrorType[ValueErrorType.Integer = 27] = "Integer", ValueErrorType[ValueErrorType.IntersectUnevaluatedProperties = 28] = "IntersectUnevaluatedProperties", ValueErrorType[ValueErrorType.Intersect = 29] = "Intersect", ValueErrorType[ValueErrorType.Iterator = 30] = "Iterator", ValueErrorType[ValueErrorType.Kind = 31] = "Kind", ValueErrorType[ValueErrorType.Literal = 32] = "Literal", ValueErrorType[ValueErrorType.Never = 33] = "Never", ValueErrorType[ValueErrorType.Not = 34] = "Not", ValueErrorType[ValueErrorType.Null = 35] = "Null", ValueErrorType[ValueErrorType.NumberExclusiveMaximum = 36] = "NumberExclusiveMaximum", ValueErrorType[ValueErrorType.NumberExclusiveMinimum = 37] = "NumberExclusiveMinimum", ValueErrorType[ValueErrorType.NumberMaximum = 38] = "NumberMaximum", ValueErrorType[ValueErrorType.NumberMinimum = 39] = "NumberMinimum", ValueErrorType[ValueErrorType.NumberMultipleOf = 40] = "NumberMultipleOf", ValueErrorType[ValueErrorType.Number = 41] = "Number", ValueErrorType[ValueErrorType.ObjectAdditionalProperties = 42] = "ObjectAdditionalProperties", ValueErrorType[ValueErrorType.ObjectMaxProperties = 43] = "ObjectMaxProperties", ValueErrorType[ValueErrorType.ObjectMinProperties = 44] = "ObjectMinProperties", ValueErrorType[ValueErrorType.ObjectRequiredProperty = 45] = "ObjectRequiredProperty", ValueErrorType[ValueErrorType.Object = 46] = "Object", ValueErrorType[ValueErrorType.Promise = 47] = "Promise", ValueErrorType[ValueErrorType.RegExp = 48] = "RegExp", ValueErrorType[ValueErrorType.StringFormatUnknown = 49] = "StringFormatUnknown", ValueErrorType[ValueErrorType.StringFormat = 50] = "StringFormat", ValueErrorType[ValueErrorType.StringMaxLength = 51] = "StringMaxLength", ValueErrorType[ValueErrorType.StringMinLength = 52] = "StringMinLength", ValueErrorType[ValueErrorType.StringPattern = 53] = "StringPattern", ValueErrorType[ValueErrorType.String = 54] = "String", ValueErrorType[ValueErrorType.Symbol = 55] = "Symbol", ValueErrorType[ValueErrorType.TupleLength = 56] = "TupleLength", ValueErrorType[ValueErrorType.Tuple = 57] = "Tuple", ValueErrorType[ValueErrorType.Uint8ArrayMaxByteLength = 58] = "Uint8ArrayMaxByteLength", ValueErrorType[ValueErrorType.Uint8ArrayMinByteLength = 59] = "Uint8ArrayMinByteLength", ValueErrorType[ValueErrorType.Uint8Array = 60] = "Uint8Array", ValueErrorType[ValueErrorType.Undefined = 61] = "Undefined", ValueErrorType[ValueErrorType.Union = 62] = "Union", ValueErrorType[ValueErrorType.Void = 63] = "Void";
})(ValueErrorType || (ValueErrorType = {}));,var _ValueErrorsUnknownTypeError = class _ValueErrorsUnknownTypeError extends TypeBoxError {
  constructor(schema) {
    super("Unknown type"), this.schema = schema;
  }
};,__name(_ValueErrorsUnknownTypeError, "ValueErrorsUnknownTypeError");,var ValueErrorsUnknownTypeError = _ValueErrorsUnknownTypeError;,function EscapeKey(key) {
  return key.replace(/~/g, "~0").replace(/\//g, "~1");
},__name(EscapeKey, "EscapeKey");,function IsDefined(value) {
  return value !== void 0;
},__name(IsDefined, "IsDefined");,var _ValueErrorIterator = class _ValueErrorIterator {
  constructor(iterator) {
    this.iterator = iterator;
  }
  [Symbol.iterator]() {
    return this.iterator;
  }
  First() {
    let next = this.iterator.next();
    return next.done ? void 0 : next.value;
  }
};,__name(_ValueErrorIterator, "ValueErrorIterator");,var ValueErrorIterator = _ValueErrorIterator;,function Create(errorType, schema, path, value, errors = []) {
  return {
    type: errorType,
    schema: schema,
    path: path,
    value: value,
    message: GetErrorFunction()({
      errorType: errorType,
      path: path,
      schema: schema,
      value: value,
      errors: errors
    }),
    errors: errors
  };
},__name(Create, "Create");,function* FromAny(schema, references, path, value) {},__name(FromAny, "FromAny");,function* FromArgument(schema, references, path, value) {},__name(FromArgument, "FromArgument");,function* FromArray(schema, references, path, value) {
  if (!IsArray(value)) return yield Create(ValueErrorType.Array, schema, path, value);
  IsDefined(schema.minItems) && !(value.length >= schema.minItems) && (yield Create(ValueErrorType.ArrayMinItems, schema, path, value)), IsDefined(schema.maxItems) && !(value.length <= schema.maxItems) && (yield Create(ValueErrorType.ArrayMaxItems, schema, path, value));
  for (let i = 0; i < value.length; i++) yield* Visit(schema.items, references, `${path}/${i}`, value[i]);
  if (schema.uniqueItems === !0 && !function () {
    let set = new Set();
    for (let element of value) {
      let hashed = Hash(element);
      if (set.has(hashed)) return !1;
      set.add(hashed);
    }
    return !0;
  }() && (yield Create(ValueErrorType.ArrayUniqueItems, schema, path, value)), !(IsDefined(schema.contains) || IsDefined(schema.minContains) || IsDefined(schema.maxContains))) return;
  let containsSchema = IsDefined(schema.contains) ? schema.contains : Never(),
    containsCount = value.reduce((acc, value, index) => Visit(containsSchema, references, `${path}${index}`, value).next().done === !0 ? acc + 1 : acc, 0);
  containsCount === 0 && (yield Create(ValueErrorType.ArrayContains, schema, path, value)), IsNumber(schema.minContains) && containsCount < schema.minContains && (yield Create(ValueErrorType.ArrayMinContains, schema, path, value)), IsNumber(schema.maxContains) && containsCount > schema.maxContains && (yield Create(ValueErrorType.ArrayMaxContains, schema, path, value));
},__name(FromArray, "FromArray");,function* FromAsyncIterator(schema, references, path, value) {
  IsAsyncIterator(value) || (yield Create(ValueErrorType.AsyncIterator, schema, path, value));
},__name(FromAsyncIterator, "FromAsyncIterator");,function* FromBigInt(schema, references, path, value) {
  if (!IsBigInt(value)) return yield Create(ValueErrorType.BigInt, schema, path, value);
  IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum) && (yield Create(ValueErrorType.BigIntExclusiveMaximum, schema, path, value)), IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum) && (yield Create(ValueErrorType.BigIntExclusiveMinimum, schema, path, value)), IsDefined(schema.maximum) && !(value <= schema.maximum) && (yield Create(ValueErrorType.BigIntMaximum, schema, path, value)), IsDefined(schema.minimum) && !(value >= schema.minimum) && (yield Create(ValueErrorType.BigIntMinimum, schema, path, value)), IsDefined(schema.multipleOf) && value % schema.multipleOf !== BigInt(0) && (yield Create(ValueErrorType.BigIntMultipleOf, schema, path, value));
},__name(FromBigInt, "FromBigInt");,function* FromBoolean(schema, references, path, value) {
  IsBoolean(value) || (yield Create(ValueErrorType.Boolean, schema, path, value));
},__name(FromBoolean, "FromBoolean");,function* FromConstructor(schema, references, path, value) {
  yield* Visit(schema.returns, references, path, value.prototype);
},__name(FromConstructor, "FromConstructor");,function* FromDate(schema, references, path, value) {
  if (!IsDate(value)) return yield Create(ValueErrorType.Date, schema, path, value);
  IsDefined(schema.exclusiveMaximumTimestamp) && !(value.getTime() < schema.exclusiveMaximumTimestamp) && (yield Create(ValueErrorType.DateExclusiveMaximumTimestamp, schema, path, value)), IsDefined(schema.exclusiveMinimumTimestamp) && !(value.getTime() > schema.exclusiveMinimumTimestamp) && (yield Create(ValueErrorType.DateExclusiveMinimumTimestamp, schema, path, value)), IsDefined(schema.maximumTimestamp) && !(value.getTime() <= schema.maximumTimestamp) && (yield Create(ValueErrorType.DateMaximumTimestamp, schema, path, value)), IsDefined(schema.minimumTimestamp) && !(value.getTime() >= schema.minimumTimestamp) && (yield Create(ValueErrorType.DateMinimumTimestamp, schema, path, value)), IsDefined(schema.multipleOfTimestamp) && value.getTime() % schema.multipleOfTimestamp !== 0 && (yield Create(ValueErrorType.DateMultipleOfTimestamp, schema, path, value));
},__name(FromDate, "FromDate");,function* FromFunction(schema, references, path, value) {
  IsFunction(value) || (yield Create(ValueErrorType.Function, schema, path, value));
},__name(FromFunction, "FromFunction");,function* FromImport(schema, references, path, value) {
  let definitions = globalThis.Object.values(schema.$defs),
    target = schema.$defs[schema.$ref];
  yield* Visit(target, [...references, ...definitions], path, value);
},__name(FromImport, "FromImport");,function* FromInteger(schema, references, path, value) {
  if (!IsInteger(value)) return yield Create(ValueErrorType.Integer, schema, path, value);
  IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum) && (yield Create(ValueErrorType.IntegerExclusiveMaximum, schema, path, value)), IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum) && (yield Create(ValueErrorType.IntegerExclusiveMinimum, schema, path, value)), IsDefined(schema.maximum) && !(value <= schema.maximum) && (yield Create(ValueErrorType.IntegerMaximum, schema, path, value)), IsDefined(schema.minimum) && !(value >= schema.minimum) && (yield Create(ValueErrorType.IntegerMinimum, schema, path, value)), IsDefined(schema.multipleOf) && value % schema.multipleOf !== 0 && (yield Create(ValueErrorType.IntegerMultipleOf, schema, path, value));
},__name(FromInteger, "FromInteger");,function* FromIntersect(schema, references, path, value) {
  let hasError = !1;
  for (let inner of schema.allOf) for (let error of Visit(inner, references, path, value)) hasError = !0, yield error;
  if (hasError) return yield Create(ValueErrorType.Intersect, schema, path, value);
  if (schema.unevaluatedProperties === !1) {
    let keyCheck = new RegExp(KeyOfPattern(schema));
    for (let valueKey of Object.getOwnPropertyNames(value)) keyCheck.test(valueKey) || (yield Create(ValueErrorType.IntersectUnevaluatedProperties, schema, `${path}/${valueKey}`, value));
  }
  if (typeof schema.unevaluatedProperties == "object") {
    let keyCheck = new RegExp(KeyOfPattern(schema));
    for (let valueKey of Object.getOwnPropertyNames(value)) if (!keyCheck.test(valueKey)) {
      let next = Visit(schema.unevaluatedProperties, references, `${path}/${valueKey}`, value[valueKey]).next();
      next.done || (yield next.value);
    }
  }
},__name(FromIntersect, "FromIntersect");,function* FromIterator(schema, references, path, value) {
  IsIterator(value) || (yield Create(ValueErrorType.Iterator, schema, path, value));
},__name(FromIterator, "FromIterator");,function* FromLiteral(schema, references, path, value) {
  value !== schema.const && (yield Create(ValueErrorType.Literal, schema, path, value));
},__name(FromLiteral, "FromLiteral");,function* FromNever(schema, references, path, value) {
  yield Create(ValueErrorType.Never, schema, path, value);
},__name(FromNever, "FromNever");,function* FromNot(schema, references, path, value) {
  Visit(schema.not, references, path, value).next().done === !0 && (yield Create(ValueErrorType.Not, schema, path, value));
},__name(FromNot, "FromNot");,function* FromNull(schema, references, path, value) {
  IsNull(value) || (yield Create(ValueErrorType.Null, schema, path, value));
},__name(FromNull, "FromNull");,function* FromNumber(schema, references, path, value) {
  if (!TypeSystemPolicy.IsNumberLike(value)) return yield Create(ValueErrorType.Number, schema, path, value);
  IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum) && (yield Create(ValueErrorType.NumberExclusiveMaximum, schema, path, value)), IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum) && (yield Create(ValueErrorType.NumberExclusiveMinimum, schema, path, value)), IsDefined(schema.maximum) && !(value <= schema.maximum) && (yield Create(ValueErrorType.NumberMaximum, schema, path, value)), IsDefined(schema.minimum) && !(value >= schema.minimum) && (yield Create(ValueErrorType.NumberMinimum, schema, path, value)), IsDefined(schema.multipleOf) && value % schema.multipleOf !== 0 && (yield Create(ValueErrorType.NumberMultipleOf, schema, path, value));
},__name(FromNumber, "FromNumber");,function* FromObject(schema, references, path, value) {
  if (!TypeSystemPolicy.IsObjectLike(value)) return yield Create(ValueErrorType.Object, schema, path, value);
  IsDefined(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties) && (yield Create(ValueErrorType.ObjectMinProperties, schema, path, value)), IsDefined(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties) && (yield Create(ValueErrorType.ObjectMaxProperties, schema, path, value));
  let requiredKeys = Array.isArray(schema.required) ? schema.required : [],
    knownKeys = Object.getOwnPropertyNames(schema.properties),
    unknownKeys = Object.getOwnPropertyNames(value);
  for (let requiredKey of requiredKeys) unknownKeys.includes(requiredKey) || (yield Create(ValueErrorType.ObjectRequiredProperty, schema.properties[requiredKey], `${path}/${EscapeKey(requiredKey)}`, void 0));
  if (schema.additionalProperties === !1) for (let valueKey of unknownKeys) knownKeys.includes(valueKey) || (yield Create(ValueErrorType.ObjectAdditionalProperties, schema, `${path}/${EscapeKey(valueKey)}`, value[valueKey]));
  if (typeof schema.additionalProperties == "object") for (let valueKey of unknownKeys) knownKeys.includes(valueKey) || (yield* Visit(schema.additionalProperties, references, `${path}/${EscapeKey(valueKey)}`, value[valueKey]));
  for (let knownKey of knownKeys) {
    let property = schema.properties[knownKey];
    schema.required && schema.required.includes(knownKey) ? (yield* Visit(property, references, `${path}/${EscapeKey(knownKey)}`, value[knownKey]), ExtendsUndefinedCheck(schema) && !(knownKey in value) && (yield Create(ValueErrorType.ObjectRequiredProperty, property, `${path}/${EscapeKey(knownKey)}`, void 0))) : TypeSystemPolicy.IsExactOptionalProperty(value, knownKey) && (yield* Visit(property, references, `${path}/${EscapeKey(knownKey)}`, value[knownKey]));
  }
},__name(FromObject, "FromObject");,function* FromPromise(schema, references, path, value) {
  IsPromise(value) || (yield Create(ValueErrorType.Promise, schema, path, value));
},__name(FromPromise, "FromPromise");,function* FromRecord(schema, references, path, value) {
  if (!TypeSystemPolicy.IsRecordLike(value)) return yield Create(ValueErrorType.Object, schema, path, value);
  IsDefined(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties) && (yield Create(ValueErrorType.ObjectMinProperties, schema, path, value)), IsDefined(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties) && (yield Create(ValueErrorType.ObjectMaxProperties, schema, path, value));
  let [patternKey, patternSchema] = Object.entries(schema.patternProperties)[0],
    regex = new RegExp(patternKey);
  for (let [propertyKey, propertyValue] of Object.entries(value)) regex.test(propertyKey) && (yield* Visit(patternSchema, references, `${path}/${EscapeKey(propertyKey)}`, propertyValue));
  if (typeof schema.additionalProperties == "object") for (let [propertyKey, propertyValue] of Object.entries(value)) regex.test(propertyKey) || (yield* Visit(schema.additionalProperties, references, `${path}/${EscapeKey(propertyKey)}`, propertyValue));
  if (schema.additionalProperties === !1) {
    for (let [propertyKey, propertyValue] of Object.entries(value)) if (!regex.test(propertyKey)) return yield Create(ValueErrorType.ObjectAdditionalProperties, schema, `${path}/${EscapeKey(propertyKey)}`, propertyValue);
  }
},__name(FromRecord, "FromRecord");,function* FromRef(schema, references, path, value) {
  yield* Visit(Deref(schema, references), references, path, value);
},__name(FromRef, "FromRef");,function* FromRegExp(schema, references, path, value) {
  if (!IsString(value)) return yield Create(ValueErrorType.String, schema, path, value);
  if (IsDefined(schema.minLength) && !(value.length >= schema.minLength) && (yield Create(ValueErrorType.StringMinLength, schema, path, value)), IsDefined(schema.maxLength) && !(value.length <= schema.maxLength) && (yield Create(ValueErrorType.StringMaxLength, schema, path, value)), !new RegExp(schema.source, schema.flags).test(value)) return yield Create(ValueErrorType.RegExp, schema, path, value);
},__name(FromRegExp, "FromRegExp");,function* FromString(schema, references, path, value) {
  if (!IsString(value)) return yield Create(ValueErrorType.String, schema, path, value);
  IsDefined(schema.minLength) && !(value.length >= schema.minLength) && (yield Create(ValueErrorType.StringMinLength, schema, path, value)), IsDefined(schema.maxLength) && !(value.length <= schema.maxLength) && (yield Create(ValueErrorType.StringMaxLength, schema, path, value)), IsString(schema.pattern) && (new RegExp(schema.pattern).test(value) || (yield Create(ValueErrorType.StringPattern, schema, path, value))), IsString(schema.format) && (format_exports.Has(schema.format) ? format_exports.Get(schema.format)(value) || (yield Create(ValueErrorType.StringFormat, schema, path, value)) : yield Create(ValueErrorType.StringFormatUnknown, schema, path, value));
},__name(FromString, "FromString");,function* FromSymbol(schema, references, path, value) {
  IsSymbol(value) || (yield Create(ValueErrorType.Symbol, schema, path, value));
},__name(FromSymbol, "FromSymbol");,function* FromTemplateLiteral(schema, references, path, value) {
  if (!IsString(value)) return yield Create(ValueErrorType.String, schema, path, value);
  new RegExp(schema.pattern).test(value) || (yield Create(ValueErrorType.StringPattern, schema, path, value));
},__name(FromTemplateLiteral, "FromTemplateLiteral");,function* FromThis(schema, references, path, value) {
  yield* Visit(Deref(schema, references), references, path, value);
},__name(FromThis, "FromThis");,function* FromTuple(schema, references, path, value) {
  if (!IsArray(value)) return yield Create(ValueErrorType.Tuple, schema, path, value);
  if (schema.items === void 0 && value.length !== 0) return yield Create(ValueErrorType.TupleLength, schema, path, value);
  if (value.length !== schema.maxItems) return yield Create(ValueErrorType.TupleLength, schema, path, value);
  if (schema.items) for (let i = 0; i < schema.items.length; i++) yield* Visit(schema.items[i], references, `${path}/${i}`, value[i]);
},__name(FromTuple, "FromTuple");,function* FromUndefined(schema, references, path, value) {
  IsUndefined(value) || (yield Create(ValueErrorType.Undefined, schema, path, value));
},__name(FromUndefined, "FromUndefined");,function* FromUnion(schema, references, path, value) {
  if (Check(schema, references, value)) return;
  let errors = schema.anyOf.map(variant => new ValueErrorIterator(Visit(variant, references, path, value)));
  yield Create(ValueErrorType.Union, schema, path, value, errors);
},__name(FromUnion, "FromUnion");,function* FromUint8Array(schema, references, path, value) {
  if (!IsUint8Array(value)) return yield Create(ValueErrorType.Uint8Array, schema, path, value);
  IsDefined(schema.maxByteLength) && !(value.length <= schema.maxByteLength) && (yield Create(ValueErrorType.Uint8ArrayMaxByteLength, schema, path, value)), IsDefined(schema.minByteLength) && !(value.length >= schema.minByteLength) && (yield Create(ValueErrorType.Uint8ArrayMinByteLength, schema, path, value));
},__name(FromUint8Array, "FromUint8Array");,function* FromUnknown(schema, references, path, value) {},__name(FromUnknown, "FromUnknown");,function* FromVoid(schema, references, path, value) {
  TypeSystemPolicy.IsVoidLike(value) || (yield Create(ValueErrorType.Void, schema, path, value));
},__name(FromVoid, "FromVoid");,function* FromKind(schema, references, path, value) {
  type_exports.Get(schema[Kind])(schema, value) || (yield Create(ValueErrorType.Kind, schema, path, value));
},__name(FromKind, "FromKind");,function* Visit(schema, references, path, value) {
  let references_ = IsDefined(schema.$id) ? [...references, schema] : references,
    schema_ = schema;
  switch (schema_[Kind]) {
    case "Any":
      return yield* FromAny(schema_, references_, path, value);
    case "Argument":
      return yield* FromArgument(schema_, references_, path, value);
    case "Array":
      return yield* FromArray(schema_, references_, path, value);
    case "AsyncIterator":
      return yield* FromAsyncIterator(schema_, references_, path, value);
    case "BigInt":
      return yield* FromBigInt(schema_, references_, path, value);
    case "Boolean":
      return yield* FromBoolean(schema_, references_, path, value);
    case "Constructor":
      return yield* FromConstructor(schema_, references_, path, value);
    case "Date":
      return yield* FromDate(schema_, references_, path, value);
    case "Function":
      return yield* FromFunction(schema_, references_, path, value);
    case "Import":
      return yield* FromImport(schema_, references_, path, value);
    case "Integer":
      return yield* FromInteger(schema_, references_, path, value);
    case "Intersect":
      return yield* FromIntersect(schema_, references_, path, value);
    case "Iterator":
      return yield* FromIterator(schema_, references_, path, value);
    case "Literal":
      return yield* FromLiteral(schema_, references_, path, value);
    case "Never":
      return yield* FromNever(schema_, references_, path, value);
    case "Not":
      return yield* FromNot(schema_, references_, path, value);
    case "Null":
      return yield* FromNull(schema_, references_, path, value);
    case "Number":
      return yield* FromNumber(schema_, references_, path, value);
    case "Object":
      return yield* FromObject(schema_, references_, path, value);
    case "Promise":
      return yield* FromPromise(schema_, references_, path, value);
    case "Record":
      return yield* FromRecord(schema_, references_, path, value);
    case "Ref":
      return yield* FromRef(schema_, references_, path, value);
    case "RegExp":
      return yield* FromRegExp(schema_, references_, path, value);
    case "String":
      return yield* FromString(schema_, references_, path, value);
    case "Symbol":
      return yield* FromSymbol(schema_, references_, path, value);
    case "TemplateLiteral":
      return yield* FromTemplateLiteral(schema_, references_, path, value);
    case "This":
      return yield* FromThis(schema_, references_, path, value);
    case "Tuple":
      return yield* FromTuple(schema_, references_, path, value);
    case "Undefined":
      return yield* FromUndefined(schema_, references_, path, value);
    case "Union":
      return yield* FromUnion(schema_, references_, path, value);
    case "Uint8Array":
      return yield* FromUint8Array(schema_, references_, path, value);
    case "Unknown":
      return yield* FromUnknown(schema_, references_, path, value);
    case "Void":
      return yield* FromVoid(schema_, references_, path, value);
    default:
      if (!type_exports.Has(schema_[Kind])) throw new ValueErrorsUnknownTypeError(schema);
      return yield* FromKind(schema_, references_, path, value);
  }
},__name(Visit, "Visit");,function Errors(...args) {
  let iterator = args.length === 3 ? Visit(args[0], args[1], "", args[2]) : Visit(args[0], [], "", args[1]);
  return new ValueErrorIterator(iterator);
},__name(Errors, "Errors");