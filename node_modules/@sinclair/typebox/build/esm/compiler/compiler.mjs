var _TypeCheck = class _TypeCheck {
  constructor(schema, references, checkFunc, code) {
    this.schema = schema, this.references = references, this.checkFunc = checkFunc, this.code = code, this.hasTransform = HasTransform(schema, references);
  }
  Code() {
    return this.code;
  }
  Schema() {
    return this.schema;
  }
  References() {
    return this.references;
  }
  Errors(value) {
    return Errors(this.schema, this.references, value);
  }
  Check(value) {
    return this.checkFunc(value);
  }
  Decode(value) {
    if (!this.checkFunc(value)) throw new TransformDecodeCheckError(this.schema, value, this.Errors(value).First());
    return this.hasTransform ? TransformDecode(this.schema, this.references, value) : value;
  }
  Encode(value) {
    let encoded = this.hasTransform ? TransformEncode(this.schema, this.references, value) : value;
    if (!this.checkFunc(encoded)) throw new TransformEncodeCheckError(this.schema, value, this.Errors(value).First());
    return encoded;
  }
};,__name(_TypeCheck, "TypeCheck");,var TypeCheck = _TypeCheck,
  Character;,(function (Character) {
  function DollarSign(code) {
    return code === 36;
  }
  __name(DollarSign, "DollarSign"), Character.DollarSign = DollarSign;
  function IsUnderscore(code) {
    return code === 95;
  }
  __name(IsUnderscore, "IsUnderscore"), Character.IsUnderscore = IsUnderscore;
  function IsAlpha(code) {
    return code >= 65 && code <= 90 || code >= 97 && code <= 122;
  }
  __name(IsAlpha, "IsAlpha"), Character.IsAlpha = IsAlpha;
  function IsNumeric(code) {
    return code >= 48 && code <= 57;
  }
  __name(IsNumeric, "IsNumeric"), Character.IsNumeric = IsNumeric;
})(Character || (Character = {}));,var MemberExpression;,(function (MemberExpression) {
  function IsFirstCharacterNumeric(value) {
    return value.length === 0 ? !1 : Character.IsNumeric(value.charCodeAt(0));
  }
  __name(IsFirstCharacterNumeric, "IsFirstCharacterNumeric");
  function IsAccessor(value) {
    if (IsFirstCharacterNumeric(value)) return !1;
    for (let i = 0; i < value.length; i++) {
      let code = value.charCodeAt(i);
      if (!(Character.IsAlpha(code) || Character.IsNumeric(code) || Character.DollarSign(code) || Character.IsUnderscore(code))) return !1;
    }
    return !0;
  }
  __name(IsAccessor, "IsAccessor");
  function EscapeHyphen(key) {
    return key.replace(/'/g, "\\'");
  }
  __name(EscapeHyphen, "EscapeHyphen");
  function Encode(object, key) {
    return IsAccessor(key) ? `${object}.${key}` : `${object}['${EscapeHyphen(key)}']`;
  }
  __name(Encode, "Encode"), MemberExpression.Encode = Encode;
})(MemberExpression || (MemberExpression = {}));,var Identifier;,(function (Identifier) {
  function Encode($id) {
    let buffer = [];
    for (let i = 0; i < $id.length; i++) {
      let code = $id.charCodeAt(i);
      Character.IsNumeric(code) || Character.IsAlpha(code) ? buffer.push($id.charAt(i)) : buffer.push(`_${code}_`);
    }
    return buffer.join("").replace(/__/g, "_");
  }
  __name(Encode, "Encode"), Identifier.Encode = Encode;
})(Identifier || (Identifier = {}));,var LiteralString;,(function (LiteralString) {
  function Escape(content) {
    return content.replace(/'/g, "\\'");
  }
  __name(Escape, "Escape"), LiteralString.Escape = Escape;
})(LiteralString || (LiteralString = {}));,var _TypeCompilerUnknownTypeError = class _TypeCompilerUnknownTypeError extends TypeBoxError {
  constructor(schema) {
    super("Unknown type"), this.schema = schema;
  }
};,__name(_TypeCompilerUnknownTypeError, "TypeCompilerUnknownTypeError");,var TypeCompilerUnknownTypeError = _TypeCompilerUnknownTypeError,
  _TypeCompilerTypeGuardError = class _TypeCompilerTypeGuardError extends TypeBoxError {
    constructor(schema) {
      super("Preflight validation check failed to guard for the given schema"), this.schema = schema;
    }
  };,__name(_TypeCompilerTypeGuardError, "TypeCompilerTypeGuardError");,var TypeCompilerTypeGuardError = _TypeCompilerTypeGuardError,
  Policy;,(function (Policy) {
  function IsExactOptionalProperty(value, key, expression) {
    return TypeSystemPolicy.ExactOptionalPropertyTypes ? `('${key}' in ${value} ? ${expression} : true)` : `(${MemberExpression.Encode(value, key)} !== undefined ? ${expression} : true)`;
  }
  __name(IsExactOptionalProperty, "IsExactOptionalProperty"), Policy.IsExactOptionalProperty = IsExactOptionalProperty;
  function IsObjectLike(value) {
    return TypeSystemPolicy.AllowArrayObject ? `(typeof ${value} === 'object' && ${value} !== null)` : `(typeof ${value} === 'object' && ${value} !== null && !Array.isArray(${value}))`;
  }
  __name(IsObjectLike, "IsObjectLike"), Policy.IsObjectLike = IsObjectLike;
  function IsRecordLike(value) {
    return TypeSystemPolicy.AllowArrayObject ? `(typeof ${value} === 'object' && ${value} !== null && !(${value} instanceof Date) && !(${value} instanceof Uint8Array))` : `(typeof ${value} === 'object' && ${value} !== null && !Array.isArray(${value}) && !(${value} instanceof Date) && !(${value} instanceof Uint8Array))`;
  }
  __name(IsRecordLike, "IsRecordLike"), Policy.IsRecordLike = IsRecordLike;
  function IsNumberLike(value) {
    return TypeSystemPolicy.AllowNaN ? `typeof ${value} === 'number'` : `Number.isFinite(${value})`;
  }
  __name(IsNumberLike, "IsNumberLike"), Policy.IsNumberLike = IsNumberLike;
  function IsVoidLike(value) {
    return TypeSystemPolicy.AllowNullVoid ? `(${value} === undefined || ${value} === null)` : `${value} === undefined`;
  }
  __name(IsVoidLike, "IsVoidLike"), Policy.IsVoidLike = IsVoidLike;
})(Policy || (Policy = {}));,var TypeCompiler;,(function (TypeCompiler) {
  function IsAnyOrUnknown(schema) {
    return schema[Kind] === "Any" || schema[Kind] === "Unknown";
  }
  __name(IsAnyOrUnknown, "IsAnyOrUnknown");
  function* FromAny(schema, references, value) {
    yield "true";
  }
  __name(FromAny, "FromAny");
  function* FromArgument(schema, references, value) {
    yield "true";
  }
  __name(FromArgument, "FromArgument");
  function* FromArray(schema, references, value) {
    yield `Array.isArray(${value})`;
    let [parameter, accumulator] = [CreateParameter("value", "any"), CreateParameter("acc", "number")];
    IsNumber(schema.maxItems) && (yield `${value}.length <= ${schema.maxItems}`), IsNumber(schema.minItems) && (yield `${value}.length >= ${schema.minItems}`);
    let elementExpression = CreateExpression(schema.items, references, "value");
    if (yield `${value}.every((${parameter}) => ${elementExpression})`, IsSchema(schema.contains) || IsNumber(schema.minContains) || IsNumber(schema.maxContains)) {
      let containsSchema = IsSchema(schema.contains) ? schema.contains : Never(),
        checkExpression = CreateExpression(containsSchema, references, "value"),
        checkMinContains = IsNumber(schema.minContains) ? [`(count >= ${schema.minContains})`] : [],
        checkMaxContains = IsNumber(schema.maxContains) ? [`(count <= ${schema.maxContains})`] : [],
        checkCount = `const count = value.reduce((${accumulator}, ${parameter}) => ${checkExpression} ? acc + 1 : acc, 0)`,
        check = ["(count > 0)", ...checkMinContains, ...checkMaxContains].join(" && ");
      yield `((${parameter}) => { ${checkCount}; return ${check}})(${value})`;
    }
    schema.uniqueItems === !0 && (yield `((${parameter}) => { const set = new Set(); for(const element of value) { const hashed = hash(element); if(set.has(hashed)) { return false } else { set.add(hashed) } } return true } )(${value})`);
  }
  __name(FromArray, "FromArray");
  function* FromAsyncIterator(schema, references, value) {
    yield `(typeof value === 'object' && Symbol.asyncIterator in ${value})`;
  }
  __name(FromAsyncIterator, "FromAsyncIterator");
  function* FromBigInt(schema, references, value) {
    yield `(typeof ${value} === 'bigint')`, IsBigInt(schema.exclusiveMaximum) && (yield `${value} < BigInt(${schema.exclusiveMaximum})`), IsBigInt(schema.exclusiveMinimum) && (yield `${value} > BigInt(${schema.exclusiveMinimum})`), IsBigInt(schema.maximum) && (yield `${value} <= BigInt(${schema.maximum})`), IsBigInt(schema.minimum) && (yield `${value} >= BigInt(${schema.minimum})`), IsBigInt(schema.multipleOf) && (yield `(${value} % BigInt(${schema.multipleOf})) === 0`);
  }
  __name(FromBigInt, "FromBigInt");
  function* FromBoolean(schema, references, value) {
    yield `(typeof ${value} === 'boolean')`;
  }
  __name(FromBoolean, "FromBoolean");
  function* FromConstructor(schema, references, value) {
    yield* Visit(schema.returns, references, `${value}.prototype`);
  }
  __name(FromConstructor, "FromConstructor");
  function* FromDate(schema, references, value) {
    yield `(${value} instanceof Date) && Number.isFinite(${value}.getTime())`, IsNumber(schema.exclusiveMaximumTimestamp) && (yield `${value}.getTime() < ${schema.exclusiveMaximumTimestamp}`), IsNumber(schema.exclusiveMinimumTimestamp) && (yield `${value}.getTime() > ${schema.exclusiveMinimumTimestamp}`), IsNumber(schema.maximumTimestamp) && (yield `${value}.getTime() <= ${schema.maximumTimestamp}`), IsNumber(schema.minimumTimestamp) && (yield `${value}.getTime() >= ${schema.minimumTimestamp}`), IsNumber(schema.multipleOfTimestamp) && (yield `(${value}.getTime() % ${schema.multipleOfTimestamp}) === 0`);
  }
  __name(FromDate, "FromDate");
  function* FromFunction(schema, references, value) {
    yield `(typeof ${value} === 'function')`;
  }
  __name(FromFunction, "FromFunction");
  function* FromImport(schema, references, value) {
    let members = globalThis.Object.getOwnPropertyNames(schema.$defs).reduce((result, key) => [...result, schema.$defs[key]], []);
    yield* Visit(Ref(schema.$ref), [...references, ...members], value);
  }
  __name(FromImport, "FromImport");
  function* FromInteger(schema, references, value) {
    yield `Number.isInteger(${value})`, IsNumber(schema.exclusiveMaximum) && (yield `${value} < ${schema.exclusiveMaximum}`), IsNumber(schema.exclusiveMinimum) && (yield `${value} > ${schema.exclusiveMinimum}`), IsNumber(schema.maximum) && (yield `${value} <= ${schema.maximum}`), IsNumber(schema.minimum) && (yield `${value} >= ${schema.minimum}`), IsNumber(schema.multipleOf) && (yield `(${value} % ${schema.multipleOf}) === 0`);
  }
  __name(FromInteger, "FromInteger");
  function* FromIntersect(schema, references, value) {
    let check1 = schema.allOf.map(schema => CreateExpression(schema, references, value)).join(" && ");
    if (schema.unevaluatedProperties === !1) {
      let keyCheck = CreateVariable(`${new RegExp(KeyOfPattern(schema))};`),
        check2 = `Object.getOwnPropertyNames(${value}).every(key => ${keyCheck}.test(key))`;
      yield `(${check1} && ${check2})`;
    } else if (IsSchema(schema.unevaluatedProperties)) {
      let keyCheck = CreateVariable(`${new RegExp(KeyOfPattern(schema))};`),
        check2 = `Object.getOwnPropertyNames(${value}).every(key => ${keyCheck}.test(key) || ${CreateExpression(schema.unevaluatedProperties, references, `${value}[key]`)})`;
      yield `(${check1} && ${check2})`;
    } else yield `(${check1})`;
  }
  __name(FromIntersect, "FromIntersect");
  function* FromIterator(schema, references, value) {
    yield `(typeof value === 'object' && Symbol.iterator in ${value})`;
  }
  __name(FromIterator, "FromIterator");
  function* FromLiteral(schema, references, value) {
    typeof schema.const == "number" || typeof schema.const == "boolean" ? yield `(${value} === ${schema.const})` : yield `(${value} === '${LiteralString.Escape(schema.const)}')`;
  }
  __name(FromLiteral, "FromLiteral");
  function* FromNever(schema, references, value) {
    yield "false";
  }
  __name(FromNever, "FromNever");
  function* FromNot(schema, references, value) {
    yield `(!${CreateExpression(schema.not, references, value)})`;
  }
  __name(FromNot, "FromNot");
  function* FromNull(schema, references, value) {
    yield `(${value} === null)`;
  }
  __name(FromNull, "FromNull");
  function* FromNumber(schema, references, value) {
    yield Policy.IsNumberLike(value), IsNumber(schema.exclusiveMaximum) && (yield `${value} < ${schema.exclusiveMaximum}`), IsNumber(schema.exclusiveMinimum) && (yield `${value} > ${schema.exclusiveMinimum}`), IsNumber(schema.maximum) && (yield `${value} <= ${schema.maximum}`), IsNumber(schema.minimum) && (yield `${value} >= ${schema.minimum}`), IsNumber(schema.multipleOf) && (yield `(${value} % ${schema.multipleOf}) === 0`);
  }
  __name(FromNumber, "FromNumber");
  function* FromObject(schema, references, value) {
    yield Policy.IsObjectLike(value), IsNumber(schema.minProperties) && (yield `Object.getOwnPropertyNames(${value}).length >= ${schema.minProperties}`), IsNumber(schema.maxProperties) && (yield `Object.getOwnPropertyNames(${value}).length <= ${schema.maxProperties}`);
    let knownKeys = Object.getOwnPropertyNames(schema.properties);
    for (let knownKey of knownKeys) {
      let memberExpression = MemberExpression.Encode(value, knownKey),
        property = schema.properties[knownKey];
      if (schema.required && schema.required.includes(knownKey)) yield* Visit(property, references, memberExpression), (ExtendsUndefinedCheck(property) || IsAnyOrUnknown(property)) && (yield `('${knownKey}' in ${value})`);else {
        let expression = CreateExpression(property, references, memberExpression);
        yield Policy.IsExactOptionalProperty(value, knownKey, expression);
      }
    }
    if (schema.additionalProperties === !1) if (schema.required && schema.required.length === knownKeys.length) yield `Object.getOwnPropertyNames(${value}).length === ${knownKeys.length}`;else {
      let keys = `[${knownKeys.map(key => `'${key}'`).join(", ")}]`;
      yield `Object.getOwnPropertyNames(${value}).every(key => ${keys}.includes(key))`;
    }
    if (typeof schema.additionalProperties == "object") {
      let expression = CreateExpression(schema.additionalProperties, references, `${value}[key]`),
        keys = `[${knownKeys.map(key => `'${key}'`).join(", ")}]`;
      yield `(Object.getOwnPropertyNames(${value}).every(key => ${keys}.includes(key) || ${expression}))`;
    }
  }
  __name(FromObject, "FromObject");
  function* FromPromise(schema, references, value) {
    yield `${value} instanceof Promise`;
  }
  __name(FromPromise, "FromPromise");
  function* FromRecord(schema, references, value) {
    yield Policy.IsRecordLike(value), IsNumber(schema.minProperties) && (yield `Object.getOwnPropertyNames(${value}).length >= ${schema.minProperties}`), IsNumber(schema.maxProperties) && (yield `Object.getOwnPropertyNames(${value}).length <= ${schema.maxProperties}`);
    let [patternKey, patternSchema] = Object.entries(schema.patternProperties)[0],
      variable = CreateVariable(`${new RegExp(patternKey)}`),
      check1 = CreateExpression(patternSchema, references, "value"),
      check2 = IsSchema(schema.additionalProperties) ? CreateExpression(schema.additionalProperties, references, value) : schema.additionalProperties === !1 ? "false" : "true",
      expression = `(${variable}.test(key) ? ${check1} : ${check2})`;
    yield `(Object.entries(${value}).every(([key, value]) => ${expression}))`;
  }
  __name(FromRecord, "FromRecord");
  function* FromRef(schema, references, value) {
    let target = Deref(schema, references);
    if (state.functions.has(schema.$ref)) return yield `${CreateFunctionName(schema.$ref)}(${value})`;
    yield* Visit(target, references, value);
  }
  __name(FromRef, "FromRef");
  function* FromRegExp(schema, references, value) {
    let variable = CreateVariable(`${new RegExp(schema.source, schema.flags)};`);
    yield `(typeof ${value} === 'string')`, IsNumber(schema.maxLength) && (yield `${value}.length <= ${schema.maxLength}`), IsNumber(schema.minLength) && (yield `${value}.length >= ${schema.minLength}`), yield `${variable}.test(${value})`;
  }
  __name(FromRegExp, "FromRegExp");
  function* FromString(schema, references, value) {
    yield `(typeof ${value} === 'string')`, IsNumber(schema.maxLength) && (yield `${value}.length <= ${schema.maxLength}`), IsNumber(schema.minLength) && (yield `${value}.length >= ${schema.minLength}`), schema.pattern !== void 0 && (yield `${CreateVariable(`${new RegExp(schema.pattern)};`)}.test(${value})`), schema.format !== void 0 && (yield `format('${schema.format}', ${value})`);
  }
  __name(FromString, "FromString");
  function* FromSymbol(schema, references, value) {
    yield `(typeof ${value} === 'symbol')`;
  }
  __name(FromSymbol, "FromSymbol");
  function* FromTemplateLiteral(schema, references, value) {
    yield `(typeof ${value} === 'string')`, yield `${CreateVariable(`${new RegExp(schema.pattern)};`)}.test(${value})`;
  }
  __name(FromTemplateLiteral, "FromTemplateLiteral");
  function* FromThis(schema, references, value) {
    yield `${CreateFunctionName(schema.$ref)}(${value})`;
  }
  __name(FromThis, "FromThis");
  function* FromTuple(schema, references, value) {
    if (yield `Array.isArray(${value})`, schema.items === void 0) return yield `${value}.length === 0`;
    yield `(${value}.length === ${schema.maxItems})`;
    for (let i = 0; i < schema.items.length; i++) yield `${CreateExpression(schema.items[i], references, `${value}[${i}]`)}`;
  }
  __name(FromTuple, "FromTuple");
  function* FromUndefined(schema, references, value) {
    yield `${value} === undefined`;
  }
  __name(FromUndefined, "FromUndefined");
  function* FromUnion(schema, references, value) {
    yield `(${schema.anyOf.map(schema => CreateExpression(schema, references, value)).join(" || ")})`;
  }
  __name(FromUnion, "FromUnion");
  function* FromUint8Array(schema, references, value) {
    yield `${value} instanceof Uint8Array`, IsNumber(schema.maxByteLength) && (yield `(${value}.length <= ${schema.maxByteLength})`), IsNumber(schema.minByteLength) && (yield `(${value}.length >= ${schema.minByteLength})`);
  }
  __name(FromUint8Array, "FromUint8Array");
  function* FromUnknown(schema, references, value) {
    yield "true";
  }
  __name(FromUnknown, "FromUnknown");
  function* FromVoid(schema, references, value) {
    yield Policy.IsVoidLike(value);
  }
  __name(FromVoid, "FromVoid");
  function* FromKind(schema, references, value) {
    let instance = state.instances.size;
    state.instances.set(instance, schema), yield `kind('${schema[Kind]}', ${instance}, ${value})`;
  }
  __name(FromKind, "FromKind");
  function* Visit(schema, references, value, useHoisting = !0) {
    let references_ = IsString(schema.$id) ? [...references, schema] : references,
      schema_ = schema;
    if (useHoisting && IsString(schema.$id)) {
      let functionName = CreateFunctionName(schema.$id);
      if (state.functions.has(functionName)) return yield `${functionName}(${value})`;
      {
        state.functions.set(functionName, "<deferred>");
        let functionCode = CreateFunction(functionName, schema, references, "value", !1);
        return state.functions.set(functionName, functionCode), yield `${functionName}(${value})`;
      }
    }
    switch (schema_[Kind]) {
      case "Any":
        return yield* FromAny(schema_, references_, value);
      case "Argument":
        return yield* FromArgument(schema_, references_, value);
      case "Array":
        return yield* FromArray(schema_, references_, value);
      case "AsyncIterator":
        return yield* FromAsyncIterator(schema_, references_, value);
      case "BigInt":
        return yield* FromBigInt(schema_, references_, value);
      case "Boolean":
        return yield* FromBoolean(schema_, references_, value);
      case "Constructor":
        return yield* FromConstructor(schema_, references_, value);
      case "Date":
        return yield* FromDate(schema_, references_, value);
      case "Function":
        return yield* FromFunction(schema_, references_, value);
      case "Import":
        return yield* FromImport(schema_, references_, value);
      case "Integer":
        return yield* FromInteger(schema_, references_, value);
      case "Intersect":
        return yield* FromIntersect(schema_, references_, value);
      case "Iterator":
        return yield* FromIterator(schema_, references_, value);
      case "Literal":
        return yield* FromLiteral(schema_, references_, value);
      case "Never":
        return yield* FromNever(schema_, references_, value);
      case "Not":
        return yield* FromNot(schema_, references_, value);
      case "Null":
        return yield* FromNull(schema_, references_, value);
      case "Number":
        return yield* FromNumber(schema_, references_, value);
      case "Object":
        return yield* FromObject(schema_, references_, value);
      case "Promise":
        return yield* FromPromise(schema_, references_, value);
      case "Record":
        return yield* FromRecord(schema_, references_, value);
      case "Ref":
        return yield* FromRef(schema_, references_, value);
      case "RegExp":
        return yield* FromRegExp(schema_, references_, value);
      case "String":
        return yield* FromString(schema_, references_, value);
      case "Symbol":
        return yield* FromSymbol(schema_, references_, value);
      case "TemplateLiteral":
        return yield* FromTemplateLiteral(schema_, references_, value);
      case "This":
        return yield* FromThis(schema_, references_, value);
      case "Tuple":
        return yield* FromTuple(schema_, references_, value);
      case "Undefined":
        return yield* FromUndefined(schema_, references_, value);
      case "Union":
        return yield* FromUnion(schema_, references_, value);
      case "Uint8Array":
        return yield* FromUint8Array(schema_, references_, value);
      case "Unknown":
        return yield* FromUnknown(schema_, references_, value);
      case "Void":
        return yield* FromVoid(schema_, references_, value);
      default:
        if (!type_exports.Has(schema_[Kind])) throw new TypeCompilerUnknownTypeError(schema);
        return yield* FromKind(schema_, references_, value);
    }
  }
  __name(Visit, "Visit");
  let state = {
    language: "javascript",
    functions: new Map(),
    variables: new Map(),
    instances: new Map()
  };
  function CreateExpression(schema, references, value, useHoisting = !0) {
    return `(${[...Visit(schema, references, value, useHoisting)].join(" && ")})`;
  }
  __name(CreateExpression, "CreateExpression");
  function CreateFunctionName($id) {
    return `check_${Identifier.Encode($id)}`;
  }
  __name(CreateFunctionName, "CreateFunctionName");
  function CreateVariable(expression) {
    let variableName = `local_${state.variables.size}`;
    return state.variables.set(variableName, `const ${variableName} = ${expression}`), variableName;
  }
  __name(CreateVariable, "CreateVariable");
  function CreateFunction(name, schema, references, value, useHoisting = !0) {
    let [newline, pad] = [`
`, length => "".padStart(length, " ")],
      parameter = CreateParameter("value", "any"),
      returns = CreateReturns("boolean"),
      expression = [...Visit(schema, references, value, useHoisting)].map(expression => `${pad(4)}${expression}`).join(` &&${newline}`);
    return `function ${name}(${parameter})${returns} {${newline}${pad(2)}return (${newline}${expression}${newline}${pad(2)})
}`;
  }
  __name(CreateFunction, "CreateFunction");
  function CreateParameter(name, type) {
    let annotation = state.language === "typescript" ? `: ${type}` : "";
    return `${name}${annotation}`;
  }
  __name(CreateParameter, "CreateParameter");
  function CreateReturns(type) {
    return state.language === "typescript" ? `: ${type}` : "";
  }
  __name(CreateReturns, "CreateReturns");
  function Build(schema, references, options) {
    let functionCode = CreateFunction("check", schema, references, "value"),
      parameter = CreateParameter("value", "any"),
      returns = CreateReturns("boolean"),
      functions = [...state.functions.values()],
      variables = [...state.variables.values()],
      checkFunction = IsString(schema.$id) ? `return function check(${parameter})${returns} {
  return ${CreateFunctionName(schema.$id)}(value)
}` : `return ${functionCode}`;
    return [...variables, ...functions, checkFunction].join(`
`);
  }
  __name(Build, "Build");
  function Code(...args) {
    let defaults = {
        language: "javascript"
      },
      [schema, references, options] = args.length === 2 && IsArray(args[1]) ? [args[0], args[1], defaults] : args.length === 2 && !IsArray(args[1]) ? [args[0], [], args[1]] : args.length === 3 ? [args[0], args[1], args[2]] : args.length === 1 ? [args[0], [], defaults] : [null, [], defaults];
    if (state.language = options.language, state.variables.clear(), state.functions.clear(), state.instances.clear(), !IsSchema(schema)) throw new TypeCompilerTypeGuardError(schema);
    for (let schema of references) if (!IsSchema(schema)) throw new TypeCompilerTypeGuardError(schema);
    return Build(schema, references, options);
  }
  __name(Code, "Code"), TypeCompiler.Code = Code;
  function Compile(schema, references = []) {
    let generatedCode = Code(schema, references, {
        language: "javascript"
      }),
      compiledFunction = globalThis.Function("kind", "format", "hash", generatedCode),
      instances = new Map(state.instances);
    function typeRegistryFunction(kind, instance, value) {
      if (!type_exports.Has(kind) || !instances.has(instance)) return !1;
      let checkFunc = type_exports.Get(kind),
        schema = instances.get(instance);
      return checkFunc(schema, value);
    }
    __name(typeRegistryFunction, "typeRegistryFunction");
    function formatRegistryFunction(format, value) {
      return format_exports.Has(format) ? format_exports.Get(format)(value) : !1;
    }
    __name(formatRegistryFunction, "formatRegistryFunction");
    function hashFunction(value) {
      return Hash(value);
    }
    __name(hashFunction, "hashFunction");
    let checkFunction = compiledFunction(typeRegistryFunction, formatRegistryFunction, hashFunction);
    return new TypeCheck(schema, references, checkFunction, generatedCode);
  }
  __name(Compile, "Compile"), TypeCompiler.Compile = Compile;
})(TypeCompiler || (TypeCompiler = {}));