function IsStringNumeric(value) {
  return IsString(value) && !isNaN(value) && !isNaN(parseFloat(value));
},__name(IsStringNumeric, "IsStringNumeric");,function IsValueToString(value) {
  return IsBigInt(value) || IsBoolean(value) || IsNumber(value);
},__name(IsValueToString, "IsValueToString");,function IsValueTrue(value) {
  return value === !0 || IsNumber(value) && value === 1 || IsBigInt(value) && value === BigInt("1") || IsString(value) && (value.toLowerCase() === "true" || value === "1");
},__name(IsValueTrue, "IsValueTrue");,function IsValueFalse(value) {
  return value === !1 || IsNumber(value) && (value === 0 || Object.is(value, -0)) || IsBigInt(value) && value === BigInt("0") || IsString(value) && (value.toLowerCase() === "false" || value === "0" || value === "-0");
},__name(IsValueFalse, "IsValueFalse");,function IsTimeStringWithTimeZone(value) {
  return IsString(value) && /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i.test(value);
},__name(IsTimeStringWithTimeZone, "IsTimeStringWithTimeZone");,function IsTimeStringWithoutTimeZone(value) {
  return IsString(value) && /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)?$/i.test(value);
},__name(IsTimeStringWithoutTimeZone, "IsTimeStringWithoutTimeZone");,function IsDateTimeStringWithTimeZone(value) {
  return IsString(value) && /^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i.test(value);
},__name(IsDateTimeStringWithTimeZone, "IsDateTimeStringWithTimeZone");,function IsDateTimeStringWithoutTimeZone(value) {
  return IsString(value) && /^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)?$/i.test(value);
},__name(IsDateTimeStringWithoutTimeZone, "IsDateTimeStringWithoutTimeZone");,function IsDateString(value) {
  return IsString(value) && /^\d\d\d\d-[0-1]\d-[0-3]\d$/i.test(value);
},__name(IsDateString, "IsDateString");,function TryConvertLiteralString(value, target) {
  let conversion = TryConvertString(value);
  return conversion === target ? conversion : value;
},__name(TryConvertLiteralString, "TryConvertLiteralString");,function TryConvertLiteralNumber(value, target) {
  let conversion = TryConvertNumber(value);
  return conversion === target ? conversion : value;
},__name(TryConvertLiteralNumber, "TryConvertLiteralNumber");,function TryConvertLiteralBoolean(value, target) {
  let conversion = TryConvertBoolean(value);
  return conversion === target ? conversion : value;
},__name(TryConvertLiteralBoolean, "TryConvertLiteralBoolean");,function TryConvertLiteral(schema, value) {
  return IsString(schema.const) ? TryConvertLiteralString(value, schema.const) : IsNumber(schema.const) ? TryConvertLiteralNumber(value, schema.const) : IsBoolean(schema.const) ? TryConvertLiteralBoolean(value, schema.const) : value;
},__name(TryConvertLiteral, "TryConvertLiteral");,function TryConvertBoolean(value) {
  return IsValueTrue(value) ? !0 : IsValueFalse(value) ? !1 : value;
},__name(TryConvertBoolean, "TryConvertBoolean");,function TryConvertBigInt(value) {
  let truncateInteger = __name(value => value.split(".")[0], "truncateInteger");
  return IsStringNumeric(value) ? BigInt(truncateInteger(value)) : IsNumber(value) ? BigInt(Math.trunc(value)) : IsValueFalse(value) ? BigInt(0) : IsValueTrue(value) ? BigInt(1) : value;
},__name(TryConvertBigInt, "TryConvertBigInt");,function TryConvertString(value) {
  return IsSymbol(value) && value.description !== void 0 ? value.description.toString() : IsValueToString(value) ? value.toString() : value;
},__name(TryConvertString, "TryConvertString");,function TryConvertNumber(value) {
  return IsStringNumeric(value) ? parseFloat(value) : IsValueTrue(value) ? 1 : IsValueFalse(value) ? 0 : value;
},__name(TryConvertNumber, "TryConvertNumber");,function TryConvertInteger(value) {
  return IsStringNumeric(value) ? parseInt(value) : IsNumber(value) ? Math.trunc(value) : IsValueTrue(value) ? 1 : IsValueFalse(value) ? 0 : value;
},__name(TryConvertInteger, "TryConvertInteger");,function TryConvertNull(value) {
  return IsString(value) && value.toLowerCase() === "null" ? null : value;
},__name(TryConvertNull, "TryConvertNull");,function TryConvertUndefined(value) {
  return IsString(value) && value === "undefined" ? void 0 : value;
},__name(TryConvertUndefined, "TryConvertUndefined");,function TryConvertDate(value) {
  return IsDate(value) ? value : IsNumber(value) ? new Date(value) : IsValueTrue(value) ? new Date(1) : IsValueFalse(value) ? new Date(0) : IsStringNumeric(value) ? new Date(parseInt(value)) : IsTimeStringWithoutTimeZone(value) ? new Date(`1970-01-01T${value}.000Z`) : IsTimeStringWithTimeZone(value) ? new Date(`1970-01-01T${value}`) : IsDateTimeStringWithoutTimeZone(value) ? new Date(`${value}.000Z`) : IsDateTimeStringWithTimeZone(value) ? new Date(value) : IsDateString(value) ? new Date(`${value}T00:00:00.000Z`) : value;
},__name(TryConvertDate, "TryConvertDate");,function FromArray(schema, references, value) {
  return (IsArray(value) ? value : [value]).map(element => Visit(schema.items, references, element));
},__name(FromArray, "FromArray");,function FromBigInt(schema, references, value) {
  return TryConvertBigInt(value);
},__name(FromBigInt, "FromBigInt");,function FromBoolean(schema, references, value) {
  return TryConvertBoolean(value);
},__name(FromBoolean, "FromBoolean");,function FromDate(schema, references, value) {
  return TryConvertDate(value);
},__name(FromDate, "FromDate");,function FromImport(schema, references, value) {
  let definitions = globalThis.Object.values(schema.$defs),
    target = schema.$defs[schema.$ref];
  return Visit(target, [...references, ...definitions], value);
},__name(FromImport, "FromImport");,function FromInteger(schema, references, value) {
  return TryConvertInteger(value);
},__name(FromInteger, "FromInteger");,function FromIntersect(schema, references, value) {
  return schema.allOf.reduce((value, schema) => Visit(schema, references, value), value);
},__name(FromIntersect, "FromIntersect");,function FromLiteral(schema, references, value) {
  return TryConvertLiteral(schema, value);
},__name(FromLiteral, "FromLiteral");,function FromNull(schema, references, value) {
  return TryConvertNull(value);
},__name(FromNull, "FromNull");,function FromNumber(schema, references, value) {
  return TryConvertNumber(value);
},__name(FromNumber, "FromNumber");,function FromObject(schema, references, value) {
  if (!IsObject(value)) return value;
  for (let propertyKey of Object.getOwnPropertyNames(schema.properties)) HasPropertyKey(value, propertyKey) && (value[propertyKey] = Visit(schema.properties[propertyKey], references, value[propertyKey]));
  return value;
},__name(FromObject, "FromObject");,function FromRecord(schema, references, value) {
  if (!IsObject(value)) return value;
  let propertyKey = Object.getOwnPropertyNames(schema.patternProperties)[0],
    property = schema.patternProperties[propertyKey];
  for (let [propKey, propValue] of Object.entries(value)) value[propKey] = Visit(property, references, propValue);
  return value;
},__name(FromRecord, "FromRecord");,function FromRef(schema, references, value) {
  return Visit(Deref(schema, references), references, value);
},__name(FromRef, "FromRef");,function FromString(schema, references, value) {
  return TryConvertString(value);
},__name(FromString, "FromString");,function FromSymbol(schema, references, value) {
  return IsString(value) || IsNumber(value) ? Symbol(value) : value;
},__name(FromSymbol, "FromSymbol");,function FromThis(schema, references, value) {
  return Visit(Deref(schema, references), references, value);
},__name(FromThis, "FromThis");,function FromTuple(schema, references, value) {
  return IsArray(value) && !IsUndefined(schema.items) ? value.map((value, index) => index < schema.items.length ? Visit(schema.items[index], references, value) : value) : value;
},__name(FromTuple, "FromTuple");,function FromUndefined(schema, references, value) {
  return TryConvertUndefined(value);
},__name(FromUndefined, "FromUndefined");,function FromUnion(schema, references, value) {
  for (let subschema of schema.anyOf) {
    let converted = Visit(subschema, references, Clone(value));
    if (Check(subschema, references, converted)) return converted;
  }
  return value;
},__name(FromUnion, "FromUnion");,function Visit(schema, references, value) {
  let references_ = Pushref(schema, references),
    schema_ = schema;
  switch (schema[Kind]) {
    case "Array":
      return FromArray(schema_, references_, value);
    case "BigInt":
      return FromBigInt(schema_, references_, value);
    case "Boolean":
      return FromBoolean(schema_, references_, value);
    case "Date":
      return FromDate(schema_, references_, value);
    case "Import":
      return FromImport(schema_, references_, value);
    case "Integer":
      return FromInteger(schema_, references_, value);
    case "Intersect":
      return FromIntersect(schema_, references_, value);
    case "Literal":
      return FromLiteral(schema_, references_, value);
    case "Null":
      return FromNull(schema_, references_, value);
    case "Number":
      return FromNumber(schema_, references_, value);
    case "Object":
      return FromObject(schema_, references_, value);
    case "Record":
      return FromRecord(schema_, references_, value);
    case "Ref":
      return FromRef(schema_, references_, value);
    case "String":
      return FromString(schema_, references_, value);
    case "Symbol":
      return FromSymbol(schema_, references_, value);
    case "This":
      return FromThis(schema_, references_, value);
    case "Tuple":
      return FromTuple(schema_, references_, value);
    case "Undefined":
      return FromUndefined(schema_, references_, value);
    case "Union":
      return FromUnion(schema_, references_, value);
    default:
      return value;
  }
},__name(Visit, "Visit");,function Convert(...args) {
  return args.length === 3 ? Visit(args[0], args[1], args[2]) : Visit(args[0], [], args[1]);
},__name(Convert, "Convert");