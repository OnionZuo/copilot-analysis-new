var Insert = Object({
    type: Literal("insert"),
    path: String(),
    value: Unknown()
  }),
  Update = Object({
    type: Literal("update"),
    path: String(),
    value: Unknown()
  }),
  Delete = Object({
    type: Literal("delete"),
    path: String()
  }),
  Edit = Union([Insert, Update, Delete]),
  _ValueDiffError = class _ValueDiffError extends TypeBoxError {
    constructor(value, message) {
      super(message), this.value = value;
    }
  };,__name(_ValueDiffError, "ValueDiffError");,var ValueDiffError = _ValueDiffError;,function CreateUpdate(path, value) {
  return {
    type: "update",
    path: path,
    value: value
  };
},__name(CreateUpdate, "CreateUpdate");,function CreateInsert(path, value) {
  return {
    type: "insert",
    path: path,
    value: value
  };
},__name(CreateInsert, "CreateInsert");,function CreateDelete(path) {
  return {
    type: "delete",
    path: path
  };
},__name(CreateDelete, "CreateDelete");,function AssertDiffable(value) {
  if (globalThis.Object.getOwnPropertySymbols(value).length > 0) throw new ValueDiffError(value, "Cannot diff objects with symbols");
},__name(AssertDiffable, "AssertDiffable");,function* ObjectType(path, current, next) {
  if (AssertDiffable(current), AssertDiffable(next), !IsStandardObject(next)) return yield CreateUpdate(path, next);
  let currentKeys = globalThis.Object.getOwnPropertyNames(current),
    nextKeys = globalThis.Object.getOwnPropertyNames(next);
  for (let key of nextKeys) HasPropertyKey(current, key) || (yield CreateInsert(`${path}/${key}`, next[key]));
  for (let key of currentKeys) HasPropertyKey(next, key) && (Equal(current, next) || (yield* Visit(`${path}/${key}`, current[key], next[key])));
  for (let key of currentKeys) HasPropertyKey(next, key) || (yield CreateDelete(`${path}/${key}`));
},__name(ObjectType, "ObjectType");,function* ArrayType(path, current, next) {
  if (!IsArray(next)) return yield CreateUpdate(path, next);
  for (let i = 0; i < Math.min(current.length, next.length); i++) yield* Visit(`${path}/${i}`, current[i], next[i]);
  for (let i = 0; i < next.length; i++) i < current.length || (yield CreateInsert(`${path}/${i}`, next[i]));
  for (let i = current.length - 1; i >= 0; i--) i < next.length || (yield CreateDelete(`${path}/${i}`));
},__name(ArrayType, "ArrayType");,function* TypedArrayType(path, current, next) {
  if (!IsTypedArray(next) || current.length !== next.length || globalThis.Object.getPrototypeOf(current).constructor.name !== globalThis.Object.getPrototypeOf(next).constructor.name) return yield CreateUpdate(path, next);
  for (let i = 0; i < Math.min(current.length, next.length); i++) yield* Visit(`${path}/${i}`, current[i], next[i]);
},__name(TypedArrayType, "TypedArrayType");,function* ValueType(path, current, next) {
  current !== next && (yield CreateUpdate(path, next));
},__name(ValueType, "ValueType");,function* Visit(path, current, next) {
  if (IsStandardObject(current)) return yield* ObjectType(path, current, next);
  if (IsArray(current)) return yield* ArrayType(path, current, next);
  if (IsTypedArray(current)) return yield* TypedArrayType(path, current, next);
  if (IsValueType(current)) return yield* ValueType(path, current, next);
  throw new ValueDiffError(current, "Unable to diff value");
},__name(Visit, "Visit");,function Diff(current, next) {
  return [...Visit("", current, next)];
},__name(Diff, "Diff");,function IsRootUpdate(edits) {
  return edits.length > 0 && edits[0].path === "" && edits[0].type === "update";
},__name(IsRootUpdate, "IsRootUpdate");,function IsIdentity(edits) {
  return edits.length === 0;
},__name(IsIdentity, "IsIdentity");,function Patch(current, edits) {
  if (IsRootUpdate(edits)) return Clone(edits[0].value);
  if (IsIdentity(edits)) return Clone(current);
  let clone = Clone(current);
  for (let edit of edits) switch (edit.type) {
    case "insert":
      {
        pointer_exports.Set(clone, edit.path, edit.value);
        break;
      }
    case "update":
      {
        pointer_exports.Set(clone, edit.path, edit.value);
        break;
      }
    case "delete":
      {
        pointer_exports.Delete(clone, edit.path);
        break;
      }
  }
  return clone;
},__name(Patch, "Patch");