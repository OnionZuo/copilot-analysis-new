var _ValueCastError = class _ValueCastError extends TypeBoxError {
  constructor(schema, message) {
    super(message), this.schema = schema;
  }
};,__name(_ValueCastError, "ValueCastError");,var ValueCastError = _ValueCastError;,function ScoreUnion(schema, references, value) {
  if (schema[Kind] === "Object" && typeof value == "object" && !IsNull(value)) {
    let object = schema,
      keys = Object.getOwnPropertyNames(value),
      entries = Object.entries(object.properties),
      [point, max] = [1 / entries.length, entries.length];
    return entries.reduce((acc, [key, schema]) => {
      let literal = schema[Kind] === "Literal" && schema.const === value[key] ? max : 0,
        checks = Check(schema, references, value[key]) ? point : 0,
        exists = keys.includes(key) ? point : 0;
      return acc + (literal + checks + exists);
    }, 0);
  } else return Check(schema, references, value) ? 1 : 0;
},__name(ScoreUnion, "ScoreUnion");,function SelectUnion(union, references, value) {
  let schemas = union.anyOf.map(schema => Deref(schema, references)),
    [select, best] = [schemas[0], 0];
  for (let schema of schemas) {
    let score = ScoreUnion(schema, references, value);
    score > best && (select = schema, best = score);
  }
  return select;
},__name(SelectUnion, "SelectUnion");,function CastUnion(union, references, value) {
  if ("default" in union) return typeof value == "function" ? union.default : Clone(union.default);
  {
    let schema = SelectUnion(union, references, value);
    return Cast(schema, references, value);
  }
},__name(CastUnion, "CastUnion");,function DefaultClone(schema, references, value) {
  return Check(schema, references, value) ? Clone(value) : Create(schema, references);
},__name(DefaultClone, "DefaultClone");,function Default(schema, references, value) {
  return Check(schema, references, value) ? value : Create(schema, references);
},__name(Default, "Default");,function FromArray(schema, references, value) {
  if (Check(schema, references, value)) return Clone(value);
  let created = IsArray(value) ? Clone(value) : Create(schema, references),
    minimum = IsNumber(schema.minItems) && created.length < schema.minItems ? [...created, ...Array.from({
      length: schema.minItems - created.length
    }, () => null)] : created,
    casted = (IsNumber(schema.maxItems) && minimum.length > schema.maxItems ? minimum.slice(0, schema.maxItems) : minimum).map(value => Visit(schema.items, references, value));
  if (schema.uniqueItems !== !0) return casted;
  let unique = [...new Set(casted)];
  if (!Check(schema, references, unique)) throw new ValueCastError(schema, "Array cast produced invalid data due to uniqueItems constraint");
  return unique;
},__name(FromArray, "FromArray");,function FromConstructor(schema, references, value) {
  if (Check(schema, references, value)) return Create(schema, references);
  let required = new Set(schema.returns.required || []),
    result = __name(function () {}, "result");
  for (let [key, property] of Object.entries(schema.returns.properties)) !required.has(key) && value.prototype[key] === void 0 || (result.prototype[key] = Visit(property, references, value.prototype[key]));
  return result;
},__name(FromConstructor, "FromConstructor");,function FromImport(schema, references, value) {
  let definitions = globalThis.Object.values(schema.$defs),
    target = schema.$defs[schema.$ref];
  return Visit(target, [...references, ...definitions], value);
},__name(FromImport, "FromImport");,function FromIntersect(schema, references, value) {
  let created = Create(schema, references),
    mapped = IsObject(created) && IsObject(value) ? {
      ...created,
      ...value
    } : value;
  return Check(schema, references, mapped) ? mapped : Create(schema, references);
},__name(FromIntersect, "FromIntersect");,function FromNever(schema, references, value) {
  throw new ValueCastError(schema, "Never types cannot be cast");
},__name(FromNever, "FromNever");,function FromObject(schema, references, value) {
  if (Check(schema, references, value)) return value;
  if (value === null || typeof value != "object") return Create(schema, references);
  let required = new Set(schema.required || []),
    result = {};
  for (let [key, property] of Object.entries(schema.properties)) !required.has(key) && value[key] === void 0 || (result[key] = Visit(property, references, value[key]));
  if (typeof schema.additionalProperties == "object") {
    let propertyNames = Object.getOwnPropertyNames(schema.properties);
    for (let propertyName of Object.getOwnPropertyNames(value)) propertyNames.includes(propertyName) || (result[propertyName] = Visit(schema.additionalProperties, references, value[propertyName]));
  }
  return result;
},__name(FromObject, "FromObject");,function FromRecord(schema, references, value) {
  if (Check(schema, references, value)) return Clone(value);
  if (value === null || typeof value != "object" || Array.isArray(value) || value instanceof Date) return Create(schema, references);
  let subschemaPropertyName = Object.getOwnPropertyNames(schema.patternProperties)[0],
    subschema = schema.patternProperties[subschemaPropertyName],
    result = {};
  for (let [propKey, propValue] of Object.entries(value)) result[propKey] = Visit(subschema, references, propValue);
  return result;
},__name(FromRecord, "FromRecord");,function FromRef(schema, references, value) {
  return Visit(Deref(schema, references), references, value);
},__name(FromRef, "FromRef");,function FromThis(schema, references, value) {
  return Visit(Deref(schema, references), references, value);
},__name(FromThis, "FromThis");,function FromTuple(schema, references, value) {
  return Check(schema, references, value) ? Clone(value) : IsArray(value) ? schema.items === void 0 ? [] : schema.items.map((schema, index) => Visit(schema, references, value[index])) : Create(schema, references);
},__name(FromTuple, "FromTuple");,function FromUnion(schema, references, value) {
  return Check(schema, references, value) ? Clone(value) : CastUnion(schema, references, value);
},__name(FromUnion, "FromUnion");,function Visit(schema, references, value) {
  let references_ = IsString(schema.$id) ? Pushref(schema, references) : references,
    schema_ = schema;
  switch (schema[Kind]) {
    case "Array":
      return FromArray(schema_, references_, value);
    case "Constructor":
      return FromConstructor(schema_, references_, value);
    case "Import":
      return FromImport(schema_, references_, value);
    case "Intersect":
      return FromIntersect(schema_, references_, value);
    case "Never":
      return FromNever(schema_, references_, value);
    case "Object":
      return FromObject(schema_, references_, value);
    case "Record":
      return FromRecord(schema_, references_, value);
    case "Ref":
      return FromRef(schema_, references_, value);
    case "This":
      return FromThis(schema_, references_, value);
    case "Tuple":
      return FromTuple(schema_, references_, value);
    case "Union":
      return FromUnion(schema_, references_, value);
    case "Date":
    case "Symbol":
    case "Uint8Array":
      return DefaultClone(schema, references, value);
    default:
      return Default(schema_, references_, value);
  }
},__name(Visit, "Visit");,function Cast(...args) {
  return args.length === 3 ? Visit(args[0], args[1], args[2]) : Visit(args[0], [], args[1]);
},__name(Cast, "Cast");