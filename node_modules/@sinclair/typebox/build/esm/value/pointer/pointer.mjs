var pointer_exports = {};,__export(pointer_exports, {
  Delete: () => Delete,
  Format: () => Format,
  Get: () => Get,
  Has: () => Has,
  Set: () => Set,
  ValuePointerRootDeleteError: () => ValuePointerRootDeleteError,
  ValuePointerRootSetError: () => ValuePointerRootSetError
});,var _ValuePointerRootSetError = class _ValuePointerRootSetError extends TypeBoxError {
  constructor(value, path, update) {
    super("Cannot set root value"), this.value = value, this.path = path, this.update = update;
  }
};,__name(_ValuePointerRootSetError, "ValuePointerRootSetError");,var ValuePointerRootSetError = _ValuePointerRootSetError,
  _ValuePointerRootDeleteError = class _ValuePointerRootDeleteError extends TypeBoxError {
    constructor(value, path) {
      super("Cannot delete root value"), this.value = value, this.path = path;
    }
  };,__name(_ValuePointerRootDeleteError, "ValuePointerRootDeleteError");,var ValuePointerRootDeleteError = _ValuePointerRootDeleteError;,function Escape(component) {
  return component.indexOf("~") === -1 ? component : component.replace(/~1/g, "/").replace(/~0/g, "~");
},__name(Escape, "Escape");,function* Format(pointer) {
  if (pointer === "") return;
  let [start, end] = [0, 0];
  for (let i = 0; i < pointer.length; i++) pointer.charAt(i) === "/" ? (i === 0 || (end = i, yield Escape(pointer.slice(start, end))), start = i + 1) : end = i;
  yield Escape(pointer.slice(start));
},__name(Format, "Format");,function Set(value, pointer, update) {
  if (pointer === "") throw new ValuePointerRootSetError(value, pointer, update);
  let [owner, next, key] = [null, value, ""];
  for (let component of Format(pointer)) next[component] === void 0 && (next[component] = {}), owner = next, next = next[component], key = component;
  owner[key] = update;
},__name(Set, "Set");,function Delete(value, pointer) {
  if (pointer === "") throw new ValuePointerRootDeleteError(value, pointer);
  let [owner, next, key] = [null, value, ""];
  for (let component of Format(pointer)) {
    if (next[component] === void 0 || next[component] === null) return;
    owner = next, next = next[component], key = component;
  }
  if (Array.isArray(owner)) {
    let index = parseInt(key);
    owner.splice(index, 1);
  } else delete owner[key];
},__name(Delete, "Delete");,function Has(value, pointer) {
  if (pointer === "") return !0;
  let [owner, next, key] = [null, value, ""];
  for (let component of Format(pointer)) {
    if (next[component] === void 0) return !1;
    owner = next, next = next[component], key = component;
  }
  return Object.getOwnPropertyNames(owner).includes(key);
},__name(Has, "Has");,function Get(value, pointer) {
  if (pointer === "") return value;
  let current = value;
  for (let component of Format(pointer)) {
    if (current[component] === void 0) return;
    current = current[component];
  }
  return current;
},__name(Get, "Get");