var _ValueCheckUnknownTypeError = class _ValueCheckUnknownTypeError extends TypeBoxError {
  constructor(schema) {
    super("Unknown type"), this.schema = schema;
  }
};,__name(_ValueCheckUnknownTypeError, "ValueCheckUnknownTypeError");,var ValueCheckUnknownTypeError = _ValueCheckUnknownTypeError;,function IsAnyOrUnknown(schema) {
  return schema[Kind] === "Any" || schema[Kind] === "Unknown";
},__name(IsAnyOrUnknown, "IsAnyOrUnknown");,function IsDefined(value) {
  return value !== void 0;
},__name(IsDefined, "IsDefined");,function FromAny(schema, references, value) {
  return !0;
},__name(FromAny, "FromAny");,function FromArgument(schema, references, value) {
  return !0;
},__name(FromArgument, "FromArgument");,function FromArray(schema, references, value) {
  if (!IsArray(value) || IsDefined(schema.minItems) && !(value.length >= schema.minItems) || IsDefined(schema.maxItems) && !(value.length <= schema.maxItems) || !value.every(value => Visit(schema.items, references, value)) || schema.uniqueItems === !0 && !function () {
    let set = new Set();
    for (let element of value) {
      let hashed = Hash(element);
      if (set.has(hashed)) return !1;
      set.add(hashed);
    }
    return !0;
  }()) return !1;
  if (!(IsDefined(schema.contains) || IsNumber(schema.minContains) || IsNumber(schema.maxContains))) return !0;
  let containsSchema = IsDefined(schema.contains) ? schema.contains : Never(),
    containsCount = value.reduce((acc, value) => Visit(containsSchema, references, value) ? acc + 1 : acc, 0);
  return !(containsCount === 0 || IsNumber(schema.minContains) && containsCount < schema.minContains || IsNumber(schema.maxContains) && containsCount > schema.maxContains);
},__name(FromArray, "FromArray");,function FromAsyncIterator(schema, references, value) {
  return IsAsyncIterator(value);
},__name(FromAsyncIterator, "FromAsyncIterator");,function FromBigInt(schema, references, value) {
  return !(!IsBigInt(value) || IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum) || IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum) || IsDefined(schema.maximum) && !(value <= schema.maximum) || IsDefined(schema.minimum) && !(value >= schema.minimum) || IsDefined(schema.multipleOf) && value % schema.multipleOf !== BigInt(0));
},__name(FromBigInt, "FromBigInt");,function FromBoolean(schema, references, value) {
  return IsBoolean(value);
},__name(FromBoolean, "FromBoolean");,function FromConstructor(schema, references, value) {
  return Visit(schema.returns, references, value.prototype);
},__name(FromConstructor, "FromConstructor");,function FromDate(schema, references, value) {
  return !(!IsDate(value) || IsDefined(schema.exclusiveMaximumTimestamp) && !(value.getTime() < schema.exclusiveMaximumTimestamp) || IsDefined(schema.exclusiveMinimumTimestamp) && !(value.getTime() > schema.exclusiveMinimumTimestamp) || IsDefined(schema.maximumTimestamp) && !(value.getTime() <= schema.maximumTimestamp) || IsDefined(schema.minimumTimestamp) && !(value.getTime() >= schema.minimumTimestamp) || IsDefined(schema.multipleOfTimestamp) && value.getTime() % schema.multipleOfTimestamp !== 0);
},__name(FromDate, "FromDate");,function FromFunction(schema, references, value) {
  return IsFunction(value);
},__name(FromFunction, "FromFunction");,function FromImport(schema, references, value) {
  let definitions = globalThis.Object.values(schema.$defs),
    target = schema.$defs[schema.$ref];
  return Visit(target, [...references, ...definitions], value);
},__name(FromImport, "FromImport");,function FromInteger(schema, references, value) {
  return !(!IsInteger(value) || IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum) || IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum) || IsDefined(schema.maximum) && !(value <= schema.maximum) || IsDefined(schema.minimum) && !(value >= schema.minimum) || IsDefined(schema.multipleOf) && value % schema.multipleOf !== 0);
},__name(FromInteger, "FromInteger");,function FromIntersect(schema, references, value) {
  let check1 = schema.allOf.every(schema => Visit(schema, references, value));
  if (schema.unevaluatedProperties === !1) {
    let keyPattern = new RegExp(KeyOfPattern(schema)),
      check2 = Object.getOwnPropertyNames(value).every(key => keyPattern.test(key));
    return check1 && check2;
  } else if (IsSchema(schema.unevaluatedProperties)) {
    let keyCheck = new RegExp(KeyOfPattern(schema)),
      check2 = Object.getOwnPropertyNames(value).every(key => keyCheck.test(key) || Visit(schema.unevaluatedProperties, references, value[key]));
    return check1 && check2;
  } else return check1;
},__name(FromIntersect, "FromIntersect");,function FromIterator(schema, references, value) {
  return IsIterator(value);
},__name(FromIterator, "FromIterator");,function FromLiteral(schema, references, value) {
  return value === schema.const;
},__name(FromLiteral, "FromLiteral");,function FromNever(schema, references, value) {
  return !1;
},__name(FromNever, "FromNever");,function FromNot(schema, references, value) {
  return !Visit(schema.not, references, value);
},__name(FromNot, "FromNot");,function FromNull(schema, references, value) {
  return IsNull(value);
},__name(FromNull, "FromNull");,function FromNumber(schema, references, value) {
  return !(!TypeSystemPolicy.IsNumberLike(value) || IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum) || IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum) || IsDefined(schema.minimum) && !(value >= schema.minimum) || IsDefined(schema.maximum) && !(value <= schema.maximum) || IsDefined(schema.multipleOf) && value % schema.multipleOf !== 0);
},__name(FromNumber, "FromNumber");,function FromObject(schema, references, value) {
  if (!TypeSystemPolicy.IsObjectLike(value) || IsDefined(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties) || IsDefined(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) return !1;
  let knownKeys = Object.getOwnPropertyNames(schema.properties);
  for (let knownKey of knownKeys) {
    let property = schema.properties[knownKey];
    if (schema.required && schema.required.includes(knownKey)) {
      if (!Visit(property, references, value[knownKey]) || (ExtendsUndefinedCheck(property) || IsAnyOrUnknown(property)) && !(knownKey in value)) return !1;
    } else if (TypeSystemPolicy.IsExactOptionalProperty(value, knownKey) && !Visit(property, references, value[knownKey])) return !1;
  }
  if (schema.additionalProperties === !1) {
    let valueKeys = Object.getOwnPropertyNames(value);
    return schema.required && schema.required.length === knownKeys.length && valueKeys.length === knownKeys.length ? !0 : valueKeys.every(valueKey => knownKeys.includes(valueKey));
  } else return typeof schema.additionalProperties == "object" ? Object.getOwnPropertyNames(value).every(key => knownKeys.includes(key) || Visit(schema.additionalProperties, references, value[key])) : !0;
},__name(FromObject, "FromObject");,function FromPromise(schema, references, value) {
  return IsPromise(value);
},__name(FromPromise, "FromPromise");,function FromRecord(schema, references, value) {
  if (!TypeSystemPolicy.IsRecordLike(value) || IsDefined(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties) || IsDefined(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) return !1;
  let [patternKey, patternSchema] = Object.entries(schema.patternProperties)[0],
    regex = new RegExp(patternKey),
    check1 = Object.entries(value).every(([key, value]) => regex.test(key) ? Visit(patternSchema, references, value) : !0),
    check2 = typeof schema.additionalProperties == "object" ? Object.entries(value).every(([key, value]) => regex.test(key) ? !0 : Visit(schema.additionalProperties, references, value)) : !0,
    check3 = schema.additionalProperties === !1 ? Object.getOwnPropertyNames(value).every(key => regex.test(key)) : !0;
  return check1 && check2 && check3;
},__name(FromRecord, "FromRecord");,function FromRef(schema, references, value) {
  return Visit(Deref(schema, references), references, value);
},__name(FromRef, "FromRef");,function FromRegExp(schema, references, value) {
  let regex = new RegExp(schema.source, schema.flags);
  return IsDefined(schema.minLength) && !(value.length >= schema.minLength) || IsDefined(schema.maxLength) && !(value.length <= schema.maxLength) ? !1 : regex.test(value);
},__name(FromRegExp, "FromRegExp");,function FromString(schema, references, value) {
  return !IsString(value) || IsDefined(schema.minLength) && !(value.length >= schema.minLength) || IsDefined(schema.maxLength) && !(value.length <= schema.maxLength) || IsDefined(schema.pattern) && !new RegExp(schema.pattern).test(value) ? !1 : IsDefined(schema.format) ? format_exports.Has(schema.format) ? format_exports.Get(schema.format)(value) : !1 : !0;
},__name(FromString, "FromString");,function FromSymbol(schema, references, value) {
  return IsSymbol(value);
},__name(FromSymbol, "FromSymbol");,function FromTemplateLiteral(schema, references, value) {
  return IsString(value) && new RegExp(schema.pattern).test(value);
},__name(FromTemplateLiteral, "FromTemplateLiteral");,function FromThis(schema, references, value) {
  return Visit(Deref(schema, references), references, value);
},__name(FromThis, "FromThis");,function FromTuple(schema, references, value) {
  if (!IsArray(value) || schema.items === void 0 && value.length !== 0 || value.length !== schema.maxItems) return !1;
  if (!schema.items) return !0;
  for (let i = 0; i < schema.items.length; i++) if (!Visit(schema.items[i], references, value[i])) return !1;
  return !0;
},__name(FromTuple, "FromTuple");,function FromUndefined(schema, references, value) {
  return IsUndefined(value);
},__name(FromUndefined, "FromUndefined");,function FromUnion(schema, references, value) {
  return schema.anyOf.some(inner => Visit(inner, references, value));
},__name(FromUnion, "FromUnion");,function FromUint8Array(schema, references, value) {
  return !(!IsUint8Array(value) || IsDefined(schema.maxByteLength) && !(value.length <= schema.maxByteLength) || IsDefined(schema.minByteLength) && !(value.length >= schema.minByteLength));
},__name(FromUint8Array, "FromUint8Array");,function FromUnknown(schema, references, value) {
  return !0;
},__name(FromUnknown, "FromUnknown");,function FromVoid(schema, references, value) {
  return TypeSystemPolicy.IsVoidLike(value);
},__name(FromVoid, "FromVoid");,function FromKind(schema, references, value) {
  return type_exports.Has(schema[Kind]) ? type_exports.Get(schema[Kind])(schema, value) : !1;
},__name(FromKind, "FromKind");,function Visit(schema, references, value) {
  let references_ = IsDefined(schema.$id) ? Pushref(schema, references) : references,
    schema_ = schema;
  switch (schema_[Kind]) {
    case "Any":
      return FromAny(schema_, references_, value);
    case "Argument":
      return FromArgument(schema_, references_, value);
    case "Array":
      return FromArray(schema_, references_, value);
    case "AsyncIterator":
      return FromAsyncIterator(schema_, references_, value);
    case "BigInt":
      return FromBigInt(schema_, references_, value);
    case "Boolean":
      return FromBoolean(schema_, references_, value);
    case "Constructor":
      return FromConstructor(schema_, references_, value);
    case "Date":
      return FromDate(schema_, references_, value);
    case "Function":
      return FromFunction(schema_, references_, value);
    case "Import":
      return FromImport(schema_, references_, value);
    case "Integer":
      return FromInteger(schema_, references_, value);
    case "Intersect":
      return FromIntersect(schema_, references_, value);
    case "Iterator":
      return FromIterator(schema_, references_, value);
    case "Literal":
      return FromLiteral(schema_, references_, value);
    case "Never":
      return FromNever(schema_, references_, value);
    case "Not":
      return FromNot(schema_, references_, value);
    case "Null":
      return FromNull(schema_, references_, value);
    case "Number":
      return FromNumber(schema_, references_, value);
    case "Object":
      return FromObject(schema_, references_, value);
    case "Promise":
      return FromPromise(schema_, references_, value);
    case "Record":
      return FromRecord(schema_, references_, value);
    case "Ref":
      return FromRef(schema_, references_, value);
    case "RegExp":
      return FromRegExp(schema_, references_, value);
    case "String":
      return FromString(schema_, references_, value);
    case "Symbol":
      return FromSymbol(schema_, references_, value);
    case "TemplateLiteral":
      return FromTemplateLiteral(schema_, references_, value);
    case "This":
      return FromThis(schema_, references_, value);
    case "Tuple":
      return FromTuple(schema_, references_, value);
    case "Undefined":
      return FromUndefined(schema_, references_, value);
    case "Union":
      return FromUnion(schema_, references_, value);
    case "Uint8Array":
      return FromUint8Array(schema_, references_, value);
    case "Unknown":
      return FromUnknown(schema_, references_, value);
    case "Void":
      return FromVoid(schema_, references_, value);
    default:
      if (!type_exports.Has(schema_[Kind])) throw new ValueCheckUnknownTypeError(schema_);
      return FromKind(schema_, references_, value);
  }
},__name(Visit, "Visit");,function Check(...args) {
  return args.length === 3 ? Visit(args[0], args[1], args[2]) : Visit(args[0], [], args[1]);
},__name(Check, "Check");