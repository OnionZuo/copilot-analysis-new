function IsCheckable(schema) {
  return IsKind(schema) && schema[Kind] !== "Unsafe";
},__name(IsCheckable, "IsCheckable");,function FromArray(schema, references, value) {
  return IsArray(value) ? value.map(value => Visit(schema.items, references, value)) : value;
},__name(FromArray, "FromArray");,function FromImport(schema, references, value) {
  let definitions = globalThis.Object.values(schema.$defs),
    target = schema.$defs[schema.$ref];
  return Visit(target, [...references, ...definitions], value);
},__name(FromImport, "FromImport");,function FromIntersect(schema, references, value) {
  let unevaluatedProperties = schema.unevaluatedProperties,
    composite = schema.allOf.map(schema => Visit(schema, references, Clone(value))).reduce((acc, value) => IsObject(value) ? {
      ...acc,
      ...value
    } : value, {});
  if (!IsObject(value) || !IsObject(composite) || !IsKind(unevaluatedProperties)) return composite;
  let knownkeys = KeyOfPropertyKeys(schema);
  for (let key of Object.getOwnPropertyNames(value)) knownkeys.includes(key) || Check(unevaluatedProperties, references, value[key]) && (composite[key] = Visit(unevaluatedProperties, references, value[key]));
  return composite;
},__name(FromIntersect, "FromIntersect");,function FromObject(schema, references, value) {
  if (!IsObject(value) || IsArray(value)) return value;
  let additionalProperties = schema.additionalProperties;
  for (let key of Object.getOwnPropertyNames(value)) {
    if (HasPropertyKey(schema.properties, key)) {
      value[key] = Visit(schema.properties[key], references, value[key]);
      continue;
    }
    if (IsKind(additionalProperties) && Check(additionalProperties, references, value[key])) {
      value[key] = Visit(additionalProperties, references, value[key]);
      continue;
    }
    delete value[key];
  }
  return value;
},__name(FromObject, "FromObject");,function FromRecord(schema, references, value) {
  if (!IsObject(value)) return value;
  let additionalProperties = schema.additionalProperties,
    propertyKeys = Object.getOwnPropertyNames(value),
    [propertyKey, propertySchema] = Object.entries(schema.patternProperties)[0],
    propertyKeyTest = new RegExp(propertyKey);
  for (let key of propertyKeys) {
    if (propertyKeyTest.test(key)) {
      value[key] = Visit(propertySchema, references, value[key]);
      continue;
    }
    if (IsKind(additionalProperties) && Check(additionalProperties, references, value[key])) {
      value[key] = Visit(additionalProperties, references, value[key]);
      continue;
    }
    delete value[key];
  }
  return value;
},__name(FromRecord, "FromRecord");,function FromRef(schema, references, value) {
  return Visit(Deref(schema, references), references, value);
},__name(FromRef, "FromRef");,function FromThis(schema, references, value) {
  return Visit(Deref(schema, references), references, value);
},__name(FromThis, "FromThis");,function FromTuple(schema, references, value) {
  if (!IsArray(value)) return value;
  if (IsUndefined(schema.items)) return [];
  let length = Math.min(value.length, schema.items.length);
  for (let i = 0; i < length; i++) value[i] = Visit(schema.items[i], references, value[i]);
  return value.length > length ? value.slice(0, length) : value;
},__name(FromTuple, "FromTuple");,function FromUnion(schema, references, value) {
  for (let inner of schema.anyOf) if (IsCheckable(inner) && Check(inner, references, value)) return Visit(inner, references, value);
  return value;
},__name(FromUnion, "FromUnion");,function Visit(schema, references, value) {
  let references_ = IsString(schema.$id) ? Pushref(schema, references) : references,
    schema_ = schema;
  switch (schema_[Kind]) {
    case "Array":
      return FromArray(schema_, references_, value);
    case "Import":
      return FromImport(schema_, references_, value);
    case "Intersect":
      return FromIntersect(schema_, references_, value);
    case "Object":
      return FromObject(schema_, references_, value);
    case "Record":
      return FromRecord(schema_, references_, value);
    case "Ref":
      return FromRef(schema_, references_, value);
    case "This":
      return FromThis(schema_, references_, value);
    case "Tuple":
      return FromTuple(schema_, references_, value);
    case "Union":
      return FromUnion(schema_, references_, value);
    default:
      return value;
  }
},__name(Visit, "Visit");,function Clean(...args) {
  return args.length === 3 ? Visit(args[0], args[1], args[2]) : Visit(args[0], [], args[1]);
},__name(Clean, "Clean");