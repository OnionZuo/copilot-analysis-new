var _ValueCreateError = class _ValueCreateError extends TypeBoxError {
  constructor(schema, message) {
    super(message), this.schema = schema;
  }
};,__name(_ValueCreateError, "ValueCreateError");,var ValueCreateError = _ValueCreateError;,function FromDefault(value) {
  return IsFunction(value) ? value() : Clone(value);
},__name(FromDefault, "FromDefault");,function FromAny(schema, references) {
  return HasPropertyKey(schema, "default") ? FromDefault(schema.default) : {};
},__name(FromAny, "FromAny");,function FromArgument(schema, references) {
  return {};
},__name(FromArgument, "FromArgument");,function FromArray(schema, references) {
  if (schema.uniqueItems === !0 && !HasPropertyKey(schema, "default")) throw new ValueCreateError(schema, "Array with the uniqueItems constraint requires a default value");
  if ("contains" in schema && !HasPropertyKey(schema, "default")) throw new ValueCreateError(schema, "Array with the contains constraint requires a default value");
  return "default" in schema ? FromDefault(schema.default) : schema.minItems !== void 0 ? Array.from({
    length: schema.minItems
  }).map(item => Visit(schema.items, references)) : [];
},__name(FromArray, "FromArray");,function FromAsyncIterator(schema, references) {
  return HasPropertyKey(schema, "default") ? FromDefault(schema.default) : async function* () {}();
},__name(FromAsyncIterator, "FromAsyncIterator");,function FromBigInt(schema, references) {
  return HasPropertyKey(schema, "default") ? FromDefault(schema.default) : BigInt(0);
},__name(FromBigInt, "FromBigInt");,function FromBoolean(schema, references) {
  return HasPropertyKey(schema, "default") ? FromDefault(schema.default) : !1;
},__name(FromBoolean, "FromBoolean");,function FromConstructor(schema, references) {
  if (HasPropertyKey(schema, "default")) return FromDefault(schema.default);
  {
    let value = Visit(schema.returns, references);
    return typeof value == "object" && !Array.isArray(value) ? class {
      constructor() {
        for (let [key, val] of Object.entries(value)) {
          let self = this;
          self[key] = val;
        }
      }
    } : class {};
  }
},__name(FromConstructor, "FromConstructor");,function FromDate(schema, references) {
  return HasPropertyKey(schema, "default") ? FromDefault(schema.default) : schema.minimumTimestamp !== void 0 ? new Date(schema.minimumTimestamp) : new Date();
},__name(FromDate, "FromDate");,function FromFunction(schema, references) {
  return HasPropertyKey(schema, "default") ? FromDefault(schema.default) : () => Visit(schema.returns, references);
},__name(FromFunction, "FromFunction");,function FromImport(schema, references) {
  let definitions = globalThis.Object.values(schema.$defs),
    target = schema.$defs[schema.$ref];
  return Visit(target, [...references, ...definitions]);
},__name(FromImport, "FromImport");,function FromInteger(schema, references) {
  return HasPropertyKey(schema, "default") ? FromDefault(schema.default) : schema.minimum !== void 0 ? schema.minimum : 0;
},__name(FromInteger, "FromInteger");,function FromIntersect(schema, references) {
  if (HasPropertyKey(schema, "default")) return FromDefault(schema.default);
  {
    let value = schema.allOf.reduce((acc, schema) => {
      let next = Visit(schema, references);
      return typeof next == "object" ? {
        ...acc,
        ...next
      } : next;
    }, {});
    if (!Check(schema, references, value)) throw new ValueCreateError(schema, "Intersect produced invalid value. Consider using a default value.");
    return value;
  }
},__name(FromIntersect, "FromIntersect");,function FromIterator(schema, references) {
  return HasPropertyKey(schema, "default") ? FromDefault(schema.default) : function* () {}();
},__name(FromIterator, "FromIterator");,function FromLiteral(schema, references) {
  return HasPropertyKey(schema, "default") ? FromDefault(schema.default) : schema.const;
},__name(FromLiteral, "FromLiteral");,function FromNever(schema, references) {
  if (HasPropertyKey(schema, "default")) return FromDefault(schema.default);
  throw new ValueCreateError(schema, "Never types cannot be created. Consider using a default value.");
},__name(FromNever, "FromNever");,function FromNot(schema, references) {
  if (HasPropertyKey(schema, "default")) return FromDefault(schema.default);
  throw new ValueCreateError(schema, "Not types must have a default value");
},__name(FromNot, "FromNot");,function FromNull(schema, references) {
  return HasPropertyKey(schema, "default") ? FromDefault(schema.default) : null;
},__name(FromNull, "FromNull");,function FromNumber(schema, references) {
  return HasPropertyKey(schema, "default") ? FromDefault(schema.default) : schema.minimum !== void 0 ? schema.minimum : 0;
},__name(FromNumber, "FromNumber");,function FromObject(schema, references) {
  if (HasPropertyKey(schema, "default")) return FromDefault(schema.default);
  {
    let required = new Set(schema.required),
      Acc = {};
    for (let [key, subschema] of Object.entries(schema.properties)) required.has(key) && (Acc[key] = Visit(subschema, references));
    return Acc;
  }
},__name(FromObject, "FromObject");,function FromPromise(schema, references) {
  return HasPropertyKey(schema, "default") ? FromDefault(schema.default) : Promise.resolve(Visit(schema.item, references));
},__name(FromPromise, "FromPromise");,function FromRecord(schema, references) {
  let [keyPattern, valueSchema] = Object.entries(schema.patternProperties)[0];
  if (HasPropertyKey(schema, "default")) return FromDefault(schema.default);
  if (keyPattern === PatternStringExact || keyPattern === PatternNumberExact) return {};
  {
    let propertyKeys = keyPattern.slice(1, keyPattern.length - 1).split("|"),
      Acc = {};
    for (let key of propertyKeys) Acc[key] = Visit(valueSchema, references);
    return Acc;
  }
},__name(FromRecord, "FromRecord");,function FromRef(schema, references) {
  return HasPropertyKey(schema, "default") ? FromDefault(schema.default) : Visit(Deref(schema, references), references);
},__name(FromRef, "FromRef");,function FromRegExp(schema, references) {
  if (HasPropertyKey(schema, "default")) return FromDefault(schema.default);
  throw new ValueCreateError(schema, "RegExp types cannot be created. Consider using a default value.");
},__name(FromRegExp, "FromRegExp");,function FromString(schema, references) {
  if (schema.pattern !== void 0) {
    if (HasPropertyKey(schema, "default")) return FromDefault(schema.default);
    throw new ValueCreateError(schema, "String types with patterns must specify a default value");
  } else if (schema.format !== void 0) {
    if (HasPropertyKey(schema, "default")) return FromDefault(schema.default);
    throw new ValueCreateError(schema, "String types with formats must specify a default value");
  } else return HasPropertyKey(schema, "default") ? FromDefault(schema.default) : schema.minLength !== void 0 ? Array.from({
    length: schema.minLength
  }).map(() => " ").join("") : "";
},__name(FromString, "FromString");,function FromSymbol(schema, references) {
  return HasPropertyKey(schema, "default") ? FromDefault(schema.default) : "value" in schema ? Symbol.for(schema.value) : Symbol();
},__name(FromSymbol, "FromSymbol");,function FromTemplateLiteral(schema, references) {
  if (HasPropertyKey(schema, "default")) return FromDefault(schema.default);
  if (!IsTemplateLiteralFinite(schema)) throw new ValueCreateError(schema, "Can only create template literals that produce a finite variants. Consider using a default value.");
  return TemplateLiteralGenerate(schema)[0];
},__name(FromTemplateLiteral, "FromTemplateLiteral");,function FromThis(schema, references) {
  if (recursiveDepth++ > recursiveMaxDepth) throw new ValueCreateError(schema, "Cannot create recursive type as it appears possibly infinite. Consider using a default.");
  return HasPropertyKey(schema, "default") ? FromDefault(schema.default) : Visit(Deref(schema, references), references);
},__name(FromThis, "FromThis");,function FromTuple(schema, references) {
  return HasPropertyKey(schema, "default") ? FromDefault(schema.default) : schema.items === void 0 ? [] : Array.from({
    length: schema.minItems
  }).map((_, index) => Visit(schema.items[index], references));
},__name(FromTuple, "FromTuple");,function FromUndefined(schema, references) {
  if (HasPropertyKey(schema, "default")) return FromDefault(schema.default);
},__name(FromUndefined, "FromUndefined");,function FromUnion(schema, references) {
  if (HasPropertyKey(schema, "default")) return FromDefault(schema.default);
  if (schema.anyOf.length === 0) throw new Error("ValueCreate.Union: Cannot create Union with zero variants");
  return Visit(schema.anyOf[0], references);
},__name(FromUnion, "FromUnion");,function FromUint8Array(schema, references) {
  return HasPropertyKey(schema, "default") ? FromDefault(schema.default) : schema.minByteLength !== void 0 ? new Uint8Array(schema.minByteLength) : new Uint8Array(0);
},__name(FromUint8Array, "FromUint8Array");,function FromUnknown(schema, references) {
  return HasPropertyKey(schema, "default") ? FromDefault(schema.default) : {};
},__name(FromUnknown, "FromUnknown");,function FromVoid(schema, references) {
  if (HasPropertyKey(schema, "default")) return FromDefault(schema.default);
},__name(FromVoid, "FromVoid");,function FromKind(schema, references) {
  if (HasPropertyKey(schema, "default")) return FromDefault(schema.default);
  throw new Error("User defined types must specify a default value");
},__name(FromKind, "FromKind");,function Visit(schema, references) {
  let references_ = Pushref(schema, references),
    schema_ = schema;
  switch (schema_[Kind]) {
    case "Any":
      return FromAny(schema_, references_);
    case "Argument":
      return FromArgument(schema_, references_);
    case "Array":
      return FromArray(schema_, references_);
    case "AsyncIterator":
      return FromAsyncIterator(schema_, references_);
    case "BigInt":
      return FromBigInt(schema_, references_);
    case "Boolean":
      return FromBoolean(schema_, references_);
    case "Constructor":
      return FromConstructor(schema_, references_);
    case "Date":
      return FromDate(schema_, references_);
    case "Function":
      return FromFunction(schema_, references_);
    case "Import":
      return FromImport(schema_, references_);
    case "Integer":
      return FromInteger(schema_, references_);
    case "Intersect":
      return FromIntersect(schema_, references_);
    case "Iterator":
      return FromIterator(schema_, references_);
    case "Literal":
      return FromLiteral(schema_, references_);
    case "Never":
      return FromNever(schema_, references_);
    case "Not":
      return FromNot(schema_, references_);
    case "Null":
      return FromNull(schema_, references_);
    case "Number":
      return FromNumber(schema_, references_);
    case "Object":
      return FromObject(schema_, references_);
    case "Promise":
      return FromPromise(schema_, references_);
    case "Record":
      return FromRecord(schema_, references_);
    case "Ref":
      return FromRef(schema_, references_);
    case "RegExp":
      return FromRegExp(schema_, references_);
    case "String":
      return FromString(schema_, references_);
    case "Symbol":
      return FromSymbol(schema_, references_);
    case "TemplateLiteral":
      return FromTemplateLiteral(schema_, references_);
    case "This":
      return FromThis(schema_, references_);
    case "Tuple":
      return FromTuple(schema_, references_);
    case "Undefined":
      return FromUndefined(schema_, references_);
    case "Union":
      return FromUnion(schema_, references_);
    case "Uint8Array":
      return FromUint8Array(schema_, references_);
    case "Unknown":
      return FromUnknown(schema_, references_);
    case "Void":
      return FromVoid(schema_, references_);
    default:
      if (!type_exports.Has(schema_[Kind])) throw new ValueCreateError(schema_, "Unknown type");
      return FromKind(schema_, references_);
  }
},__name(Visit, "Visit");,var recursiveMaxDepth = 512,
  recursiveDepth = 0;,function Create(...args) {
  return recursiveDepth = 0, args.length === 2 ? Visit(args[0], args[1]) : Visit(args[0], []);
},__name(Create, "Create");