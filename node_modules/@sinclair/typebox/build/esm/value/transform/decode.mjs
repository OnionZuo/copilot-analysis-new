var _TransformDecodeCheckError = class _TransformDecodeCheckError extends TypeBoxError {
  constructor(schema, value, error) {
    super("Unable to decode value as it does not match the expected schema"), this.schema = schema, this.value = value, this.error = error;
  }
};,__name(_TransformDecodeCheckError, "TransformDecodeCheckError");,var TransformDecodeCheckError = _TransformDecodeCheckError,
  _TransformDecodeError = class _TransformDecodeError extends TypeBoxError {
    constructor(schema, path, value, error) {
      super(error instanceof Error ? error.message : "Unknown error"), this.schema = schema, this.path = path, this.value = value, this.error = error;
    }
  };,__name(_TransformDecodeError, "TransformDecodeError");,var TransformDecodeError = _TransformDecodeError;,function Default(schema, path, value) {
  try {
    return IsTransform(schema) ? schema[TransformKind].Decode(value) : value;
  } catch (error) {
    throw new TransformDecodeError(schema, path, value, error);
  }
},__name(Default, "Default");,function FromArray(schema, references, path, value) {
  return IsArray(value) ? Default(schema, path, value.map((value, index) => Visit(schema.items, references, `${path}/${index}`, value))) : Default(schema, path, value);
},__name(FromArray, "FromArray");,function FromIntersect(schema, references, path, value) {
  if (!IsObject(value) || IsValueType(value)) return Default(schema, path, value);
  let knownEntries = KeyOfPropertyEntries(schema),
    knownKeys = knownEntries.map(entry => entry[0]),
    knownProperties = {
      ...value
    };
  for (let [knownKey, knownSchema] of knownEntries) knownKey in knownProperties && (knownProperties[knownKey] = Visit(knownSchema, references, `${path}/${knownKey}`, knownProperties[knownKey]));
  if (!IsTransform(schema.unevaluatedProperties)) return Default(schema, path, knownProperties);
  let unknownKeys = Object.getOwnPropertyNames(knownProperties),
    unevaluatedProperties = schema.unevaluatedProperties,
    unknownProperties = {
      ...knownProperties
    };
  for (let key of unknownKeys) knownKeys.includes(key) || (unknownProperties[key] = Default(unevaluatedProperties, `${path}/${key}`, unknownProperties[key]));
  return Default(schema, path, unknownProperties);
},__name(FromIntersect, "FromIntersect");,function FromImport(schema, references, path, value) {
  let additional = globalThis.Object.values(schema.$defs),
    target = schema.$defs[schema.$ref],
    result = Visit(target, [...references, ...additional], path, value);
  return Default(schema, path, result);
},__name(FromImport, "FromImport");,function FromNot(schema, references, path, value) {
  return Default(schema, path, Visit(schema.not, references, path, value));
},__name(FromNot, "FromNot");,function FromObject(schema, references, path, value) {
  if (!IsObject(value)) return Default(schema, path, value);
  let knownKeys = KeyOfPropertyKeys(schema),
    knownProperties = {
      ...value
    };
  for (let key of knownKeys) HasPropertyKey(knownProperties, key) && (IsUndefined(knownProperties[key]) && (!IsUndefined(schema.properties[key]) || TypeSystemPolicy.IsExactOptionalProperty(knownProperties, key)) || (knownProperties[key] = Visit(schema.properties[key], references, `${path}/${key}`, knownProperties[key])));
  if (!IsSchema(schema.additionalProperties)) return Default(schema, path, knownProperties);
  let unknownKeys = Object.getOwnPropertyNames(knownProperties),
    additionalProperties = schema.additionalProperties,
    unknownProperties = {
      ...knownProperties
    };
  for (let key of unknownKeys) knownKeys.includes(key) || (unknownProperties[key] = Default(additionalProperties, `${path}/${key}`, unknownProperties[key]));
  return Default(schema, path, unknownProperties);
},__name(FromObject, "FromObject");,function FromRecord(schema, references, path, value) {
  if (!IsObject(value)) return Default(schema, path, value);
  let pattern = Object.getOwnPropertyNames(schema.patternProperties)[0],
    knownKeys = new RegExp(pattern),
    knownProperties = {
      ...value
    };
  for (let key of Object.getOwnPropertyNames(value)) knownKeys.test(key) && (knownProperties[key] = Visit(schema.patternProperties[pattern], references, `${path}/${key}`, knownProperties[key]));
  if (!IsSchema(schema.additionalProperties)) return Default(schema, path, knownProperties);
  let unknownKeys = Object.getOwnPropertyNames(knownProperties),
    additionalProperties = schema.additionalProperties,
    unknownProperties = {
      ...knownProperties
    };
  for (let key of unknownKeys) knownKeys.test(key) || (unknownProperties[key] = Default(additionalProperties, `${path}/${key}`, unknownProperties[key]));
  return Default(schema, path, unknownProperties);
},__name(FromRecord, "FromRecord");,function FromRef(schema, references, path, value) {
  let target = Deref(schema, references);
  return Default(schema, path, Visit(target, references, path, value));
},__name(FromRef, "FromRef");,function FromThis(schema, references, path, value) {
  let target = Deref(schema, references);
  return Default(schema, path, Visit(target, references, path, value));
},__name(FromThis, "FromThis");,function FromTuple(schema, references, path, value) {
  return IsArray(value) && IsArray(schema.items) ? Default(schema, path, schema.items.map((schema, index) => Visit(schema, references, `${path}/${index}`, value[index]))) : Default(schema, path, value);
},__name(FromTuple, "FromTuple");,function FromUnion(schema, references, path, value) {
  for (let subschema of schema.anyOf) {
    if (!Check(subschema, references, value)) continue;
    let decoded = Visit(subschema, references, path, value);
    return Default(schema, path, decoded);
  }
  return Default(schema, path, value);
},__name(FromUnion, "FromUnion");,function Visit(schema, references, path, value) {
  let references_ = Pushref(schema, references),
    schema_ = schema;
  switch (schema[Kind]) {
    case "Array":
      return FromArray(schema_, references_, path, value);
    case "Import":
      return FromImport(schema_, references_, path, value);
    case "Intersect":
      return FromIntersect(schema_, references_, path, value);
    case "Not":
      return FromNot(schema_, references_, path, value);
    case "Object":
      return FromObject(schema_, references_, path, value);
    case "Record":
      return FromRecord(schema_, references_, path, value);
    case "Ref":
      return FromRef(schema_, references_, path, value);
    case "Symbol":
      return Default(schema_, path, value);
    case "This":
      return FromThis(schema_, references_, path, value);
    case "Tuple":
      return FromTuple(schema_, references_, path, value);
    case "Union":
      return FromUnion(schema_, references_, path, value);
    default:
      return Default(schema_, path, value);
  }
},__name(Visit, "Visit");,function TransformDecode(schema, references, value) {
  return Visit(schema, references, "", value);
},__name(TransformDecode, "TransformDecode");