function FromArray(schema, references) {
  return IsTransform(schema) || Visit(schema.items, references);
},__name(FromArray, "FromArray");,function FromAsyncIterator(schema, references) {
  return IsTransform(schema) || Visit(schema.items, references);
},__name(FromAsyncIterator, "FromAsyncIterator");,function FromConstructor(schema, references) {
  return IsTransform(schema) || Visit(schema.returns, references) || schema.parameters.some(schema => Visit(schema, references));
},__name(FromConstructor, "FromConstructor");,function FromFunction(schema, references) {
  return IsTransform(schema) || Visit(schema.returns, references) || schema.parameters.some(schema => Visit(schema, references));
},__name(FromFunction, "FromFunction");,function FromIntersect(schema, references) {
  return IsTransform(schema) || IsTransform(schema.unevaluatedProperties) || schema.allOf.some(schema => Visit(schema, references));
},__name(FromIntersect, "FromIntersect");,function FromImport(schema, references) {
  let additional = globalThis.Object.getOwnPropertyNames(schema.$defs).reduce((result, key) => [...result, schema.$defs[key]], []),
    target = schema.$defs[schema.$ref];
  return IsTransform(schema) || Visit(target, [...additional, ...references]);
},__name(FromImport, "FromImport");,function FromIterator(schema, references) {
  return IsTransform(schema) || Visit(schema.items, references);
},__name(FromIterator, "FromIterator");,function FromNot(schema, references) {
  return IsTransform(schema) || Visit(schema.not, references);
},__name(FromNot, "FromNot");,function FromObject(schema, references) {
  return IsTransform(schema) || Object.values(schema.properties).some(schema => Visit(schema, references)) || IsSchema(schema.additionalProperties) && Visit(schema.additionalProperties, references);
},__name(FromObject, "FromObject");,function FromPromise(schema, references) {
  return IsTransform(schema) || Visit(schema.item, references);
},__name(FromPromise, "FromPromise");,function FromRecord(schema, references) {
  let pattern = Object.getOwnPropertyNames(schema.patternProperties)[0],
    property = schema.patternProperties[pattern];
  return IsTransform(schema) || Visit(property, references) || IsSchema(schema.additionalProperties) && IsTransform(schema.additionalProperties);
},__name(FromRecord, "FromRecord");,function FromRef(schema, references) {
  return IsTransform(schema) ? !0 : Visit(Deref(schema, references), references);
},__name(FromRef, "FromRef");,function FromThis(schema, references) {
  return IsTransform(schema) ? !0 : Visit(Deref(schema, references), references);
},__name(FromThis, "FromThis");,function FromTuple(schema, references) {
  return IsTransform(schema) || !IsUndefined(schema.items) && schema.items.some(schema => Visit(schema, references));
},__name(FromTuple, "FromTuple");,function FromUnion(schema, references) {
  return IsTransform(schema) || schema.anyOf.some(schema => Visit(schema, references));
},__name(FromUnion, "FromUnion");,function Visit(schema, references) {
  let references_ = Pushref(schema, references),
    schema_ = schema;
  if (schema.$id && visited.has(schema.$id)) return !1;
  switch (schema.$id && visited.add(schema.$id), schema[Kind]) {
    case "Array":
      return FromArray(schema_, references_);
    case "AsyncIterator":
      return FromAsyncIterator(schema_, references_);
    case "Constructor":
      return FromConstructor(schema_, references_);
    case "Function":
      return FromFunction(schema_, references_);
    case "Import":
      return FromImport(schema_, references_);
    case "Intersect":
      return FromIntersect(schema_, references_);
    case "Iterator":
      return FromIterator(schema_, references_);
    case "Not":
      return FromNot(schema_, references_);
    case "Object":
      return FromObject(schema_, references_);
    case "Promise":
      return FromPromise(schema_, references_);
    case "Record":
      return FromRecord(schema_, references_);
    case "Ref":
      return FromRef(schema_, references_);
    case "This":
      return FromThis(schema_, references_);
    case "Tuple":
      return FromTuple(schema_, references_);
    case "Union":
      return FromUnion(schema_, references_);
    default:
      return IsTransform(schema);
  }
},__name(Visit, "Visit");,var visited = new Set();,function HasTransform(schema, references) {
  return visited.clear(), Visit(schema, references);
},__name(HasTransform, "HasTransform");