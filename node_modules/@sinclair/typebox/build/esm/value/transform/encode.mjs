var _TransformEncodeCheckError = class _TransformEncodeCheckError extends TypeBoxError {
  constructor(schema, value, error) {
    super("The encoded value does not match the expected schema"), this.schema = schema, this.value = value, this.error = error;
  }
};,__name(_TransformEncodeCheckError, "TransformEncodeCheckError");,var TransformEncodeCheckError = _TransformEncodeCheckError,
  _TransformEncodeError = class _TransformEncodeError extends TypeBoxError {
    constructor(schema, path, value, error) {
      super(`${error instanceof Error ? error.message : "Unknown error"}`), this.schema = schema, this.path = path, this.value = value, this.error = error;
    }
  };,__name(_TransformEncodeError, "TransformEncodeError");,var TransformEncodeError = _TransformEncodeError;,function Default(schema, path, value) {
  try {
    return IsTransform(schema) ? schema[TransformKind].Encode(value) : value;
  } catch (error) {
    throw new TransformEncodeError(schema, path, value, error);
  }
},__name(Default, "Default");,function FromArray(schema, references, path, value) {
  let defaulted = Default(schema, path, value);
  return IsArray(defaulted) ? defaulted.map((value, index) => Visit(schema.items, references, `${path}/${index}`, value)) : defaulted;
},__name(FromArray, "FromArray");,function FromImport(schema, references, path, value) {
  let additional = globalThis.Object.values(schema.$defs),
    target = schema.$defs[schema.$ref],
    result = Default(schema, path, value);
  return Visit(target, [...references, ...additional], path, result);
},__name(FromImport, "FromImport");,function FromIntersect(schema, references, path, value) {
  let defaulted = Default(schema, path, value);
  if (!IsObject(value) || IsValueType(value)) return defaulted;
  let knownEntries = KeyOfPropertyEntries(schema),
    knownKeys = knownEntries.map(entry => entry[0]),
    knownProperties = {
      ...defaulted
    };
  for (let [knownKey, knownSchema] of knownEntries) knownKey in knownProperties && (knownProperties[knownKey] = Visit(knownSchema, references, `${path}/${knownKey}`, knownProperties[knownKey]));
  if (!IsTransform(schema.unevaluatedProperties)) return knownProperties;
  let unknownKeys = Object.getOwnPropertyNames(knownProperties),
    unevaluatedProperties = schema.unevaluatedProperties,
    properties = {
      ...knownProperties
    };
  for (let key of unknownKeys) knownKeys.includes(key) || (properties[key] = Default(unevaluatedProperties, `${path}/${key}`, properties[key]));
  return properties;
},__name(FromIntersect, "FromIntersect");,function FromNot(schema, references, path, value) {
  return Default(schema.not, path, Default(schema, path, value));
},__name(FromNot, "FromNot");,function FromObject(schema, references, path, value) {
  let defaulted = Default(schema, path, value);
  if (!IsObject(defaulted)) return defaulted;
  let knownKeys = KeyOfPropertyKeys(schema),
    knownProperties = {
      ...defaulted
    };
  for (let key of knownKeys) HasPropertyKey(knownProperties, key) && (IsUndefined(knownProperties[key]) && (!IsUndefined(schema.properties[key]) || TypeSystemPolicy.IsExactOptionalProperty(knownProperties, key)) || (knownProperties[key] = Visit(schema.properties[key], references, `${path}/${key}`, knownProperties[key])));
  if (!IsSchema(schema.additionalProperties)) return knownProperties;
  let unknownKeys = Object.getOwnPropertyNames(knownProperties),
    additionalProperties = schema.additionalProperties,
    properties = {
      ...knownProperties
    };
  for (let key of unknownKeys) knownKeys.includes(key) || (properties[key] = Default(additionalProperties, `${path}/${key}`, properties[key]));
  return properties;
},__name(FromObject, "FromObject");,function FromRecord(schema, references, path, value) {
  let defaulted = Default(schema, path, value);
  if (!IsObject(value)) return defaulted;
  let pattern = Object.getOwnPropertyNames(schema.patternProperties)[0],
    knownKeys = new RegExp(pattern),
    knownProperties = {
      ...defaulted
    };
  for (let key of Object.getOwnPropertyNames(value)) knownKeys.test(key) && (knownProperties[key] = Visit(schema.patternProperties[pattern], references, `${path}/${key}`, knownProperties[key]));
  if (!IsSchema(schema.additionalProperties)) return knownProperties;
  let unknownKeys = Object.getOwnPropertyNames(knownProperties),
    additionalProperties = schema.additionalProperties,
    properties = {
      ...knownProperties
    };
  for (let key of unknownKeys) knownKeys.test(key) || (properties[key] = Default(additionalProperties, `${path}/${key}`, properties[key]));
  return properties;
},__name(FromRecord, "FromRecord");,function FromRef(schema, references, path, value) {
  let target = Deref(schema, references),
    resolved = Visit(target, references, path, value);
  return Default(schema, path, resolved);
},__name(FromRef, "FromRef");,function FromThis(schema, references, path, value) {
  let target = Deref(schema, references),
    resolved = Visit(target, references, path, value);
  return Default(schema, path, resolved);
},__name(FromThis, "FromThis");,function FromTuple(schema, references, path, value) {
  let value1 = Default(schema, path, value);
  return IsArray(schema.items) ? schema.items.map((schema, index) => Visit(schema, references, `${path}/${index}`, value1[index])) : [];
},__name(FromTuple, "FromTuple");,function FromUnion(schema, references, path, value) {
  for (let subschema of schema.anyOf) {
    if (!Check(subschema, references, value)) continue;
    let value1 = Visit(subschema, references, path, value);
    return Default(schema, path, value1);
  }
  for (let subschema of schema.anyOf) {
    let value1 = Visit(subschema, references, path, value);
    if (Check(schema, references, value1)) return Default(schema, path, value1);
  }
  return Default(schema, path, value);
},__name(FromUnion, "FromUnion");,function Visit(schema, references, path, value) {
  let references_ = Pushref(schema, references),
    schema_ = schema;
  switch (schema[Kind]) {
    case "Array":
      return FromArray(schema_, references_, path, value);
    case "Import":
      return FromImport(schema_, references_, path, value);
    case "Intersect":
      return FromIntersect(schema_, references_, path, value);
    case "Not":
      return FromNot(schema_, references_, path, value);
    case "Object":
      return FromObject(schema_, references_, path, value);
    case "Record":
      return FromRecord(schema_, references_, path, value);
    case "Ref":
      return FromRef(schema_, references_, path, value);
    case "This":
      return FromThis(schema_, references_, path, value);
    case "Tuple":
      return FromTuple(schema_, references_, path, value);
    case "Union":
      return FromUnion(schema_, references_, path, value);
    default:
      return Default(schema_, path, value);
  }
},__name(Visit, "Visit");,function TransformEncode(schema, references, value) {
  return Visit(schema, references, "", value);
},__name(TransformEncode, "TransformEncode");