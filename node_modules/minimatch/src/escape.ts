var escape = __name((s, {
  windowsPathsNoEscape = !1
} = {}) => windowsPathsNoEscape ? s.replace(/[?*()[\]]/g, "[$&]") : s.replace(/[?*()[\]\\]/g, "\\$&"), "escape");,var minimatch = __name((p, pattern, options = {}) => (assertValidPattern(pattern), !options.nocomment && pattern.charAt(0) === "#" ? !1 : new Minimatch(pattern, options).match(p)), "minimatch"),
  starDotExtRE = /^\*+([^+@!?\*\[\(]*)$/,
  starDotExtTest = __name(ext => f => !f.startsWith(".") && f.endsWith(ext), "starDotExtTest"),
  starDotExtTestDot = __name(ext => f => f.endsWith(ext), "starDotExtTestDot"),
  starDotExtTestNocase = __name(ext => (ext = ext.toLowerCase(), f => !f.startsWith(".") && f.toLowerCase().endsWith(ext)), "starDotExtTestNocase"),
  starDotExtTestNocaseDot = __name(ext => (ext = ext.toLowerCase(), f => f.toLowerCase().endsWith(ext)), "starDotExtTestNocaseDot"),
  starDotStarRE = /^\*+\.\*+$/,
  starDotStarTest = __name(f => !f.startsWith(".") && f.includes("."), "starDotStarTest"),
  starDotStarTestDot = __name(f => f !== "." && f !== ".." && f.includes("."), "starDotStarTestDot"),
  dotStarRE = /^\.\*+$/,
  dotStarTest = __name(f => f !== "." && f !== ".." && f.startsWith("."), "dotStarTest"),
  starRE = /^\*+$/,
  starTest = __name(f => f.length !== 0 && !f.startsWith("."), "starTest"),
  starTestDot = __name(f => f.length !== 0 && f !== "." && f !== "..", "starTestDot"),
  qmarksRE = /^\?+([^+@!?\*\[\(]*)?$/,
  qmarksTestNocase = __name(([$0, ext = ""]) => {
    let noext = qmarksTestNoExt([$0]);
    return ext ? (ext = ext.toLowerCase(), f => noext(f) && f.toLowerCase().endsWith(ext)) : noext;
  }, "qmarksTestNocase"),
  qmarksTestNocaseDot = __name(([$0, ext = ""]) => {
    let noext = qmarksTestNoExtDot([$0]);
    return ext ? (ext = ext.toLowerCase(), f => noext(f) && f.toLowerCase().endsWith(ext)) : noext;
  }, "qmarksTestNocaseDot"),
  qmarksTestDot = __name(([$0, ext = ""]) => {
    let noext = qmarksTestNoExtDot([$0]);
    return ext ? f => noext(f) && f.endsWith(ext) : noext;
  }, "qmarksTestDot"),
  qmarksTest = __name(([$0, ext = ""]) => {
    let noext = qmarksTestNoExt([$0]);
    return ext ? f => noext(f) && f.endsWith(ext) : noext;
  }, "qmarksTest"),
  qmarksTestNoExt = __name(([$0]) => {
    let len = $0.length;
    return f => f.length === len && !f.startsWith(".");
  }, "qmarksTestNoExt"),
  qmarksTestNoExtDot = __name(([$0]) => {
    let len = $0.length;
    return f => f.length === len && f !== "." && f !== "..";
  }, "qmarksTestNoExtDot"),
  defaultPlatform = typeof process == "object" && process ? typeof process.env == "object" && process.env && process.env.__MINIMATCH_TESTING_PLATFORM__ || process.platform : "posix",
  path = {
    win32: {
      sep: "\\"
    },
    posix: {
      sep: "/"
    }
  },
  sep = defaultPlatform === "win32" ? path.win32.sep : path.posix.sep;,minimatch.sep = sep;,var GLOBSTAR = Symbol("globstar **");,minimatch.GLOBSTAR = GLOBSTAR;,var qmark = "[^/]",
  star = qmark + "*?",
  twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?",
  twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?",
  filter = __name((pattern, options = {}) => p => minimatch(p, pattern, options), "filter");,minimatch.filter = filter;,var ext = __name((a, b = {}) => Object.assign({}, a, b), "ext"),
  defaults = __name(def => {
    var _a, _b;
    if (!def || typeof def != "object" || !Object.keys(def).length) return minimatch;
    let orig = minimatch;
    return Object.assign(__name((p, pattern, options = {}) => orig(p, pattern, ext(def, options)), "m"), {
      Minimatch: (_a = class extends orig.Minimatch {
        constructor(pattern, options = {}) {
          super(pattern, ext(def, options));
        }
        static defaults(options) {
          return orig.defaults(ext(def, options)).Minimatch;
        }
      }, __name(_a, "Minimatch"), _a),
      AST: (_b = class extends orig.AST {
        constructor(type, parent, options = {}) {
          super(type, parent, ext(def, options));
        }
        static fromGlob(pattern, options = {}) {
          return orig.AST.fromGlob(pattern, ext(def, options));
        }
      }, __name(_b, "AST"), _b),
      unescape: __name((s, options = {}) => orig.unescape(s, ext(def, options)), "unescape"),
      escape: __name((s, options = {}) => orig.escape(s, ext(def, options)), "escape"),
      filter: __name((pattern, options = {}) => orig.filter(pattern, ext(def, options)), "filter"),
      defaults: __name(options => orig.defaults(ext(def, options)), "defaults"),
      makeRe: __name((pattern, options = {}) => orig.makeRe(pattern, ext(def, options)), "makeRe"),
      braceExpand: __name((pattern, options = {}) => orig.braceExpand(pattern, ext(def, options)), "braceExpand"),
      match: __name((list, pattern, options = {}) => orig.match(list, pattern, ext(def, options)), "match"),
      sep: orig.sep,
      GLOBSTAR: GLOBSTAR
    });
  }, "defaults");,minimatch.defaults = defaults;,var braceExpand = __name((pattern, options = {}) => (assertValidPattern(pattern), options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern) ? [pattern] : (0, NSe.expand)(pattern)), "braceExpand");,minimatch.braceExpand = braceExpand;,var makeRe = __name((pattern, options = {}) => new Minimatch(pattern, options).makeRe(), "makeRe");,minimatch.makeRe = makeRe;,var match = __name((list, pattern, options = {}) => {
  let mm = new Minimatch(pattern, options);
  return list = list.filter(f => mm.match(f)), mm.options.nonull && !list.length && list.push(pattern), list;
}, "match");,minimatch.match = match;,var globMagic = /[?*]|[+@!]\(.*?\)|\[|\]/,
  regExpEscape = __name(s => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&"), "regExpEscape"),
  _Minimatch = class _Minimatch {
    constructor(pattern, options = {}) {
      __publicField(this, "options");
      __publicField(this, "set");
      __publicField(this, "pattern");
      __publicField(this, "windowsPathsNoEscape");
      __publicField(this, "nonegate");
      __publicField(this, "negate");
      __publicField(this, "comment");
      __publicField(this, "empty");
      __publicField(this, "preserveMultipleSlashes");
      __publicField(this, "partial");
      __publicField(this, "globSet");
      __publicField(this, "globParts");
      __publicField(this, "nocase");
      __publicField(this, "isWindows");
      __publicField(this, "platform");
      __publicField(this, "windowsNoMagicRoot");
      __publicField(this, "regexp");
      assertValidPattern(pattern), options = options || {}, this.options = options, this.pattern = pattern, this.platform = options.platform || defaultPlatform, this.isWindows = this.platform === "win32", this.windowsPathsNoEscape = !!options.windowsPathsNoEscape || options.allowWindowsEscape === !1, this.windowsPathsNoEscape && (this.pattern = this.pattern.replace(/\\/g, "/")), this.preserveMultipleSlashes = !!options.preserveMultipleSlashes, this.regexp = null, this.negate = !1, this.nonegate = !!options.nonegate, this.comment = !1, this.empty = !1, this.partial = !!options.partial, this.nocase = !!this.options.nocase, this.windowsNoMagicRoot = options.windowsNoMagicRoot !== void 0 ? options.windowsNoMagicRoot : !!(this.isWindows && this.nocase), this.globSet = [], this.globParts = [], this.set = [], this.make();
    }
    hasMagic() {
      if (this.options.magicalBraces && this.set.length > 1) return !0;
      for (let pattern of this.set) for (let part of pattern) if (typeof part != "string") return !0;
      return !1;
    }
    debug(..._) {}
    make() {
      let pattern = this.pattern,
        options = this.options;
      if (!options.nocomment && pattern.charAt(0) === "#") {
        this.comment = !0;
        return;
      }
      if (!pattern) {
        this.empty = !0;
        return;
      }
      this.parseNegate(), this.globSet = [...new Set(this.braceExpand())], options.debug && (this.debug = (...args) => console.error(...args)), this.debug(this.pattern, this.globSet);
      let rawGlobParts = this.globSet.map(s => this.slashSplit(s));
      this.globParts = this.preprocess(rawGlobParts), this.debug(this.pattern, this.globParts);
      let set = this.globParts.map((s, _, __) => {
        if (this.isWindows && this.windowsNoMagicRoot) {
          let isUNC = s[0] === "" && s[1] === "" && (s[2] === "?" || !globMagic.test(s[2])) && !globMagic.test(s[3]),
            isDrive = /^[a-z]:/i.test(s[0]);
          if (isUNC) return [...s.slice(0, 4), ...s.slice(4).map(ss => this.parse(ss))];
          if (isDrive) return [s[0], ...s.slice(1).map(ss => this.parse(ss))];
        }
        return s.map(ss => this.parse(ss));
      });
      if (this.debug(this.pattern, set), this.set = set.filter(s => s.indexOf(!1) === -1), this.isWindows) for (let i = 0; i < this.set.length; i++) {
        let p = this.set[i];
        p[0] === "" && p[1] === "" && this.globParts[i][2] === "?" && typeof p[3] == "string" && /^[a-z]:$/i.test(p[3]) && (p[2] = "?");
      }
      this.debug(this.pattern, this.set);
    }
    preprocess(globParts) {
      if (this.options.noglobstar) for (let i = 0; i < globParts.length; i++) for (let j = 0; j < globParts[i].length; j++) globParts[i][j] === "**" && (globParts[i][j] = "*");
      let {
        optimizationLevel = 1
      } = this.options;
      return optimizationLevel >= 2 ? (globParts = this.firstPhasePreProcess(globParts), globParts = this.secondPhasePreProcess(globParts)) : optimizationLevel >= 1 ? globParts = this.levelOneOptimize(globParts) : globParts = this.adjascentGlobstarOptimize(globParts), globParts;
    }
    adjascentGlobstarOptimize(globParts) {
      return globParts.map(parts => {
        let gs = -1;
        for (; (gs = parts.indexOf("**", gs + 1)) !== -1;) {
          let i = gs;
          for (; parts[i + 1] === "**";) i++;
          i !== gs && parts.splice(gs, i - gs);
        }
        return parts;
      });
    }
    levelOneOptimize(globParts) {
      return globParts.map(parts => (parts = parts.reduce((set, part) => {
        let prev = set[set.length - 1];
        return part === "**" && prev === "**" ? set : part === ".." && prev && prev !== ".." && prev !== "." && prev !== "**" ? (set.pop(), set) : (set.push(part), set);
      }, []), parts.length === 0 ? [""] : parts));
    }
    levelTwoFileOptimize(parts) {
      Array.isArray(parts) || (parts = this.slashSplit(parts));
      let didSomething = !1;
      do {
        if (didSomething = !1, !this.preserveMultipleSlashes) {
          for (let i = 1; i < parts.length - 1; i++) {
            let p = parts[i];
            i === 1 && p === "" && parts[0] === "" || (p === "." || p === "") && (didSomething = !0, parts.splice(i, 1), i--);
          }
          parts[0] === "." && parts.length === 2 && (parts[1] === "." || parts[1] === "") && (didSomething = !0, parts.pop());
        }
        let dd = 0;
        for (; (dd = parts.indexOf("..", dd + 1)) !== -1;) {
          let p = parts[dd - 1];
          p && p !== "." && p !== ".." && p !== "**" && (didSomething = !0, parts.splice(dd - 1, 2), dd -= 2);
        }
      } while (didSomething);
      return parts.length === 0 ? [""] : parts;
    }
    firstPhasePreProcess(globParts) {
      let didSomething = !1;
      do {
        didSomething = !1;
        for (let parts of globParts) {
          let gs = -1;
          for (; (gs = parts.indexOf("**", gs + 1)) !== -1;) {
            let gss = gs;
            for (; parts[gss + 1] === "**";) gss++;
            gss > gs && parts.splice(gs + 1, gss - gs);
            let next = parts[gs + 1],
              p = parts[gs + 2],
              p2 = parts[gs + 3];
            if (next !== ".." || !p || p === "." || p === ".." || !p2 || p2 === "." || p2 === "..") continue;
            didSomething = !0, parts.splice(gs, 1);
            let other = parts.slice(0);
            other[gs] = "**", globParts.push(other), gs--;
          }
          if (!this.preserveMultipleSlashes) {
            for (let i = 1; i < parts.length - 1; i++) {
              let p = parts[i];
              i === 1 && p === "" && parts[0] === "" || (p === "." || p === "") && (didSomething = !0, parts.splice(i, 1), i--);
            }
            parts[0] === "." && parts.length === 2 && (parts[1] === "." || parts[1] === "") && (didSomething = !0, parts.pop());
          }
          let dd = 0;
          for (; (dd = parts.indexOf("..", dd + 1)) !== -1;) {
            let p = parts[dd - 1];
            if (p && p !== "." && p !== ".." && p !== "**") {
              didSomething = !0;
              let splin = dd === 1 && parts[dd + 1] === "**" ? ["."] : [];
              parts.splice(dd - 1, 2, ...splin), parts.length === 0 && parts.push(""), dd -= 2;
            }
          }
        }
      } while (didSomething);
      return globParts;
    }
    secondPhasePreProcess(globParts) {
      for (let i = 0; i < globParts.length - 1; i++) for (let j = i + 1; j < globParts.length; j++) {
        let matched = this.partsMatch(globParts[i], globParts[j], !this.preserveMultipleSlashes);
        if (matched) {
          globParts[i] = [], globParts[j] = matched;
          break;
        }
      }
      return globParts.filter(gs => gs.length);
    }
    partsMatch(a, b, emptyGSMatch = !1) {
      let ai = 0,
        bi = 0,
        result = [],
        which = "";
      for (; ai < a.length && bi < b.length;) if (a[ai] === b[bi]) result.push(which === "b" ? b[bi] : a[ai]), ai++, bi++;else if (emptyGSMatch && a[ai] === "**" && b[bi] === a[ai + 1]) result.push(a[ai]), ai++;else if (emptyGSMatch && b[bi] === "**" && a[ai] === b[bi + 1]) result.push(b[bi]), bi++;else if (a[ai] === "*" && b[bi] && (this.options.dot || !b[bi].startsWith(".")) && b[bi] !== "**") {
        if (which === "b") return !1;
        which = "a", result.push(a[ai]), ai++, bi++;
      } else if (b[bi] === "*" && a[ai] && (this.options.dot || !a[ai].startsWith(".")) && a[ai] !== "**") {
        if (which === "a") return !1;
        which = "b", result.push(b[bi]), ai++, bi++;
      } else return !1;
      return a.length === b.length && result;
    }
    parseNegate() {
      if (this.nonegate) return;
      let pattern = this.pattern,
        negate = !1,
        negateOffset = 0;
      for (let i = 0; i < pattern.length && pattern.charAt(i) === "!"; i++) negate = !negate, negateOffset++;
      negateOffset && (this.pattern = pattern.slice(negateOffset)), this.negate = negate;
    }
    matchOne(file, pattern, partial = !1) {
      let options = this.options;
      if (this.isWindows) {
        let fileDrive = typeof file[0] == "string" && /^[a-z]:$/i.test(file[0]),
          fileUNC = !fileDrive && file[0] === "" && file[1] === "" && file[2] === "?" && /^[a-z]:$/i.test(file[3]),
          patternDrive = typeof pattern[0] == "string" && /^[a-z]:$/i.test(pattern[0]),
          patternUNC = !patternDrive && pattern[0] === "" && pattern[1] === "" && pattern[2] === "?" && typeof pattern[3] == "string" && /^[a-z]:$/i.test(pattern[3]),
          fdi = fileUNC ? 3 : fileDrive ? 0 : void 0,
          pdi = patternUNC ? 3 : patternDrive ? 0 : void 0;
        if (typeof fdi == "number" && typeof pdi == "number") {
          let [fd, pd] = [file[fdi], pattern[pdi]];
          fd.toLowerCase() === pd.toLowerCase() && (pattern[pdi] = fd, pdi > fdi ? pattern = pattern.slice(pdi) : fdi > pdi && (file = file.slice(fdi)));
        }
      }
      let {
        optimizationLevel = 1
      } = this.options;
      optimizationLevel >= 2 && (file = this.levelTwoFileOptimize(file)), this.debug("matchOne", this, {
        file: file,
        pattern: pattern
      }), this.debug("matchOne", file.length, pattern.length);
      for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
        this.debug("matchOne loop");
        var p = pattern[pi],
          f = file[fi];
        if (this.debug(pattern, p, f), p === !1) return !1;
        if (p === GLOBSTAR) {
          this.debug("GLOBSTAR", [pattern, p, f]);
          var fr = fi,
            pr = pi + 1;
          if (pr === pl) {
            for (this.debug("** at the end"); fi < fl; fi++) if (file[fi] === "." || file[fi] === ".." || !options.dot && file[fi].charAt(0) === ".") return !1;
            return !0;
          }
          for (; fr < fl;) {
            var swallowee = file[fr];
            if (this.debug(`
globstar while`, file, fr, pattern, pr, swallowee), this.matchOne(file.slice(fr), pattern.slice(pr), partial)) return this.debug("globstar found match!", fr, fl, swallowee), !0;
            if (swallowee === "." || swallowee === ".." || !options.dot && swallowee.charAt(0) === ".") {
              this.debug("dot detected!", file, fr, pattern, pr);
              break;
            }
            this.debug("globstar swallow a segment, and continue"), fr++;
          }
          return !!(partial && (this.debug(`
>>> no match, partial?`, file, fr, pattern, pr), fr === fl));
        }
        let hit;
        if (typeof p == "string" ? (hit = f === p, this.debug("string match", p, f, hit)) : (hit = p.test(f), this.debug("pattern match", p, f, hit)), !hit) return !1;
      }
      if (fi === fl && pi === pl) return !0;
      if (fi === fl) return partial;
      if (pi === pl) return fi === fl - 1 && file[fi] === "";
      throw new Error("wtf?");
    }
    braceExpand() {
      return braceExpand(this.pattern, this.options);
    }
    parse(pattern) {
      assertValidPattern(pattern);
      let options = this.options;
      if (pattern === "**") return GLOBSTAR;
      if (pattern === "") return "";
      let m,
        fastTest = null;
      (m = pattern.match(starRE)) ? fastTest = options.dot ? starTestDot : starTest : (m = pattern.match(starDotExtRE)) ? fastTest = (options.nocase ? options.dot ? starDotExtTestNocaseDot : starDotExtTestNocase : options.dot ? starDotExtTestDot : starDotExtTest)(m[1]) : (m = pattern.match(qmarksRE)) ? fastTest = (options.nocase ? options.dot ? qmarksTestNocaseDot : qmarksTestNocase : options.dot ? qmarksTestDot : qmarksTest)(m) : (m = pattern.match(starDotStarRE)) ? fastTest = options.dot ? starDotStarTestDot : starDotStarTest : (m = pattern.match(dotStarRE)) && (fastTest = dotStarTest);
      let re = AST.fromGlob(pattern, this.options).toMMPattern();
      return fastTest && typeof re == "object" && Reflect.defineProperty(re, "test", {
        value: fastTest
      }), re;
    }
    makeRe() {
      if (this.regexp || this.regexp === !1) return this.regexp;
      let set = this.set;
      if (!set.length) return this.regexp = !1, this.regexp;
      let options = this.options,
        twoStar = options.noglobstar ? star : options.dot ? twoStarDot : twoStarNoDot,
        flags = new Set(options.nocase ? ["i"] : []),
        re = set.map(pattern => {
          let pp = pattern.map(p => {
            if (p instanceof RegExp) for (let f of p.flags.split("")) flags.add(f);
            return typeof p == "string" ? regExpEscape(p) : p === GLOBSTAR ? GLOBSTAR : p._src;
          });
          return pp.forEach((p, i) => {
            let next = pp[i + 1],
              prev = pp[i - 1];
            p !== GLOBSTAR || prev === GLOBSTAR || (prev === void 0 ? next !== void 0 && next !== GLOBSTAR ? pp[i + 1] = "(?:\\/|" + twoStar + "\\/)?" + next : pp[i] = twoStar : next === void 0 ? pp[i - 1] = prev + "(?:\\/|" + twoStar + ")?" : next !== GLOBSTAR && (pp[i - 1] = prev + "(?:\\/|\\/" + twoStar + "\\/)" + next, pp[i + 1] = GLOBSTAR));
          }), pp.filter(p => p !== GLOBSTAR).join("/");
        }).join("|"),
        [open, close] = set.length > 1 ? ["(?:", ")"] : ["", ""];
      re = "^" + open + re + close + "$", this.negate && (re = "^(?!" + re + ").+$");
      try {
        this.regexp = new RegExp(re, [...flags].join(""));
      } catch {
        this.regexp = !1;
      }
      return this.regexp;
    }
    slashSplit(p) {
      return this.preserveMultipleSlashes ? p.split("/") : this.isWindows && /^\/\/[^\/]+/.test(p) ? ["", ...p.split(/\/+/)] : p.split(/\/+/);
    }
    match(f, partial = this.partial) {
      if (this.debug("match", f, this.pattern), this.comment) return !1;
      if (this.empty) return f === "";
      if (f === "/" && partial) return !0;
      let options = this.options;
      this.isWindows && (f = f.split("\\").join("/"));
      let ff = this.slashSplit(f);
      this.debug(this.pattern, "split", ff);
      let set = this.set;
      this.debug(this.pattern, "set", set);
      let filename = ff[ff.length - 1];
      if (!filename) for (let i = ff.length - 2; !filename && i >= 0; i--) filename = ff[i];
      for (let i = 0; i < set.length; i++) {
        let pattern = set[i],
          file = ff;
        if (options.matchBase && pattern.length === 1 && (file = [filename]), this.matchOne(file, pattern, partial)) return options.flipNegate ? !0 : !this.negate;
      }
      return options.flipNegate ? !1 : this.negate;
    }
    static defaults(def) {
      return minimatch.defaults(def).Minimatch;
    }
  };,__name(_Minimatch, "Minimatch");,var Minimatch = _Minimatch;,minimatch.AST = AST;,minimatch.Minimatch = Minimatch;,minimatch.escape = escape;,minimatch.unescape = unescape;