var types = new Set(["!", "?", "+", "*", "@"]),
  isExtglobType = __name(c => types.has(c), "isExtglobType"),
  startNoTraversal = "(?!(?:^|/)\\.\\.?(?:$|/))",
  startNoDot = "(?!\\.)",
  addPatternStart = new Set(["[", "."]),
  justDots = new Set(["..", "."]),
  reSpecials = new Set("().*{}+?[]^$\\!"),
  regExpEscape = __name(s => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&"), "regExpEscape"),
  qmark = "[^/]",
  star = qmark + "*?",
  starNoEmpty = qmark + "+?",
  _root,
  _hasMagic,
  _uflag,
  _parts,
  _parent,
  _parentIndex,
  _negs,
  _filledNegs,
  _options,
  _toString,
  _emptyExt,
  _AST_instances,
  fillNegs_fn,
  _AST_static,
  parseAST_fn,
  partsToRegExp_fn,
  parseGlob_fn,
  _AST = class _AST {
    constructor(type, parent, options = {}) {
      __privateAdd(this, _AST_instances);
      __publicField(this, "type");
      __privateAdd(this, _root);
      __privateAdd(this, _hasMagic);
      __privateAdd(this, _uflag, !1);
      __privateAdd(this, _parts, []);
      __privateAdd(this, _parent);
      __privateAdd(this, _parentIndex);
      __privateAdd(this, _negs);
      __privateAdd(this, _filledNegs, !1);
      __privateAdd(this, _options);
      __privateAdd(this, _toString);
      __privateAdd(this, _emptyExt, !1);
      this.type = type, type && __privateSet(this, _hasMagic, !0), __privateSet(this, _parent, parent), __privateSet(this, _root, __privateGet(this, _parent) ? __privateGet(L(this, _parent), _root) : this), __privateSet(this, _options, __privateGet(this, _root) === this ? options : __privateGet(L(this, _root), _options)), __privateSet(this, _negs, __privateGet(this, _root) === this ? [] : __privateGet(L(this, _root), _negs)), type === "!" && !__privateGet(L(this, _root), _filledNegs) && __privateGet(this, _negs).push(this), __privateSet(this, _parentIndex, __privateGet(this, _parent) ? __privateGet(L(this, _parent), _parts).length : 0);
    }
    get hasMagic() {
      if (__privateGet(this, _hasMagic) !== void 0) return __privateGet(this, _hasMagic);
      for (let p of __privateGet(this, _parts)) if (typeof p != "string" && (p.type || p.hasMagic)) return __privateSet(this, _hasMagic, !0);
      return __privateGet(this, _hasMagic);
    }
    toString() {
      return __privateGet(this, _toString) !== void 0 ? __privateGet(this, _toString) : this.type ? __privateSet(this, _toString, this.type + "(" + __privateGet(this, _parts).map(p => String(p)).join("|") + ")") : __privateSet(this, _toString, __privateGet(this, _parts).map(p => String(p)).join(""));
    }
    push(...parts) {
      for (let p of parts) if (p !== "") {
        if (typeof p != "string" && !(p instanceof _AST && __privateGet(p, _parent) === this)) throw new Error("invalid part: " + p);
        __privateGet(this, _parts).push(p);
      }
    }
    toJSON() {
      var _a;
      let ret = this.type === null ? __privateGet(this, _parts).slice().map(p => typeof p == "string" ? p : p.toJSON()) : [this.type, ...__privateGet(this, _parts).map(p => p.toJSON())];
      return this.isStart() && !this.type && ret.unshift([]), this.isEnd() && (this === __privateGet(this, _root) || __privateGet(L(this, _root), _filledNegs) && ((_a = __privateGet(this, _parent)) == null ? void 0 : _a.type) === "!") && ret.push({}), ret;
    }
    isStart() {
      var _a;
      if (__privateGet(this, _root) === this) return !0;
      if (!((_a = __privateGet(this, _parent)) != null && _a.isStart())) return !1;
      if (__privateGet(this, _parentIndex) === 0) return !0;
      let p = __privateGet(this, _parent);
      for (let i = 0; i < __privateGet(this, _parentIndex); i++) {
        let pp = __privateGet(p, _parts)[i];
        if (!(pp instanceof _AST && pp.type === "!")) return !1;
      }
      return !0;
    }
    isEnd() {
      var _a, _b, _c;
      if (__privateGet(this, _root) === this || ((_a = __privateGet(this, _parent)) == null ? void 0 : _a.type) === "!") return !0;
      if (!((_b = __privateGet(this, _parent)) != null && _b.isEnd())) return !1;
      if (!this.type) return (_c = __privateGet(this, _parent)) == null ? void 0 : _c.isEnd();
      let pl = __privateGet(this, _parent) ? __privateGet(L(this, _parent), _parts).length : 0;
      return __privateGet(this, _parentIndex) === pl - 1;
    }
    copyIn(part) {
      typeof part == "string" ? this.push(part) : this.push(part.clone(this));
    }
    clone(parent) {
      let c = new _AST(this.type, parent);
      for (let p of __privateGet(this, _parts)) c.copyIn(p);
      return c;
    }
    static fromGlob(pattern, options = {}) {
      var _a;
      let ast = new _AST(null, void 0, options);
      return __privateMethod(_a = _AST, _AST_static, parseAST_fn).call(_a, pattern, ast, 0, options), ast;
    }
    toMMPattern() {
      if (this !== __privateGet(this, _root)) return __privateGet(this, _root).toMMPattern();
      let glob = this.toString(),
        [re, body, hasMagic, uflag] = this.toRegExpSource();
      if (!(hasMagic || __privateGet(this, _hasMagic) || __privateGet(this, _options).nocase && !__privateGet(this, _options).nocaseMagicOnly && glob.toUpperCase() !== glob.toLowerCase())) return body;
      let flags = (__privateGet(this, _options).nocase ? "i" : "") + (uflag ? "u" : "");
      return Object.assign(new RegExp(`^${re}$`, flags), {
        _src: re,
        _glob: glob
      });
    }
    get options() {
      return __privateGet(this, _options);
    }
    toRegExpSource(allowDot) {
      var _a;
      let dot = allowDot != null ? allowDot : !!__privateGet(this, _options).dot;
      if (__privateGet(this, _root) === this && __privateMethod(this, _AST_instances, fillNegs_fn).call(this), !this.type) {
        let noEmpty = this.isStart() && this.isEnd(),
          src = __privateGet(this, _parts).map(p => {
            var _a;
            let [re, _, hasMagic, uflag] = typeof p == "string" ? __privateMethod(_a = _AST, _AST_static, parseGlob_fn).call(_a, p, __privateGet(this, _hasMagic), noEmpty) : p.toRegExpSource(allowDot);
            return __privateSet(this, _hasMagic, __privateGet(this, _hasMagic) || hasMagic), __privateSet(this, _uflag, __privateGet(this, _uflag) || uflag), re;
          }).join(""),
          start = "";
        if (this.isStart() && typeof __privateGet(this, _parts)[0] == "string" && !(__privateGet(this, _parts).length === 1 && justDots.has(__privateGet(this, _parts)[0]))) {
          let aps = addPatternStart,
            needNoTrav = dot && aps.has(src.charAt(0)) || src.startsWith("\\.") && aps.has(src.charAt(2)) || src.startsWith("\\.\\.") && aps.has(src.charAt(4)),
            needNoDot = !dot && !allowDot && aps.has(src.charAt(0));
          start = needNoTrav ? startNoTraversal : needNoDot ? startNoDot : "";
        }
        let end = "";
        return this.isEnd() && __privateGet(L(this, _root), _filledNegs) && ((_a = __privateGet(this, _parent)) == null ? void 0 : _a.type) === "!" && (end = "(?:$|\\/)"), [start + src + end, unescape(src), __privateSet(this, _hasMagic, !!__privateGet(this, _hasMagic)), __privateGet(this, _uflag)];
      }
      let repeated = this.type === "*" || this.type === "+",
        start = this.type === "!" ? "(?:(?!(?:" : "(?:",
        body = __privateMethod(this, _AST_instances, partsToRegExp_fn).call(this, dot);
      if (this.isStart() && this.isEnd() && !body && this.type !== "!") {
        let s = this.toString();
        return __privateSet(this, _parts, [s]), this.type = null, __privateSet(this, _hasMagic, void 0), [s, unescape(this.toString()), !1, !1];
      }
      let bodyDotAllowed = !repeated || allowDot || dot || !startNoDot ? "" : __privateMethod(this, _AST_instances, partsToRegExp_fn).call(this, !0);
      bodyDotAllowed === body && (bodyDotAllowed = ""), bodyDotAllowed && (body = `(?:${body})(?:${bodyDotAllowed})*?`);
      let final = "";
      if (this.type === "!" && __privateGet(this, _emptyExt)) final = (this.isStart() && !dot ? startNoDot : "") + starNoEmpty;else {
        let close = this.type === "!" ? "))" + (this.isStart() && !dot && !allowDot ? startNoDot : "") + star + ")" : this.type === "@" ? ")" : this.type === "?" ? ")?" : this.type === "+" && bodyDotAllowed ? ")" : this.type === "*" && bodyDotAllowed ? ")?" : `)${this.type}`;
        final = start + body + close;
      }
      return [final, unescape(body), __privateSet(this, _hasMagic, !!__privateGet(this, _hasMagic)), __privateGet(this, _uflag)];
    }
  };,_root = new WeakMap(), _hasMagic = new WeakMap(), _uflag = new WeakMap(), _parts = new WeakMap(), _parent = new WeakMap(), _parentIndex = new WeakMap(), _negs = new WeakMap(), _filledNegs = new WeakMap(), _options = new WeakMap(), _toString = new WeakMap(), _emptyExt = new WeakMap(), _AST_instances = new WeakSet(), fillNegs_fn = __name(function () {
  if (this !== __privateGet(this, _root)) throw new Error("should only call on root");
  if (__privateGet(this, _filledNegs)) return this;
  this.toString(), __privateSet(this, _filledNegs, !0);
  let n;
  for (; n = __privateGet(this, _negs).pop();) {
    if (n.type !== "!") continue;
    let p = n,
      pp = __privateGet(p, _parent);
    for (; pp;) {
      for (let i = __privateGet(p, _parentIndex) + 1; !pp.type && i < __privateGet(pp, _parts).length; i++) for (let part of __privateGet(n, _parts)) {
        if (typeof part == "string") throw new Error("string part in extglob AST??");
        part.copyIn(__privateGet(pp, _parts)[i]);
      }
      p = pp, pp = __privateGet(p, _parent);
    }
  }
  return this;
}, "#fillNegs"), _AST_static = new WeakSet(), parseAST_fn = __name(function (str, ast, pos, opt) {
  var _a, _b;
  let escaping = !1,
    inBrace = !1,
    braceStart = -1,
    braceNeg = !1;
  if (ast.type === null) {
    let i = pos,
      acc = "";
    for (; i < str.length;) {
      let c = str.charAt(i++);
      if (escaping || c === "\\") {
        escaping = !escaping, acc += c;
        continue;
      }
      if (inBrace) {
        i === braceStart + 1 ? (c === "^" || c === "!") && (braceNeg = !0) : c === "]" && !(i === braceStart + 2 && braceNeg) && (inBrace = !1), acc += c;
        continue;
      } else if (c === "[") {
        inBrace = !0, braceStart = i, braceNeg = !1, acc += c;
        continue;
      }
      if (!opt.noext && isExtglobType(c) && str.charAt(i) === "(") {
        ast.push(acc), acc = "";
        let ext = new _AST(c, ast);
        i = __privateMethod(_a = _AST, _AST_static, parseAST_fn).call(_a, str, ext, i, opt), ast.push(ext);
        continue;
      }
      acc += c;
    }
    return ast.push(acc), i;
  }
  let i = pos + 1,
    part = new _AST(null, ast),
    parts = [],
    acc = "";
  for (; i < str.length;) {
    let c = str.charAt(i++);
    if (escaping || c === "\\") {
      escaping = !escaping, acc += c;
      continue;
    }
    if (inBrace) {
      i === braceStart + 1 ? (c === "^" || c === "!") && (braceNeg = !0) : c === "]" && !(i === braceStart + 2 && braceNeg) && (inBrace = !1), acc += c;
      continue;
    } else if (c === "[") {
      inBrace = !0, braceStart = i, braceNeg = !1, acc += c;
      continue;
    }
    if (isExtglobType(c) && str.charAt(i) === "(") {
      part.push(acc), acc = "";
      let ext = new _AST(c, part);
      part.push(ext), i = __privateMethod(_b = _AST, _AST_static, parseAST_fn).call(_b, str, ext, i, opt);
      continue;
    }
    if (c === "|") {
      part.push(acc), acc = "", parts.push(part), part = new _AST(null, ast);
      continue;
    }
    if (c === ")") return acc === "" && __privateGet(ast, _parts).length === 0 && __privateSet(ast, _emptyExt, !0), part.push(acc), acc = "", ast.push(...parts, part), i;
    acc += c;
  }
  return ast.type = null, __privateSet(ast, _hasMagic, void 0), __privateSet(ast, _parts, [str.substring(pos - 1)]), i;
}, "#parseAST"), partsToRegExp_fn = __name(function (dot) {
  return __privateGet(this, _parts).map(p => {
    if (typeof p == "string") throw new Error("string type in extglob ast??");
    let [re, _, _hasMagic, uflag] = p.toRegExpSource(dot);
    return __privateSet(this, _uflag, __privateGet(this, _uflag) || uflag), re;
  }).filter(p => !(this.isStart() && this.isEnd()) || !!p).join("|");
}, "#partsToRegExp"), parseGlob_fn = __name(function (glob, hasMagic, noEmpty = !1) {
  let escaping = !1,
    re = "",
    uflag = !1;
  for (let i = 0; i < glob.length; i++) {
    let c = glob.charAt(i);
    if (escaping) {
      escaping = !1, re += (reSpecials.has(c) ? "\\" : "") + c;
      continue;
    }
    if (c === "\\") {
      i === glob.length - 1 ? re += "\\\\" : escaping = !0;
      continue;
    }
    if (c === "[") {
      let [src, needUflag, consumed, magic] = parseClass(glob, i);
      if (consumed) {
        re += src, uflag = uflag || needUflag, i += consumed - 1, hasMagic = hasMagic || magic;
        continue;
      }
    }
    if (c === "*") {
      noEmpty && glob === "*" ? re += starNoEmpty : re += star, hasMagic = !0;
      continue;
    }
    if (c === "?") {
      re += qmark, hasMagic = !0;
      continue;
    }
    re += regExpEscape(c);
  }
  return [re, unescape(glob), !!hasMagic, uflag];
}, "#parseGlob"), __privateAdd(_AST, _AST_static), __name(_AST, "AST");,var AST = _AST;