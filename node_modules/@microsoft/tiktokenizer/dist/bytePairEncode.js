var require_bytePairEncode = __commonJSMin(exports => {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: !0
  });
  exports.bytePairEncode = exports.BinaryMap = exports.binaryMapKey = void 0;
  var binaryMapKey = __name((k, start, end) => {
    let length = end - start,
      lowerMask = 16777215 >>> Math.max(0, (3 - length) * 8),
      lower = (k[start + 0] | k[start + 1] << 8 | k[start + 2] << 16) & lowerMask,
      upperMask = 16777215 >>> Math.min(31, Math.max(0, (6 - length) * 8)),
      upper = (k[start + 3] | k[start + 4] << 8 | k[start + 5] << 16) & upperMask;
    return lower + 16777216 * upper;
  }, "binaryMapKey");
  exports.binaryMapKey = binaryMapKey;
  var _BinaryMap = class _BinaryMap {
    constructor() {
      this.nested = new Map(), this.final = new Map();
    }
    get(key, start = 0, end = key.length) {
      var _a;
      let isFinal = end < 6 + start,
        mapKey = (0, exports.binaryMapKey)(key, start, end);
      return isFinal ? this.final.get(mapKey) : (_a = this.nested.get(mapKey)) == null ? void 0 : _a.get(key, 6 + start, end);
    }
    set(key, value) {
      let k = (0, exports.binaryMapKey)(key, 0, key.length);
      if (key.length < 6) {
        this.final.set(k, value);
        return;
      }
      let existing = this.nested.get(k);
      if (existing instanceof _BinaryMap) existing.set(key.subarray(6), value);else {
        let newMap = new _BinaryMap();
        newMap.set(key.subarray(6), value), this.nested.set(k, newMap);
      }
    }
  };
  __name(_BinaryMap, "BinaryMap");
  var BinaryMap = _BinaryMap;
  exports.BinaryMap = BinaryMap;
  var ranksBuf = new Int32Array(128),
    indicesBuf = new Int32Array(128);
  function bytePairEncode(mergingBytes, ranks, length) {
    var _a;
    if (length === 1) return [ranks.get(mergingBytes)];
    let minRank = 2147483647,
      minIndex = -1;
    for (; ranksBuf.length < length * 2;) indicesBuf = new Int32Array(indicesBuf.length * 2), ranksBuf = new Int32Array(ranksBuf.length * 2);
    for (let i = 0; i < length - 1; i++) {
      let rank = (_a = ranks.get(mergingBytes, i, i + 2)) != null ? _a : 2147483647;
      rank < minRank && (minRank = rank, minIndex = i), indicesBuf[i] = i, ranksBuf[i] = rank;
    }
    indicesBuf[length - 1] = length - 1, ranksBuf[length - 1] = 2147483647, indicesBuf[length] = length, ranksBuf[length] = 2147483647;
    let maxIndex = length + 1;
    function getRank(startIndex, skip = 0) {
      if (startIndex + skip + 2 < maxIndex) {
        let rank = ranks.get(mergingBytes, indicesBuf[startIndex], indicesBuf[startIndex + skip + 2]);
        if (rank !== void 0) return rank;
      }
      return 2147483647;
    }
    for (__name(getRank, "getRank"); minRank !== 2147483647;) {
      ranksBuf[indicesBuf[minIndex]] = getRank(minIndex, 1), minIndex > 0 && (ranksBuf[indicesBuf[minIndex - 1]] = getRank(minIndex - 1, 1));
      for (let i = minIndex + 1; i < maxIndex - 1; i++) indicesBuf[i] = indicesBuf[i + 1];
      maxIndex--, minIndex = -1, minRank = 2147483647;
      for (let i = 0; i < maxIndex - 1; i++) {
        let rank = ranksBuf[indicesBuf[i]];
        ranksBuf[indicesBuf[i]] < minRank && (minRank = rank, minIndex = i);
      }
    }
    let outList = [];
    for (let i = 0; i < maxIndex - 1; i++) outList.push(ranks.get(mergingBytes, indicesBuf[i], indicesBuf[i + 1]));
    return outList;
  }
  __name(bytePairEncode, "bytePairEncode");
  exports.bytePairEncode = bytePairEncode;
});