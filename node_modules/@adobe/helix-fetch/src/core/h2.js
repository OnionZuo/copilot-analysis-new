var require_h2 = __commonJSMin((exports, module) => {
  "use strict";

  var {
      connect: connect,
      constants: constants
    } = require("http2"),
    {
      Readable: Readable
    } = require("stream"),
    debug = b_()("helix-fetch:h2"),
    {
      RequestAbortedError: RequestAbortedError
    } = nN(),
    {
      decodeStream: decodeStream
    } = gh(),
    {
      NGHTTP2_CANCEL: NGHTTP2_CANCEL
    } = constants,
    SESSION_IDLE_TIMEOUT = 5 * 60 * 1e3,
    PUSHED_STREAM_IDLE_TIMEOUT = 5e3,
    setupContext = __name(ctx => {
      ctx.h2 = {
        sessionCache: {}
      };
    }, "setupContext"),
    resetContext = __name(async ({
      h2: h2
    }) => Promise.all(Object.values(h2.sessionCache).map(session => new Promise(resolve => {
      session.on("close", resolve), debug(`resetContext: destroying session (socket #${session.socket && session.socket.id}, ${session.socket && session.socket.servername})`), session.destroy();
    }))), "resetContext"),
    createResponse = __name((headers, clientHttp2Stream, decode, onError = () => {}) => {
      let hdrs = {
          ...headers
        },
        statusCode = hdrs[":status"];
      delete hdrs[":status"];
      let readable = decode ? decodeStream(statusCode, headers, clientHttp2Stream, onError) : clientHttp2Stream;
      return {
        statusCode: statusCode,
        statusText: "",
        httpVersion: "2.0",
        httpVersionMajor: 2,
        httpVersionMinor: 0,
        headers: hdrs,
        readable: readable,
        decoded: !!(decode && readable !== clientHttp2Stream)
      };
    }, "createResponse"),
    handlePush = __name((ctx, origin, decode, pushedStream, requestHeaders, flags) => {
      let {
          options: {
            h2: {
              pushPromiseHandler: pushPromiseHandler,
              pushHandler: pushHandler,
              pushedStreamIdleTimeout = PUSHED_STREAM_IDLE_TIMEOUT
            }
          }
        } = ctx,
        path = requestHeaders[":path"],
        url = `${origin}${path}`;
      debug(`received PUSH_PROMISE: ${url}, stream #${pushedStream.id}, headers: ${JSON.stringify(requestHeaders)}, flags: ${flags}`), pushPromiseHandler && pushPromiseHandler(url, requestHeaders, __name(() => {
        pushedStream.close(NGHTTP2_CANCEL);
      }, "rejectPush")), pushedStream.on("push", (responseHeaders, flgs) => {
        debug(`received push headers for ${origin}${path}, stream #${pushedStream.id}, headers: ${JSON.stringify(responseHeaders)}, flags: ${flgs}`), pushedStream.setTimeout(pushedStreamIdleTimeout, () => {
          debug(`closing pushed stream #${pushedStream.id} after ${pushedStreamIdleTimeout} ms of inactivity`), pushedStream.close(NGHTTP2_CANCEL);
        }), pushHandler && pushHandler(url, requestHeaders, createResponse(responseHeaders, pushedStream, decode));
      }), pushedStream.on("aborted", () => {
        debug(`pushed stream #${pushedStream.id} aborted`);
      }), pushedStream.on("error", err => {
        debug(`pushed stream #${pushedStream.id} encountered error: ${err}`);
      }), pushedStream.on("frameError", (type, code, id) => {
        debug(`pushed stream #${pushedStream.id} encountered frameError: type: ${type}, code: ${code}, id: ${id}`);
      });
    }, "handlePush"),
    request = __name(async (ctx, url, options) => {
      let {
          origin: origin,
          pathname: pathname,
          search: search,
          hash: hash
        } = url,
        path = `${pathname}${search}${hash}`,
        {
          options: {
            h2: ctxOpts = {}
          },
          h2: {
            sessionCache: sessionCache
          }
        } = ctx,
        {
          idleSessionTimeout = SESSION_IDLE_TIMEOUT,
          pushPromiseHandler: pushPromiseHandler,
          pushHandler: pushHandler
        } = ctxOpts,
        opts = {
          ...options
        },
        {
          method: method,
          headers: headers,
          socket: socket,
          body: body,
          decode: decode
        } = opts;
      return socket && delete opts.socket, headers.host && (headers[":authority"] = headers.host, delete headers.host), new Promise((resolve, reject) => {
        let session = sessionCache[origin];
        if (!session || session.closed || session.destroyed) {
          let rejectUnauthorized = !(ctx.options.rejectUnauthorized === !1 || ctxOpts.rejectUnauthorized === !1),
            connectOptions = {
              ...ctxOpts,
              rejectUnauthorized: rejectUnauthorized
            };
          socket && !socket.inUse && (connectOptions.createConnection = () => (debug(`reusing socket #${socket.id} (${socket.servername})`), socket.inUse = !0, socket)), session = connect(origin, {
            ...connectOptions,
            settings: {
              enablePush: !!(pushPromiseHandler || pushHandler)
            }
          }), session.setMaxListeners(1e3), session.setTimeout(idleSessionTimeout, () => {
            debug(`closing session ${origin} after ${idleSessionTimeout} ms of inactivity`), session.close();
          }), session.once("connect", () => {
            debug(`session ${origin} established`), debug(`caching session ${origin}`), sessionCache[origin] = session;
          }), session.on("localSettings", settings => {
            debug(`session ${origin} localSettings: ${JSON.stringify(settings)}`);
          }), session.on("remoteSettings", settings => {
            debug(`session ${origin} remoteSettings: ${JSON.stringify(settings)}`);
          }), session.once("close", () => {
            debug(`session ${origin} closed`), sessionCache[origin] === session && (debug(`discarding cached session ${origin}`), delete sessionCache[origin]);
          }), session.once("error", err => {
            debug(`session ${origin} encountered error: ${err}`), sessionCache[origin] === session && (debug(`discarding cached session ${origin}`), delete sessionCache[origin]);
          }), session.on("frameError", (type, code, id) => {
            debug(`session ${origin} encountered frameError: type: ${type}, code: ${code}, id: ${id}`);
          }), session.once("goaway", (errorCode, lastStreamID, opaqueData) => {
            debug(`session ${origin} received GOAWAY frame: errorCode: ${errorCode}, lastStreamID: ${lastStreamID}, opaqueData: ${opaqueData ? opaqueData.toString() : void 0}`);
          }), session.on("stream", (stream, hdrs, flags) => {
            handlePush(ctx, origin, decode, stream, hdrs, flags);
          });
        } else socket && socket.id !== session.socket.id && !socket.inUse && (debug(`discarding redundant socket used for ALPN: #${socket.id} ${socket.servername}`), socket.destroy());
        debug(`${method} ${url.host}${path}`);
        let req,
          {
            signal: signal
          } = opts,
          onAbortSignal = __name(() => {
            signal.removeEventListener("abort", onAbortSignal), reject(new RequestAbortedError()), req && req.close(NGHTTP2_CANCEL);
          }, "onAbortSignal");
        if (signal) {
          if (signal.aborted) {
            reject(new RequestAbortedError());
            return;
          }
          signal.addEventListener("abort", onAbortSignal);
        }
        let onSessionError = __name(err => {
          debug(`session ${origin} encountered error during ${opts.method} ${url.href}: ${err}`), reject(err);
        }, "onSessionError");
        session.once("error", onSessionError), req = session.request({
          ":method": method,
          ":path": path,
          ...headers
        }), req.once("response", hdrs => {
          session.off("error", onSessionError), signal && signal.removeEventListener("abort", onAbortSignal), resolve(createResponse(hdrs, req, opts.decode, reject));
        }), req.once("error", err => {
          session.off("error", onSessionError), signal && signal.removeEventListener("abort", onAbortSignal), req.rstCode !== NGHTTP2_CANCEL && (debug(`${opts.method} ${url.href} failed with: ${err.message}`), req.close(NGHTTP2_CANCEL), reject(err));
        }), req.once("frameError", (type, code, id) => {
          session.off("error", onSessionError), debug(`encountered frameError during ${opts.method} ${url.href}: type: ${type}, code: ${code}, id: ${id}`);
        }), req.on("push", (hdrs, flags) => {
          debug(`received 'push' event: headers: ${JSON.stringify(hdrs)}, flags: ${flags}`);
        }), body instanceof Readable ? body.pipe(req) : (body && req.write(body), req.end());
      });
    }, "request");
  module.exports = {
    request: request,
    setupContext: setupContext,
    resetContext: resetContext
  };
});