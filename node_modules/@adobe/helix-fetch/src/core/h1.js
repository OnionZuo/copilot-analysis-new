var require_h1 = __commonJSMin((exports, module) => {
  "use strict";

  var http = require("http"),
    https = require("https"),
    {
      Readable: Readable
    } = require("stream"),
    debug = b_()("helix-fetch:h1"),
    {
      RequestAbortedError: RequestAbortedError
    } = nN(),
    {
      decodeStream: decodeStream
    } = gh(),
    getAgent = __name((ctx, protocol) => {
      let {
        h1: h1,
        options: {
          h1: opts,
          rejectUnauthorized: rejectUnauthorized
        }
      } = ctx;
      return protocol === "https:" ? h1.httpsAgent ? h1.httpsAgent : opts || typeof rejectUnauthorized == "boolean" ? (h1.httpsAgent = new https.Agent(typeof rejectUnauthorized == "boolean" ? {
        ...(opts || {}),
        rejectUnauthorized: rejectUnauthorized
      } : opts), h1.httpsAgent) : void 0 : h1.httpAgent ? h1.httpAgent : opts ? (h1.httpAgent = new http.Agent(opts), h1.httpAgent) : void 0;
    }, "getAgent"),
    setupContext = __name(ctx => {
      ctx.h1 = {};
    }, "setupContext"),
    resetContext = __name(async ({
      h1: h1
    }) => {
      h1.httpAgent && (debug("resetContext: destroying httpAgent"), h1.httpAgent.destroy(), delete h1.httpAgent), h1.httpsAgent && (debug("resetContext: destroying httpsAgent"), h1.httpsAgent.destroy(), delete h1.httpsAgent);
    }, "resetContext"),
    createResponse = __name((incomingMessage, decode, onError) => {
      let {
          statusCode: statusCode,
          statusMessage: statusMessage,
          httpVersion: httpVersion,
          httpVersionMajor: httpVersionMajor,
          httpVersionMinor: httpVersionMinor,
          headers: headers
        } = incomingMessage,
        readable = decode ? decodeStream(statusCode, headers, incomingMessage, onError) : incomingMessage;
      return {
        statusCode: statusCode,
        statusText: statusMessage,
        httpVersion: httpVersion,
        httpVersionMajor: httpVersionMajor,
        httpVersionMinor: httpVersionMinor,
        headers: headers,
        readable: readable,
        decoded: !!(decode && readable !== incomingMessage)
      };
    }, "createResponse"),
    h1Request = __name(async (ctx, url, options) => {
      let {
          request: request
        } = url.protocol === "https:" ? https : http,
        agent = getAgent(ctx, url.protocol),
        opts = {
          ...options,
          agent: agent
        },
        {
          socket: socket,
          body: body
        } = opts;
      return socket && (delete opts.socket, socket.assigned || (socket.assigned = !0, agent ? opts.agent = new Proxy(agent, {
        get: __name((target, property) => property === "createConnection" && !socket.inUse ? (_connectOptions, cb) => {
          debug(`agent reusing socket #${socket.id} (${socket.servername})`), socket.inUse = !0, cb(null, socket);
        } : target[property], "get")
      }) : opts.createConnection = (_connectOptions, cb) => {
        debug(`reusing socket #${socket.id} (${socket.servername})`), socket.inUse = !0, cb(null, socket);
      })), new Promise((resolve, reject) => {
        debug(`${opts.method} ${url.href}`);
        let req,
          {
            signal: signal
          } = opts,
          onAbortSignal = __name(() => {
            signal.removeEventListener("abort", onAbortSignal), socket && !socket.inUse && (debug(`discarding redundant socket used for ALPN: #${socket.id} ${socket.servername}`), socket.destroy()), reject(new RequestAbortedError()), req && req.abort();
          }, "onAbortSignal");
        if (signal) {
          if (signal.aborted) {
            reject(new RequestAbortedError());
            return;
          }
          signal.addEventListener("abort", onAbortSignal);
        }
        req = request(url, opts), req.once("response", res => {
          signal && signal.removeEventListener("abort", onAbortSignal), socket && !socket.inUse && (debug(`discarding redundant socket used for ALPN: #${socket.id} ${socket.servername}`), socket.destroy()), resolve(createResponse(res, opts.decode, reject));
        }), req.once("error", err => {
          signal && signal.removeEventListener("abort", onAbortSignal), socket && !socket.inUse && (debug(`discarding redundant socket used for ALPN: #${socket.id} ${socket.servername}`), socket.destroy()), req.aborted || (debug(`${opts.method} ${url.href} failed with: ${err.message}`), req.abort(), reject(err));
        }), body instanceof Readable ? body.pipe(req) : (body && req.write(body), req.end());
      });
    }, "h1Request");
  module.exports = {
    request: h1Request,
    setupContext: setupContext,
    resetContext: resetContext
  };
});