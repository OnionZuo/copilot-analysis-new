var require_request = __commonJSMin((exports, module) => {
  "use strict";

  var {
      Readable: Readable
    } = require("stream"),
    tls = require("tls"),
    {
      types: {
        isAnyArrayBuffer: isAnyArrayBuffer
      }
    } = require("util"),
    LRU = BZ(),
    debug = b_()("helix-fetch:core"),
    {
      RequestAbortedError: RequestAbortedError
    } = nN(),
    h1 = jke(),
    h2 = Zke(),
    lock = Wke(),
    {
      isPlainObject: isPlainObject
    } = gh(),
    {
      isFormData: isFormData,
      FormDataSerializer: FormDataSerializer
    } = WD(),
    {
      version: version
    } = Yke(),
    ALPN_HTTP2 = "h2",
    ALPN_HTTP2C = "h2c",
    ALPN_HTTP1_0 = "http/1.0",
    ALPN_HTTP1_1 = "http/1.1",
    ALPN_CACHE_SIZE = 100,
    ALPN_CACHE_TTL = 60 * 60 * 1e3,
    ALPN_PROTOCOLS = [ALPN_HTTP2, ALPN_HTTP1_1, ALPN_HTTP1_0],
    DEFAULT_USER_AGENT = `helix-fetch/${version}`,
    DEFAULT_OPTIONS = {
      method: "GET",
      compress: !0,
      decode: !0
    },
    socketIdCounter = 0,
    connectionLock = lock(),
    connectTLS = __name((url, options) => new Promise((resolve, reject) => {
      let {
          signal: signal
        } = options,
        socket,
        onAbortSignal = __name(() => {
          signal.removeEventListener("abort", onAbortSignal);
          let err = new RequestAbortedError();
          reject(err), socket && socket.destroy(err);
        }, "onAbortSignal");
      if (signal) {
        if (signal.aborted) {
          reject(new RequestAbortedError());
          return;
        }
        signal.addEventListener("abort", onAbortSignal);
      }
      let port = +url.port || 443,
        onError = __name(err => {
          signal && signal.removeEventListener("abort", onAbortSignal), err instanceof RequestAbortedError || (debug(`connecting to ${url.hostname}:${port} failed with: ${err.message}`), reject(err));
        }, "onError");
      socket = tls.connect(port, url.hostname, options), socket.once("secureConnect", () => {
        signal && signal.removeEventListener("abort", onAbortSignal), socket.off("error", onError), socketIdCounter += 1, socket.id = socketIdCounter, socket.secureConnecting = !1, debug(`established TLS connection: #${socket.id} (${socket.servername})`), resolve(socket);
      }), socket.once("error", onError);
    }), "connectTLS"),
    connect = __name(async (url, options) => {
      let socket = await connectionLock.acquire(url.origin);
      try {
        return socket || (socket = await connectTLS(url, options)), socket;
      } finally {
        connectionLock.release(url.origin, socket);
      }
    }, "connect"),
    determineProtocol = __name(async (ctx, url, signal) => {
      let origin = `${url.protocol}//${url.host}`,
        protocol = ctx.alpnCache.get(origin);
      if (protocol) return {
        protocol: protocol
      };
      switch (url.protocol) {
        case "http:":
          return protocol = ALPN_HTTP1_1, ctx.alpnCache.set(origin, protocol), {
            protocol: protocol
          };
        case "http2:":
          return protocol = ALPN_HTTP2C, ctx.alpnCache.set(origin, protocol), {
            protocol: protocol
          };
        case "https:":
          break;
        default:
          throw new TypeError(`unsupported protocol: ${url.protocol}`);
      }
      let {
          options: {
            rejectUnauthorized: _rejectUnauthorized,
            h1: h1Opts = {},
            h2: h2Opts = {}
          }
        } = ctx,
        rejectUnauthorized = !(_rejectUnauthorized === !1 || h1Opts.rejectUnauthorized === !1 || h2Opts.rejectUnauthorized === !1),
        connectOptions = {
          servername: url.hostname,
          ALPNProtocols: ctx.alpnProtocols,
          signal: signal,
          rejectUnauthorized: rejectUnauthorized
        };
      ctx.options.ca && (connectOptions.ca = ctx.options.ca);
      let socket = await connect(url, connectOptions);
      return protocol = socket.alpnProtocol, protocol || (protocol = ALPN_HTTP1_1), ctx.alpnCache.set(origin, protocol), {
        protocol: protocol,
        socket: socket
      };
    }, "determineProtocol"),
    sanitizeHeaders = __name(headers => {
      let result = {};
      return Object.keys(headers).forEach(name => {
        result[name.toLowerCase()] = headers[name];
      }), result;
    }, "sanitizeHeaders"),
    getProtocolAndSocketFromFactory = __name(async (socketFactory, url, requestOptions, alpns) => {
      let isSecure = url.protocol === "https:",
        port;
      url.port ? port = url.port : isSecure ? port = 443 : port = 80;
      let options = {
          ...requestOptions,
          host: url.host,
          hostname: url.hostname,
          port: port
        },
        socket = await socketFactory(options);
      if (isSecure) {
        let secOpts = {
          ...options,
          ALPNProtocols: alpns
        };
        secOpts.socket = socket, secOpts.servername = options.host;
        let secureSocket = await connectTLS(url, secOpts);
        return {
          protocol: secureSocket.alpnProtocol || ALPN_HTTP1_1,
          socket: secureSocket
        };
      }
      return {
        protocol: socket.alpnProtocol || ALPN_HTTP1_1,
        socket: socket
      };
    }, "getProtocolAndSocketFromFactory"),
    request = __name(async (ctx, uri, options) => {
      let url = new URL(uri),
        opts = {
          ...DEFAULT_OPTIONS,
          ...(options || {})
        };
      typeof opts.method == "string" && (opts.method = opts.method.toUpperCase()), opts.headers = sanitizeHeaders(opts.headers || {}), opts.headers.host === void 0 && (opts.headers.host = url.host), ctx.userAgent && opts.headers["user-agent"] === void 0 && (opts.headers["user-agent"] = ctx.userAgent);
      let contentType;
      if (opts.body instanceof URLSearchParams) contentType = "application/x-www-form-urlencoded; charset=utf-8", opts.body = opts.body.toString();else if (isFormData(opts.body)) {
        let fd = new FormDataSerializer(opts.body);
        contentType = fd.contentType(), opts.body = fd.stream(), opts.headers["transfer-encoding"] === void 0 && opts.headers["content-length"] === void 0 && (opts.headers["content-length"] = String(fd.length()));
      } else typeof opts.body == "string" || opts.body instanceof String ? contentType = "text/plain; charset=utf-8" : isPlainObject(opts.body) ? (opts.body = JSON.stringify(opts.body), contentType = "application/json") : isAnyArrayBuffer(opts.body) && (opts.body = Buffer.from(opts.body));
      opts.headers["content-type"] === void 0 && contentType !== void 0 && (opts.headers["content-type"] = contentType), opts.body != null && (opts.body instanceof Readable || (!(typeof opts.body == "string" || opts.body instanceof String) && !Buffer.isBuffer(opts.body) && (opts.body = String(opts.body)), opts.headers["transfer-encoding"] === void 0 && opts.headers["content-length"] === void 0 && (opts.headers["content-length"] = String(Buffer.isBuffer(opts.body) ? opts.body.length : Buffer.byteLength(opts.body, "utf-8"))))), opts.headers.accept === void 0 && (opts.headers.accept = "*/*"), opts.body == null && ["POST", "PUT"].includes(opts.method) && (opts.headers["content-length"] = "0"), opts.compress && opts.headers["accept-encoding"] === void 0 && (opts.headers["accept-encoding"] = "gzip,deflate,br");
      let {
          signal: signal
        } = opts,
        {
          protocol: protocol,
          socket = null
        } = ctx.socketFactory ? await getProtocolAndSocketFromFactory(ctx.socketFactory, url, opts, ctx.alpnProtocols) : await determineProtocol(ctx, url, signal);
      switch (debug(`${url.host} -> ${protocol}`), protocol) {
        case ALPN_HTTP2:
          try {
            return await h2.request(ctx, url, socket ? {
              ...opts,
              socket: socket
            } : opts);
          } catch (err) {
            let {
              code: code,
              message: message
            } = err;
            throw code === "ERR_HTTP2_ERROR" && message === "Protocol error" && ctx.alpnCache.delete(`${url.protocol}//${url.host}`), err;
          }
        case ALPN_HTTP2C:
          return h2.request(ctx, new URL(`http://${url.host}${url.pathname}${url.hash}${url.search}`), socket ? {
            ...opts,
            socket: socket
          } : opts);
        case ALPN_HTTP1_0:
        case ALPN_HTTP1_1:
          return h1.request(ctx, url, socket ? {
            ...opts,
            socket: socket
          } : opts);
        default:
          throw new TypeError(`unsupported protocol: ${protocol}`);
      }
    }, "request"),
    resetContext = __name(async ctx => (ctx.alpnCache.clear(), Promise.all([h1.resetContext(ctx), h2.resetContext(ctx)])), "resetContext"),
    setupContext = __name(ctx => {
      let {
        options: {
          alpnProtocols = ALPN_PROTOCOLS,
          alpnCacheTTL = ALPN_CACHE_TTL,
          alpnCacheSize = ALPN_CACHE_SIZE,
          userAgent = DEFAULT_USER_AGENT,
          socketFactory: socketFactory
        }
      } = ctx;
      ctx.alpnProtocols = alpnProtocols, ctx.alpnCache = new LRU({
        max: alpnCacheSize,
        ttl: alpnCacheTTL
      }), ctx.userAgent = userAgent, ctx.socketFactory = socketFactory, h1.setupContext(ctx), h2.setupContext(ctx);
    }, "setupContext");
  module.exports = {
    request: request,
    setupContext: setupContext,
    resetContext: resetContext,
    RequestAbortedError: RequestAbortedError,
    ALPN_HTTP2: ALPN_HTTP2,
    ALPN_HTTP2C: ALPN_HTTP2C,
    ALPN_HTTP1_1: ALPN_HTTP1_1,
    ALPN_HTTP1_0: ALPN_HTTP1_0
  };
});