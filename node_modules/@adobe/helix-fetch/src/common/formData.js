var require_formData = __commonJSMin((exports, module) => {
  "use strict";

  var {
      randomBytes: randomBytes
    } = require("crypto"),
    {
      Readable: Readable
    } = require("stream"),
    isBlob = __name(obj => typeof obj == "object" && ["arrayBuffer", "stream", "text", "slice", "constructor"].map(nm => typeof obj[nm]).filter(type => type !== "function").length === 0 && typeof obj.type == "string" && typeof obj.size == "number" && /^(Blob|File)$/.test(obj[Symbol.toStringTag]), "isBlob"),
    isFormData = __name(obj => obj != null && typeof obj == "object" && ["append", "delete", "get", "getAll", "has", "set", "keys", "values", "entries", "constructor"].map(nm => typeof obj[nm]).filter(type => type !== "function").length === 0 && obj[Symbol.toStringTag] === "FormData", "isFormData"),
    getFooter = __name(boundary => `--${boundary}--\r
\r
`, "getFooter"),
    getHeader = __name((boundary, name, field) => {
      let header = "";
      return header += `--${boundary}\r
`, header += `Content-Disposition: form-data; name="${name}"`, isBlob(field) && (header += `; filename="${field.name}"\r
`, header += `Content-Type: ${field.type || "application/octet-stream"}`), `${header}\r
\r
`;
    }, "getHeader");
  async function* formDataIterator(form, boundary) {
    for (let [name, value] of form) yield getHeader(boundary, name, value), isBlob(value) ? yield* value.stream() : yield value, yield `\r
`;
    yield getFooter(boundary);
  }
  __name(formDataIterator, "formDataIterator");
  var getFormDataLength = __name((form, boundary) => {
      let length = 0;
      for (let [name, value] of form) length += Buffer.byteLength(getHeader(boundary, name, value)), length += isBlob(value) ? value.size : Buffer.byteLength(String(value)), length += Buffer.byteLength(`\r
`);
      return length += Buffer.byteLength(getFooter(boundary)), length;
    }, "getFormDataLength"),
    _FormDataSerializer = class _FormDataSerializer {
      constructor(formData) {
        this.fd = formData, this.boundary = randomBytes(8).toString("hex");
      }
      length() {
        return typeof this._length > "u" && (this._length = getFormDataLength(this.fd, this.boundary)), this._length;
      }
      contentType() {
        return `multipart/form-data; boundary=${this.boundary}`;
      }
      stream() {
        return Readable.from(formDataIterator(this.fd, this.boundary));
      }
    };
  __name(_FormDataSerializer, "FormDataSerializer");
  var FormDataSerializer = _FormDataSerializer;
  module.exports = {
    isFormData: isFormData,
    FormDataSerializer: FormDataSerializer
  };
});