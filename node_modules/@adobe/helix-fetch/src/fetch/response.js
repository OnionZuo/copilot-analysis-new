var require_response = __commonJSMin((exports, module) => {
  "use strict";

  var {
      Body: Body,
      cloneStream: cloneStream,
      guessContentType: guessContentType
    } = HT(),
    {
      Headers: Headers
    } = DB(),
    {
      isPlainObject: isPlainObject
    } = gh(),
    {
      isFormData: isFormData,
      FormDataSerializer: FormDataSerializer
    } = WD(),
    INTERNALS = Symbol("Response internals"),
    _Response = class _Response extends Body {
      constructor(body = null, init = {}) {
        let headers = new Headers(init.headers),
          respBody = body;
        if (isFormData(respBody) && !headers.has("content-type")) {
          let fd = new FormDataSerializer(respBody);
          respBody = fd.stream(), headers.set("content-type", fd.contentType()), !headers.has("transfer-encoding") && !headers.has("content-length") && headers.set("content-length", fd.length());
        }
        if (respBody !== null && !headers.has("content-type")) if (isPlainObject(respBody)) respBody = JSON.stringify(respBody), headers.set("content-type", "application/json");else {
          let contentType = guessContentType(respBody);
          contentType && headers.set("content-type", contentType);
        }
        super(respBody), this[INTERNALS] = {
          url: init.url,
          status: init.status || 200,
          statusText: init.statusText || "",
          headers: headers,
          httpVersion: init.httpVersion,
          decoded: init.decoded,
          counter: init.counter
        };
      }
      get url() {
        return this[INTERNALS].url || "";
      }
      get status() {
        return this[INTERNALS].status;
      }
      get statusText() {
        return this[INTERNALS].statusText;
      }
      get ok() {
        return this[INTERNALS].status >= 200 && this[INTERNALS].status < 300;
      }
      get redirected() {
        return this[INTERNALS].counter > 0;
      }
      get headers() {
        return this[INTERNALS].headers;
      }
      get httpVersion() {
        return this[INTERNALS].httpVersion;
      }
      get decoded() {
        return this[INTERNALS].decoded;
      }
      static redirect(url, status = 302) {
        if (![301, 302, 303, 307, 308].includes(status)) throw new RangeError("Invalid status code");
        return new _Response(null, {
          headers: {
            location: new URL(url).toString()
          },
          status: status
        });
      }
      clone() {
        if (this.bodyUsed) throw new TypeError("Cannot clone: already read");
        return new _Response(cloneStream(this), {
          ...this[INTERNALS]
        });
      }
      get [Symbol.toStringTag]() {
        return this.constructor.name;
      }
    };
  __name(_Response, "Response");
  var Response = _Response;
  Object.defineProperties(Response.prototype, {
    url: {
      enumerable: !0
    },
    status: {
      enumerable: !0
    },
    ok: {
      enumerable: !0
    },
    redirected: {
      enumerable: !0
    },
    statusText: {
      enumerable: !0
    },
    headers: {
      enumerable: !0
    },
    clone: {
      enumerable: !0
    }
  });
  module.exports = {
    Response: Response
  };
});