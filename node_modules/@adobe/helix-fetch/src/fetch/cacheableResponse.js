var require_cacheableResponse = __commonJSMin((exports, module) => {
  "use strict";

  var {
      Readable: Readable
    } = require("stream"),
    {
      Headers: Headers
    } = DB(),
    {
      Response: Response
    } = qZ(),
    INTERNALS = Symbol("CacheableResponse internals"),
    toArrayBuffer = __name(buf => buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength), "toArrayBuffer"),
    _CacheableResponse = class _CacheableResponse extends Response {
      constructor(body, init) {
        super(body, init);
        let headers = new Headers(init.headers);
        this[INTERNALS] = {
          headers: headers,
          bufferedBody: body
        };
      }
      get headers() {
        return this[INTERNALS].headers;
      }
      set headers(headers) {
        if (headers instanceof Headers) this[INTERNALS].headers = headers;else throw new TypeError("instance of Headers expected");
      }
      get body() {
        return Readable.from(this[INTERNALS].bufferedBody);
      }
      get bodyUsed() {
        return !1;
      }
      async buffer() {
        return this[INTERNALS].bufferedBody;
      }
      async arrayBuffer() {
        return toArrayBuffer(this[INTERNALS].bufferedBody);
      }
      async text() {
        return this[INTERNALS].bufferedBody.toString();
      }
      async json() {
        return JSON.parse(await this.text());
      }
      clone() {
        let {
          url: url,
          status: status,
          statusText: statusText,
          headers: headers,
          httpVersion: httpVersion,
          decoded: decoded,
          counter: counter
        } = this;
        return new _CacheableResponse(this[INTERNALS].bufferedBody, {
          url: url,
          status: status,
          statusText: statusText,
          headers: headers,
          httpVersion: httpVersion,
          decoded: decoded,
          counter: counter
        });
      }
      get [Symbol.toStringTag]() {
        return this.constructor.name;
      }
    };
  __name(_CacheableResponse, "CacheableResponse");
  var CacheableResponse = _CacheableResponse,
    cacheableResponse = __name(async res => {
      let buf = await res.buffer(),
        {
          url: url,
          status: status,
          statusText: statusText,
          headers: headers,
          httpVersion: httpVersion,
          decoded: decoded,
          counter: counter
        } = res;
      return new CacheableResponse(buf, {
        url: url,
        status: status,
        statusText: statusText,
        headers: headers,
        httpVersion: httpVersion,
        decoded: decoded,
        counter: counter
      });
    }, "cacheableResponse");
  module.exports = {
    cacheableResponse: cacheableResponse
  };
});