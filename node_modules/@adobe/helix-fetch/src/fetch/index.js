var require_fetch = __commonJSMin((exports, module) => {
  "use strict";

  var {
      EventEmitter: EventEmitter
    } = require("events"),
    {
      Readable: Readable
    } = require("stream"),
    debug = b_()("helix-fetch"),
    LRU = BZ(),
    {
      Body: Body
    } = HT(),
    {
      Headers: Headers
    } = DB(),
    {
      Request: Request
    } = Bke(),
    {
      Response: Response
    } = qZ(),
    {
      FetchBaseError: FetchBaseError,
      FetchError: FetchError,
      AbortError: AbortError
    } = FZ(),
    {
      AbortController: AbortController,
      AbortSignal: AbortSignal,
      TimeoutSignal: TimeoutSignal
    } = PZ(),
    CachePolicy = Tke(),
    {
      cacheableResponse: cacheableResponse
    } = Lke(),
    {
      sizeof: sizeof
    } = gh(),
    {
      isFormData: isFormData
    } = WD(),
    {
      context: context,
      RequestAbortedError: RequestAbortedError
    } = nEe(),
    CACHEABLE_METHODS = ["GET", "HEAD"],
    DEFAULT_MAX_CACHE_ITEMS = 500,
    DEFAULT_MAX_CACHE_SIZE = 100 * 1024 * 1024,
    PUSH_EVENT = "push",
    fetch = __name(async (ctx, url, options) => {
      let {
          request: request
        } = ctx.context,
        req = url instanceof Request && typeof options > "u" ? url : new Request(url, options),
        {
          method: method,
          body: body,
          signal: signal,
          compress: compress,
          decode: decode,
          follow: follow,
          redirect: redirect,
          init: {
            body: initBody
          }
        } = req,
        coreResp;
      if (signal && signal.aborted) {
        let err = new AbortError("The operation was aborted.");
        throw req.init.body instanceof Readable && req.init.body.destroy(err), err;
      }
      try {
        coreResp = await request(req.url, {
          ...options,
          method: method,
          headers: req.headers.plain(),
          body: initBody && !(initBody instanceof Readable) && !isFormData(initBody) ? initBody : body,
          compress: compress,
          decode: decode,
          follow: follow,
          redirect: redirect,
          signal: signal
        });
      } catch (err) {
        throw initBody instanceof Readable && initBody.destroy(err), err instanceof TypeError ? err : err instanceof RequestAbortedError ? new AbortError("The operation was aborted.") : new FetchError(err.message, "system", err);
      }
      let abortHandler = __name(() => {
        signal.removeEventListener("abort", abortHandler);
        let err = new AbortError("The operation was aborted.");
        req.init.body instanceof Readable && req.init.body.destroy(err), coreResp.readable.emit("error", err);
      }, "abortHandler");
      signal && signal.addEventListener("abort", abortHandler);
      let {
        statusCode: statusCode,
        statusText: statusText,
        httpVersion: httpVersion,
        headers: headers,
        readable: readable,
        decoded: decoded
      } = coreResp;
      if ([301, 302, 303, 307, 308].includes(statusCode)) {
        let {
            location: location
          } = headers,
          locationURL = location == null ? null : new URL(location, req.url);
        switch (req.redirect) {
          case "manual":
            break;
          case "error":
            throw signal && signal.removeEventListener("abort", abortHandler), new FetchError(`uri requested responds with a redirect, redirect mode is set to 'error': ${req.url}`, "no-redirect");
          case "follow":
            {
              if (locationURL === null) break;
              if (req.counter >= req.follow) throw signal && signal.removeEventListener("abort", abortHandler), new FetchError(`maximum redirect reached at: ${req.url}`, "max-redirect");
              let requestOptions = {
                headers: new Headers(req.headers),
                follow: req.follow,
                compress: req.compress,
                decode: req.decode,
                counter: req.counter + 1,
                method: req.method,
                body: req.body,
                signal: req.signal
              };
              if (statusCode !== 303 && req.body && req.init.body instanceof Readable) throw signal && signal.removeEventListener("abort", abortHandler), new FetchError("Cannot follow redirect with body being a readable stream", "unsupported-redirect");
              return (statusCode === 303 || (statusCode === 301 || statusCode === 302) && req.method === "POST") && (requestOptions.method = "GET", requestOptions.body = void 0, requestOptions.headers.delete("content-length")), signal && signal.removeEventListener("abort", abortHandler), fetch(ctx, new Request(locationURL, requestOptions));
            }
          default:
        }
      }
      return signal && (readable.once("end", () => {
        signal.removeEventListener("abort", abortHandler);
      }), readable.once("error", () => {
        signal.removeEventListener("abort", abortHandler);
      })), new Response(readable, {
        url: req.url,
        status: statusCode,
        statusText: statusText,
        headers: headers,
        httpVersion: httpVersion,
        decoded: decoded,
        counter: req.counter
      });
    }, "fetch"),
    cacheResponse = __name(async (ctx, request, response) => {
      if (ctx.options.maxCacheSize === 0 || !CACHEABLE_METHODS.includes(request.method)) return response;
      let policy = new CachePolicy(request, response, {
        shared: !1
      });
      if (policy.storable()) {
        let cacheable = await cacheableResponse(response);
        return ctx.cache.set(request.url, {
          policy: policy,
          response: cacheable
        }, policy.timeToLive()), cacheable;
      } else return response;
    }, "cacheResponse"),
    cachingFetch = __name(async (ctx, url, options) => {
      let req = new Request(url, options);
      if (ctx.options.maxCacheSize !== 0 && CACHEABLE_METHODS.includes(req.method) && !["no-store", "reload"].includes(req.cache)) {
        let {
          policy: policy,
          response: response
        } = ctx.cache.get(req.url) || {};
        if (policy && policy.satisfiesWithoutRevalidation(req)) {
          response.headers = new Headers(policy.responseHeaders(response));
          let resp = response.clone();
          return resp.fromCache = !0, resp;
        }
      }
      let resp = await fetch(ctx, req);
      return req.cache !== "no-store" ? cacheResponse(ctx, req, resp) : resp;
    }, "cachingFetch"),
    createUrl = __name((url, qs = {}) => {
      let urlWithQuery = new URL(url);
      if (typeof qs != "object" || Array.isArray(qs)) throw new TypeError("qs: object expected");
      return Object.entries(qs).forEach(([k, v]) => {
        Array.isArray(v) ? v.forEach(entry => urlWithQuery.searchParams.append(k, entry)) : urlWithQuery.searchParams.append(k, v);
      }), urlWithQuery.href;
    }, "createUrl"),
    timeoutSignal = __name(ms => new TimeoutSignal(ms), "timeoutSignal"),
    _FetchContext = class _FetchContext {
      constructor(options) {
        this.options = {
          ...options
        };
        let {
            maxCacheSize: maxCacheSize
          } = this.options,
          maxSize = typeof maxCacheSize == "number" && maxCacheSize >= 0 ? maxCacheSize : DEFAULT_MAX_CACHE_SIZE,
          max = DEFAULT_MAX_CACHE_ITEMS;
        maxSize === 0 && (maxSize = 1, max = 1);
        let sizeCalculation = __name(({
          response: response
        }, _) => sizeof(response), "sizeCalculation");
        this.cache = new LRU({
          max: max,
          maxSize: maxSize,
          sizeCalculation: sizeCalculation
        }), this.eventEmitter = new EventEmitter(), this.options.h2 = this.options.h2 || {}, typeof this.options.h2.enablePush > "u" && (this.options.h2.enablePush = !0);
        let {
          enablePush: enablePush
        } = this.options.h2;
        enablePush && (this.options.h2.pushPromiseHandler = (url, headers, reject) => {
          let hdrs = {
            ...headers
          };
          Object.keys(hdrs).filter(name => name.startsWith(":")).forEach(name => delete hdrs[name]), this.pushPromiseHandler(url, hdrs, reject);
        }, this.options.h2.pushHandler = (url, reqHeaders, response) => {
          let hdrs = {
            ...reqHeaders
          };
          Object.keys(hdrs).filter(name => name.startsWith(":")).forEach(name => delete hdrs[name]);
          let {
            statusCode: statusCode,
            statusText: statusText,
            httpVersion: httpVersion,
            headers: headers,
            readable: readable,
            decoded: decoded
          } = response;
          this.pushHandler(url, hdrs, new Response(readable, {
            url: url,
            status: statusCode,
            statusText: statusText,
            headers: headers,
            httpVersion: httpVersion,
            decoded: decoded
          }));
        }), this.context = context(this.options);
      }
      api() {
        return {
          fetch: __name(async (url, options) => this.fetch(url, options), "fetch"),
          Body: Body,
          Headers: Headers,
          Request: Request,
          Response: Response,
          AbortController: AbortController,
          AbortSignal: AbortSignal,
          FetchBaseError: FetchBaseError,
          FetchError: FetchError,
          AbortError: AbortError,
          context: __name((options = {}) => new _FetchContext(options).api(), "context"),
          setCA: __name(ca => this.setCA(ca), "setCA"),
          noCache: __name((options = {}) => new _FetchContext({
            ...options,
            maxCacheSize: 0
          }).api(), "noCache"),
          h1: __name((options = {}) => new _FetchContext({
            ...options,
            alpnProtocols: [this.context.ALPN_HTTP1_1]
          }).api(), "h1"),
          keepAlive: __name((options = {}) => new _FetchContext({
            ...options,
            alpnProtocols: [this.context.ALPN_HTTP1_1],
            h1: {
              keepAlive: !0
            }
          }).api(), "keepAlive"),
          h1NoCache: __name((options = {}) => new _FetchContext({
            ...options,
            maxCacheSize: 0,
            alpnProtocols: [this.context.ALPN_HTTP1_1]
          }).api(), "h1NoCache"),
          keepAliveNoCache: __name((options = {}) => new _FetchContext({
            ...options,
            maxCacheSize: 0,
            alpnProtocols: [this.context.ALPN_HTTP1_1],
            h1: {
              keepAlive: !0
            }
          }).api(), "keepAliveNoCache"),
          reset: __name(async () => this.context.reset(), "reset"),
          onPush: __name(fn => this.onPush(fn), "onPush"),
          offPush: __name(fn => this.offPush(fn), "offPush"),
          createUrl: createUrl,
          timeoutSignal: timeoutSignal,
          clearCache: __name(() => this.clearCache(), "clearCache"),
          cacheStats: __name(() => this.cacheStats(), "cacheStats"),
          ALPN_HTTP2: this.context.ALPN_HTTP2,
          ALPN_HTTP2C: this.context.ALPN_HTTP2C,
          ALPN_HTTP1_1: this.context.ALPN_HTTP1_1,
          ALPN_HTTP1_0: this.context.ALPN_HTTP1_0
        };
      }
      async fetch(url, options) {
        return cachingFetch(this, url, options);
      }
      setCA(ca) {
        this.options.ca = ca, this.context.setCA(ca);
      }
      onPush(fn) {
        return this.eventEmitter.on(PUSH_EVENT, fn);
      }
      offPush(fn) {
        return this.eventEmitter.off(PUSH_EVENT, fn);
      }
      clearCache() {
        this.cache.clear();
      }
      cacheStats() {
        return {
          size: this.cache.calculatedSize,
          count: this.cache.size
        };
      }
      pushPromiseHandler(url, headers, reject) {
        debug(`received server push promise: ${url}, headers: ${JSON.stringify(headers)}`);
        let req = new Request(url, {
            headers: headers
          }),
          {
            policy: policy
          } = this.cache.get(url) || {};
        policy && policy.satisfiesWithoutRevalidation(req) && (debug(`already cached, reject push promise: ${url}, headers: ${JSON.stringify(headers)}`), reject());
      }
      async pushHandler(url, headers, response) {
        debug(`caching resource pushed by server: ${url}, reqHeaders: ${JSON.stringify(headers)}, status: ${response.status}, respHeaders: ${JSON.stringify(response.headers)}`);
        let cachedResponse = await cacheResponse(this, new Request(url, {
          headers: headers
        }), response);
        this.eventEmitter.emit(PUSH_EVENT, url, cachedResponse);
      }
    };
  __name(_FetchContext, "FetchContext");
  var FetchContext = _FetchContext;
  module.exports = new FetchContext().api();
});