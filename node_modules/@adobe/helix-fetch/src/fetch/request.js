var require_request = __commonJSMin((exports, module) => {
  "use strict";

  var {
      AbortSignal: AbortSignal
    } = PZ(),
    {
      Body: Body,
      cloneStream: cloneStream,
      guessContentType: guessContentType
    } = HT(),
    {
      Headers: Headers
    } = DB(),
    {
      isPlainObject: isPlainObject
    } = gh(),
    {
      isFormData: isFormData,
      FormDataSerializer: FormDataSerializer
    } = WD(),
    DEFAULT_FOLLOW = 20,
    INTERNALS = Symbol("Request internals"),
    _Request = class _Request extends Body {
      constructor(input, init = {}) {
        let req = input instanceof _Request ? input : null,
          parsedURL = req ? new URL(req.url) : new URL(input),
          method = init.method || req && req.method || "GET";
        if (method = method.toUpperCase(), (init.body != null || req && req.body !== null) && ["GET", "HEAD"].includes(method)) throw new TypeError("Request with GET/HEAD method cannot have body");
        let body = init.body || (req && req.body ? cloneStream(req) : null),
          headers = new Headers(init.headers || req && req.headers || {});
        if (isFormData(body) && !headers.has("content-type")) {
          let fd = new FormDataSerializer(body);
          body = fd.stream(), headers.set("content-type", fd.contentType()), !headers.has("transfer-encoding") && !headers.has("content-length") && headers.set("content-length", fd.length());
        }
        if (!headers.has("content-type")) if (isPlainObject(body)) body = JSON.stringify(body), headers.set("content-type", "application/json");else {
          let contentType = guessContentType(body);
          contentType && headers.set("content-type", contentType);
        }
        super(body);
        let signal = req ? req.signal : null;
        if ("signal" in init && (signal = init.signal), signal && !(signal instanceof AbortSignal)) throw new TypeError("signal needs to be an instance of AbortSignal");
        let redirect = init.redirect || req && req.redirect || "follow";
        if (!["follow", "error", "manual"].includes(redirect)) throw new TypeError(`'${redirect}' is not a valid redirect option`);
        let cache = init.cache || req && req.cache || "default";
        if (!["default", "no-store", "reload", "no-cache", "force-cache", "only-if-cached"].includes(cache)) throw new TypeError(`'${cache}' is not a valid cache option`);
        this[INTERNALS] = {
          init: {
            ...init
          },
          method: method,
          redirect: redirect,
          cache: cache,
          headers: headers,
          parsedURL: parsedURL,
          signal: signal
        }, init.follow === void 0 ? !req || req.follow === void 0 ? this.follow = DEFAULT_FOLLOW : this.follow = req.follow : this.follow = init.follow, this.counter = init.counter || req && req.counter || 0, init.compress === void 0 ? !req || req.compress === void 0 ? this.compress = !0 : this.compress = req.compress : this.compress = init.compress, init.decode === void 0 ? !req || req.decode === void 0 ? this.decode = !0 : this.decode = req.decode : this.decode = init.decode;
      }
      get method() {
        return this[INTERNALS].method;
      }
      get url() {
        return this[INTERNALS].parsedURL.toString();
      }
      get headers() {
        return this[INTERNALS].headers;
      }
      get redirect() {
        return this[INTERNALS].redirect;
      }
      get cache() {
        return this[INTERNALS].cache;
      }
      get signal() {
        return this[INTERNALS].signal;
      }
      clone() {
        return new _Request(this);
      }
      get init() {
        return this[INTERNALS].init;
      }
      get [Symbol.toStringTag]() {
        return this.constructor.name;
      }
    };
  __name(_Request, "Request");
  var Request = _Request;
  Object.defineProperties(Request.prototype, {
    method: {
      enumerable: !0
    },
    url: {
      enumerable: !0
    },
    headers: {
      enumerable: !0
    },
    redirect: {
      enumerable: !0
    },
    cache: {
      enumerable: !0
    },
    clone: {
      enumerable: !0
    },
    signal: {
      enumerable: !0
    }
  });
  module.exports = {
    Request: Request
  };
});