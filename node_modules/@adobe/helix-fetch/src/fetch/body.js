var require_body = __commonJSMin((exports, module) => {
  "use strict";

  var {
      PassThrough: PassThrough,
      Readable: Readable
    } = require("stream"),
    {
      types: {
        isAnyArrayBuffer: isAnyArrayBuffer
      }
    } = require("util"),
    {
      FetchError: FetchError,
      FetchBaseError: FetchBaseError
    } = FZ(),
    {
      streamToBuffer: streamToBuffer
    } = gh(),
    EMPTY_BUFFER = Buffer.alloc(0),
    INTERNALS = Symbol("Body internals"),
    toArrayBuffer = __name(buf => buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength), "toArrayBuffer"),
    consume = __name(async body => {
      if (body[INTERNALS].disturbed) throw new TypeError("Already read");
      if (body[INTERNALS].error) throw new TypeError(`Stream had error: ${body[INTERNALS].error.message}`);
      body[INTERNALS].disturbed = !0;
      let {
        stream: stream
      } = body[INTERNALS];
      return stream === null ? EMPTY_BUFFER : streamToBuffer(stream);
    }, "consume"),
    _Body = class _Body {
      constructor(body) {
        let stream;
        body == null ? stream = null : body instanceof URLSearchParams ? stream = Readable.from(body.toString()) : body instanceof Readable ? stream = body : Buffer.isBuffer(body) ? stream = Readable.from(body) : isAnyArrayBuffer(body) ? stream = Readable.from(Buffer.from(body)) : typeof body == "string" || body instanceof String ? stream = Readable.from(body) : stream = Readable.from(String(body)), this[INTERNALS] = {
          stream: stream,
          disturbed: !1,
          error: null
        }, body instanceof Readable && stream.on("error", err => {
          let error = err instanceof FetchBaseError ? err : new FetchError(`Invalid response body while trying to fetch ${this.url}: ${err.message}`, "system", err);
          this[INTERNALS].error = error;
        });
      }
      get body() {
        return this[INTERNALS].stream;
      }
      get bodyUsed() {
        return this[INTERNALS].disturbed;
      }
      async buffer() {
        return consume(this);
      }
      async arrayBuffer() {
        return toArrayBuffer(await this.buffer());
      }
      async text() {
        return (await consume(this)).toString();
      }
      async json() {
        return JSON.parse(await this.text());
      }
    };
  __name(_Body, "Body");
  var Body = _Body;
  Object.defineProperties(Body.prototype, {
    body: {
      enumerable: !0
    },
    bodyUsed: {
      enumerable: !0
    },
    arrayBuffer: {
      enumerable: !0
    },
    json: {
      enumerable: !0
    },
    text: {
      enumerable: !0
    }
  });
  var cloneStream = __name(body => {
      if (body[INTERNALS].disturbed) throw new TypeError("Cannot clone: already read");
      let {
          stream: stream
        } = body[INTERNALS],
        result = stream;
      if (stream instanceof Readable) {
        result = new PassThrough();
        let clonedStream = new PassThrough();
        stream.pipe(result), stream.pipe(clonedStream), body[INTERNALS].stream = clonedStream;
      }
      return result;
    }, "cloneStream"),
    guessContentType = __name(body => body === null ? null : typeof body == "string" ? "text/plain; charset=utf-8" : body instanceof URLSearchParams ? "application/x-www-form-urlencoded; charset=utf-8" : Buffer.isBuffer(body) || isAnyArrayBuffer(body) || body instanceof Readable ? null : "text/plain; charset=utf-8", "guessContentType");
  module.exports = {
    Body: Body,
    cloneStream: cloneStream,
    guessContentType: guessContentType
  };
});