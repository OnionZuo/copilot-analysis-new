var require_headers = __commonJSMin((exports, module) => {
  "use strict";

  var {
      validateHeaderName: validateHeaderName,
      validateHeaderValue: validateHeaderValue
    } = require("http"),
    {
      isPlainObject: isPlainObject
    } = gh(),
    INTERNALS = Symbol("Headers internals"),
    normalizeName = __name(name => {
      let nm = typeof name != "string" ? String(name) : name;
      if (typeof validateHeaderName == "function") validateHeaderName(nm);else if (!/^[\^`\-\w!#$%&'*+.|~]+$/.test(nm)) {
        let err = new TypeError(`Header name must be a valid HTTP token [${nm}]`);
        throw Object.defineProperty(err, "code", {
          value: "ERR_INVALID_HTTP_TOKEN"
        }), err;
      }
      return nm.toLowerCase();
    }, "normalizeName"),
    normalizeValue = __name((value, name) => {
      let val = typeof value != "string" ? String(value) : value;
      if (typeof validateHeaderValue == "function") validateHeaderValue(name, val);else if (/[^\t\u0020-\u007E\u0080-\u00FF]/.test(val)) {
        let err = new TypeError(`Invalid character in header content ["${name}"]`);
        throw Object.defineProperty(err, "code", {
          value: "ERR_INVALID_CHAR"
        }), err;
      }
      return val;
    }, "normalizeValue"),
    _Headers = class _Headers {
      constructor(init = {}) {
        if (this[INTERNALS] = {
          map: new Map()
        }, init instanceof _Headers) init.forEach((value, name) => {
          this.append(name, value);
        });else if (Array.isArray(init)) init.forEach(([name, value]) => {
          this.append(name, value);
        });else if (isPlainObject(init)) for (let [name, value] of Object.entries(init)) this.append(name, value);
      }
      set(name, value) {
        this[INTERNALS].map.set(normalizeName(name), normalizeValue(value, name));
      }
      has(name) {
        return this[INTERNALS].map.has(normalizeName(name));
      }
      get(name) {
        let val = this[INTERNALS].map.get(normalizeName(name));
        return val === void 0 ? null : val;
      }
      append(name, value) {
        let nm = normalizeName(name),
          val = normalizeValue(value, name),
          oldVal = this[INTERNALS].map.get(nm);
        this[INTERNALS].map.set(nm, oldVal ? `${oldVal}, ${val}` : val);
      }
      delete(name) {
        this[INTERNALS].map.delete(normalizeName(name));
      }
      forEach(callback, thisArg) {
        for (let name of this.keys()) callback.call(thisArg, this.get(name), name);
      }
      keys() {
        return Array.from(this[INTERNALS].map.keys()).sort();
      }
      *values() {
        for (let name of this.keys()) yield this.get(name);
      }
      *entries() {
        for (let name of this.keys()) yield [name, this.get(name)];
      }
      [Symbol.iterator]() {
        return this.entries();
      }
      get [Symbol.toStringTag]() {
        return this.constructor.name;
      }
      plain() {
        return Object.fromEntries(this[INTERNALS].map);
      }
    };
  __name(_Headers, "Headers");
  var Headers = _Headers;
  Object.defineProperties(Headers.prototype, ["append", "delete", "entries", "forEach", "get", "has", "keys", "set", "values"].reduce((result, property) => (result[property] = {
    enumerable: !0
  }, result), {}));
  module.exports = {
    Headers: Headers
  };
});