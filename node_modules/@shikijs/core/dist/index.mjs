function splitLines(code, preserveEnding = !1) {
  var _a;
  let parts = code.split(/(\r?\n)/g),
    index = 0,
    lines = [];
  for (let i = 0; i < parts.length; i += 2) {
    let line = preserveEnding ? parts[i] + (parts[i + 1] || "") : parts[i];
    lines.push([line, index]), index += parts[i].length, index += ((_a = parts[i + 1]) == null ? void 0 : _a.length) || 0;
  }
  return lines;
},__name(splitLines, "splitLines");,function isPlainLang(lang) {
  return !lang || ["plaintext", "txt", "text", "plain"].includes(lang);
},__name(isPlainLang, "isPlainLang");,function isSpecialLang(lang) {
  return lang === "ansi" || isPlainLang(lang);
},__name(isSpecialLang, "isSpecialLang");,function isNoneTheme(theme) {
  return theme === "none";
},__name(isNoneTheme, "isNoneTheme");,function isSpecialTheme(theme) {
  return isNoneTheme(theme);
},__name(isSpecialTheme, "isSpecialTheme");,function addClassToHast(node, className) {
  var _a;
  if (!className) return node;
  node.properties || (node.properties = {}), (_a = node.properties).class || (_a.class = []), typeof node.properties.class == "string" && (node.properties.class = node.properties.class.split(/\s+/g)), Array.isArray(node.properties.class) || (node.properties.class = []);
  let targets = Array.isArray(className) ? className : className.split(/\s+/g);
  for (let c of targets) c && !node.properties.class.includes(c) && node.properties.class.push(c);
  return node;
},__name(addClassToHast, "addClassToHast");,function splitToken(token, offsets) {
  let lastOffset = 0,
    tokens = [];
  for (let offset of offsets) offset > lastOffset && tokens.push({
    ...token,
    content: token.content.slice(lastOffset, offset),
    offset: token.offset + lastOffset
  }), lastOffset = offset;
  return lastOffset < token.content.length && tokens.push({
    ...token,
    content: token.content.slice(lastOffset),
    offset: token.offset + lastOffset
  }), tokens;
},__name(splitToken, "splitToken");,function splitTokens(tokens, breakpoints) {
  let sorted = Array.from(breakpoints instanceof Set ? breakpoints : new Set(breakpoints)).sort((a, b) => a - b);
  return sorted.length ? tokens.map(line => line.flatMap(token => {
    let breakpointsInToken = sorted.filter(i => token.offset < i && i < token.offset + token.content.length).map(i => i - token.offset).sort((a, b) => a - b);
    return breakpointsInToken.length ? splitToken(token, breakpointsInToken) : token;
  })) : tokens;
},__name(splitTokens, "splitTokens");,function resolveColorReplacements(theme, options) {
  let replacements = typeof theme == "string" ? {} : {
      ...theme.colorReplacements
    },
    themeName = typeof theme == "string" ? theme : theme.name;
  for (let [key, value] of Object.entries((options == null ? void 0 : options.colorReplacements) || {})) typeof value == "string" ? replacements[key] = value : key === themeName && Object.assign(replacements, value);
  return replacements;
},__name(resolveColorReplacements, "resolveColorReplacements");,function applyColorReplacements(color, replacements) {
  return color && ((replacements == null ? void 0 : replacements[color == null ? void 0 : color.toLowerCase()]) || color);
},__name(applyColorReplacements, "applyColorReplacements");,function getTokenStyleObject(token) {
  let styles = {};
  return token.color && (styles.color = token.color), token.bgColor && (styles["background-color"] = token.bgColor), token.fontStyle && (token.fontStyle & FontStyle.Italic && (styles["font-style"] = "italic"), token.fontStyle & FontStyle.Bold && (styles["font-weight"] = "bold"), token.fontStyle & FontStyle.Underline && (styles["text-decoration"] = "underline")), styles;
},__name(getTokenStyleObject, "getTokenStyleObject");,function stringifyTokenStyle(token) {
  return Object.entries(token).map(([key, value]) => `${key}:${value}`).join(";");
},__name(stringifyTokenStyle, "stringifyTokenStyle");,function createPositionConverter(code) {
  let lines = splitLines(code, !0).map(([line]) => line);
  function indexToPos(index) {
    if (index === code.length) return {
      line: lines.length - 1,
      character: lines[lines.length - 1].length
    };
    let character = index,
      line = 0;
    for (let lineText of lines) {
      if (character < lineText.length) break;
      character -= lineText.length, line++;
    }
    return {
      line: line,
      character: character
    };
  }
  __name(indexToPos, "indexToPos");
  function posToIndex(line, character) {
    let index = 0;
    for (let i = 0; i < line; i++) index += lines[i].length;
    return index += character, index;
  }
  return __name(posToIndex, "posToIndex"), {
    lines: lines,
    indexToPos: indexToPos,
    posToIndex: posToIndex
  };
},__name(createPositionConverter, "createPositionConverter");,var namedColors = ["black", "red", "green", "yellow", "blue", "magenta", "cyan", "white", "brightBlack", "brightRed", "brightGreen", "brightYellow", "brightBlue", "brightMagenta", "brightCyan", "brightWhite"],
  decorations = {
    1: "bold",
    2: "dim",
    3: "italic",
    4: "underline",
    7: "reverse",
    9: "strikethrough"
  };,function findSequence(value, position) {
  let nextEscape = value.indexOf("\x1B[", position);
  if (nextEscape !== -1) {
    let nextClose = value.indexOf("m", nextEscape);
    return {
      sequence: value.substring(nextEscape + 2, nextClose).split(";"),
      startPosition: nextEscape,
      position: nextClose + 1
    };
  }
  return {
    position: value.length
  };
},__name(findSequence, "findSequence");,function parseColor(sequence, index) {
  let offset = 1,
    colorMode = sequence[index + offset++],
    color;
  if (colorMode === "2") {
    let rgb = [sequence[index + offset++], sequence[index + offset++], sequence[index + offset]].map(x => Number.parseInt(x));
    rgb.length === 3 && !rgb.some(x => Number.isNaN(x)) && (color = {
      type: "rgb",
      rgb: rgb
    });
  } else if (colorMode === "5") {
    let colorIndex = Number.parseInt(sequence[index + offset]);
    Number.isNaN(colorIndex) || (color = {
      type: "table",
      index: Number(colorIndex)
    });
  }
  return [offset, color];
},__name(parseColor, "parseColor");,function parseSequence(sequence) {
  let commands = [];
  for (let i = 0; i < sequence.length; i++) {
    let code = sequence[i],
      codeInt = Number.parseInt(code);
    if (!Number.isNaN(codeInt)) if (codeInt === 0) commands.push({
      type: "resetAll"
    });else if (codeInt <= 9) decorations[codeInt] && commands.push({
      type: "setDecoration",
      value: decorations[codeInt]
    });else if (codeInt <= 29) {
      let decoration = decorations[codeInt - 20];
      decoration && commands.push({
        type: "resetDecoration",
        value: decoration
      });
    } else if (codeInt <= 37) commands.push({
      type: "setForegroundColor",
      value: {
        type: "named",
        name: namedColors[codeInt - 30]
      }
    });else if (codeInt === 38) {
      let [offset, color] = parseColor(sequence, i);
      color && commands.push({
        type: "setForegroundColor",
        value: color
      }), i += offset;
    } else if (codeInt === 39) commands.push({
      type: "resetForegroundColor"
    });else if (codeInt <= 47) commands.push({
      type: "setBackgroundColor",
      value: {
        type: "named",
        name: namedColors[codeInt - 40]
      }
    });else if (codeInt === 48) {
      let [offset, color] = parseColor(sequence, i);
      color && commands.push({
        type: "setBackgroundColor",
        value: color
      }), i += offset;
    } else codeInt === 49 ? commands.push({
      type: "resetBackgroundColor"
    }) : codeInt >= 90 && codeInt <= 97 ? commands.push({
      type: "setForegroundColor",
      value: {
        type: "named",
        name: namedColors[codeInt - 90 + 8]
      }
    }) : codeInt >= 100 && codeInt <= 107 && commands.push({
      type: "setBackgroundColor",
      value: {
        type: "named",
        name: namedColors[codeInt - 100 + 8]
      }
    });
  }
  return commands;
},__name(parseSequence, "parseSequence");,function createAnsiSequenceParser() {
  let foreground = null,
    background = null,
    decorations2 = new Set();
  return {
    parse(value) {
      let tokens = [],
        position = 0;
      do {
        let findResult = findSequence(value, position),
          text = findResult.sequence ? value.substring(position, findResult.startPosition) : value.substring(position);
        if (text.length > 0 && tokens.push({
          value: text,
          foreground: foreground,
          background: background,
          decorations: new Set(decorations2)
        }), findResult.sequence) {
          let commands = parseSequence(findResult.sequence);
          for (let styleToken of commands) styleToken.type === "resetAll" ? (foreground = null, background = null, decorations2.clear()) : styleToken.type === "resetForegroundColor" ? foreground = null : styleToken.type === "resetBackgroundColor" ? background = null : styleToken.type === "resetDecoration" && decorations2.delete(styleToken.value);
          for (let styleToken of commands) styleToken.type === "setForegroundColor" ? foreground = styleToken.value : styleToken.type === "setBackgroundColor" ? background = styleToken.value : styleToken.type === "setDecoration" && decorations2.add(styleToken.value);
        }
        position = findResult.position;
      } while (position < value.length);
      return tokens;
    }
  };
},__name(createAnsiSequenceParser, "createAnsiSequenceParser");,var defaultNamedColorsMap = {
  black: "#000000",
  red: "#bb0000",
  green: "#00bb00",
  yellow: "#bbbb00",
  blue: "#0000bb",
  magenta: "#ff00ff",
  cyan: "#00bbbb",
  white: "#eeeeee",
  brightBlack: "#555555",
  brightRed: "#ff5555",
  brightGreen: "#00ff00",
  brightYellow: "#ffff55",
  brightBlue: "#5555ff",
  brightMagenta: "#ff55ff",
  brightCyan: "#55ffff",
  brightWhite: "#ffffff"
};,function createColorPalette(namedColorsMap = defaultNamedColorsMap) {
  function namedColor(name) {
    return namedColorsMap[name];
  }
  __name(namedColor, "namedColor");
  function rgbColor(rgb) {
    return `#${rgb.map(x => Math.max(0, Math.min(x, 255)).toString(16).padStart(2, "0")).join("")}`;
  }
  __name(rgbColor, "rgbColor");
  let colorTable;
  function getColorTable() {
    if (colorTable) return colorTable;
    colorTable = [];
    for (let i = 0; i < namedColors.length; i++) colorTable.push(namedColor(namedColors[i]));
    let levels = [0, 95, 135, 175, 215, 255];
    for (let r = 0; r < 6; r++) for (let g = 0; g < 6; g++) for (let b = 0; b < 6; b++) colorTable.push(rgbColor([levels[r], levels[g], levels[b]]));
    let level = 8;
    for (let i = 0; i < 24; i++, level += 10) colorTable.push(rgbColor([level, level, level]));
    return colorTable;
  }
  __name(getColorTable, "getColorTable");
  function tableColor(index) {
    return getColorTable()[index];
  }
  __name(tableColor, "tableColor");
  function value(color) {
    switch (color.type) {
      case "named":
        return namedColor(color.name);
      case "rgb":
        return rgbColor(color.rgb);
      case "table":
        return tableColor(color.index);
    }
  }
  return __name(value, "value"), {
    value: value
  };
},__name(createColorPalette, "createColorPalette");,function tokenizeAnsiWithTheme(theme, fileContents, options) {
  let colorReplacements = resolveColorReplacements(theme, options),
    lines = splitLines(fileContents),
    colorPalette = createColorPalette(Object.fromEntries(namedColors.map(name => {
      var _a;
      return [name, (_a = theme.colors) == null ? void 0 : _a[`terminal.ansi${name[0].toUpperCase()}${name.substring(1)}`]];
    }))),
    parser = createAnsiSequenceParser();
  return lines.map(line => parser.parse(line[0]).map(token => {
    let color, bgColor;
    token.decorations.has("reverse") ? (color = token.background ? colorPalette.value(token.background) : theme.bg, bgColor = token.foreground ? colorPalette.value(token.foreground) : theme.fg) : (color = token.foreground ? colorPalette.value(token.foreground) : theme.fg, bgColor = token.background ? colorPalette.value(token.background) : void 0), color = applyColorReplacements(color, colorReplacements), bgColor = applyColorReplacements(bgColor, colorReplacements), token.decorations.has("dim") && (color = dimColor(color));
    let fontStyle = FontStyle.None;
    return token.decorations.has("bold") && (fontStyle |= FontStyle.Bold), token.decorations.has("italic") && (fontStyle |= FontStyle.Italic), token.decorations.has("underline") && (fontStyle |= FontStyle.Underline), {
      content: token.value,
      offset: line[1],
      color: color,
      bgColor: bgColor,
      fontStyle: fontStyle
    };
  }));
},__name(tokenizeAnsiWithTheme, "tokenizeAnsiWithTheme");,function dimColor(color) {
  let hexMatch = color.match(/#([0-9a-f]{3})([0-9a-f]{3})?([0-9a-f]{2})?/);
  if (hexMatch) if (hexMatch[3]) {
    let alpha = Math.round(Number.parseInt(hexMatch[3], 16) / 2).toString(16).padStart(2, "0");
    return `#${hexMatch[1]}${hexMatch[2]}${alpha}`;
  } else return hexMatch[2] ? `#${hexMatch[1]}${hexMatch[2]}80` : `#${Array.from(hexMatch[1]).map(x => `${x}${x}`).join("")}80`;
  let cssVarMatch = color.match(/var\((--[\w-]+-ansi-[\w-]+)\)/);
  return cssVarMatch ? `var(${cssVarMatch[1]}-dim)` : color;
},__name(dimColor, "dimColor");,var _ShikiError = class _ShikiError extends Error {
  constructor(message) {
    super(message), this.name = "ShikiError";
  }
};,__name(_ShikiError, "ShikiError");,var ShikiError = _ShikiError,
  _GrammarState = class _GrammarState {
    constructor(_stack, lang, theme) {
      __publicField(this, "_stack");
      __publicField(this, "lang");
      __publicField(this, "theme");
      this._stack = _stack, this.lang = lang, this.theme = theme;
    }
    static initial(lang, theme) {
      return new _GrammarState(INITIAL, lang, theme);
    }
    get scopes() {
      return getScopes(this._stack);
    }
    toJSON() {
      return {
        lang: this.lang,
        theme: this.theme,
        scopes: this.scopes
      };
    }
  };,__name(_GrammarState, "GrammarState");,var GrammarState = _GrammarState;,function getScopes(stack) {
  let scopes = [],
    visited = new Set();
  function pushScope(stack) {
    var _a;
    if (visited.has(stack)) return;
    visited.add(stack);
    let name = (_a = stack == null ? void 0 : stack.nameScopesList) == null ? void 0 : _a.scopeName;
    name && scopes.push(name), stack.parent && pushScope(stack.parent);
  }
  return __name(pushScope, "pushScope"), pushScope(stack), scopes;
},__name(getScopes, "getScopes");,function getGrammarStack(state) {
  if (!(state instanceof GrammarState)) throw new ShikiError("Invalid grammar state");
  return state._stack;
},__name(getGrammarStack, "getGrammarStack");,function codeToTokensBase(internal, code, options = {}) {
  let {
    lang = "text",
    theme: themeName = internal.getLoadedThemes()[0]
  } = options;
  if (isPlainLang(lang) || isNoneTheme(themeName)) return splitLines(code).map(line => [{
    content: line[0],
    offset: line[1]
  }]);
  let {
    theme: theme,
    colorMap: colorMap
  } = internal.setTheme(themeName);
  if (lang === "ansi") return tokenizeAnsiWithTheme(theme, code, options);
  let _grammar = internal.getLanguage(lang);
  if (options.grammarState) {
    if (options.grammarState.lang !== _grammar.name) throw new ShikiError(`Grammar state language "${options.grammarState.lang}" does not match highlight language "${_grammar.name}"`);
    if (options.grammarState.theme !== themeName) throw new ShikiError(`Grammar state theme "${options.grammarState.theme}" does not match highlight theme "${themeName}"`);
  }
  return tokenizeWithTheme(code, _grammar, theme, colorMap, options);
},__name(codeToTokensBase, "codeToTokensBase");,function getLastGrammarState(internal, code, options = {}) {
  let {
    lang = "text",
    theme: themeName = internal.getLoadedThemes()[0]
  } = options;
  if (isPlainLang(lang) || isNoneTheme(themeName)) throw new ShikiError("Plain language does not have grammar state");
  if (lang === "ansi") throw new ShikiError("ANSI language does not have grammar state");
  let {
      theme: theme,
      colorMap: colorMap
    } = internal.setTheme(themeName),
    _grammar = internal.getLanguage(lang);
  return new GrammarState(_tokenizeWithTheme(code, _grammar, theme, colorMap, options).stateStack, _grammar.name, theme.name);
},__name(getLastGrammarState, "getLastGrammarState");,function tokenizeWithTheme(code, grammar, theme, colorMap, options) {
  return _tokenizeWithTheme(code, grammar, theme, colorMap, options).tokens;
},__name(tokenizeWithTheme, "tokenizeWithTheme");,function _tokenizeWithTheme(code, grammar, theme, colorMap, options) {
  let colorReplacements = resolveColorReplacements(theme, options),
    {
      tokenizeMaxLineLength = 0,
      tokenizeTimeLimit = 500
    } = options,
    lines = splitLines(code),
    stateStack = options.grammarState ? getGrammarStack(options.grammarState) : options.grammarContextCode != null ? _tokenizeWithTheme(options.grammarContextCode, grammar, theme, colorMap, {
      ...options,
      grammarState: void 0,
      grammarContextCode: void 0
    }).stateStack : INITIAL,
    actual = [],
    final = [];
  for (let i = 0, len = lines.length; i < len; i++) {
    let [line, lineOffset] = lines[i];
    if (line === "") {
      actual = [], final.push([]);
      continue;
    }
    if (tokenizeMaxLineLength > 0 && line.length >= tokenizeMaxLineLength) {
      actual = [], final.push([{
        content: line,
        offset: lineOffset,
        color: "",
        fontStyle: 0
      }]);
      continue;
    }
    let resultWithScopes, tokensWithScopes, tokensWithScopesIndex;
    options.includeExplanation && (resultWithScopes = grammar.tokenizeLine(line, stateStack), tokensWithScopes = resultWithScopes.tokens, tokensWithScopesIndex = 0);
    let result = grammar.tokenizeLine2(line, stateStack, tokenizeTimeLimit),
      tokensLength = result.tokens.length / 2;
    for (let j = 0; j < tokensLength; j++) {
      let startIndex = result.tokens[2 * j],
        nextStartIndex = j + 1 < tokensLength ? result.tokens[2 * j + 2] : line.length;
      if (startIndex === nextStartIndex) continue;
      let metadata = result.tokens[2 * j + 1],
        color = applyColorReplacements(colorMap[StackElementMetadata.getForeground(metadata)], colorReplacements),
        fontStyle = StackElementMetadata.getFontStyle(metadata),
        token = {
          content: line.substring(startIndex, nextStartIndex),
          offset: lineOffset + startIndex,
          color: color,
          fontStyle: fontStyle
        };
      if (options.includeExplanation) {
        let themeSettingsSelectors = [];
        if (options.includeExplanation !== "scopeName") for (let setting of theme.settings) {
          let selectors;
          switch (typeof setting.scope) {
            case "string":
              selectors = setting.scope.split(/,/).map(scope => scope.trim());
              break;
            case "object":
              selectors = setting.scope;
              break;
            default:
              continue;
          }
          themeSettingsSelectors.push({
            settings: setting,
            selectors: selectors.map(selector => selector.split(/ /))
          });
        }
        token.explanation = [];
        let offset = 0;
        for (; startIndex + offset < nextStartIndex;) {
          let tokenWithScopes = tokensWithScopes[tokensWithScopesIndex],
            tokenWithScopesText = line.substring(tokenWithScopes.startIndex, tokenWithScopes.endIndex);
          offset += tokenWithScopesText.length, token.explanation.push({
            content: tokenWithScopesText,
            scopes: options.includeExplanation === "scopeName" ? explainThemeScopesNameOnly(tokenWithScopes.scopes) : explainThemeScopesFull(themeSettingsSelectors, tokenWithScopes.scopes)
          }), tokensWithScopesIndex += 1;
        }
      }
      actual.push(token);
    }
    final.push(actual), actual = [], stateStack = result.ruleStack;
  }
  return {
    tokens: final,
    stateStack: stateStack
  };
},__name(_tokenizeWithTheme, "_tokenizeWithTheme");,function explainThemeScopesNameOnly(scopes) {
  return scopes.map(scope => ({
    scopeName: scope
  }));
},__name(explainThemeScopesNameOnly, "explainThemeScopesNameOnly");,function explainThemeScopesFull(themeSelectors, scopes) {
  let result = [];
  for (let i = 0, len = scopes.length; i < len; i++) {
    let scope = scopes[i];
    result[i] = {
      scopeName: scope,
      themeMatches: explainThemeScope(themeSelectors, scope, scopes.slice(0, i))
    };
  }
  return result;
},__name(explainThemeScopesFull, "explainThemeScopesFull");,function matchesOne(selector, scope) {
  return selector === scope || scope.substring(0, selector.length) === selector && scope[selector.length] === ".";
},__name(matchesOne, "matchesOne");,function matches(selectors, scope, parentScopes) {
  if (!matchesOne(selectors[selectors.length - 1], scope)) return !1;
  let selectorParentIndex = selectors.length - 2,
    parentIndex = parentScopes.length - 1;
  for (; selectorParentIndex >= 0 && parentIndex >= 0;) matchesOne(selectors[selectorParentIndex], parentScopes[parentIndex]) && (selectorParentIndex -= 1), parentIndex -= 1;
  return selectorParentIndex === -1;
},__name(matches, "matches");,function explainThemeScope(themeSettingsSelectors, scope, parentScopes) {
  let result = [];
  for (let {
    selectors: selectors,
    settings: settings
  } of themeSettingsSelectors) for (let selectorPieces of selectors) if (matches(selectorPieces, scope, parentScopes)) {
    result.push(settings);
    break;
  }
  return result;
},__name(explainThemeScope, "explainThemeScope");,function codeToTokensWithThemes(internal, code, options) {
  let themes = Object.entries(options.themes).filter(i => i[1]).map(i => ({
      color: i[0],
      theme: i[1]
    })),
    tokens = syncThemesTokenization(...themes.map(t => codeToTokensBase(internal, code, {
      ...options,
      theme: t.theme
    })));
  return tokens[0].map((line, lineIdx) => line.map((_token, tokenIdx) => {
    let mergedToken = {
      content: _token.content,
      variants: {},
      offset: _token.offset
    };
    return "includeExplanation" in options && options.includeExplanation && (mergedToken.explanation = _token.explanation), tokens.forEach((t, themeIdx) => {
      let {
        content: _,
        explanation: __,
        offset: ___,
        ...styles
      } = t[lineIdx][tokenIdx];
      mergedToken.variants[themes[themeIdx].color] = styles;
    }), mergedToken;
  }));
},__name(codeToTokensWithThemes, "codeToTokensWithThemes");,function syncThemesTokenization(...themes) {
  let outThemes = themes.map(() => []),
    count = themes.length;
  for (let i = 0; i < themes[0].length; i++) {
    let lines = themes.map(t => t[i]),
      outLines = outThemes.map(() => []);
    outThemes.forEach((t, i) => t.push(outLines[i]));
    let indexes = lines.map(() => 0),
      current = lines.map(l => l[0]);
    for (; current.every(t => t);) {
      let minLength = Math.min(...current.map(t => t.content.length));
      for (let n = 0; n < count; n++) {
        let token = current[n];
        token.content.length === minLength ? (outLines[n].push(token), indexes[n] += 1, current[n] = lines[n][indexes[n]]) : (outLines[n].push({
          ...token,
          content: token.content.slice(0, minLength)
        }), current[n] = {
          ...token,
          content: token.content.slice(minLength),
          offset: token.offset + minLength
        });
      }
    }
  }
  return outThemes;
},__name(syncThemesTokenization, "syncThemesTokenization");,function codeToTokens(internal, code, options) {
  let bg, fg, tokens, themeName, rootStyle;
  if ("themes" in options) {
    let {
        defaultColor = "light",
        cssVariablePrefix = "--shiki-"
      } = options,
      themes = Object.entries(options.themes).filter(i => i[1]).map(i => ({
        color: i[0],
        theme: i[1]
      })).sort((a, b) => a.color === defaultColor ? -1 : b.color === defaultColor ? 1 : 0);
    if (themes.length === 0) throw new ShikiError("`themes` option must not be empty");
    let themeTokens = codeToTokensWithThemes(internal, code, options);
    if (defaultColor && !themes.find(t => t.color === defaultColor)) throw new ShikiError(`\`themes\` option must contain the defaultColor key \`${defaultColor}\``);
    let themeRegs = themes.map(t => internal.getTheme(t.theme)),
      themesOrder = themes.map(t => t.color);
    tokens = themeTokens.map(line => line.map(token => mergeToken(token, themesOrder, cssVariablePrefix, defaultColor)));
    let themeColorReplacements = themes.map(t => resolveColorReplacements(t.theme, options));
    fg = themes.map((t, idx) => (idx === 0 && defaultColor ? "" : `${cssVariablePrefix + t.color}:`) + (applyColorReplacements(themeRegs[idx].fg, themeColorReplacements[idx]) || "inherit")).join(";"), bg = themes.map((t, idx) => (idx === 0 && defaultColor ? "" : `${cssVariablePrefix + t.color}-bg:`) + (applyColorReplacements(themeRegs[idx].bg, themeColorReplacements[idx]) || "inherit")).join(";"), themeName = `shiki-themes ${themeRegs.map(t => t.name).join(" ")}`, rootStyle = defaultColor ? void 0 : [fg, bg].join(";");
  } else if ("theme" in options) {
    let colorReplacements = resolveColorReplacements(options.theme, options);
    tokens = codeToTokensBase(internal, code, options);
    let _theme = internal.getTheme(options.theme);
    bg = applyColorReplacements(_theme.bg, colorReplacements), fg = applyColorReplacements(_theme.fg, colorReplacements), themeName = _theme.name;
  } else throw new ShikiError("Invalid options, either `theme` or `themes` must be provided");
  return {
    tokens: tokens,
    fg: fg,
    bg: bg,
    themeName: themeName,
    rootStyle: rootStyle
  };
},__name(codeToTokens, "codeToTokens");,function mergeToken(merged, variantsOrder, cssVariablePrefix, defaultColor) {
  let token = {
      content: merged.content,
      explanation: merged.explanation,
      offset: merged.offset
    },
    styles = variantsOrder.map(t => getTokenStyleObject(merged.variants[t])),
    styleKeys = new Set(styles.flatMap(t => Object.keys(t))),
    mergedStyles = styles.reduce((acc, cur, idx) => {
      for (let key of styleKeys) {
        let value = cur[key] || "inherit";
        if (idx === 0 && defaultColor) acc[key] = value;else {
          let keyName = key === "color" ? "" : key === "background-color" ? "-bg" : `-${key}`,
            varKey = cssVariablePrefix + variantsOrder[idx] + (key === "color" ? "" : keyName);
          acc[key] ? acc[key] += `;${varKey}:${value}` : acc[key] = `${varKey}:${value}`;
        }
      }
      return acc;
    }, {});
  return token.htmlStyle = defaultColor ? stringifyTokenStyle(mergedStyles) : Object.values(mergedStyles).join(";"), token;
},__name(mergeToken, "mergeToken");,function transformerDecorations() {
  let map = new WeakMap();
  function getContext(shiki) {
    if (!map.has(shiki.meta)) {
      let normalizePosition = function (p) {
        if (typeof p == "number") {
          if (p < 0 || p > shiki.source.length) throw new ShikiError(`Invalid decoration offset: ${p}. Code length: ${shiki.source.length}`);
          return {
            ...converter.indexToPos(p),
            offset: p
          };
        } else {
          let line = converter.lines[p.line];
          if (line === void 0) throw new ShikiError(`Invalid decoration position ${JSON.stringify(p)}. Lines length: ${converter.lines.length}`);
          if (p.character < 0 || p.character > line.length) throw new ShikiError(`Invalid decoration position ${JSON.stringify(p)}. Line ${p.line} length: ${line.length}`);
          return {
            ...p,
            offset: converter.posToIndex(p.line, p.character)
          };
        }
      };
      __name(normalizePosition, "normalizePosition");
      let converter = createPositionConverter(shiki.source),
        decorations = (shiki.options.decorations || []).map(d => ({
          ...d,
          start: normalizePosition(d.start),
          end: normalizePosition(d.end)
        }));
      verifyIntersections(decorations), map.set(shiki.meta, {
        decorations: decorations,
        converter: converter,
        source: shiki.source
      });
    }
    return map.get(shiki.meta);
  }
  return __name(getContext, "getContext"), {
    name: "shiki:decorations",
    tokens(tokens) {
      var _a;
      if (!((_a = this.options.decorations) != null && _a.length)) return;
      let breakpoints = getContext(this).decorations.flatMap(d => [d.start.offset, d.end.offset]);
      return splitTokens(tokens, breakpoints);
    },
    code(codeEl) {
      var _a;
      if (!((_a = this.options.decorations) != null && _a.length)) return;
      let ctx = getContext(this),
        lines = Array.from(codeEl.children).filter(i => i.type === "element" && i.tagName === "span");
      if (lines.length !== ctx.converter.lines.length) throw new ShikiError(`Number of lines in code element (${lines.length}) does not match the number of lines in the source (${ctx.converter.lines.length}). Failed to apply decorations.`);
      function applyLineSection(line, start, end, decoration) {
        let lineEl = lines[line],
          text = "",
          startIndex = -1,
          endIndex = -1;
        if (start === 0 && (startIndex = 0), end === 0 && (endIndex = 0), end === Number.POSITIVE_INFINITY && (endIndex = lineEl.children.length), startIndex === -1 || endIndex === -1) for (let i = 0; i < lineEl.children.length; i++) text += stringify$2(lineEl.children[i]), startIndex === -1 && text.length === start && (startIndex = i + 1), endIndex === -1 && text.length === end && (endIndex = i + 1);
        if (startIndex === -1) throw new ShikiError(`Failed to find start index for decoration ${JSON.stringify(decoration.start)}`);
        if (endIndex === -1) throw new ShikiError(`Failed to find end index for decoration ${JSON.stringify(decoration.end)}`);
        let children = lineEl.children.slice(startIndex, endIndex);
        if (!decoration.alwaysWrap && children.length === lineEl.children.length) applyDecoration(lineEl, decoration, "line");else if (!decoration.alwaysWrap && children.length === 1 && children[0].type === "element") applyDecoration(children[0], decoration, "token");else {
          let wrapper = {
            type: "element",
            tagName: "span",
            properties: {},
            children: children
          };
          applyDecoration(wrapper, decoration, "wrapper"), lineEl.children.splice(startIndex, children.length, wrapper);
        }
      }
      __name(applyLineSection, "applyLineSection");
      function applyLine(line, decoration) {
        lines[line] = applyDecoration(lines[line], decoration, "line");
      }
      __name(applyLine, "applyLine");
      function applyDecoration(el, decoration, type) {
        var _a;
        let properties = decoration.properties || {},
          transform = decoration.transform || (i => i);
        return el.tagName = decoration.tagName || "span", el.properties = {
          ...el.properties,
          ...properties,
          class: el.properties.class
        }, (_a = decoration.properties) != null && _a.class && addClassToHast(el, decoration.properties.class), el = transform(el, type) || el, el;
      }
      __name(applyDecoration, "applyDecoration");
      let lineApplies = [],
        sorted = ctx.decorations.sort((a, b) => b.start.offset - a.start.offset);
      for (let decoration of sorted) {
        let {
          start: start,
          end: end
        } = decoration;
        if (start.line === end.line) applyLineSection(start.line, start.character, end.character, decoration);else if (start.line < end.line) {
          applyLineSection(start.line, start.character, Number.POSITIVE_INFINITY, decoration);
          for (let i = start.line + 1; i < end.line; i++) lineApplies.unshift(() => applyLine(i, decoration));
          applyLineSection(end.line, 0, end.character, decoration);
        }
      }
      lineApplies.forEach(i => i());
    }
  };
},__name(transformerDecorations, "transformerDecorations");,function verifyIntersections(items) {
  for (let i = 0; i < items.length; i++) {
    let foo = items[i];
    if (foo.start.offset > foo.end.offset) throw new ShikiError(`Invalid decoration range: ${JSON.stringify(foo.start)} - ${JSON.stringify(foo.end)}`);
    for (let j = i + 1; j < items.length; j++) {
      let bar = items[j],
        isFooHasBarStart = foo.start.offset < bar.start.offset && bar.start.offset < foo.end.offset,
        isFooHasBarEnd = foo.start.offset < bar.end.offset && bar.end.offset < foo.end.offset,
        isBarHasFooStart = bar.start.offset < foo.start.offset && foo.start.offset < bar.end.offset,
        isBarHasFooEnd = bar.start.offset < foo.end.offset && foo.end.offset < bar.end.offset;
      if (isFooHasBarStart || isFooHasBarEnd || isBarHasFooStart || isBarHasFooEnd) {
        if (isFooHasBarEnd && isFooHasBarEnd || isBarHasFooStart && isBarHasFooEnd) continue;
        throw new ShikiError(`Decorations ${JSON.stringify(foo.start)} and ${JSON.stringify(bar.start)} intersect.`);
      }
    }
  }
},__name(verifyIntersections, "verifyIntersections");,function stringify$2(el) {
  return el.type === "text" ? el.value : el.type === "element" ? el.children.map(stringify$2).join("") : "";
},__name(stringify$2, "stringify$2");,var builtInTransformers = [transformerDecorations()];,function getTransformers(options) {
  return [...(options.transformers || []), ...builtInTransformers];
},__name(getTransformers, "getTransformers");,function codeToHast(internal, code, options, transformerContext = {
  meta: {},
  options: options,
  codeToHast: __name((_code, _options) => codeToHast(internal, _code, _options), "codeToHast"),
  codeToTokens: __name((_code, _options) => codeToTokens(internal, _code, _options), "codeToTokens")
}) {
  var _a, _b;
  let input = code;
  for (let transformer of getTransformers(options)) input = ((_a = transformer.preprocess) == null ? void 0 : _a.call(transformerContext, input, options)) || input;
  let {
      tokens: tokens,
      fg: fg,
      bg: bg,
      themeName: themeName,
      rootStyle: rootStyle
    } = codeToTokens(internal, input, options),
    {
      mergeWhitespaces = !0
    } = options;
  mergeWhitespaces === !0 ? tokens = mergeWhitespaceTokens(tokens) : mergeWhitespaces === "never" && (tokens = splitWhitespaceTokens(tokens));
  let contextSource = {
    ...transformerContext,
    get source() {
      return input;
    }
  };
  for (let transformer of getTransformers(options)) tokens = ((_b = transformer.tokens) == null ? void 0 : _b.call(contextSource, tokens)) || tokens;
  return tokensToHast(tokens, {
    ...options,
    fg: fg,
    bg: bg,
    themeName: themeName,
    rootStyle: rootStyle
  }, contextSource);
},__name(codeToHast, "codeToHast");,function tokensToHast(tokens, options, transformerContext) {
  var _a, _b, _c;
  let transformers = getTransformers(options),
    lines = [],
    root = {
      type: "root",
      children: []
    },
    {
      structure = "classic"
    } = options,
    preNode = {
      type: "element",
      tagName: "pre",
      properties: {
        class: `shiki ${options.themeName || ""}`,
        style: options.rootStyle || `background-color:${options.bg};color:${options.fg}`,
        tabindex: "0",
        ...Object.fromEntries(Array.from(Object.entries(options.meta || {})).filter(([key]) => !key.startsWith("_")))
      },
      children: []
    },
    codeNode = {
      type: "element",
      tagName: "code",
      properties: {},
      children: lines
    },
    lineNodes = [],
    context = {
      ...transformerContext,
      structure: structure,
      addClassToHast: addClassToHast,
      get source() {
        return transformerContext.source;
      },
      get tokens() {
        return tokens;
      },
      get options() {
        return options;
      },
      get root() {
        return root;
      },
      get pre() {
        return preNode;
      },
      get code() {
        return codeNode;
      },
      get lines() {
        return lineNodes;
      }
    };
  if (tokens.forEach((line, idx) => {
    var _a, _b;
    idx && (structure === "inline" ? root.children.push({
      type: "element",
      tagName: "br",
      properties: {},
      children: []
    }) : structure === "classic" && lines.push({
      type: "text",
      value: `
`
    }));
    let lineNode = {
        type: "element",
        tagName: "span",
        properties: {
          class: "line"
        },
        children: []
      },
      col = 0;
    for (let token of line) {
      let tokenNode = {
          type: "element",
          tagName: "span",
          properties: {},
          children: [{
            type: "text",
            value: token.content
          }]
        },
        style = token.htmlStyle || stringifyTokenStyle(getTokenStyleObject(token));
      style && (tokenNode.properties.style = style);
      for (let transformer of transformers) tokenNode = ((_a = transformer == null ? void 0 : transformer.span) == null ? void 0 : _a.call(context, tokenNode, idx + 1, col, lineNode)) || tokenNode;
      structure === "inline" ? root.children.push(tokenNode) : structure === "classic" && lineNode.children.push(tokenNode), col += token.content.length;
    }
    if (structure === "classic") {
      for (let transformer of transformers) lineNode = ((_b = transformer == null ? void 0 : transformer.line) == null ? void 0 : _b.call(context, lineNode, idx + 1)) || lineNode;
      lineNodes.push(lineNode), lines.push(lineNode);
    }
  }), structure === "classic") {
    for (let transformer of transformers) codeNode = ((_a = transformer == null ? void 0 : transformer.code) == null ? void 0 : _a.call(context, codeNode)) || codeNode;
    preNode.children.push(codeNode);
    for (let transformer of transformers) preNode = ((_b = transformer == null ? void 0 : transformer.pre) == null ? void 0 : _b.call(context, preNode)) || preNode;
    root.children.push(preNode);
  }
  let result = root;
  for (let transformer of transformers) result = ((_c = transformer == null ? void 0 : transformer.root) == null ? void 0 : _c.call(context, result)) || result;
  return result;
},__name(tokensToHast, "tokensToHast");,function mergeWhitespaceTokens(tokens) {
  return tokens.map(line => {
    let newLine = [],
      carryOnContent = "",
      firstOffset = 0;
    return line.forEach((token, idx) => {
      let couldMerge = !(token.fontStyle && token.fontStyle & FontStyle.Underline);
      couldMerge && token.content.match(/^\s+$/) && line[idx + 1] ? (firstOffset || (firstOffset = token.offset), carryOnContent += token.content) : carryOnContent ? (couldMerge ? newLine.push({
        ...token,
        offset: firstOffset,
        content: carryOnContent + token.content
      }) : newLine.push({
        content: carryOnContent,
        offset: firstOffset
      }, token), firstOffset = 0, carryOnContent = "") : newLine.push(token);
    }), newLine;
  });
},__name(mergeWhitespaceTokens, "mergeWhitespaceTokens");,function splitWhitespaceTokens(tokens) {
  return tokens.map(line => line.flatMap(token => {
    if (token.content.match(/^\s+$/)) return token;
    let match = token.content.match(/^(\s*)(.*?)(\s*)$/);
    if (!match) return token;
    let [, leading, content, trailing] = match;
    if (!leading && !trailing) return token;
    let expanded = [{
      ...token,
      offset: token.offset + leading.length,
      content: content
    }];
    return leading && expanded.unshift({
      content: leading,
      offset: token.offset
    }), trailing && expanded.push({
      content: trailing,
      offset: token.offset + leading.length + content.length
    }), expanded;
  }));
},__name(splitWhitespaceTokens, "splitWhitespaceTokens");,var htmlVoidElements = ["area", "base", "basefont", "bgsound", "br", "col", "command", "embed", "frame", "hr", "image", "img", "input", "keygen", "link", "meta", "param", "source", "track", "wbr"],
  _Schema = class _Schema {
    constructor(property, normal, space) {
      this.property = property, this.normal = normal, space && (this.space = space);
    }
  };,__name(_Schema, "Schema");,var Schema = _Schema;,Schema.prototype.property = {};,Schema.prototype.normal = {};,Schema.prototype.space = null;,function merge(definitions, space) {
  let property = {},
    normal = {},
    index = -1;
  for (; ++index < definitions.length;) Object.assign(property, definitions[index].property), Object.assign(normal, definitions[index].normal);
  return new Schema(property, normal, space);
},__name(merge, "merge");,function normalize(value) {
  return value.toLowerCase();
},__name(normalize, "normalize");,var _Info = class _Info {
  constructor(property, attribute) {
    this.property = property, this.attribute = attribute;
  }
};,__name(_Info, "Info");,var Info = _Info;,Info.prototype.space = null;,Info.prototype.boolean = !1;,Info.prototype.booleanish = !1;,Info.prototype.overloadedBoolean = !1;,Info.prototype.number = !1;,Info.prototype.commaSeparated = !1;,Info.prototype.spaceSeparated = !1;,Info.prototype.commaOrSpaceSeparated = !1;,Info.prototype.mustUseProperty = !1;,Info.prototype.defined = !1;,var powers = 0,
  boolean = increment(),
  booleanish = increment(),
  overloadedBoolean = increment(),
  number = increment(),
  spaceSeparated = increment(),
  commaSeparated = increment(),
  commaOrSpaceSeparated = increment();,function increment() {
  return 2 ** ++powers;
},__name(increment, "increment");,var types = Object.freeze({
    __proto__: null,
    boolean: boolean,
    booleanish: booleanish,
    commaOrSpaceSeparated: commaOrSpaceSeparated,
    commaSeparated: commaSeparated,
    number: number,
    overloadedBoolean: overloadedBoolean,
    spaceSeparated: spaceSeparated
  }),
  checks = Object.keys(types),
  _DefinedInfo = class _DefinedInfo extends Info {
    constructor(property, attribute, mask, space) {
      let index = -1;
      if (super(property, attribute), mark(this, "space", space), typeof mask == "number") for (; ++index < checks.length;) {
        let check = checks[index];
        mark(this, checks[index], (mask & types[check]) === types[check]);
      }
    }
  };,__name(_DefinedInfo, "DefinedInfo");,var DefinedInfo = _DefinedInfo;,DefinedInfo.prototype.defined = !0;,function mark(values, key, value) {
  value && (values[key] = value);
},__name(mark, "mark");,var own$3 = {}.hasOwnProperty;,function create(definition) {
  let property = {},
    normal = {},
    prop;
  for (prop in definition.properties) if (own$3.call(definition.properties, prop)) {
    let value = definition.properties[prop],
      info = new DefinedInfo(prop, definition.transform(definition.attributes || {}, prop), value, definition.space);
    definition.mustUseProperty && definition.mustUseProperty.includes(prop) && (info.mustUseProperty = !0), property[prop] = info, normal[normalize(prop)] = prop, normal[normalize(info.attribute)] = prop;
  }
  return new Schema(property, normal, definition.space);
},__name(create, "create");,var xlink = create({
    space: "xlink",
    transform(_, prop) {
      return "xlink:" + prop.slice(5).toLowerCase();
    },
    properties: {
      xLinkActuate: null,
      xLinkArcRole: null,
      xLinkHref: null,
      xLinkRole: null,
      xLinkShow: null,
      xLinkTitle: null,
      xLinkType: null
    }
  }),
  xml = create({
    space: "xml",
    transform(_, prop) {
      return "xml:" + prop.slice(3).toLowerCase();
    },
    properties: {
      xmlLang: null,
      xmlBase: null,
      xmlSpace: null
    }
  });,function caseSensitiveTransform(attributes, attribute) {
  return attribute in attributes ? attributes[attribute] : attribute;
},__name(caseSensitiveTransform, "caseSensitiveTransform");,function caseInsensitiveTransform(attributes, property) {
  return caseSensitiveTransform(attributes, property.toLowerCase());
},__name(caseInsensitiveTransform, "caseInsensitiveTransform");,var xmlns = create({
    space: "xmlns",
    attributes: {
      xmlnsxlink: "xmlns:xlink"
    },
    transform: caseInsensitiveTransform,
    properties: {
      xmlns: null,
      xmlnsXLink: null
    }
  }),
  aria = create({
    transform(_, prop) {
      return prop === "role" ? prop : "aria-" + prop.slice(4).toLowerCase();
    },
    properties: {
      ariaActiveDescendant: null,
      ariaAtomic: booleanish,
      ariaAutoComplete: null,
      ariaBusy: booleanish,
      ariaChecked: booleanish,
      ariaColCount: number,
      ariaColIndex: number,
      ariaColSpan: number,
      ariaControls: spaceSeparated,
      ariaCurrent: null,
      ariaDescribedBy: spaceSeparated,
      ariaDetails: null,
      ariaDisabled: booleanish,
      ariaDropEffect: spaceSeparated,
      ariaErrorMessage: null,
      ariaExpanded: booleanish,
      ariaFlowTo: spaceSeparated,
      ariaGrabbed: booleanish,
      ariaHasPopup: null,
      ariaHidden: booleanish,
      ariaInvalid: null,
      ariaKeyShortcuts: null,
      ariaLabel: null,
      ariaLabelledBy: spaceSeparated,
      ariaLevel: number,
      ariaLive: null,
      ariaModal: booleanish,
      ariaMultiLine: booleanish,
      ariaMultiSelectable: booleanish,
      ariaOrientation: null,
      ariaOwns: spaceSeparated,
      ariaPlaceholder: null,
      ariaPosInSet: number,
      ariaPressed: booleanish,
      ariaReadOnly: booleanish,
      ariaRelevant: null,
      ariaRequired: booleanish,
      ariaRoleDescription: spaceSeparated,
      ariaRowCount: number,
      ariaRowIndex: number,
      ariaRowSpan: number,
      ariaSelected: booleanish,
      ariaSetSize: number,
      ariaSort: null,
      ariaValueMax: number,
      ariaValueMin: number,
      ariaValueNow: number,
      ariaValueText: null,
      role: null
    }
  }),
  html$3 = create({
    space: "html",
    attributes: {
      acceptcharset: "accept-charset",
      classname: "class",
      htmlfor: "for",
      httpequiv: "http-equiv"
    },
    transform: caseInsensitiveTransform,
    mustUseProperty: ["checked", "multiple", "muted", "selected"],
    properties: {
      abbr: null,
      accept: commaSeparated,
      acceptCharset: spaceSeparated,
      accessKey: spaceSeparated,
      action: null,
      allow: null,
      allowFullScreen: boolean,
      allowPaymentRequest: boolean,
      allowUserMedia: boolean,
      alt: null,
      as: null,
      async: boolean,
      autoCapitalize: null,
      autoComplete: spaceSeparated,
      autoFocus: boolean,
      autoPlay: boolean,
      blocking: spaceSeparated,
      capture: null,
      charSet: null,
      checked: boolean,
      cite: null,
      className: spaceSeparated,
      cols: number,
      colSpan: null,
      content: null,
      contentEditable: booleanish,
      controls: boolean,
      controlsList: spaceSeparated,
      coords: number | commaSeparated,
      crossOrigin: null,
      data: null,
      dateTime: null,
      decoding: null,
      default: boolean,
      defer: boolean,
      dir: null,
      dirName: null,
      disabled: boolean,
      download: overloadedBoolean,
      draggable: booleanish,
      encType: null,
      enterKeyHint: null,
      fetchPriority: null,
      form: null,
      formAction: null,
      formEncType: null,
      formMethod: null,
      formNoValidate: boolean,
      formTarget: null,
      headers: spaceSeparated,
      height: number,
      hidden: boolean,
      high: number,
      href: null,
      hrefLang: null,
      htmlFor: spaceSeparated,
      httpEquiv: spaceSeparated,
      id: null,
      imageSizes: null,
      imageSrcSet: null,
      inert: boolean,
      inputMode: null,
      integrity: null,
      is: null,
      isMap: boolean,
      itemId: null,
      itemProp: spaceSeparated,
      itemRef: spaceSeparated,
      itemScope: boolean,
      itemType: spaceSeparated,
      kind: null,
      label: null,
      lang: null,
      language: null,
      list: null,
      loading: null,
      loop: boolean,
      low: number,
      manifest: null,
      max: null,
      maxLength: number,
      media: null,
      method: null,
      min: null,
      minLength: number,
      multiple: boolean,
      muted: boolean,
      name: null,
      nonce: null,
      noModule: boolean,
      noValidate: boolean,
      onAbort: null,
      onAfterPrint: null,
      onAuxClick: null,
      onBeforeMatch: null,
      onBeforePrint: null,
      onBeforeToggle: null,
      onBeforeUnload: null,
      onBlur: null,
      onCancel: null,
      onCanPlay: null,
      onCanPlayThrough: null,
      onChange: null,
      onClick: null,
      onClose: null,
      onContextLost: null,
      onContextMenu: null,
      onContextRestored: null,
      onCopy: null,
      onCueChange: null,
      onCut: null,
      onDblClick: null,
      onDrag: null,
      onDragEnd: null,
      onDragEnter: null,
      onDragExit: null,
      onDragLeave: null,
      onDragOver: null,
      onDragStart: null,
      onDrop: null,
      onDurationChange: null,
      onEmptied: null,
      onEnded: null,
      onError: null,
      onFocus: null,
      onFormData: null,
      onHashChange: null,
      onInput: null,
      onInvalid: null,
      onKeyDown: null,
      onKeyPress: null,
      onKeyUp: null,
      onLanguageChange: null,
      onLoad: null,
      onLoadedData: null,
      onLoadedMetadata: null,
      onLoadEnd: null,
      onLoadStart: null,
      onMessage: null,
      onMessageError: null,
      onMouseDown: null,
      onMouseEnter: null,
      onMouseLeave: null,
      onMouseMove: null,
      onMouseOut: null,
      onMouseOver: null,
      onMouseUp: null,
      onOffline: null,
      onOnline: null,
      onPageHide: null,
      onPageShow: null,
      onPaste: null,
      onPause: null,
      onPlay: null,
      onPlaying: null,
      onPopState: null,
      onProgress: null,
      onRateChange: null,
      onRejectionHandled: null,
      onReset: null,
      onResize: null,
      onScroll: null,
      onScrollEnd: null,
      onSecurityPolicyViolation: null,
      onSeeked: null,
      onSeeking: null,
      onSelect: null,
      onSlotChange: null,
      onStalled: null,
      onStorage: null,
      onSubmit: null,
      onSuspend: null,
      onTimeUpdate: null,
      onToggle: null,
      onUnhandledRejection: null,
      onUnload: null,
      onVolumeChange: null,
      onWaiting: null,
      onWheel: null,
      open: boolean,
      optimum: number,
      pattern: null,
      ping: spaceSeparated,
      placeholder: null,
      playsInline: boolean,
      popover: null,
      popoverTarget: null,
      popoverTargetAction: null,
      poster: null,
      preload: null,
      readOnly: boolean,
      referrerPolicy: null,
      rel: spaceSeparated,
      required: boolean,
      reversed: boolean,
      rows: number,
      rowSpan: number,
      sandbox: spaceSeparated,
      scope: null,
      scoped: boolean,
      seamless: boolean,
      selected: boolean,
      shadowRootDelegatesFocus: boolean,
      shadowRootMode: null,
      shape: null,
      size: number,
      sizes: null,
      slot: null,
      span: number,
      spellCheck: booleanish,
      src: null,
      srcDoc: null,
      srcLang: null,
      srcSet: null,
      start: number,
      step: null,
      style: null,
      tabIndex: number,
      target: null,
      title: null,
      translate: null,
      type: null,
      typeMustMatch: boolean,
      useMap: null,
      value: booleanish,
      width: number,
      wrap: null,
      align: null,
      aLink: null,
      archive: spaceSeparated,
      axis: null,
      background: null,
      bgColor: null,
      border: number,
      borderColor: null,
      bottomMargin: number,
      cellPadding: null,
      cellSpacing: null,
      char: null,
      charOff: null,
      classId: null,
      clear: null,
      code: null,
      codeBase: null,
      codeType: null,
      color: null,
      compact: boolean,
      declare: boolean,
      event: null,
      face: null,
      frame: null,
      frameBorder: null,
      hSpace: number,
      leftMargin: number,
      link: null,
      longDesc: null,
      lowSrc: null,
      marginHeight: number,
      marginWidth: number,
      noResize: boolean,
      noHref: boolean,
      noShade: boolean,
      noWrap: boolean,
      object: null,
      profile: null,
      prompt: null,
      rev: null,
      rightMargin: number,
      rules: null,
      scheme: null,
      scrolling: booleanish,
      standby: null,
      summary: null,
      text: null,
      topMargin: number,
      valueType: null,
      version: null,
      vAlign: null,
      vLink: null,
      vSpace: number,
      allowTransparency: null,
      autoCorrect: null,
      autoSave: null,
      disablePictureInPicture: boolean,
      disableRemotePlayback: boolean,
      prefix: null,
      property: null,
      results: number,
      security: null,
      unselectable: null
    }
  }),
  svg$1 = create({
    space: "svg",
    attributes: {
      accentHeight: "accent-height",
      alignmentBaseline: "alignment-baseline",
      arabicForm: "arabic-form",
      baselineShift: "baseline-shift",
      capHeight: "cap-height",
      className: "class",
      clipPath: "clip-path",
      clipRule: "clip-rule",
      colorInterpolation: "color-interpolation",
      colorInterpolationFilters: "color-interpolation-filters",
      colorProfile: "color-profile",
      colorRendering: "color-rendering",
      crossOrigin: "crossorigin",
      dataType: "datatype",
      dominantBaseline: "dominant-baseline",
      enableBackground: "enable-background",
      fillOpacity: "fill-opacity",
      fillRule: "fill-rule",
      floodColor: "flood-color",
      floodOpacity: "flood-opacity",
      fontFamily: "font-family",
      fontSize: "font-size",
      fontSizeAdjust: "font-size-adjust",
      fontStretch: "font-stretch",
      fontStyle: "font-style",
      fontVariant: "font-variant",
      fontWeight: "font-weight",
      glyphName: "glyph-name",
      glyphOrientationHorizontal: "glyph-orientation-horizontal",
      glyphOrientationVertical: "glyph-orientation-vertical",
      hrefLang: "hreflang",
      horizAdvX: "horiz-adv-x",
      horizOriginX: "horiz-origin-x",
      horizOriginY: "horiz-origin-y",
      imageRendering: "image-rendering",
      letterSpacing: "letter-spacing",
      lightingColor: "lighting-color",
      markerEnd: "marker-end",
      markerMid: "marker-mid",
      markerStart: "marker-start",
      navDown: "nav-down",
      navDownLeft: "nav-down-left",
      navDownRight: "nav-down-right",
      navLeft: "nav-left",
      navNext: "nav-next",
      navPrev: "nav-prev",
      navRight: "nav-right",
      navUp: "nav-up",
      navUpLeft: "nav-up-left",
      navUpRight: "nav-up-right",
      onAbort: "onabort",
      onActivate: "onactivate",
      onAfterPrint: "onafterprint",
      onBeforePrint: "onbeforeprint",
      onBegin: "onbegin",
      onCancel: "oncancel",
      onCanPlay: "oncanplay",
      onCanPlayThrough: "oncanplaythrough",
      onChange: "onchange",
      onClick: "onclick",
      onClose: "onclose",
      onCopy: "oncopy",
      onCueChange: "oncuechange",
      onCut: "oncut",
      onDblClick: "ondblclick",
      onDrag: "ondrag",
      onDragEnd: "ondragend",
      onDragEnter: "ondragenter",
      onDragExit: "ondragexit",
      onDragLeave: "ondragleave",
      onDragOver: "ondragover",
      onDragStart: "ondragstart",
      onDrop: "ondrop",
      onDurationChange: "ondurationchange",
      onEmptied: "onemptied",
      onEnd: "onend",
      onEnded: "onended",
      onError: "onerror",
      onFocus: "onfocus",
      onFocusIn: "onfocusin",
      onFocusOut: "onfocusout",
      onHashChange: "onhashchange",
      onInput: "oninput",
      onInvalid: "oninvalid",
      onKeyDown: "onkeydown",
      onKeyPress: "onkeypress",
      onKeyUp: "onkeyup",
      onLoad: "onload",
      onLoadedData: "onloadeddata",
      onLoadedMetadata: "onloadedmetadata",
      onLoadStart: "onloadstart",
      onMessage: "onmessage",
      onMouseDown: "onmousedown",
      onMouseEnter: "onmouseenter",
      onMouseLeave: "onmouseleave",
      onMouseMove: "onmousemove",
      onMouseOut: "onmouseout",
      onMouseOver: "onmouseover",
      onMouseUp: "onmouseup",
      onMouseWheel: "onmousewheel",
      onOffline: "onoffline",
      onOnline: "ononline",
      onPageHide: "onpagehide",
      onPageShow: "onpageshow",
      onPaste: "onpaste",
      onPause: "onpause",
      onPlay: "onplay",
      onPlaying: "onplaying",
      onPopState: "onpopstate",
      onProgress: "onprogress",
      onRateChange: "onratechange",
      onRepeat: "onrepeat",
      onReset: "onreset",
      onResize: "onresize",
      onScroll: "onscroll",
      onSeeked: "onseeked",
      onSeeking: "onseeking",
      onSelect: "onselect",
      onShow: "onshow",
      onStalled: "onstalled",
      onStorage: "onstorage",
      onSubmit: "onsubmit",
      onSuspend: "onsuspend",
      onTimeUpdate: "ontimeupdate",
      onToggle: "ontoggle",
      onUnload: "onunload",
      onVolumeChange: "onvolumechange",
      onWaiting: "onwaiting",
      onZoom: "onzoom",
      overlinePosition: "overline-position",
      overlineThickness: "overline-thickness",
      paintOrder: "paint-order",
      panose1: "panose-1",
      pointerEvents: "pointer-events",
      referrerPolicy: "referrerpolicy",
      renderingIntent: "rendering-intent",
      shapeRendering: "shape-rendering",
      stopColor: "stop-color",
      stopOpacity: "stop-opacity",
      strikethroughPosition: "strikethrough-position",
      strikethroughThickness: "strikethrough-thickness",
      strokeDashArray: "stroke-dasharray",
      strokeDashOffset: "stroke-dashoffset",
      strokeLineCap: "stroke-linecap",
      strokeLineJoin: "stroke-linejoin",
      strokeMiterLimit: "stroke-miterlimit",
      strokeOpacity: "stroke-opacity",
      strokeWidth: "stroke-width",
      tabIndex: "tabindex",
      textAnchor: "text-anchor",
      textDecoration: "text-decoration",
      textRendering: "text-rendering",
      transformOrigin: "transform-origin",
      typeOf: "typeof",
      underlinePosition: "underline-position",
      underlineThickness: "underline-thickness",
      unicodeBidi: "unicode-bidi",
      unicodeRange: "unicode-range",
      unitsPerEm: "units-per-em",
      vAlphabetic: "v-alphabetic",
      vHanging: "v-hanging",
      vIdeographic: "v-ideographic",
      vMathematical: "v-mathematical",
      vectorEffect: "vector-effect",
      vertAdvY: "vert-adv-y",
      vertOriginX: "vert-origin-x",
      vertOriginY: "vert-origin-y",
      wordSpacing: "word-spacing",
      writingMode: "writing-mode",
      xHeight: "x-height",
      playbackOrder: "playbackorder",
      timelineBegin: "timelinebegin"
    },
    transform: caseSensitiveTransform,
    properties: {
      about: commaOrSpaceSeparated,
      accentHeight: number,
      accumulate: null,
      additive: null,
      alignmentBaseline: null,
      alphabetic: number,
      amplitude: number,
      arabicForm: null,
      ascent: number,
      attributeName: null,
      attributeType: null,
      azimuth: number,
      bandwidth: null,
      baselineShift: null,
      baseFrequency: null,
      baseProfile: null,
      bbox: null,
      begin: null,
      bias: number,
      by: null,
      calcMode: null,
      capHeight: number,
      className: spaceSeparated,
      clip: null,
      clipPath: null,
      clipPathUnits: null,
      clipRule: null,
      color: null,
      colorInterpolation: null,
      colorInterpolationFilters: null,
      colorProfile: null,
      colorRendering: null,
      content: null,
      contentScriptType: null,
      contentStyleType: null,
      crossOrigin: null,
      cursor: null,
      cx: null,
      cy: null,
      d: null,
      dataType: null,
      defaultAction: null,
      descent: number,
      diffuseConstant: number,
      direction: null,
      display: null,
      dur: null,
      divisor: number,
      dominantBaseline: null,
      download: boolean,
      dx: null,
      dy: null,
      edgeMode: null,
      editable: null,
      elevation: number,
      enableBackground: null,
      end: null,
      event: null,
      exponent: number,
      externalResourcesRequired: null,
      fill: null,
      fillOpacity: number,
      fillRule: null,
      filter: null,
      filterRes: null,
      filterUnits: null,
      floodColor: null,
      floodOpacity: null,
      focusable: null,
      focusHighlight: null,
      fontFamily: null,
      fontSize: null,
      fontSizeAdjust: null,
      fontStretch: null,
      fontStyle: null,
      fontVariant: null,
      fontWeight: null,
      format: null,
      fr: null,
      from: null,
      fx: null,
      fy: null,
      g1: commaSeparated,
      g2: commaSeparated,
      glyphName: commaSeparated,
      glyphOrientationHorizontal: null,
      glyphOrientationVertical: null,
      glyphRef: null,
      gradientTransform: null,
      gradientUnits: null,
      handler: null,
      hanging: number,
      hatchContentUnits: null,
      hatchUnits: null,
      height: null,
      href: null,
      hrefLang: null,
      horizAdvX: number,
      horizOriginX: number,
      horizOriginY: number,
      id: null,
      ideographic: number,
      imageRendering: null,
      initialVisibility: null,
      in: null,
      in2: null,
      intercept: number,
      k: number,
      k1: number,
      k2: number,
      k3: number,
      k4: number,
      kernelMatrix: commaOrSpaceSeparated,
      kernelUnitLength: null,
      keyPoints: null,
      keySplines: null,
      keyTimes: null,
      kerning: null,
      lang: null,
      lengthAdjust: null,
      letterSpacing: null,
      lightingColor: null,
      limitingConeAngle: number,
      local: null,
      markerEnd: null,
      markerMid: null,
      markerStart: null,
      markerHeight: null,
      markerUnits: null,
      markerWidth: null,
      mask: null,
      maskContentUnits: null,
      maskUnits: null,
      mathematical: null,
      max: null,
      media: null,
      mediaCharacterEncoding: null,
      mediaContentEncodings: null,
      mediaSize: number,
      mediaTime: null,
      method: null,
      min: null,
      mode: null,
      name: null,
      navDown: null,
      navDownLeft: null,
      navDownRight: null,
      navLeft: null,
      navNext: null,
      navPrev: null,
      navRight: null,
      navUp: null,
      navUpLeft: null,
      navUpRight: null,
      numOctaves: null,
      observer: null,
      offset: null,
      onAbort: null,
      onActivate: null,
      onAfterPrint: null,
      onBeforePrint: null,
      onBegin: null,
      onCancel: null,
      onCanPlay: null,
      onCanPlayThrough: null,
      onChange: null,
      onClick: null,
      onClose: null,
      onCopy: null,
      onCueChange: null,
      onCut: null,
      onDblClick: null,
      onDrag: null,
      onDragEnd: null,
      onDragEnter: null,
      onDragExit: null,
      onDragLeave: null,
      onDragOver: null,
      onDragStart: null,
      onDrop: null,
      onDurationChange: null,
      onEmptied: null,
      onEnd: null,
      onEnded: null,
      onError: null,
      onFocus: null,
      onFocusIn: null,
      onFocusOut: null,
      onHashChange: null,
      onInput: null,
      onInvalid: null,
      onKeyDown: null,
      onKeyPress: null,
      onKeyUp: null,
      onLoad: null,
      onLoadedData: null,
      onLoadedMetadata: null,
      onLoadStart: null,
      onMessage: null,
      onMouseDown: null,
      onMouseEnter: null,
      onMouseLeave: null,
      onMouseMove: null,
      onMouseOut: null,
      onMouseOver: null,
      onMouseUp: null,
      onMouseWheel: null,
      onOffline: null,
      onOnline: null,
      onPageHide: null,
      onPageShow: null,
      onPaste: null,
      onPause: null,
      onPlay: null,
      onPlaying: null,
      onPopState: null,
      onProgress: null,
      onRateChange: null,
      onRepeat: null,
      onReset: null,
      onResize: null,
      onScroll: null,
      onSeeked: null,
      onSeeking: null,
      onSelect: null,
      onShow: null,
      onStalled: null,
      onStorage: null,
      onSubmit: null,
      onSuspend: null,
      onTimeUpdate: null,
      onToggle: null,
      onUnload: null,
      onVolumeChange: null,
      onWaiting: null,
      onZoom: null,
      opacity: null,
      operator: null,
      order: null,
      orient: null,
      orientation: null,
      origin: null,
      overflow: null,
      overlay: null,
      overlinePosition: number,
      overlineThickness: number,
      paintOrder: null,
      panose1: null,
      path: null,
      pathLength: number,
      patternContentUnits: null,
      patternTransform: null,
      patternUnits: null,
      phase: null,
      ping: spaceSeparated,
      pitch: null,
      playbackOrder: null,
      pointerEvents: null,
      points: null,
      pointsAtX: number,
      pointsAtY: number,
      pointsAtZ: number,
      preserveAlpha: null,
      preserveAspectRatio: null,
      primitiveUnits: null,
      propagate: null,
      property: commaOrSpaceSeparated,
      r: null,
      radius: null,
      referrerPolicy: null,
      refX: null,
      refY: null,
      rel: commaOrSpaceSeparated,
      rev: commaOrSpaceSeparated,
      renderingIntent: null,
      repeatCount: null,
      repeatDur: null,
      requiredExtensions: commaOrSpaceSeparated,
      requiredFeatures: commaOrSpaceSeparated,
      requiredFonts: commaOrSpaceSeparated,
      requiredFormats: commaOrSpaceSeparated,
      resource: null,
      restart: null,
      result: null,
      rotate: null,
      rx: null,
      ry: null,
      scale: null,
      seed: null,
      shapeRendering: null,
      side: null,
      slope: null,
      snapshotTime: null,
      specularConstant: number,
      specularExponent: number,
      spreadMethod: null,
      spacing: null,
      startOffset: null,
      stdDeviation: null,
      stemh: null,
      stemv: null,
      stitchTiles: null,
      stopColor: null,
      stopOpacity: null,
      strikethroughPosition: number,
      strikethroughThickness: number,
      string: null,
      stroke: null,
      strokeDashArray: commaOrSpaceSeparated,
      strokeDashOffset: null,
      strokeLineCap: null,
      strokeLineJoin: null,
      strokeMiterLimit: number,
      strokeOpacity: number,
      strokeWidth: null,
      style: null,
      surfaceScale: number,
      syncBehavior: null,
      syncBehaviorDefault: null,
      syncMaster: null,
      syncTolerance: null,
      syncToleranceDefault: null,
      systemLanguage: commaOrSpaceSeparated,
      tabIndex: number,
      tableValues: null,
      target: null,
      targetX: number,
      targetY: number,
      textAnchor: null,
      textDecoration: null,
      textRendering: null,
      textLength: null,
      timelineBegin: null,
      title: null,
      transformBehavior: null,
      type: null,
      typeOf: commaOrSpaceSeparated,
      to: null,
      transform: null,
      transformOrigin: null,
      u1: null,
      u2: null,
      underlinePosition: number,
      underlineThickness: number,
      unicode: null,
      unicodeBidi: null,
      unicodeRange: null,
      unitsPerEm: number,
      values: null,
      vAlphabetic: number,
      vMathematical: number,
      vectorEffect: null,
      vHanging: number,
      vIdeographic: number,
      version: null,
      vertAdvY: number,
      vertOriginX: number,
      vertOriginY: number,
      viewBox: null,
      viewTarget: null,
      visibility: null,
      width: null,
      widths: null,
      wordSpacing: null,
      writingMode: null,
      x: null,
      x1: null,
      x2: null,
      xChannelSelector: null,
      xHeight: number,
      y: null,
      y1: null,
      y2: null,
      yChannelSelector: null,
      z: null,
      zoomAndPan: null
    }
  }),
  valid = /^data[-\w.:]+$/i,
  dash = /-[a-z]/g,
  cap = /[A-Z]/g;,function find(schema, value) {
  let normal = normalize(value),
    prop = value,
    Type = Info;
  if (normal in schema.normal) return schema.property[schema.normal[normal]];
  if (normal.length > 4 && normal.slice(0, 4) === "data" && valid.test(value)) {
    if (value.charAt(4) === "-") {
      let rest = value.slice(5).replace(dash, camelcase);
      prop = "data" + rest.charAt(0).toUpperCase() + rest.slice(1);
    } else {
      let rest = value.slice(4);
      if (!dash.test(rest)) {
        let dashes = rest.replace(cap, kebab);
        dashes.charAt(0) !== "-" && (dashes = "-" + dashes), value = "data" + dashes;
      }
    }
    Type = DefinedInfo;
  }
  return new Type(prop, value);
},__name(find, "find");,function kebab($0) {
  return "-" + $0.toLowerCase();
},__name(kebab, "kebab");,function camelcase($0) {
  return $0.charAt(1).toUpperCase();
},__name(camelcase, "camelcase");,var html$2 = merge([xml, xlink, xmlns, aria, html$3], "html"),
  svg = merge([xml, xlink, xmlns, aria, svg$1], "svg"),
  own$2 = {}.hasOwnProperty;,function zwitch(key, options) {
  let settings = options || {};
  function one(value, ...parameters) {
    let fn = one.invalid,
      handlers = one.handlers;
    if (value && own$2.call(value, key)) {
      let id = String(value[key]);
      fn = own$2.call(handlers, id) ? handlers[id] : one.unknown;
    }
    if (fn) return fn.call(this, value, ...parameters);
  }
  return __name(one, "one"), one.handlers = settings.handlers || {}, one.invalid = settings.invalid, one.unknown = settings.unknown, one;
},__name(zwitch, "zwitch");,function core(value, options) {
  if (value = value.replace(options.subset ? charactersToExpression(options.subset) : /["&'<>`]/g, basic), options.subset || options.escapeOnly) return value;
  return value.replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, surrogate).replace(/[\x01-\t\v\f\x0E-\x1F\x7F\x81\x8D\x8F\x90\x9D\xA0-\uFFFF]/g, basic);
  function surrogate(pair, index, all) {
    return options.format((pair.charCodeAt(0) - 55296) * 1024 + pair.charCodeAt(1) - 56320 + 65536, all.charCodeAt(index + 2), options);
  }
  function basic(character, index, all) {
    return options.format(character.charCodeAt(0), all.charCodeAt(index + 1), options);
  }
},__name(core, "core");,function charactersToExpression(subset) {
  let groups = [],
    index = -1;
  for (; ++index < subset.length;) groups.push(subset[index].replace(/[|\\{}()[\]^$+*?.]/g, "\\$&"));
  return new RegExp("(?:" + groups.join("|") + ")", "g");
},__name(charactersToExpression, "charactersToExpression");,function toHexadecimal(code, next, omit) {
  let value = "&#x" + code.toString(16).toUpperCase();
  return omit && next && !/[\dA-Fa-f]/.test(String.fromCharCode(next)) ? value : value + ";";
},__name(toHexadecimal, "toHexadecimal");,function toDecimal(code, next, omit) {
  let value = "&#" + String(code);
  return omit && next && !/\d/.test(String.fromCharCode(next)) ? value : value + ";";
},__name(toDecimal, "toDecimal");,var characterEntitiesLegacy = ["AElig", "AMP", "Aacute", "Acirc", "Agrave", "Aring", "Atilde", "Auml", "COPY", "Ccedil", "ETH", "Eacute", "Ecirc", "Egrave", "Euml", "GT", "Iacute", "Icirc", "Igrave", "Iuml", "LT", "Ntilde", "Oacute", "Ocirc", "Ograve", "Oslash", "Otilde", "Ouml", "QUOT", "REG", "THORN", "Uacute", "Ucirc", "Ugrave", "Uuml", "Yacute", "aacute", "acirc", "acute", "aelig", "agrave", "amp", "aring", "atilde", "auml", "brvbar", "ccedil", "cedil", "cent", "copy", "curren", "deg", "divide", "eacute", "ecirc", "egrave", "eth", "euml", "frac12", "frac14", "frac34", "gt", "iacute", "icirc", "iexcl", "igrave", "iquest", "iuml", "laquo", "lt", "macr", "micro", "middot", "nbsp", "not", "ntilde", "oacute", "ocirc", "ograve", "ordf", "ordm", "oslash", "otilde", "ouml", "para", "plusmn", "pound", "quot", "raquo", "reg", "sect", "shy", "sup1", "sup2", "sup3", "szlig", "thorn", "times", "uacute", "ucirc", "ugrave", "uml", "uuml", "yacute", "yen", "yuml"],
  characterEntitiesHtml4 = {
    nbsp: "\xA0",
    iexcl: "\xA1",
    cent: "\xA2",
    pound: "\xA3",
    curren: "\xA4",
    yen: "\xA5",
    brvbar: "\xA6",
    sect: "\xA7",
    uml: "\xA8",
    copy: "\xA9",
    ordf: "\xAA",
    laquo: "\xAB",
    not: "\xAC",
    shy: "\xAD",
    reg: "\xAE",
    macr: "\xAF",
    deg: "\xB0",
    plusmn: "\xB1",
    sup2: "\xB2",
    sup3: "\xB3",
    acute: "\xB4",
    micro: "\xB5",
    para: "\xB6",
    middot: "\xB7",
    cedil: "\xB8",
    sup1: "\xB9",
    ordm: "\xBA",
    raquo: "\xBB",
    frac14: "\xBC",
    frac12: "\xBD",
    frac34: "\xBE",
    iquest: "\xBF",
    Agrave: "\xC0",
    Aacute: "\xC1",
    Acirc: "\xC2",
    Atilde: "\xC3",
    Auml: "\xC4",
    Aring: "\xC5",
    AElig: "\xC6",
    Ccedil: "\xC7",
    Egrave: "\xC8",
    Eacute: "\xC9",
    Ecirc: "\xCA",
    Euml: "\xCB",
    Igrave: "\xCC",
    Iacute: "\xCD",
    Icirc: "\xCE",
    Iuml: "\xCF",
    ETH: "\xD0",
    Ntilde: "\xD1",
    Ograve: "\xD2",
    Oacute: "\xD3",
    Ocirc: "\xD4",
    Otilde: "\xD5",
    Ouml: "\xD6",
    times: "\xD7",
    Oslash: "\xD8",
    Ugrave: "\xD9",
    Uacute: "\xDA",
    Ucirc: "\xDB",
    Uuml: "\xDC",
    Yacute: "\xDD",
    THORN: "\xDE",
    szlig: "\xDF",
    agrave: "\xE0",
    aacute: "\xE1",
    acirc: "\xE2",
    atilde: "\xE3",
    auml: "\xE4",
    aring: "\xE5",
    aelig: "\xE6",
    ccedil: "\xE7",
    egrave: "\xE8",
    eacute: "\xE9",
    ecirc: "\xEA",
    euml: "\xEB",
    igrave: "\xEC",
    iacute: "\xED",
    icirc: "\xEE",
    iuml: "\xEF",
    eth: "\xF0",
    ntilde: "\xF1",
    ograve: "\xF2",
    oacute: "\xF3",
    ocirc: "\xF4",
    otilde: "\xF5",
    ouml: "\xF6",
    divide: "\xF7",
    oslash: "\xF8",
    ugrave: "\xF9",
    uacute: "\xFA",
    ucirc: "\xFB",
    uuml: "\xFC",
    yacute: "\xFD",
    thorn: "\xFE",
    yuml: "\xFF",
    fnof: "\u0192",
    Alpha: "\u0391",
    Beta: "\u0392",
    Gamma: "\u0393",
    Delta: "\u0394",
    Epsilon: "\u0395",
    Zeta: "\u0396",
    Eta: "\u0397",
    Theta: "\u0398",
    Iota: "\u0399",
    Kappa: "\u039A",
    Lambda: "\u039B",
    Mu: "\u039C",
    Nu: "\u039D",
    Xi: "\u039E",
    Omicron: "\u039F",
    Pi: "\u03A0",
    Rho: "\u03A1",
    Sigma: "\u03A3",
    Tau: "\u03A4",
    Upsilon: "\u03A5",
    Phi: "\u03A6",
    Chi: "\u03A7",
    Psi: "\u03A8",
    Omega: "\u03A9",
    alpha: "\u03B1",
    beta: "\u03B2",
    gamma: "\u03B3",
    delta: "\u03B4",
    epsilon: "\u03B5",
    zeta: "\u03B6",
    eta: "\u03B7",
    theta: "\u03B8",
    iota: "\u03B9",
    kappa: "\u03BA",
    lambda: "\u03BB",
    mu: "\u03BC",
    nu: "\u03BD",
    xi: "\u03BE",
    omicron: "\u03BF",
    pi: "\u03C0",
    rho: "\u03C1",
    sigmaf: "\u03C2",
    sigma: "\u03C3",
    tau: "\u03C4",
    upsilon: "\u03C5",
    phi: "\u03C6",
    chi: "\u03C7",
    psi: "\u03C8",
    omega: "\u03C9",
    thetasym: "\u03D1",
    upsih: "\u03D2",
    piv: "\u03D6",
    bull: "\u2022",
    hellip: "\u2026",
    prime: "\u2032",
    Prime: "\u2033",
    oline: "\u203E",
    frasl: "\u2044",
    weierp: "\u2118",
    image: "\u2111",
    real: "\u211C",
    trade: "\u2122",
    alefsym: "\u2135",
    larr: "\u2190",
    uarr: "\u2191",
    rarr: "\u2192",
    darr: "\u2193",
    harr: "\u2194",
    crarr: "\u21B5",
    lArr: "\u21D0",
    uArr: "\u21D1",
    rArr: "\u21D2",
    dArr: "\u21D3",
    hArr: "\u21D4",
    forall: "\u2200",
    part: "\u2202",
    exist: "\u2203",
    empty: "\u2205",
    nabla: "\u2207",
    isin: "\u2208",
    notin: "\u2209",
    ni: "\u220B",
    prod: "\u220F",
    sum: "\u2211",
    minus: "\u2212",
    lowast: "\u2217",
    radic: "\u221A",
    prop: "\u221D",
    infin: "\u221E",
    ang: "\u2220",
    and: "\u2227",
    or: "\u2228",
    cap: "\u2229",
    cup: "\u222A",
    int: "\u222B",
    there4: "\u2234",
    sim: "\u223C",
    cong: "\u2245",
    asymp: "\u2248",
    ne: "\u2260",
    equiv: "\u2261",
    le: "\u2264",
    ge: "\u2265",
    sub: "\u2282",
    sup: "\u2283",
    nsub: "\u2284",
    sube: "\u2286",
    supe: "\u2287",
    oplus: "\u2295",
    otimes: "\u2297",
    perp: "\u22A5",
    sdot: "\u22C5",
    lceil: "\u2308",
    rceil: "\u2309",
    lfloor: "\u230A",
    rfloor: "\u230B",
    lang: "\u2329",
    rang: "\u232A",
    loz: "\u25CA",
    spades: "\u2660",
    clubs: "\u2663",
    hearts: "\u2665",
    diams: "\u2666",
    quot: '"',
    amp: "&",
    lt: "<",
    gt: ">",
    OElig: "\u0152",
    oelig: "\u0153",
    Scaron: "\u0160",
    scaron: "\u0161",
    Yuml: "\u0178",
    circ: "\u02C6",
    tilde: "\u02DC",
    ensp: "\u2002",
    emsp: "\u2003",
    thinsp: "\u2009",
    zwnj: "\u200C",
    zwj: "\u200D",
    lrm: "\u200E",
    rlm: "\u200F",
    ndash: "\u2013",
    mdash: "\u2014",
    lsquo: "\u2018",
    rsquo: "\u2019",
    sbquo: "\u201A",
    ldquo: "\u201C",
    rdquo: "\u201D",
    bdquo: "\u201E",
    dagger: "\u2020",
    Dagger: "\u2021",
    permil: "\u2030",
    lsaquo: "\u2039",
    rsaquo: "\u203A",
    euro: "\u20AC"
  },
  dangerous = ["cent", "copy", "divide", "gt", "lt", "not", "para", "times"],
  own$1 = {}.hasOwnProperty,
  characters = {},
  key;,for (key in characterEntitiesHtml4) own$1.call(characterEntitiesHtml4, key) && (characters[characterEntitiesHtml4[key]] = key);,function toNamed(code, next, omit, attribute) {
  let character = String.fromCharCode(code);
  if (own$1.call(characters, character)) {
    let name = characters[character],
      value = "&" + name;
    return omit && characterEntitiesLegacy.includes(name) && !dangerous.includes(name) && (!attribute || next && next !== 61 && /[^\da-z]/i.test(String.fromCharCode(next))) ? value : value + ";";
  }
  return "";
},__name(toNamed, "toNamed");,function formatSmart(code, next, options) {
  let numeric = toHexadecimal(code, next, options.omitOptionalSemicolons),
    named;
  if ((options.useNamedReferences || options.useShortestReferences) && (named = toNamed(code, next, options.omitOptionalSemicolons, options.attribute)), (options.useShortestReferences || !named) && options.useShortestReferences) {
    let decimal = toDecimal(code, next, options.omitOptionalSemicolons);
    decimal.length < numeric.length && (numeric = decimal);
  }
  return named && (!options.useShortestReferences || named.length < numeric.length) ? named : numeric;
},__name(formatSmart, "formatSmart");,function stringifyEntities(value, options) {
  return core(value, Object.assign({
    format: formatSmart
  }, options));
},__name(stringifyEntities, "stringifyEntities");,var htmlCommentRegex = /^>|^->|<!--|-->|--!>|<!-$/g,
  bogusCommentEntitySubset = [">"],
  commentEntitySubset = ["<", ">"];,function comment(node, _1, _2, state) {
  return state.settings.bogusComments ? "<?" + stringifyEntities(node.value, Object.assign({}, state.settings.characterReferences, {
    subset: bogusCommentEntitySubset
  })) + ">" : "<!--" + node.value.replace(htmlCommentRegex, encode) + "-->";
  function encode($0) {
    return stringifyEntities($0, Object.assign({}, state.settings.characterReferences, {
      subset: commentEntitySubset
    }));
  }
},__name(comment, "comment");,function doctype(_1, _2, _3, state) {
  return "<!" + (state.settings.upperDoctype ? "DOCTYPE" : "doctype") + (state.settings.tightDoctype ? "" : " ") + "html>";
},__name(doctype, "doctype");,function ccount(value, character) {
  let source = String(value);
  if (typeof character != "string") throw new TypeError("Expected character");
  let count = 0,
    index = source.indexOf(character);
  for (; index !== -1;) count++, index = source.indexOf(character, index + character.length);
  return count;
},__name(ccount, "ccount");,function stringify$1(values, options) {
  let settings = options || {};
  return (values[values.length - 1] === "" ? [...values, ""] : values).join((settings.padRight ? " " : "") + "," + (settings.padLeft === !1 ? "" : " ")).trim();
},__name(stringify$1, "stringify$1");,function stringify(values) {
  return values.join(" ").trim();
},__name(stringify, "stringify");,var re = /[ \t\n\f\r]/g;,function whitespace(thing) {
  return typeof thing == "object" ? thing.type === "text" ? empty(thing.value) : !1 : empty(thing);
},__name(whitespace, "whitespace");,function empty(value) {
  return value.replace(re, "") === "";
},__name(empty, "empty");,var siblingAfter = siblings(1),
  siblingBefore = siblings(-1),
  emptyChildren$1 = [];,function siblings(increment) {
  return sibling;
  function sibling(parent, index, includeWhitespace) {
    let siblings = parent ? parent.children : emptyChildren$1,
      offset = (index || 0) + increment,
      next = siblings[offset];
    if (!includeWhitespace) for (; next && whitespace(next);) offset += increment, next = siblings[offset];
    return next;
  }
},__name(siblings, "siblings");,var own = {}.hasOwnProperty;,function omission(handlers) {
  return omit;
  function omit(node, index, parent) {
    return own.call(handlers, node.tagName) && handlers[node.tagName](node, index, parent);
  }
},__name(omission, "omission");,var closing = omission({
  body: body$1,
  caption: headOrColgroupOrCaption,
  colgroup: headOrColgroupOrCaption,
  dd: dd,
  dt: dt,
  head: headOrColgroupOrCaption,
  html: html$1,
  li: li,
  optgroup: optgroup,
  option: option,
  p: p,
  rp: rubyElement,
  rt: rubyElement,
  tbody: tbody$1,
  td: cells,
  tfoot: tfoot,
  th: cells,
  thead: thead,
  tr: tr
});,function headOrColgroupOrCaption(_, index, parent) {
  let next = siblingAfter(parent, index, !0);
  return !next || next.type !== "comment" && !(next.type === "text" && whitespace(next.value.charAt(0)));
},__name(headOrColgroupOrCaption, "headOrColgroupOrCaption");,function html$1(_, index, parent) {
  let next = siblingAfter(parent, index);
  return !next || next.type !== "comment";
},__name(html$1, "html$1");,function body$1(_, index, parent) {
  let next = siblingAfter(parent, index);
  return !next || next.type !== "comment";
},__name(body$1, "body$1");,function p(_, index, parent) {
  let next = siblingAfter(parent, index);
  return next ? next.type === "element" && (next.tagName === "address" || next.tagName === "article" || next.tagName === "aside" || next.tagName === "blockquote" || next.tagName === "details" || next.tagName === "div" || next.tagName === "dl" || next.tagName === "fieldset" || next.tagName === "figcaption" || next.tagName === "figure" || next.tagName === "footer" || next.tagName === "form" || next.tagName === "h1" || next.tagName === "h2" || next.tagName === "h3" || next.tagName === "h4" || next.tagName === "h5" || next.tagName === "h6" || next.tagName === "header" || next.tagName === "hgroup" || next.tagName === "hr" || next.tagName === "main" || next.tagName === "menu" || next.tagName === "nav" || next.tagName === "ol" || next.tagName === "p" || next.tagName === "pre" || next.tagName === "section" || next.tagName === "table" || next.tagName === "ul") : !parent || !(parent.type === "element" && (parent.tagName === "a" || parent.tagName === "audio" || parent.tagName === "del" || parent.tagName === "ins" || parent.tagName === "map" || parent.tagName === "noscript" || parent.tagName === "video"));
},__name(p, "p");,function li(_, index, parent) {
  let next = siblingAfter(parent, index);
  return !next || next.type === "element" && next.tagName === "li";
},__name(li, "li");,function dt(_, index, parent) {
  let next = siblingAfter(parent, index);
  return !!(next && next.type === "element" && (next.tagName === "dt" || next.tagName === "dd"));
},__name(dt, "dt");,function dd(_, index, parent) {
  let next = siblingAfter(parent, index);
  return !next || next.type === "element" && (next.tagName === "dt" || next.tagName === "dd");
},__name(dd, "dd");,function rubyElement(_, index, parent) {
  let next = siblingAfter(parent, index);
  return !next || next.type === "element" && (next.tagName === "rp" || next.tagName === "rt");
},__name(rubyElement, "rubyElement");,function optgroup(_, index, parent) {
  let next = siblingAfter(parent, index);
  return !next || next.type === "element" && next.tagName === "optgroup";
},__name(optgroup, "optgroup");,function option(_, index, parent) {
  let next = siblingAfter(parent, index);
  return !next || next.type === "element" && (next.tagName === "option" || next.tagName === "optgroup");
},__name(option, "option");,function thead(_, index, parent) {
  let next = siblingAfter(parent, index);
  return !!(next && next.type === "element" && (next.tagName === "tbody" || next.tagName === "tfoot"));
},__name(thead, "thead");,function tbody$1(_, index, parent) {
  let next = siblingAfter(parent, index);
  return !next || next.type === "element" && (next.tagName === "tbody" || next.tagName === "tfoot");
},__name(tbody$1, "tbody$1");,function tfoot(_, index, parent) {
  return !siblingAfter(parent, index);
},__name(tfoot, "tfoot");,function tr(_, index, parent) {
  let next = siblingAfter(parent, index);
  return !next || next.type === "element" && next.tagName === "tr";
},__name(tr, "tr");,function cells(_, index, parent) {
  let next = siblingAfter(parent, index);
  return !next || next.type === "element" && (next.tagName === "td" || next.tagName === "th");
},__name(cells, "cells");,var opening = omission({
  body: body,
  colgroup: colgroup,
  head: head,
  html: html,
  tbody: tbody
});,function html(node) {
  let head = siblingAfter(node, -1);
  return !head || head.type !== "comment";
},__name(html, "html");,function head(node) {
  let children = node.children,
    seen = [],
    index = -1;
  for (; ++index < children.length;) {
    let child = children[index];
    if (child.type === "element" && (child.tagName === "title" || child.tagName === "base")) {
      if (seen.includes(child.tagName)) return !1;
      seen.push(child.tagName);
    }
  }
  return children.length > 0;
},__name(head, "head");,function body(node) {
  let head = siblingAfter(node, -1, !0);
  return !head || head.type !== "comment" && !(head.type === "text" && whitespace(head.value.charAt(0))) && !(head.type === "element" && (head.tagName === "meta" || head.tagName === "link" || head.tagName === "script" || head.tagName === "style" || head.tagName === "template"));
},__name(body, "body");,function colgroup(node, index, parent) {
  let previous = siblingBefore(parent, index),
    head = siblingAfter(node, -1, !0);
  return parent && previous && previous.type === "element" && previous.tagName === "colgroup" && closing(previous, parent.children.indexOf(previous), parent) ? !1 : !!(head && head.type === "element" && head.tagName === "col");
},__name(colgroup, "colgroup");,function tbody(node, index, parent) {
  let previous = siblingBefore(parent, index),
    head = siblingAfter(node, -1);
  return parent && previous && previous.type === "element" && (previous.tagName === "thead" || previous.tagName === "tbody") && closing(previous, parent.children.indexOf(previous), parent) ? !1 : !!(head && head.type === "element" && head.tagName === "tr");
},__name(tbody, "tbody");,var constants = {
  name: [[`	
\f\r &/=>`.split(""), `	
\f\r "&'/=>\``.split("")], [`\0	
\f\r "&'/<=>`.split(""), `\0	
\f\r "&'/<=>\``.split("")]],
  unquoted: [[`	
\f\r &>`.split(""), `\0	
\f\r "&'<=>\``.split("")], [`\0	
\f\r "&'<=>\``.split(""), `\0	
\f\r "&'<=>\``.split("")]],
  single: [["&'".split(""), "\"&'`".split("")], ["\0&'".split(""), "\0\"&'`".split("")]],
  double: [['"&'.split(""), "\"&'`".split("")], ['\0"&'.split(""), "\0\"&'`".split("")]]
};,function element(node, index, parent, state) {
  let schema = state.schema,
    omit = schema.space === "svg" ? !1 : state.settings.omitOptionalTags,
    selfClosing = schema.space === "svg" ? state.settings.closeEmptyElements : state.settings.voids.includes(node.tagName.toLowerCase()),
    parts = [],
    last;
  schema.space === "html" && node.tagName === "svg" && (state.schema = svg);
  let attributes = serializeAttributes(state, node.properties),
    content = state.all(schema.space === "html" && node.tagName === "template" ? node.content : node);
  return state.schema = schema, content && (selfClosing = !1), (attributes || !omit || !opening(node, index, parent)) && (parts.push("<", node.tagName, attributes ? " " + attributes : ""), selfClosing && (schema.space === "svg" || state.settings.closeSelfClosing) && (last = attributes.charAt(attributes.length - 1), (!state.settings.tightSelfClosing || last === "/" || last && last !== '"' && last !== "'") && parts.push(" "), parts.push("/")), parts.push(">")), parts.push(content), !selfClosing && (!omit || !closing(node, index, parent)) && parts.push("</" + node.tagName + ">"), parts.join("");
},__name(element, "element");,function serializeAttributes(state, properties) {
  let values = [],
    index = -1,
    key;
  if (properties) {
    for (key in properties) if (properties[key] !== null && properties[key] !== void 0) {
      let value = serializeAttribute(state, key, properties[key]);
      value && values.push(value);
    }
  }
  for (; ++index < values.length;) {
    let last = state.settings.tightAttributes ? values[index].charAt(values[index].length - 1) : void 0;
    index !== values.length - 1 && last !== '"' && last !== "'" && (values[index] += " ");
  }
  return values.join("");
},__name(serializeAttributes, "serializeAttributes");,function serializeAttribute(state, key, value) {
  let info = find(state.schema, key),
    x = state.settings.allowParseErrors && state.schema.space === "html" ? 0 : 1,
    y = state.settings.allowDangerousCharacters ? 0 : 1,
    quote = state.quote,
    result;
  if (info.overloadedBoolean && (value === info.attribute || value === "") ? value = !0 : (info.boolean || info.overloadedBoolean && typeof value != "string") && (value = !!value), value == null || value === !1 || typeof value == "number" && Number.isNaN(value)) return "";
  let name = stringifyEntities(info.attribute, Object.assign({}, state.settings.characterReferences, {
    subset: constants.name[x][y]
  }));
  return value === !0 || (value = Array.isArray(value) ? (info.commaSeparated ? stringify$1 : stringify)(value, {
    padLeft: !state.settings.tightCommaSeparatedLists
  }) : String(value), state.settings.collapseEmptyAttributes && !value) ? name : (state.settings.preferUnquoted && (result = stringifyEntities(value, Object.assign({}, state.settings.characterReferences, {
    attribute: !0,
    subset: constants.unquoted[x][y]
  }))), result !== value && (state.settings.quoteSmart && ccount(value, quote) > ccount(value, state.alternative) && (quote = state.alternative), result = quote + stringifyEntities(value, Object.assign({}, state.settings.characterReferences, {
    subset: (quote === "'" ? constants.single : constants.double)[x][y],
    attribute: !0
  })) + quote), name + (result && "=" + result));
},__name(serializeAttribute, "serializeAttribute");,var textEntitySubset = ["<", "&"];,function text(node, _, parent, state) {
  return parent && parent.type === "element" && (parent.tagName === "script" || parent.tagName === "style") ? node.value : stringifyEntities(node.value, Object.assign({}, state.settings.characterReferences, {
    subset: textEntitySubset
  }));
},__name(text, "text");,function raw(node, index, parent, state) {
  return state.settings.allowDangerousHtml ? node.value : text(node, index, parent, state);
},__name(raw, "raw");,function root(node, _1, _2, state) {
  return state.all(node);
},__name(root, "root");,var handle = zwitch("type", {
  invalid: invalid,
  unknown: unknown,
  handlers: {
    comment: comment,
    doctype: doctype,
    element: element,
    raw: raw,
    root: root,
    text: text
  }
});,function invalid(node) {
  throw new Error("Expected node, not `" + node + "`");
},__name(invalid, "invalid");,function unknown(node_) {
  let node = node_;
  throw new Error("Cannot compile unknown node `" + node.type + "`");
},__name(unknown, "unknown");,var emptyOptions = {},
  emptyCharacterReferences = {},
  emptyChildren = [];,function toHtml(tree, options) {
  let options_ = options || emptyOptions,
    quote = options_.quote || '"',
    alternative = quote === '"' ? "'" : '"';
  if (quote !== '"' && quote !== "'") throw new Error("Invalid quote `" + quote + "`, expected `'` or `\"`");
  return {
    one: one,
    all: all,
    settings: {
      omitOptionalTags: options_.omitOptionalTags || !1,
      allowParseErrors: options_.allowParseErrors || !1,
      allowDangerousCharacters: options_.allowDangerousCharacters || !1,
      quoteSmart: options_.quoteSmart || !1,
      preferUnquoted: options_.preferUnquoted || !1,
      tightAttributes: options_.tightAttributes || !1,
      upperDoctype: options_.upperDoctype || !1,
      tightDoctype: options_.tightDoctype || !1,
      bogusComments: options_.bogusComments || !1,
      tightCommaSeparatedLists: options_.tightCommaSeparatedLists || !1,
      tightSelfClosing: options_.tightSelfClosing || !1,
      collapseEmptyAttributes: options_.collapseEmptyAttributes || !1,
      allowDangerousHtml: options_.allowDangerousHtml || !1,
      voids: options_.voids || htmlVoidElements,
      characterReferences: options_.characterReferences || emptyCharacterReferences,
      closeSelfClosing: options_.closeSelfClosing || !1,
      closeEmptyElements: options_.closeEmptyElements || !1
    },
    schema: options_.space === "svg" ? svg : html$2,
    quote: quote,
    alternative: alternative
  }.one(Array.isArray(tree) ? {
    type: "root",
    children: tree
  } : tree, void 0, void 0);
},__name(toHtml, "toHtml");,function one(node, index, parent) {
  return handle(node, index, parent, this);
},__name(one, "one");,function all(parent) {
  let results = [],
    children = parent && parent.children || emptyChildren,
    index = -1;
  for (; ++index < children.length;) results[index] = this.one(children[index], index, parent);
  return results.join("");
},__name(all, "all");,function codeToHtml(internal, code, options) {
  var _a;
  let context = {
      meta: {},
      options: options,
      codeToHast: __name((_code, _options) => codeToHast(internal, _code, _options), "codeToHast"),
      codeToTokens: __name((_code, _options) => codeToTokens(internal, _code, _options), "codeToTokens")
    },
    result = toHtml(codeToHast(internal, code, options, context));
  for (let transformer of getTransformers(options)) result = ((_a = transformer.postprocess) == null ? void 0 : _a.call(context, result, options)) || result;
  return result;
},__name(codeToHtml, "codeToHtml");,var VSCODE_FALLBACK_EDITOR_FG = {
    light: "#333333",
    dark: "#bbbbbb"
  },
  VSCODE_FALLBACK_EDITOR_BG = {
    light: "#fffffe",
    dark: "#1e1e1e"
  },
  RESOLVED_KEY = "__shiki_resolved";,function normalizeTheme(rawTheme) {
  var _a, _b, _c, _d, _e;
  if (rawTheme != null && rawTheme[RESOLVED_KEY]) return rawTheme;
  let theme = {
    ...rawTheme
  };
  theme.tokenColors && !theme.settings && (theme.settings = theme.tokenColors, delete theme.tokenColors), theme.type || (theme.type = "dark"), theme.colorReplacements = {
    ...theme.colorReplacements
  }, theme.settings || (theme.settings = []);
  let {
    bg: bg,
    fg: fg
  } = theme;
  if (!bg || !fg) {
    let globalSetting = theme.settings ? theme.settings.find(s => !s.name && !s.scope) : void 0;
    (_a = globalSetting == null ? void 0 : globalSetting.settings) != null && _a.foreground && (fg = globalSetting.settings.foreground), (_b = globalSetting == null ? void 0 : globalSetting.settings) != null && _b.background && (bg = globalSetting.settings.background), !fg && (_c = theme == null ? void 0 : theme.colors) != null && _c["editor.foreground"] && (fg = theme.colors["editor.foreground"]), !bg && (_d = theme == null ? void 0 : theme.colors) != null && _d["editor.background"] && (bg = theme.colors["editor.background"]), fg || (fg = theme.type === "light" ? VSCODE_FALLBACK_EDITOR_FG.light : VSCODE_FALLBACK_EDITOR_FG.dark), bg || (bg = theme.type === "light" ? VSCODE_FALLBACK_EDITOR_BG.light : VSCODE_FALLBACK_EDITOR_BG.dark), theme.fg = fg, theme.bg = bg;
  }
  theme.settings[0] && theme.settings[0].settings && !theme.settings[0].scope || theme.settings.unshift({
    settings: {
      foreground: theme.fg,
      background: theme.bg
    }
  });
  let replacementCount = 0,
    replacementMap = new Map();
  function getReplacementColor(value) {
    var _a;
    if (replacementMap.has(value)) return replacementMap.get(value);
    replacementCount += 1;
    let hex = `#${replacementCount.toString(16).padStart(8, "0").toLowerCase()}`;
    return (_a = theme.colorReplacements) != null && _a[`#${hex}`] ? getReplacementColor(value) : (replacementMap.set(value, hex), hex);
  }
  __name(getReplacementColor, "getReplacementColor"), theme.settings = theme.settings.map(setting => {
    var _a, _b;
    let replaceFg = ((_a = setting.settings) == null ? void 0 : _a.foreground) && !setting.settings.foreground.startsWith("#"),
      replaceBg = ((_b = setting.settings) == null ? void 0 : _b.background) && !setting.settings.background.startsWith("#");
    if (!replaceFg && !replaceBg) return setting;
    let clone = {
      ...setting,
      settings: {
        ...setting.settings
      }
    };
    if (replaceFg) {
      let replacement = getReplacementColor(setting.settings.foreground);
      theme.colorReplacements[replacement] = setting.settings.foreground, clone.settings.foreground = replacement;
    }
    if (replaceBg) {
      let replacement = getReplacementColor(setting.settings.background);
      theme.colorReplacements[replacement] = setting.settings.background, clone.settings.background = replacement;
    }
    return clone;
  });
  for (let key of Object.keys(theme.colors || {})) if ((key === "editor.foreground" || key === "editor.background" || key.startsWith("terminal.ansi")) && !((_e = theme.colors[key]) != null && _e.startsWith("#"))) {
    let replacement = getReplacementColor(theme.colors[key]);
    theme.colorReplacements[replacement] = theme.colors[key], theme.colors[key] = replacement;
  }
  return Object.defineProperty(theme, RESOLVED_KEY, {
    enumerable: !1,
    writable: !1,
    value: !0
  }), theme;
},__name(normalizeTheme, "normalizeTheme");,var _Registry = class _Registry extends Registry$1 {
  constructor(_resolver, _themes, _langs, _alias = {}) {
    super(_resolver);
    __publicField(this, "_resolver");
    __publicField(this, "_themes");
    __publicField(this, "_langs");
    __publicField(this, "_alias");
    __publicField(this, "_resolvedThemes", new Map());
    __publicField(this, "_resolvedGrammars", new Map());
    __publicField(this, "_langMap", new Map());
    __publicField(this, "_langGraph", new Map());
    __publicField(this, "_textmateThemeCache", new WeakMap());
    __publicField(this, "_loadedThemesCache", null);
    __publicField(this, "_loadedLanguagesCache", null);
    this._resolver = _resolver, this._themes = _themes, this._langs = _langs, this._alias = _alias, _themes.forEach(t => this.loadTheme(t)), _langs.forEach(l => this.loadLanguage(l));
  }
  getTheme(theme) {
    return typeof theme == "string" ? this._resolvedThemes.get(theme) : this.loadTheme(theme);
  }
  loadTheme(theme) {
    let _theme = normalizeTheme(theme);
    return _theme.name && (this._resolvedThemes.set(_theme.name, _theme), this._loadedThemesCache = null), _theme;
  }
  getLoadedThemes() {
    return this._loadedThemesCache || (this._loadedThemesCache = [...this._resolvedThemes.keys()]), this._loadedThemesCache;
  }
  setTheme(theme) {
    let textmateTheme = this._textmateThemeCache.get(theme);
    textmateTheme || (textmateTheme = Theme.createFromRawTheme(theme), this._textmateThemeCache.set(theme, textmateTheme)), this._syncRegistry.setTheme(textmateTheme);
  }
  getGrammar(name) {
    if (this._alias[name]) {
      let resolved = new Set([name]);
      for (; this._alias[name];) {
        if (name = this._alias[name], resolved.has(name)) throw new ShikiError(`Circular alias \`${Array.from(resolved).join(" -> ")} -> ${name}\``);
        resolved.add(name);
      }
    }
    return this._resolvedGrammars.get(name);
  }
  async loadLanguage(lang) {
    var _a, _b, _c, _d;
    if (this.getGrammar(lang.name)) return;
    let embeddedLazilyBy = new Set([...this._langMap.values()].filter(i => {
      var _a;
      return (_a = i.embeddedLangsLazy) == null ? void 0 : _a.includes(lang.name);
    }));
    this._resolver.addLanguage(lang);
    let grammarConfig = {
      balancedBracketSelectors: lang.balancedBracketSelectors || ["*"],
      unbalancedBracketSelectors: lang.unbalancedBracketSelectors || []
    };
    this._syncRegistry._rawGrammars.set(lang.scopeName, lang);
    let g = await this.loadGrammarWithConfiguration(lang.scopeName, 1, grammarConfig);
    if (g.name = lang.name, this._resolvedGrammars.set(lang.name, g), lang.aliases && lang.aliases.forEach(alias => {
      this._alias[alias] = lang.name;
    }), this._loadedLanguagesCache = null, embeddedLazilyBy.size) for (let e of embeddedLazilyBy) this._resolvedGrammars.delete(e.name), this._loadedLanguagesCache = null, (_b = (_a = this._syncRegistry) == null ? void 0 : _a._injectionGrammars) == null || _b.delete(e.scopeName), (_d = (_c = this._syncRegistry) == null ? void 0 : _c._grammars) == null || _d.delete(e.scopeName), await this.loadLanguage(this._langMap.get(e.name));
  }
  async init() {
    this._themes.map(t => this.loadTheme(t)), await this.loadLanguages(this._langs);
  }
  dispose() {
    super.dispose(), this._resolvedThemes.clear(), this._resolvedGrammars.clear(), this._langMap.clear(), this._langGraph.clear(), this._loadedThemesCache = null;
  }
  async loadLanguages(langs) {
    for (let lang of langs) this.resolveEmbeddedLanguages(lang);
    let langsGraphArray = Array.from(this._langGraph.entries()),
      missingLangs = langsGraphArray.filter(([_, lang]) => !lang);
    if (missingLangs.length) {
      let dependents = langsGraphArray.filter(([_, lang]) => {
        var _a;
        return lang && ((_a = lang.embeddedLangs) == null ? void 0 : _a.some(l => missingLangs.map(([name]) => name).includes(l)));
      }).filter(lang => !missingLangs.includes(lang));
      throw new ShikiError(`Missing languages ${missingLangs.map(([name]) => `\`${name}\``).join(", ")}, required by ${dependents.map(([name]) => `\`${name}\``).join(", ")}`);
    }
    for (let [_, lang] of langsGraphArray) this._resolver.addLanguage(lang);
    for (let [_, lang] of langsGraphArray) await this.loadLanguage(lang);
  }
  getLoadedLanguages() {
    return this._loadedLanguagesCache || (this._loadedLanguagesCache = [...new Set([...this._resolvedGrammars.keys(), ...Object.keys(this._alias)])]), this._loadedLanguagesCache;
  }
  resolveEmbeddedLanguages(lang) {
    if (this._langMap.set(lang.name, lang), this._langGraph.set(lang.name, lang), lang.embeddedLangs) for (let embeddedLang of lang.embeddedLangs) this._langGraph.set(embeddedLang, this._langMap.get(embeddedLang));
  }
};,__name(_Registry, "Registry");,var Registry = _Registry,
  _Resolver = class _Resolver {
    constructor(onigLibPromise, langs) {
      __publicField(this, "_langs", new Map());
      __publicField(this, "_scopeToLang", new Map());
      __publicField(this, "_injections", new Map());
      __publicField(this, "_onigLibPromise");
      this._onigLibPromise = onigLibPromise.then(engine => ({
        createOnigScanner: __name(patterns => engine.createScanner(patterns), "createOnigScanner"),
        createOnigString: __name(s => engine.createString(s), "createOnigString")
      })), langs.forEach(i => this.addLanguage(i));
    }
    get onigLib() {
      return this._onigLibPromise;
    }
    getLangRegistration(langIdOrAlias) {
      return this._langs.get(langIdOrAlias);
    }
    async loadGrammar(scopeName) {
      return this._scopeToLang.get(scopeName);
    }
    addLanguage(l) {
      this._langs.set(l.name, l), l.aliases && l.aliases.forEach(a => {
        this._langs.set(a, l);
      }), this._scopeToLang.set(l.scopeName, l), l.injectTo && l.injectTo.forEach(i => {
        this._injections.get(i) || this._injections.set(i, []), this._injections.get(i).push(l.scopeName);
      });
    }
    getInjections(scopeName) {
      let scopeParts = scopeName.split("."),
        injections = [];
      for (let i = 1; i <= scopeParts.length; i++) {
        let subScopeName = scopeParts.slice(0, i).join(".");
        injections = [...injections, ...(this._injections.get(subScopeName) || [])];
      }
      return injections;
    }
  };,__name(_Resolver, "Resolver");,var Resolver = _Resolver;,function getHeapMax() {
  return 2147483648;
},__name(getHeapMax, "getHeapMax");,function _emscripten_get_now() {
  return typeof performance < "u" ? performance.now() : Date.now();
},__name(_emscripten_get_now, "_emscripten_get_now");,var alignUp = __name((x, multiple) => x + (multiple - x % multiple) % multiple, "alignUp");,async function main(init) {
  let wasmMemory,
    buffer,
    binding = {};
  function updateGlobalBufferAndViews(buf) {
    buffer = buf, binding.HEAPU8 = new Uint8Array(buf), binding.HEAPU32 = new Uint32Array(buf);
  }
  __name(updateGlobalBufferAndViews, "updateGlobalBufferAndViews");
  function _emscripten_memcpy_big(dest, src, num) {
    binding.HEAPU8.copyWithin(dest, src, src + num);
  }
  __name(_emscripten_memcpy_big, "_emscripten_memcpy_big");
  function emscripten_realloc_buffer(size) {
    try {
      return wasmMemory.grow(size - buffer.byteLength + 65535 >>> 16), updateGlobalBufferAndViews(wasmMemory.buffer), 1;
    } catch {}
  }
  __name(emscripten_realloc_buffer, "emscripten_realloc_buffer");
  function _emscripten_resize_heap(requestedSize) {
    let oldSize = binding.HEAPU8.length;
    requestedSize = requestedSize >>> 0;
    let maxHeapSize = getHeapMax();
    if (requestedSize > maxHeapSize) return !1;
    for (let cutDown = 1; cutDown <= 4; cutDown *= 2) {
      let overGrownHeapSize = oldSize * (1 + .2 / cutDown);
      overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296);
      let newSize = Math.min(maxHeapSize, alignUp(Math.max(requestedSize, overGrownHeapSize), 65536));
      if (emscripten_realloc_buffer(newSize)) return !0;
    }
    return !1;
  }
  __name(_emscripten_resize_heap, "_emscripten_resize_heap");
  let UTF8Decoder = typeof TextDecoder < "u" ? new TextDecoder("utf8") : void 0;
  function UTF8ArrayToString(heapOrArray, idx, maxBytesToRead = 1024) {
    let endIdx = idx + maxBytesToRead,
      endPtr = idx;
    for (; heapOrArray[endPtr] && !(endPtr >= endIdx);) ++endPtr;
    if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));
    let str = "";
    for (; idx < endPtr;) {
      let u0 = heapOrArray[idx++];
      if (!(u0 & 128)) {
        str += String.fromCharCode(u0);
        continue;
      }
      let u1 = heapOrArray[idx++] & 63;
      if ((u0 & 224) === 192) {
        str += String.fromCharCode((u0 & 31) << 6 | u1);
        continue;
      }
      let u2 = heapOrArray[idx++] & 63;
      if ((u0 & 240) === 224 ? u0 = (u0 & 15) << 12 | u1 << 6 | u2 : u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heapOrArray[idx++] & 63, u0 < 65536) str += String.fromCharCode(u0);else {
        let ch = u0 - 65536;
        str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);
      }
    }
    return str;
  }
  __name(UTF8ArrayToString, "UTF8ArrayToString");
  function UTF8ToString(ptr, maxBytesToRead) {
    return ptr ? UTF8ArrayToString(binding.HEAPU8, ptr, maxBytesToRead) : "";
  }
  __name(UTF8ToString, "UTF8ToString");
  let asmLibraryArg = {
    emscripten_get_now: _emscripten_get_now,
    emscripten_memcpy_big: _emscripten_memcpy_big,
    emscripten_resize_heap: _emscripten_resize_heap,
    fd_write: __name(() => 0, "fd_write")
  };
  async function createWasm() {
    let exports = await init({
      env: asmLibraryArg,
      wasi_snapshot_preview1: asmLibraryArg
    });
    wasmMemory = exports.memory, updateGlobalBufferAndViews(wasmMemory.buffer), Object.assign(binding, exports), binding.UTF8ToString = UTF8ToString;
  }
  return __name(createWasm, "createWasm"), await createWasm(), binding;
},__name(main, "main");,var onigBinding = null;,function throwLastOnigError(onigBinding) {
  throw new ShikiError(onigBinding.UTF8ToString(onigBinding.getLastOnigError()));
},__name(throwLastOnigError, "throwLastOnigError");,var _UtfString = class _UtfString {
  constructor(str) {
    __publicField(this, "utf16Length");
    __publicField(this, "utf8Length");
    __publicField(this, "utf16Value");
    __publicField(this, "utf8Value");
    __publicField(this, "utf16OffsetToUtf8");
    __publicField(this, "utf8OffsetToUtf16");
    let utf16Length = str.length,
      utf8Length = _UtfString._utf8ByteLength(str),
      computeIndicesMapping = utf8Length !== utf16Length,
      utf16OffsetToUtf8 = computeIndicesMapping ? new Uint32Array(utf16Length + 1) : null;
    computeIndicesMapping && (utf16OffsetToUtf8[utf16Length] = utf8Length);
    let utf8OffsetToUtf16 = computeIndicesMapping ? new Uint32Array(utf8Length + 1) : null;
    computeIndicesMapping && (utf8OffsetToUtf16[utf8Length] = utf16Length);
    let utf8Value = new Uint8Array(utf8Length),
      i8 = 0;
    for (let i16 = 0; i16 < utf16Length; i16++) {
      let charCode = str.charCodeAt(i16),
        codePoint = charCode,
        wasSurrogatePair = !1;
      if (charCode >= 55296 && charCode <= 56319 && i16 + 1 < utf16Length) {
        let nextCharCode = str.charCodeAt(i16 + 1);
        nextCharCode >= 56320 && nextCharCode <= 57343 && (codePoint = (charCode - 55296 << 10) + 65536 | nextCharCode - 56320, wasSurrogatePair = !0);
      }
      computeIndicesMapping && (utf16OffsetToUtf8[i16] = i8, wasSurrogatePair && (utf16OffsetToUtf8[i16 + 1] = i8), codePoint <= 127 ? utf8OffsetToUtf16[i8 + 0] = i16 : codePoint <= 2047 ? (utf8OffsetToUtf16[i8 + 0] = i16, utf8OffsetToUtf16[i8 + 1] = i16) : codePoint <= 65535 ? (utf8OffsetToUtf16[i8 + 0] = i16, utf8OffsetToUtf16[i8 + 1] = i16, utf8OffsetToUtf16[i8 + 2] = i16) : (utf8OffsetToUtf16[i8 + 0] = i16, utf8OffsetToUtf16[i8 + 1] = i16, utf8OffsetToUtf16[i8 + 2] = i16, utf8OffsetToUtf16[i8 + 3] = i16)), codePoint <= 127 ? utf8Value[i8++] = codePoint : codePoint <= 2047 ? (utf8Value[i8++] = 192 | (codePoint & 1984) >>> 6, utf8Value[i8++] = 128 | (codePoint & 63) >>> 0) : codePoint <= 65535 ? (utf8Value[i8++] = 224 | (codePoint & 61440) >>> 12, utf8Value[i8++] = 128 | (codePoint & 4032) >>> 6, utf8Value[i8++] = 128 | (codePoint & 63) >>> 0) : (utf8Value[i8++] = 240 | (codePoint & 1835008) >>> 18, utf8Value[i8++] = 128 | (codePoint & 258048) >>> 12, utf8Value[i8++] = 128 | (codePoint & 4032) >>> 6, utf8Value[i8++] = 128 | (codePoint & 63) >>> 0), wasSurrogatePair && i16++;
    }
    this.utf16Length = utf16Length, this.utf8Length = utf8Length, this.utf16Value = str, this.utf8Value = utf8Value, this.utf16OffsetToUtf8 = utf16OffsetToUtf8, this.utf8OffsetToUtf16 = utf8OffsetToUtf16;
  }
  static _utf8ByteLength(str) {
    let result = 0;
    for (let i = 0, len = str.length; i < len; i++) {
      let charCode = str.charCodeAt(i),
        codepoint = charCode,
        wasSurrogatePair = !1;
      if (charCode >= 55296 && charCode <= 56319 && i + 1 < len) {
        let nextCharCode = str.charCodeAt(i + 1);
        nextCharCode >= 56320 && nextCharCode <= 57343 && (codepoint = (charCode - 55296 << 10) + 65536 | nextCharCode - 56320, wasSurrogatePair = !0);
      }
      codepoint <= 127 ? result += 1 : codepoint <= 2047 ? result += 2 : codepoint <= 65535 ? result += 3 : result += 4, wasSurrogatePair && i++;
    }
    return result;
  }
  createString(onigBinding) {
    let result = onigBinding.omalloc(this.utf8Length);
    return onigBinding.HEAPU8.set(this.utf8Value, result), result;
  }
};,__name(_UtfString, "UtfString");,var UtfString = _UtfString,
  _OnigString = class _OnigString {
    constructor(str) {
      __publicField(this, "id", ++_OnigString.LAST_ID);
      __publicField(this, "_onigBinding");
      __publicField(this, "content");
      __publicField(this, "utf16Length");
      __publicField(this, "utf8Length");
      __publicField(this, "utf16OffsetToUtf8");
      __publicField(this, "utf8OffsetToUtf16");
      __publicField(this, "ptr");
      if (!onigBinding) throw new ShikiError("Must invoke loadWasm first.");
      this._onigBinding = onigBinding, this.content = str;
      let utfString = new UtfString(str);
      this.utf16Length = utfString.utf16Length, this.utf8Length = utfString.utf8Length, this.utf16OffsetToUtf8 = utfString.utf16OffsetToUtf8, this.utf8OffsetToUtf16 = utfString.utf8OffsetToUtf16, this.utf8Length < 1e4 && !_OnigString._sharedPtrInUse ? (_OnigString._sharedPtr || (_OnigString._sharedPtr = onigBinding.omalloc(1e4)), _OnigString._sharedPtrInUse = !0, onigBinding.HEAPU8.set(utfString.utf8Value, _OnigString._sharedPtr), this.ptr = _OnigString._sharedPtr) : this.ptr = utfString.createString(onigBinding);
    }
    convertUtf8OffsetToUtf16(utf8Offset) {
      return this.utf8OffsetToUtf16 ? utf8Offset < 0 ? 0 : utf8Offset > this.utf8Length ? this.utf16Length : this.utf8OffsetToUtf16[utf8Offset] : utf8Offset;
    }
    convertUtf16OffsetToUtf8(utf16Offset) {
      return this.utf16OffsetToUtf8 ? utf16Offset < 0 ? 0 : utf16Offset > this.utf16Length ? this.utf8Length : this.utf16OffsetToUtf8[utf16Offset] : utf16Offset;
    }
    dispose() {
      this.ptr === _OnigString._sharedPtr ? _OnigString._sharedPtrInUse = !1 : this._onigBinding.ofree(this.ptr);
    }
  };,__name(_OnigString, "OnigString"), __publicField(_OnigString, "LAST_ID", 0), __publicField(_OnigString, "_sharedPtr", 0), __publicField(_OnigString, "_sharedPtrInUse", !1);,var OnigString = _OnigString,
  _OnigScanner = class _OnigScanner {
    constructor(patterns) {
      __publicField(this, "_onigBinding");
      __publicField(this, "_ptr");
      if (!onigBinding) throw new ShikiError("Must invoke loadWasm first.");
      let strPtrsArr = [],
        strLenArr = [];
      for (let i = 0, len = patterns.length; i < len; i++) {
        let utfString = new UtfString(patterns[i]);
        strPtrsArr[i] = utfString.createString(onigBinding), strLenArr[i] = utfString.utf8Length;
      }
      let strPtrsPtr = onigBinding.omalloc(4 * patterns.length);
      onigBinding.HEAPU32.set(strPtrsArr, strPtrsPtr / 4);
      let strLenPtr = onigBinding.omalloc(4 * patterns.length);
      onigBinding.HEAPU32.set(strLenArr, strLenPtr / 4);
      let scannerPtr = onigBinding.createOnigScanner(strPtrsPtr, strLenPtr, patterns.length);
      for (let i = 0, len = patterns.length; i < len; i++) onigBinding.ofree(strPtrsArr[i]);
      onigBinding.ofree(strLenPtr), onigBinding.ofree(strPtrsPtr), scannerPtr === 0 && throwLastOnigError(onigBinding), this._onigBinding = onigBinding, this._ptr = scannerPtr;
    }
    dispose() {
      this._onigBinding.freeOnigScanner(this._ptr);
    }
    findNextMatchSync(string, startPosition, arg) {
      let options = 0;
      if (typeof arg == "number" && (options = arg), typeof string == "string") {
        string = new OnigString(string);
        let result = this._findNextMatchSync(string, startPosition, !1, options);
        return string.dispose(), result;
      }
      return this._findNextMatchSync(string, startPosition, !1, options);
    }
    _findNextMatchSync(string, startPosition, debugCall, options) {
      let onigBinding = this._onigBinding,
        resultPtr = onigBinding.findNextOnigScannerMatch(this._ptr, string.id, string.ptr, string.utf8Length, string.convertUtf16OffsetToUtf8(startPosition), options);
      if (resultPtr === 0) return null;
      let HEAPU32 = onigBinding.HEAPU32,
        offset = resultPtr / 4,
        index = HEAPU32[offset++],
        count = HEAPU32[offset++],
        captureIndices = [];
      for (let i = 0; i < count; i++) {
        let beg = string.convertUtf8OffsetToUtf16(HEAPU32[offset++]),
          end = string.convertUtf8OffsetToUtf16(HEAPU32[offset++]);
        captureIndices[i] = {
          start: beg,
          end: end,
          length: end - beg
        };
      }
      return {
        index: index,
        captureIndices: captureIndices
      };
    }
  };,__name(_OnigScanner, "OnigScanner");,var OnigScanner = _OnigScanner;,function isInstantiatorOptionsObject(dataOrOptions) {
  return typeof dataOrOptions.instantiator == "function";
},__name(isInstantiatorOptionsObject, "isInstantiatorOptionsObject");,function isInstantiatorModule(dataOrOptions) {
  return typeof dataOrOptions.default == "function";
},__name(isInstantiatorModule, "isInstantiatorModule");,function isDataOptionsObject(dataOrOptions) {
  return typeof dataOrOptions.data < "u";
},__name(isDataOptionsObject, "isDataOptionsObject");,function isResponse(dataOrOptions) {
  return typeof Response < "u" && dataOrOptions instanceof Response;
},__name(isResponse, "isResponse");,function isArrayBuffer(data) {
  var _a;
  return typeof ArrayBuffer < "u" && (data instanceof ArrayBuffer || ArrayBuffer.isView(data)) || typeof Buffer < "u" && ((_a = Buffer.isBuffer) == null ? void 0 : _a.call(Buffer, data)) || typeof SharedArrayBuffer < "u" && data instanceof SharedArrayBuffer || typeof Uint32Array < "u" && data instanceof Uint32Array;
},__name(isArrayBuffer, "isArrayBuffer");,var initPromise;,function loadWasm(options) {
  if (initPromise) return initPromise;
  async function _load() {
    onigBinding = await main(async info => {
      let instance = options;
      return instance = await instance, typeof instance == "function" && (instance = await instance(info)), typeof instance == "function" && (instance = await instance(info)), isInstantiatorOptionsObject(instance) ? instance = await instance.instantiator(info) : isInstantiatorModule(instance) ? instance = await instance.default(info) : (isDataOptionsObject(instance) && (instance = instance.data), isResponse(instance) ? typeof WebAssembly.instantiateStreaming == "function" ? instance = await _makeResponseStreamingLoader(instance)(info) : instance = await _makeResponseNonStreamingLoader(instance)(info) : isArrayBuffer(instance) ? instance = await _makeArrayBufferLoader(instance)(info) : instance instanceof WebAssembly.Module ? instance = await _makeArrayBufferLoader(instance)(info) : "default" in instance && instance.default instanceof WebAssembly.Module && (instance = await _makeArrayBufferLoader(instance.default)(info))), "instance" in instance && (instance = instance.instance), "exports" in instance && (instance = instance.exports), instance;
    });
  }
  return __name(_load, "_load"), initPromise = _load(), initPromise;
},__name(loadWasm, "loadWasm");,function _makeArrayBufferLoader(data) {
  return importObject => WebAssembly.instantiate(data, importObject);
},__name(_makeArrayBufferLoader, "_makeArrayBufferLoader");,function _makeResponseStreamingLoader(data) {
  return importObject => WebAssembly.instantiateStreaming(data, importObject);
},__name(_makeResponseStreamingLoader, "_makeResponseStreamingLoader");,function _makeResponseNonStreamingLoader(data) {
  return async importObject => {
    let arrayBuffer = await data.arrayBuffer();
    return WebAssembly.instantiate(arrayBuffer, importObject);
  };
},__name(_makeResponseNonStreamingLoader, "_makeResponseNonStreamingLoader");,async function createWasmOnigEngine(options) {
  return options && (await loadWasm(options)), {
    createScanner(patterns) {
      return new OnigScanner(patterns);
    },
    createString(s) {
      return new OnigString(s);
    }
  };
},__name(createWasmOnigEngine, "createWasmOnigEngine");,var _defaultWasmLoader;,var instancesCount = 0;,async function createShikiInternal(options = {}) {
  instancesCount += 1, options.warnings !== !1 && instancesCount >= 10 && instancesCount % 10 === 0 && console.warn(`[Shiki] ${instancesCount} instances have been created. Shiki is supposed to be used as a singleton, consider refactoring your code to cache your highlighter instance; Or call \`highlighter.dispose()\` to release unused instances.`);
  let isDisposed = !1;
  async function normalizeGetter(p) {
    return Promise.resolve(typeof p == "function" ? p() : p).then(r => r.default || r);
  }
  __name(normalizeGetter, "normalizeGetter");
  async function resolveLangs(langs) {
    return Array.from(new Set((await Promise.all(langs.filter(l => !isSpecialLang(l)).map(async lang => await normalizeGetter(lang).then(r => Array.isArray(r) ? r : [r])))).flat()));
  }
  __name(resolveLangs, "resolveLangs");
  let [themes, langs] = await Promise.all([Promise.all((options.themes || []).map(normalizeGetter)).then(r => r.map(normalizeTheme)), resolveLangs(options.langs || [])]),
    resolver = new Resolver(Promise.resolve(options.engine || createWasmOnigEngine(options.loadWasm || _defaultWasmLoader)), langs),
    _registry = new Registry(resolver, themes, langs, options.langAlias);
  await _registry.init();
  let _lastTheme;
  function getLanguage(name) {
    ensureNotDisposed();
    let _lang = _registry.getGrammar(typeof name == "string" ? name : name.name);
    if (!_lang) throw new ShikiError(`Language \`${name}\` not found, you may need to load it first`);
    return _lang;
  }
  __name(getLanguage, "getLanguage");
  function getTheme(name) {
    if (name === "none") return {
      bg: "",
      fg: "",
      name: "none",
      settings: [],
      type: "dark"
    };
    ensureNotDisposed();
    let _theme = _registry.getTheme(name);
    if (!_theme) throw new ShikiError(`Theme \`${name}\` not found, you may need to load it first`);
    return _theme;
  }
  __name(getTheme, "getTheme");
  function setTheme(name) {
    ensureNotDisposed();
    let theme = getTheme(name);
    _lastTheme !== name && (_registry.setTheme(theme), _lastTheme = name);
    let colorMap = _registry.getColorMap();
    return {
      theme: theme,
      colorMap: colorMap
    };
  }
  __name(setTheme, "setTheme");
  function getLoadedThemes() {
    return ensureNotDisposed(), _registry.getLoadedThemes();
  }
  __name(getLoadedThemes, "getLoadedThemes");
  function getLoadedLanguages() {
    return ensureNotDisposed(), _registry.getLoadedLanguages();
  }
  __name(getLoadedLanguages, "getLoadedLanguages");
  async function loadLanguage(...langs) {
    ensureNotDisposed(), await _registry.loadLanguages(await resolveLangs(langs));
  }
  __name(loadLanguage, "loadLanguage");
  async function loadTheme(...themes) {
    ensureNotDisposed(), await Promise.all(themes.map(async theme => isSpecialTheme(theme) ? null : _registry.loadTheme(await normalizeGetter(theme))));
  }
  __name(loadTheme, "loadTheme");
  function ensureNotDisposed() {
    if (isDisposed) throw new ShikiError("Shiki instance has been disposed");
  }
  __name(ensureNotDisposed, "ensureNotDisposed");
  function dispose() {
    isDisposed || (isDisposed = !0, _registry.dispose(), instancesCount -= 1);
  }
  return __name(dispose, "dispose"), {
    setTheme: setTheme,
    getTheme: getTheme,
    getLanguage: getLanguage,
    getLoadedThemes: getLoadedThemes,
    getLoadedLanguages: getLoadedLanguages,
    loadLanguage: loadLanguage,
    loadTheme: loadTheme,
    dispose: dispose,
    [Symbol.dispose]: dispose
  };
},__name(createShikiInternal, "createShikiInternal");,async function createHighlighterCore(options = {}) {
  let internal = await createShikiInternal(options);
  return {
    getLastGrammarState: __name((code, options) => getLastGrammarState(internal, code, options), "getLastGrammarState"),
    codeToTokensBase: __name((code, options) => codeToTokensBase(internal, code, options), "codeToTokensBase"),
    codeToTokensWithThemes: __name((code, options) => codeToTokensWithThemes(internal, code, options), "codeToTokensWithThemes"),
    codeToTokens: __name((code, options) => codeToTokens(internal, code, options), "codeToTokens"),
    codeToHast: __name((code, options) => codeToHast(internal, code, options), "codeToHast"),
    codeToHtml: __name((code, options) => codeToHtml(internal, code, options), "codeToHtml"),
    ...internal,
    getInternalContext: __name(() => internal, "getInternalContext")
  };
},__name(createHighlighterCore, "createHighlighterCore");,function makeSingletonHighlighterCore(createHighlighter) {
  let _shiki;
  async function getSingletonHighlighterCore(options = {}) {
    if (_shiki) {
      let s = await _shiki;
      return await Promise.all([s.loadTheme(...(options.themes || [])), s.loadLanguage(...(options.langs || []))]), s;
    } else return _shiki = createHighlighter({
      ...options,
      themes: options.themes || [],
      langs: options.langs || []
    }), _shiki;
  }
  return __name(getSingletonHighlighterCore, "getSingletonHighlighterCore"), getSingletonHighlighterCore;
},__name(makeSingletonHighlighterCore, "makeSingletonHighlighterCore");,var getSingletonHighlighterCore = makeSingletonHighlighterCore(createHighlighterCore);