typeof process < "u" && process.env.VSCODE_TEXTMATE_DEBUG;,var EncodedTokenAttributes;,(function (EncodedTokenAttributes) {
  function toBinaryStr(encodedTokenAttributes) {
    return encodedTokenAttributes.toString(2).padStart(32, "0");
  }
  __name(toBinaryStr, "toBinaryStr"), EncodedTokenAttributes.toBinaryStr = toBinaryStr;
  function print(encodedTokenAttributes) {
    let languageId = EncodedTokenAttributes.getLanguageId(encodedTokenAttributes),
      tokenType = EncodedTokenAttributes.getTokenType(encodedTokenAttributes),
      fontStyle = EncodedTokenAttributes.getFontStyle(encodedTokenAttributes),
      foreground = EncodedTokenAttributes.getForeground(encodedTokenAttributes),
      background = EncodedTokenAttributes.getBackground(encodedTokenAttributes);
    console.log({
      languageId: languageId,
      tokenType: tokenType,
      fontStyle: fontStyle,
      foreground: foreground,
      background: background
    });
  }
  __name(print, "print"), EncodedTokenAttributes.print = print;
  function getLanguageId(encodedTokenAttributes) {
    return (encodedTokenAttributes & 255) >>> 0;
  }
  __name(getLanguageId, "getLanguageId"), EncodedTokenAttributes.getLanguageId = getLanguageId;
  function getTokenType(encodedTokenAttributes) {
    return (encodedTokenAttributes & 768) >>> 8;
  }
  __name(getTokenType, "getTokenType"), EncodedTokenAttributes.getTokenType = getTokenType;
  function containsBalancedBrackets(encodedTokenAttributes) {
    return (encodedTokenAttributes & 1024) !== 0;
  }
  __name(containsBalancedBrackets, "containsBalancedBrackets"), EncodedTokenAttributes.containsBalancedBrackets = containsBalancedBrackets;
  function getFontStyle(encodedTokenAttributes) {
    return (encodedTokenAttributes & 30720) >>> 11;
  }
  __name(getFontStyle, "getFontStyle"), EncodedTokenAttributes.getFontStyle = getFontStyle;
  function getForeground(encodedTokenAttributes) {
    return (encodedTokenAttributes & 16744448) >>> 15;
  }
  __name(getForeground, "getForeground"), EncodedTokenAttributes.getForeground = getForeground;
  function getBackground(encodedTokenAttributes) {
    return (encodedTokenAttributes & 4278190080) >>> 24;
  }
  __name(getBackground, "getBackground"), EncodedTokenAttributes.getBackground = getBackground;
  function set(encodedTokenAttributes, languageId, tokenType, containsBalancedBrackets, fontStyle, foreground, background) {
    let _languageId = EncodedTokenAttributes.getLanguageId(encodedTokenAttributes),
      _tokenType = EncodedTokenAttributes.getTokenType(encodedTokenAttributes),
      _containsBalancedBracketsBit = EncodedTokenAttributes.containsBalancedBrackets(encodedTokenAttributes) ? 1 : 0,
      _fontStyle = EncodedTokenAttributes.getFontStyle(encodedTokenAttributes),
      _foreground = EncodedTokenAttributes.getForeground(encodedTokenAttributes),
      _background = EncodedTokenAttributes.getBackground(encodedTokenAttributes);
    return languageId !== 0 && (_languageId = languageId), tokenType !== 8 && (_tokenType = tokenType), containsBalancedBrackets !== null && (_containsBalancedBracketsBit = containsBalancedBrackets ? 1 : 0), fontStyle !== -1 && (_fontStyle = fontStyle), foreground !== 0 && (_foreground = foreground), background !== 0 && (_background = background), (_languageId << 0 | _tokenType << 8 | _containsBalancedBracketsBit << 10 | _fontStyle << 11 | _foreground << 15 | _background << 24) >>> 0;
  }
  __name(set, "set"), EncodedTokenAttributes.set = set;
})(EncodedTokenAttributes || (EncodedTokenAttributes = {}));,function createMatchers(selector, matchesName) {
  let results = [],
    tokenizer = newTokenizer(selector),
    token = tokenizer.next();
  for (; token !== null;) {
    let priority = 0;
    if (token.length === 2 && token.charAt(1) === ":") {
      switch (token.charAt(0)) {
        case "R":
          priority = 1;
          break;
        case "L":
          priority = -1;
          break;
        default:
          console.log(`Unknown priority ${token} in scope selector`);
      }
      token = tokenizer.next();
    }
    let matcher = parseConjunction();
    if (results.push({
      matcher: matcher,
      priority: priority
    }), token !== ",") break;
    token = tokenizer.next();
  }
  return results;
  function parseOperand() {
    if (token === "-") {
      token = tokenizer.next();
      let expressionToNegate = parseOperand();
      return matcherInput => !!expressionToNegate && !expressionToNegate(matcherInput);
    }
    if (token === "(") {
      token = tokenizer.next();
      let expressionInParents = parseInnerExpression();
      return token === ")" && (token = tokenizer.next()), expressionInParents;
    }
    if (isIdentifier(token)) {
      let identifiers = [];
      do identifiers.push(token), token = tokenizer.next(); while (isIdentifier(token));
      return matcherInput => matchesName(identifiers, matcherInput);
    }
    return null;
  }
  function parseConjunction() {
    let matchers = [],
      matcher = parseOperand();
    for (; matcher;) matchers.push(matcher), matcher = parseOperand();
    return matcherInput => matchers.every(matcher => matcher(matcherInput));
  }
  function parseInnerExpression() {
    let matchers = [],
      matcher = parseConjunction();
    for (; matcher && (matchers.push(matcher), token === "|" || token === ",");) {
      do token = tokenizer.next(); while (token === "|" || token === ",");
      matcher = parseConjunction();
    }
    return matcherInput => matchers.some(matcher => matcher(matcherInput));
  }
},__name(createMatchers, "createMatchers");,function isIdentifier(token) {
  return !!token && !!token.match(/[\w\.:]+/);
},__name(isIdentifier, "isIdentifier");,function newTokenizer(input) {
  let regex = /([LR]:|[\w\.:][\w\.:\-]*|[\,\|\-\(\)])/g,
    match = regex.exec(input);
  return {
    next: __name(() => {
      if (!match) return null;
      let res = match[0];
      return match = regex.exec(input), res;
    }, "next")
  };
},__name(newTokenizer, "newTokenizer");,function disposeOnigString(str) {
  typeof str.dispose == "function" && str.dispose();
},__name(disposeOnigString, "disposeOnigString");,function clone(something) {
  return doClone(something);
},__name(clone, "clone");,function doClone(something) {
  return Array.isArray(something) ? cloneArray(something) : typeof something == "object" ? cloneObj(something) : something;
},__name(doClone, "doClone");,function cloneArray(arr) {
  let r = [];
  for (let i = 0, len = arr.length; i < len; i++) r[i] = doClone(arr[i]);
  return r;
},__name(cloneArray, "cloneArray");,function cloneObj(obj) {
  let r = {};
  for (let key in obj) r[key] = doClone(obj[key]);
  return r;
},__name(cloneObj, "cloneObj");,function mergeObjects(target, ...sources) {
  return sources.forEach(source => {
    for (let key in source) target[key] = source[key];
  }), target;
},__name(mergeObjects, "mergeObjects");,function basename(path) {
  let idx = ~path.lastIndexOf("/") || ~path.lastIndexOf("\\");
  return idx === 0 ? path : ~idx === path.length - 1 ? basename(path.substring(0, path.length - 1)) : path.substr(~idx + 1);
},__name(basename, "basename");,var CAPTURING_REGEX_SOURCE = /\$(\d+)|\${(\d+):\/(downcase|upcase)}/g,
  _RegexSource = class _RegexSource {
    static hasCaptures(regexSource) {
      return regexSource === null ? !1 : (CAPTURING_REGEX_SOURCE.lastIndex = 0, CAPTURING_REGEX_SOURCE.test(regexSource));
    }
    static replaceCaptures(regexSource, captureSource, captureIndices) {
      return regexSource.replace(CAPTURING_REGEX_SOURCE, (match, index, commandIndex, command) => {
        let capture = captureIndices[parseInt(index || commandIndex, 10)];
        if (capture) {
          let result = captureSource.substring(capture.start, capture.end);
          for (; result[0] === ".";) result = result.substring(1);
          switch (command) {
            case "downcase":
              return result.toLowerCase();
            case "upcase":
              return result.toUpperCase();
            default:
              return result;
          }
        } else return match;
      });
    }
  };,__name(_RegexSource, "RegexSource");,var RegexSource = _RegexSource;,function strcmp(a, b) {
  return a < b ? -1 : a > b ? 1 : 0;
},__name(strcmp, "strcmp");,function strArrCmp(a, b) {
  if (a === null && b === null) return 0;
  if (!a) return -1;
  if (!b) return 1;
  let len1 = a.length,
    len2 = b.length;
  if (len1 === len2) {
    for (let i = 0; i < len1; i++) {
      let res = strcmp(a[i], b[i]);
      if (res !== 0) return res;
    }
    return 0;
  }
  return len1 - len2;
},__name(strArrCmp, "strArrCmp");,function isValidHexColor(hex) {
  return !!(/^#[0-9a-f]{6}$/i.test(hex) || /^#[0-9a-f]{8}$/i.test(hex) || /^#[0-9a-f]{3}$/i.test(hex) || /^#[0-9a-f]{4}$/i.test(hex));
},__name(isValidHexColor, "isValidHexColor");,function escapeRegExpCharacters(value) {
  return value.replace(/[\-\\\{\}\*\+\?\|\^\$\.\,\[\]\(\)\#\s]/g, "\\$&");
},__name(escapeRegExpCharacters, "escapeRegExpCharacters");,var _CachedFn = class _CachedFn {
  constructor(fn) {
    __publicField(this, "fn");
    __publicField(this, "cache", new Map());
    this.fn = fn;
  }
  get(key) {
    if (this.cache.has(key)) return this.cache.get(key);
    let value = this.fn(key);
    return this.cache.set(key, value), value;
  }
};,__name(_CachedFn, "CachedFn");,var CachedFn = _CachedFn,
  _TopLevelRuleReference = class _TopLevelRuleReference {
    constructor(scopeName) {
      __publicField(this, "scopeName");
      this.scopeName = scopeName;
    }
    toKey() {
      return this.scopeName;
    }
  };,__name(_TopLevelRuleReference, "TopLevelRuleReference");,var TopLevelRuleReference = _TopLevelRuleReference,
  _TopLevelRepositoryRuleReference = class _TopLevelRepositoryRuleReference {
    constructor(scopeName, ruleName) {
      __publicField(this, "scopeName");
      __publicField(this, "ruleName");
      this.scopeName = scopeName, this.ruleName = ruleName;
    }
    toKey() {
      return `${this.scopeName}#${this.ruleName}`;
    }
  };,__name(_TopLevelRepositoryRuleReference, "TopLevelRepositoryRuleReference");,var TopLevelRepositoryRuleReference = _TopLevelRepositoryRuleReference,
  _ExternalReferenceCollector = class _ExternalReferenceCollector {
    constructor() {
      __publicField(this, "_references", []);
      __publicField(this, "_seenReferenceKeys", new Set());
      __publicField(this, "visitedRule", new Set());
    }
    get references() {
      return this._references;
    }
    add(reference) {
      let key = reference.toKey();
      this._seenReferenceKeys.has(key) || (this._seenReferenceKeys.add(key), this._references.push(reference));
    }
  };,__name(_ExternalReferenceCollector, "ExternalReferenceCollector");,var ExternalReferenceCollector = _ExternalReferenceCollector,
  _ScopeDependencyProcessor = class _ScopeDependencyProcessor {
    constructor(repo, initialScopeName) {
      __publicField(this, "repo");
      __publicField(this, "initialScopeName");
      __publicField(this, "seenFullScopeRequests", new Set());
      __publicField(this, "seenPartialScopeRequests", new Set());
      __publicField(this, "Q");
      this.repo = repo, this.initialScopeName = initialScopeName, this.seenFullScopeRequests.add(this.initialScopeName), this.Q = [new TopLevelRuleReference(this.initialScopeName)];
    }
    processQueue() {
      let q = this.Q;
      this.Q = [];
      let deps = new ExternalReferenceCollector();
      for (let dep of q) collectReferencesOfReference(dep, this.initialScopeName, this.repo, deps);
      for (let dep of deps.references) if (dep instanceof TopLevelRuleReference) {
        if (this.seenFullScopeRequests.has(dep.scopeName)) continue;
        this.seenFullScopeRequests.add(dep.scopeName), this.Q.push(dep);
      } else {
        if (this.seenFullScopeRequests.has(dep.scopeName) || this.seenPartialScopeRequests.has(dep.toKey())) continue;
        this.seenPartialScopeRequests.add(dep.toKey()), this.Q.push(dep);
      }
    }
  };,__name(_ScopeDependencyProcessor, "ScopeDependencyProcessor");,var ScopeDependencyProcessor = _ScopeDependencyProcessor;,function collectReferencesOfReference(reference, baseGrammarScopeName, repo, result) {
  let selfGrammar = repo.lookup(reference.scopeName);
  if (!selfGrammar) {
    if (reference.scopeName === baseGrammarScopeName) throw new Error(`No grammar provided for <${baseGrammarScopeName}>`);
    return;
  }
  let baseGrammar = repo.lookup(baseGrammarScopeName);
  reference instanceof TopLevelRuleReference ? collectExternalReferencesInTopLevelRule({
    baseGrammar: baseGrammar,
    selfGrammar: selfGrammar
  }, result) : collectExternalReferencesInTopLevelRepositoryRule(reference.ruleName, {
    baseGrammar: baseGrammar,
    selfGrammar: selfGrammar,
    repository: selfGrammar.repository
  }, result);
  let injections = repo.injections(reference.scopeName);
  if (injections) for (let injection of injections) result.add(new TopLevelRuleReference(injection));
},__name(collectReferencesOfReference, "collectReferencesOfReference");,function collectExternalReferencesInTopLevelRepositoryRule(ruleName, context, result) {
  if (context.repository && context.repository[ruleName]) {
    let rule = context.repository[ruleName];
    collectExternalReferencesInRules([rule], context, result);
  }
},__name(collectExternalReferencesInTopLevelRepositoryRule, "collectExternalReferencesInTopLevelRepositoryRule");,function collectExternalReferencesInTopLevelRule(context, result) {
  context.selfGrammar.patterns && Array.isArray(context.selfGrammar.patterns) && collectExternalReferencesInRules(context.selfGrammar.patterns, {
    ...context,
    repository: context.selfGrammar.repository
  }, result), context.selfGrammar.injections && collectExternalReferencesInRules(Object.values(context.selfGrammar.injections), {
    ...context,
    repository: context.selfGrammar.repository
  }, result);
},__name(collectExternalReferencesInTopLevelRule, "collectExternalReferencesInTopLevelRule");,function collectExternalReferencesInRules(rules, context, result) {
  for (let rule of rules) {
    if (result.visitedRule.has(rule)) continue;
    result.visitedRule.add(rule);
    let patternRepository = rule.repository ? mergeObjects({}, context.repository, rule.repository) : context.repository;
    Array.isArray(rule.patterns) && collectExternalReferencesInRules(rule.patterns, {
      ...context,
      repository: patternRepository
    }, result);
    let include = rule.include;
    if (!include) continue;
    let reference = parseInclude(include);
    switch (reference.kind) {
      case 0:
        collectExternalReferencesInTopLevelRule({
          ...context,
          selfGrammar: context.baseGrammar
        }, result);
        break;
      case 1:
        collectExternalReferencesInTopLevelRule(context, result);
        break;
      case 2:
        collectExternalReferencesInTopLevelRepositoryRule(reference.ruleName, {
          ...context,
          repository: patternRepository
        }, result);
        break;
      case 3:
      case 4:
        let selfGrammar = reference.scopeName === context.selfGrammar.scopeName ? context.selfGrammar : reference.scopeName === context.baseGrammar.scopeName ? context.baseGrammar : void 0;
        if (selfGrammar) {
          let newContext = {
            baseGrammar: context.baseGrammar,
            selfGrammar: selfGrammar,
            repository: patternRepository
          };
          reference.kind === 4 ? collectExternalReferencesInTopLevelRepositoryRule(reference.ruleName, newContext, result) : collectExternalReferencesInTopLevelRule(newContext, result);
        } else reference.kind === 4 ? result.add(new TopLevelRepositoryRuleReference(reference.scopeName, reference.ruleName)) : result.add(new TopLevelRuleReference(reference.scopeName));
        break;
    }
  }
},__name(collectExternalReferencesInRules, "collectExternalReferencesInRules");,var _BaseReference = class _BaseReference {
  constructor() {
    __publicField(this, "kind", 0);
  }
};,__name(_BaseReference, "BaseReference");,var BaseReference = _BaseReference,
  _SelfReference = class _SelfReference {
    constructor() {
      __publicField(this, "kind", 1);
    }
  };,__name(_SelfReference, "SelfReference");,var SelfReference = _SelfReference,
  _RelativeReference = class _RelativeReference {
    constructor(ruleName) {
      __publicField(this, "ruleName");
      __publicField(this, "kind", 2);
      this.ruleName = ruleName;
    }
  };,__name(_RelativeReference, "RelativeReference");,var RelativeReference = _RelativeReference,
  _TopLevelReference = class _TopLevelReference {
    constructor(scopeName) {
      __publicField(this, "scopeName");
      __publicField(this, "kind", 3);
      this.scopeName = scopeName;
    }
  };,__name(_TopLevelReference, "TopLevelReference");,var TopLevelReference = _TopLevelReference,
  _TopLevelRepositoryReference = class _TopLevelRepositoryReference {
    constructor(scopeName, ruleName) {
      __publicField(this, "scopeName");
      __publicField(this, "ruleName");
      __publicField(this, "kind", 4);
      this.scopeName = scopeName, this.ruleName = ruleName;
    }
  };,__name(_TopLevelRepositoryReference, "TopLevelRepositoryReference");,var TopLevelRepositoryReference = _TopLevelRepositoryReference;,function parseInclude(include) {
  if (include === "$base") return new BaseReference();
  if (include === "$self") return new SelfReference();
  let indexOfSharp = include.indexOf("#");
  if (indexOfSharp === -1) return new TopLevelReference(include);
  if (indexOfSharp === 0) return new RelativeReference(include.substring(1));
  {
    let scopeName = include.substring(0, indexOfSharp),
      ruleName = include.substring(indexOfSharp + 1);
    return new TopLevelRepositoryReference(scopeName, ruleName);
  }
},__name(parseInclude, "parseInclude");,var HAS_BACK_REFERENCES = /\\(\d+)/,
  BACK_REFERENCING_END = /\\(\d+)/g,
  endRuleId = -1,
  whileRuleId = -2;,var _Rule = class _Rule {
  constructor($location, id, name, contentName) {
    __publicField(this, "$location");
    __publicField(this, "id");
    __publicField(this, "_nameIsCapturing");
    __publicField(this, "_name");
    __publicField(this, "_contentNameIsCapturing");
    __publicField(this, "_contentName");
    this.$location = $location, this.id = id, this._name = name || null, this._nameIsCapturing = RegexSource.hasCaptures(this._name), this._contentName = contentName || null, this._contentNameIsCapturing = RegexSource.hasCaptures(this._contentName);
  }
  get debugName() {
    let location = this.$location ? `${basename(this.$location.filename)}:${this.$location.line}` : "unknown";
    return `${this.constructor.name}#${this.id} @ ${location}`;
  }
  getName(lineText, captureIndices) {
    return !this._nameIsCapturing || this._name === null || lineText === null || captureIndices === null ? this._name : RegexSource.replaceCaptures(this._name, lineText, captureIndices);
  }
  getContentName(lineText, captureIndices) {
    return !this._contentNameIsCapturing || this._contentName === null ? this._contentName : RegexSource.replaceCaptures(this._contentName, lineText, captureIndices);
  }
};,__name(_Rule, "Rule");,var Rule = _Rule,
  _CaptureRule = class _CaptureRule extends Rule {
    constructor($location, id, name, contentName, retokenizeCapturedWithRuleId) {
      super($location, id, name, contentName);
      __publicField(this, "retokenizeCapturedWithRuleId");
      this.retokenizeCapturedWithRuleId = retokenizeCapturedWithRuleId;
    }
    dispose() {}
    collectPatterns(grammar, out) {
      throw new Error("Not supported!");
    }
    compile(grammar, endRegexSource) {
      throw new Error("Not supported!");
    }
    compileAG(grammar, endRegexSource, allowA, allowG) {
      throw new Error("Not supported!");
    }
  };,__name(_CaptureRule, "CaptureRule");,var CaptureRule = _CaptureRule,
  _MatchRule = class _MatchRule extends Rule {
    constructor($location, id, name, match, captures) {
      super($location, id, name, null);
      __publicField(this, "_match");
      __publicField(this, "captures");
      __publicField(this, "_cachedCompiledPatterns");
      this._match = new RegExpSource(match, this.id), this.captures = captures, this._cachedCompiledPatterns = null;
    }
    dispose() {
      this._cachedCompiledPatterns && (this._cachedCompiledPatterns.dispose(), this._cachedCompiledPatterns = null);
    }
    get debugMatchRegExp() {
      return `${this._match.source}`;
    }
    collectPatterns(grammar, out) {
      out.push(this._match);
    }
    compile(grammar, endRegexSource) {
      return this._getCachedCompiledPatterns(grammar).compile(grammar);
    }
    compileAG(grammar, endRegexSource, allowA, allowG) {
      return this._getCachedCompiledPatterns(grammar).compileAG(grammar, allowA, allowG);
    }
    _getCachedCompiledPatterns(grammar) {
      return this._cachedCompiledPatterns || (this._cachedCompiledPatterns = new RegExpSourceList(), this.collectPatterns(grammar, this._cachedCompiledPatterns)), this._cachedCompiledPatterns;
    }
  };,__name(_MatchRule, "MatchRule");,var MatchRule = _MatchRule,
  _IncludeOnlyRule = class _IncludeOnlyRule extends Rule {
    constructor($location, id, name, contentName, patterns) {
      super($location, id, name, contentName);
      __publicField(this, "hasMissingPatterns");
      __publicField(this, "patterns");
      __publicField(this, "_cachedCompiledPatterns");
      this.patterns = patterns.patterns, this.hasMissingPatterns = patterns.hasMissingPatterns, this._cachedCompiledPatterns = null;
    }
    dispose() {
      this._cachedCompiledPatterns && (this._cachedCompiledPatterns.dispose(), this._cachedCompiledPatterns = null);
    }
    collectPatterns(grammar, out) {
      for (let pattern of this.patterns) grammar.getRule(pattern).collectPatterns(grammar, out);
    }
    compile(grammar, endRegexSource) {
      return this._getCachedCompiledPatterns(grammar).compile(grammar);
    }
    compileAG(grammar, endRegexSource, allowA, allowG) {
      return this._getCachedCompiledPatterns(grammar).compileAG(grammar, allowA, allowG);
    }
    _getCachedCompiledPatterns(grammar) {
      return this._cachedCompiledPatterns || (this._cachedCompiledPatterns = new RegExpSourceList(), this.collectPatterns(grammar, this._cachedCompiledPatterns)), this._cachedCompiledPatterns;
    }
  };,__name(_IncludeOnlyRule, "IncludeOnlyRule");,var IncludeOnlyRule = _IncludeOnlyRule,
  _BeginEndRule = class _BeginEndRule extends Rule {
    constructor($location, id, name, contentName, begin, beginCaptures, end, endCaptures, applyEndPatternLast, patterns) {
      super($location, id, name, contentName);
      __publicField(this, "_begin");
      __publicField(this, "beginCaptures");
      __publicField(this, "_end");
      __publicField(this, "endHasBackReferences");
      __publicField(this, "endCaptures");
      __publicField(this, "applyEndPatternLast");
      __publicField(this, "hasMissingPatterns");
      __publicField(this, "patterns");
      __publicField(this, "_cachedCompiledPatterns");
      this._begin = new RegExpSource(begin, this.id), this.beginCaptures = beginCaptures, this._end = new RegExpSource(end || "\uFFFF", -1), this.endHasBackReferences = this._end.hasBackReferences, this.endCaptures = endCaptures, this.applyEndPatternLast = applyEndPatternLast || !1, this.patterns = patterns.patterns, this.hasMissingPatterns = patterns.hasMissingPatterns, this._cachedCompiledPatterns = null;
    }
    dispose() {
      this._cachedCompiledPatterns && (this._cachedCompiledPatterns.dispose(), this._cachedCompiledPatterns = null);
    }
    get debugBeginRegExp() {
      return `${this._begin.source}`;
    }
    get debugEndRegExp() {
      return `${this._end.source}`;
    }
    getEndWithResolvedBackReferences(lineText, captureIndices) {
      return this._end.resolveBackReferences(lineText, captureIndices);
    }
    collectPatterns(grammar, out) {
      out.push(this._begin);
    }
    compile(grammar, endRegexSource) {
      return this._getCachedCompiledPatterns(grammar, endRegexSource).compile(grammar);
    }
    compileAG(grammar, endRegexSource, allowA, allowG) {
      return this._getCachedCompiledPatterns(grammar, endRegexSource).compileAG(grammar, allowA, allowG);
    }
    _getCachedCompiledPatterns(grammar, endRegexSource) {
      if (!this._cachedCompiledPatterns) {
        this._cachedCompiledPatterns = new RegExpSourceList();
        for (let pattern of this.patterns) grammar.getRule(pattern).collectPatterns(grammar, this._cachedCompiledPatterns);
        this.applyEndPatternLast ? this._cachedCompiledPatterns.push(this._end.hasBackReferences ? this._end.clone() : this._end) : this._cachedCompiledPatterns.unshift(this._end.hasBackReferences ? this._end.clone() : this._end);
      }
      return this._end.hasBackReferences && (this.applyEndPatternLast ? this._cachedCompiledPatterns.setSource(this._cachedCompiledPatterns.length() - 1, endRegexSource) : this._cachedCompiledPatterns.setSource(0, endRegexSource)), this._cachedCompiledPatterns;
    }
  };,__name(_BeginEndRule, "BeginEndRule");,var BeginEndRule = _BeginEndRule,
  _BeginWhileRule = class _BeginWhileRule extends Rule {
    constructor($location, id, name, contentName, begin, beginCaptures, _while, whileCaptures, patterns) {
      super($location, id, name, contentName);
      __publicField(this, "_begin");
      __publicField(this, "beginCaptures");
      __publicField(this, "whileCaptures");
      __publicField(this, "_while");
      __publicField(this, "whileHasBackReferences");
      __publicField(this, "hasMissingPatterns");
      __publicField(this, "patterns");
      __publicField(this, "_cachedCompiledPatterns");
      __publicField(this, "_cachedCompiledWhilePatterns");
      this._begin = new RegExpSource(begin, this.id), this.beginCaptures = beginCaptures, this.whileCaptures = whileCaptures, this._while = new RegExpSource(_while, whileRuleId), this.whileHasBackReferences = this._while.hasBackReferences, this.patterns = patterns.patterns, this.hasMissingPatterns = patterns.hasMissingPatterns, this._cachedCompiledPatterns = null, this._cachedCompiledWhilePatterns = null;
    }
    dispose() {
      this._cachedCompiledPatterns && (this._cachedCompiledPatterns.dispose(), this._cachedCompiledPatterns = null), this._cachedCompiledWhilePatterns && (this._cachedCompiledWhilePatterns.dispose(), this._cachedCompiledWhilePatterns = null);
    }
    get debugBeginRegExp() {
      return `${this._begin.source}`;
    }
    get debugWhileRegExp() {
      return `${this._while.source}`;
    }
    getWhileWithResolvedBackReferences(lineText, captureIndices) {
      return this._while.resolveBackReferences(lineText, captureIndices);
    }
    collectPatterns(grammar, out) {
      out.push(this._begin);
    }
    compile(grammar, endRegexSource) {
      return this._getCachedCompiledPatterns(grammar).compile(grammar);
    }
    compileAG(grammar, endRegexSource, allowA, allowG) {
      return this._getCachedCompiledPatterns(grammar).compileAG(grammar, allowA, allowG);
    }
    _getCachedCompiledPatterns(grammar) {
      if (!this._cachedCompiledPatterns) {
        this._cachedCompiledPatterns = new RegExpSourceList();
        for (let pattern of this.patterns) grammar.getRule(pattern).collectPatterns(grammar, this._cachedCompiledPatterns);
      }
      return this._cachedCompiledPatterns;
    }
    compileWhile(grammar, endRegexSource) {
      return this._getCachedCompiledWhilePatterns(grammar, endRegexSource).compile(grammar);
    }
    compileWhileAG(grammar, endRegexSource, allowA, allowG) {
      return this._getCachedCompiledWhilePatterns(grammar, endRegexSource).compileAG(grammar, allowA, allowG);
    }
    _getCachedCompiledWhilePatterns(grammar, endRegexSource) {
      return this._cachedCompiledWhilePatterns || (this._cachedCompiledWhilePatterns = new RegExpSourceList(), this._cachedCompiledWhilePatterns.push(this._while.hasBackReferences ? this._while.clone() : this._while)), this._while.hasBackReferences && this._cachedCompiledWhilePatterns.setSource(0, endRegexSource || "\uFFFF"), this._cachedCompiledWhilePatterns;
    }
  };,__name(_BeginWhileRule, "BeginWhileRule");,var BeginWhileRule = _BeginWhileRule,
  _RuleFactory = class _RuleFactory {
    static createCaptureRule(helper, $location, name, contentName, retokenizeCapturedWithRuleId) {
      return helper.registerRule(id => new CaptureRule($location, id, name, contentName, retokenizeCapturedWithRuleId));
    }
    static getCompiledRuleId(desc, helper, repository) {
      return desc.id || helper.registerRule(id => {
        if (desc.id = id, desc.match) return new MatchRule(desc.$vscodeTextmateLocation, desc.id, desc.name, desc.match, _RuleFactory._compileCaptures(desc.captures, helper, repository));
        if (typeof desc.begin > "u") {
          desc.repository && (repository = mergeObjects({}, repository, desc.repository));
          let patterns = desc.patterns;
          return typeof patterns > "u" && desc.include && (patterns = [{
            include: desc.include
          }]), new IncludeOnlyRule(desc.$vscodeTextmateLocation, desc.id, desc.name, desc.contentName, _RuleFactory._compilePatterns(patterns, helper, repository));
        }
        return desc.while ? new BeginWhileRule(desc.$vscodeTextmateLocation, desc.id, desc.name, desc.contentName, desc.begin, _RuleFactory._compileCaptures(desc.beginCaptures || desc.captures, helper, repository), desc.while, _RuleFactory._compileCaptures(desc.whileCaptures || desc.captures, helper, repository), _RuleFactory._compilePatterns(desc.patterns, helper, repository)) : new BeginEndRule(desc.$vscodeTextmateLocation, desc.id, desc.name, desc.contentName, desc.begin, _RuleFactory._compileCaptures(desc.beginCaptures || desc.captures, helper, repository), desc.end, _RuleFactory._compileCaptures(desc.endCaptures || desc.captures, helper, repository), desc.applyEndPatternLast, _RuleFactory._compilePatterns(desc.patterns, helper, repository));
      }), desc.id;
    }
    static _compileCaptures(captures, helper, repository) {
      let r = [];
      if (captures) {
        let maximumCaptureId = 0;
        for (let captureId in captures) {
          if (captureId === "$vscodeTextmateLocation") continue;
          let numericCaptureId = parseInt(captureId, 10);
          numericCaptureId > maximumCaptureId && (maximumCaptureId = numericCaptureId);
        }
        for (let i = 0; i <= maximumCaptureId; i++) r[i] = null;
        for (let captureId in captures) {
          if (captureId === "$vscodeTextmateLocation") continue;
          let numericCaptureId = parseInt(captureId, 10),
            retokenizeCapturedWithRuleId = 0;
          captures[captureId].patterns && (retokenizeCapturedWithRuleId = _RuleFactory.getCompiledRuleId(captures[captureId], helper, repository)), r[numericCaptureId] = _RuleFactory.createCaptureRule(helper, captures[captureId].$vscodeTextmateLocation, captures[captureId].name, captures[captureId].contentName, retokenizeCapturedWithRuleId);
        }
      }
      return r;
    }
    static _compilePatterns(patterns, helper, repository) {
      let r = [];
      if (patterns) for (let i = 0, len = patterns.length; i < len; i++) {
        let pattern = patterns[i],
          ruleId = -1;
        if (pattern.include) {
          let reference = parseInclude(pattern.include);
          switch (reference.kind) {
            case 0:
            case 1:
              ruleId = _RuleFactory.getCompiledRuleId(repository[pattern.include], helper, repository);
              break;
            case 2:
              let localIncludedRule = repository[reference.ruleName];
              localIncludedRule && (ruleId = _RuleFactory.getCompiledRuleId(localIncludedRule, helper, repository));
              break;
            case 3:
            case 4:
              let externalGrammarName = reference.scopeName,
                externalGrammarInclude = reference.kind === 4 ? reference.ruleName : null,
                externalGrammar = helper.getExternalGrammar(externalGrammarName, repository);
              if (externalGrammar) if (externalGrammarInclude) {
                let externalIncludedRule = externalGrammar.repository[externalGrammarInclude];
                externalIncludedRule && (ruleId = _RuleFactory.getCompiledRuleId(externalIncludedRule, helper, externalGrammar.repository));
              } else ruleId = _RuleFactory.getCompiledRuleId(externalGrammar.repository.$self, helper, externalGrammar.repository);
              break;
          }
        } else ruleId = _RuleFactory.getCompiledRuleId(pattern, helper, repository);
        if (ruleId !== -1) {
          let rule = helper.getRule(ruleId),
            skipRule = !1;
          if ((rule instanceof IncludeOnlyRule || rule instanceof BeginEndRule || rule instanceof BeginWhileRule) && rule.hasMissingPatterns && rule.patterns.length === 0 && (skipRule = !0), skipRule) continue;
          r.push(ruleId);
        }
      }
      return {
        patterns: r,
        hasMissingPatterns: (patterns ? patterns.length : 0) !== r.length
      };
    }
  };,__name(_RuleFactory, "RuleFactory");,var RuleFactory = _RuleFactory,
  _RegExpSource = class _RegExpSource {
    constructor(regExpSource, ruleId) {
      __publicField(this, "source");
      __publicField(this, "ruleId");
      __publicField(this, "hasAnchor");
      __publicField(this, "hasBackReferences");
      __publicField(this, "_anchorCache");
      if (regExpSource) {
        let len = regExpSource.length,
          lastPushedPos = 0,
          output = [],
          hasAnchor = !1;
        for (let pos = 0; pos < len; pos++) if (regExpSource.charAt(pos) === "\\" && pos + 1 < len) {
          let nextCh = regExpSource.charAt(pos + 1);
          nextCh === "z" ? (output.push(regExpSource.substring(lastPushedPos, pos)), output.push("$(?!\\n)(?<!\\n)"), lastPushedPos = pos + 2) : (nextCh === "A" || nextCh === "G") && (hasAnchor = !0), pos++;
        }
        this.hasAnchor = hasAnchor, lastPushedPos === 0 ? this.source = regExpSource : (output.push(regExpSource.substring(lastPushedPos, len)), this.source = output.join(""));
      } else this.hasAnchor = !1, this.source = regExpSource;
      this.hasAnchor ? this._anchorCache = this._buildAnchorCache() : this._anchorCache = null, this.ruleId = ruleId, this.hasBackReferences = HAS_BACK_REFERENCES.test(this.source);
    }
    clone() {
      return new _RegExpSource(this.source, this.ruleId);
    }
    setSource(newSource) {
      this.source !== newSource && (this.source = newSource, this.hasAnchor && (this._anchorCache = this._buildAnchorCache()));
    }
    resolveBackReferences(lineText, captureIndices) {
      let capturedValues = captureIndices.map(capture => lineText.substring(capture.start, capture.end));
      return BACK_REFERENCING_END.lastIndex = 0, this.source.replace(BACK_REFERENCING_END, (match, g1) => escapeRegExpCharacters(capturedValues[parseInt(g1, 10)] || ""));
    }
    _buildAnchorCache() {
      let A0_G0_result = [],
        A0_G1_result = [],
        A1_G0_result = [],
        A1_G1_result = [],
        pos,
        len,
        ch,
        nextCh;
      for (pos = 0, len = this.source.length; pos < len; pos++) ch = this.source.charAt(pos), A0_G0_result[pos] = ch, A0_G1_result[pos] = ch, A1_G0_result[pos] = ch, A1_G1_result[pos] = ch, ch === "\\" && pos + 1 < len && (nextCh = this.source.charAt(pos + 1), nextCh === "A" ? (A0_G0_result[pos + 1] = "\uFFFF", A0_G1_result[pos + 1] = "\uFFFF", A1_G0_result[pos + 1] = "A", A1_G1_result[pos + 1] = "A") : nextCh === "G" ? (A0_G0_result[pos + 1] = "\uFFFF", A0_G1_result[pos + 1] = "G", A1_G0_result[pos + 1] = "\uFFFF", A1_G1_result[pos + 1] = "G") : (A0_G0_result[pos + 1] = nextCh, A0_G1_result[pos + 1] = nextCh, A1_G0_result[pos + 1] = nextCh, A1_G1_result[pos + 1] = nextCh), pos++);
      return {
        A0_G0: A0_G0_result.join(""),
        A0_G1: A0_G1_result.join(""),
        A1_G0: A1_G0_result.join(""),
        A1_G1: A1_G1_result.join("")
      };
    }
    resolveAnchors(allowA, allowG) {
      return !this.hasAnchor || !this._anchorCache ? this.source : allowA ? allowG ? this._anchorCache.A1_G1 : this._anchorCache.A1_G0 : allowG ? this._anchorCache.A0_G1 : this._anchorCache.A0_G0;
    }
  };,__name(_RegExpSource, "RegExpSource");,var RegExpSource = _RegExpSource,
  _RegExpSourceList = class _RegExpSourceList {
    constructor() {
      __publicField(this, "_items");
      __publicField(this, "_hasAnchors");
      __publicField(this, "_cached");
      __publicField(this, "_anchorCache");
      this._items = [], this._hasAnchors = !1, this._cached = null, this._anchorCache = {
        A0_G0: null,
        A0_G1: null,
        A1_G0: null,
        A1_G1: null
      };
    }
    dispose() {
      this._disposeCaches();
    }
    _disposeCaches() {
      this._cached && (this._cached.dispose(), this._cached = null), this._anchorCache.A0_G0 && (this._anchorCache.A0_G0.dispose(), this._anchorCache.A0_G0 = null), this._anchorCache.A0_G1 && (this._anchorCache.A0_G1.dispose(), this._anchorCache.A0_G1 = null), this._anchorCache.A1_G0 && (this._anchorCache.A1_G0.dispose(), this._anchorCache.A1_G0 = null), this._anchorCache.A1_G1 && (this._anchorCache.A1_G1.dispose(), this._anchorCache.A1_G1 = null);
    }
    push(item) {
      this._items.push(item), this._hasAnchors = this._hasAnchors || item.hasAnchor;
    }
    unshift(item) {
      this._items.unshift(item), this._hasAnchors = this._hasAnchors || item.hasAnchor;
    }
    length() {
      return this._items.length;
    }
    setSource(index, newSource) {
      this._items[index].source !== newSource && (this._disposeCaches(), this._items[index].setSource(newSource));
    }
    compile(onigLib) {
      if (!this._cached) {
        let regExps = this._items.map(e => e.source);
        this._cached = new CompiledRule(onigLib, regExps, this._items.map(e => e.ruleId));
      }
      return this._cached;
    }
    compileAG(onigLib, allowA, allowG) {
      return this._hasAnchors ? allowA ? allowG ? (this._anchorCache.A1_G1 || (this._anchorCache.A1_G1 = this._resolveAnchors(onigLib, allowA, allowG)), this._anchorCache.A1_G1) : (this._anchorCache.A1_G0 || (this._anchorCache.A1_G0 = this._resolveAnchors(onigLib, allowA, allowG)), this._anchorCache.A1_G0) : allowG ? (this._anchorCache.A0_G1 || (this._anchorCache.A0_G1 = this._resolveAnchors(onigLib, allowA, allowG)), this._anchorCache.A0_G1) : (this._anchorCache.A0_G0 || (this._anchorCache.A0_G0 = this._resolveAnchors(onigLib, allowA, allowG)), this._anchorCache.A0_G0) : this.compile(onigLib);
    }
    _resolveAnchors(onigLib, allowA, allowG) {
      let regExps = this._items.map(e => e.resolveAnchors(allowA, allowG));
      return new CompiledRule(onigLib, regExps, this._items.map(e => e.ruleId));
    }
  };,__name(_RegExpSourceList, "RegExpSourceList");,var RegExpSourceList = _RegExpSourceList,
  _CompiledRule = class _CompiledRule {
    constructor(onigLib, regExps, rules) {
      __publicField(this, "regExps");
      __publicField(this, "rules");
      __publicField(this, "scanner");
      this.regExps = regExps, this.rules = rules, this.scanner = onigLib.createOnigScanner(regExps);
    }
    dispose() {
      typeof this.scanner.dispose == "function" && this.scanner.dispose();
    }
    toString() {
      let r = [];
      for (let i = 0, len = this.rules.length; i < len; i++) r.push("   - " + this.rules[i] + ": " + this.regExps[i]);
      return r.join(`
`);
    }
    findNextMatchSync(string, startPosition, options) {
      let result = this.scanner.findNextMatchSync(string, startPosition, options);
      return result ? {
        ruleId: this.rules[result.index],
        captureIndices: result.captureIndices
      } : null;
    }
  };,__name(_CompiledRule, "CompiledRule");,var CompiledRule = _CompiledRule,
  _Theme = class _Theme {
    constructor(_colorMap, _defaults, _root) {
      __publicField(this, "_colorMap");
      __publicField(this, "_defaults");
      __publicField(this, "_root");
      __publicField(this, "_cachedMatchRoot", new CachedFn(scopeName => this._root.match(scopeName)));
      this._colorMap = _colorMap, this._defaults = _defaults, this._root = _root;
    }
    static createFromRawTheme(source, colorMap) {
      return this.createFromParsedTheme(parseTheme(source), colorMap);
    }
    static createFromParsedTheme(source, colorMap) {
      return resolveParsedThemeRules(source, colorMap);
    }
    getColorMap() {
      return this._colorMap.getColorMap();
    }
    getDefaults() {
      return this._defaults;
    }
    match(scopePath) {
      if (scopePath === null) return this._defaults;
      let scopeName = scopePath.scopeName,
        effectiveRule = this._cachedMatchRoot.get(scopeName).find(v => _scopePathMatchesParentScopes(scopePath.parent, v.parentScopes));
      return effectiveRule ? new StyleAttributes(effectiveRule.fontStyle, effectiveRule.foreground, effectiveRule.background) : null;
    }
  };,__name(_Theme, "Theme");,var Theme = _Theme,
  _ScopeStack = class _ScopeStack {
    constructor(parent, scopeName) {
      __publicField(this, "parent");
      __publicField(this, "scopeName");
      this.parent = parent, this.scopeName = scopeName;
    }
    static push(path, scopeNames) {
      for (let name of scopeNames) path = new _ScopeStack(path, name);
      return path;
    }
    static from(...segments) {
      let result = null;
      for (let i = 0; i < segments.length; i++) result = new _ScopeStack(result, segments[i]);
      return result;
    }
    push(scopeName) {
      return new _ScopeStack(this, scopeName);
    }
    getSegments() {
      let item = this,
        result = [];
      for (; item;) result.push(item.scopeName), item = item.parent;
      return result.reverse(), result;
    }
    toString() {
      return this.getSegments().join(" ");
    }
    extends(other) {
      return this === other ? !0 : this.parent === null ? !1 : this.parent.extends(other);
    }
    getExtensionIfDefined(base) {
      let result = [],
        item = this;
      for (; item && item !== base;) result.push(item.scopeName), item = item.parent;
      return item === base ? result.reverse() : void 0;
    }
  };,__name(_ScopeStack, "ScopeStack");,var ScopeStack = _ScopeStack;,function _scopePathMatchesParentScopes(scopePath, parentScopes) {
  if (parentScopes === null) return !0;
  let index = 0,
    scopePattern = parentScopes[index];
  for (; scopePath;) {
    if (_matchesScope(scopePath.scopeName, scopePattern)) {
      if (index++, index === parentScopes.length) return !0;
      scopePattern = parentScopes[index];
    }
    scopePath = scopePath.parent;
  }
  return !1;
},__name(_scopePathMatchesParentScopes, "_scopePathMatchesParentScopes");,function _matchesScope(scopeName, scopePattern) {
  return scopePattern === scopeName || scopeName.startsWith(scopePattern) && scopeName[scopePattern.length] === ".";
},__name(_matchesScope, "_matchesScope");,var _StyleAttributes = class _StyleAttributes {
  constructor(fontStyle, foregroundId, backgroundId) {
    __publicField(this, "fontStyle");
    __publicField(this, "foregroundId");
    __publicField(this, "backgroundId");
    this.fontStyle = fontStyle, this.foregroundId = foregroundId, this.backgroundId = backgroundId;
  }
};,__name(_StyleAttributes, "StyleAttributes");,var StyleAttributes = _StyleAttributes;,function parseTheme(source) {
  if (!source) return [];
  if (!source.settings || !Array.isArray(source.settings)) return [];
  let settings = source.settings,
    result = [],
    resultLen = 0;
  for (let i = 0, len = settings.length; i < len; i++) {
    let entry = settings[i];
    if (!entry.settings) continue;
    let scopes;
    if (typeof entry.scope == "string") {
      let _scope = entry.scope;
      _scope = _scope.replace(/^[,]+/, ""), _scope = _scope.replace(/[,]+$/, ""), scopes = _scope.split(",");
    } else Array.isArray(entry.scope) ? scopes = entry.scope : scopes = [""];
    let fontStyle = -1;
    if (typeof entry.settings.fontStyle == "string") {
      fontStyle = 0;
      let segments = entry.settings.fontStyle.split(" ");
      for (let j = 0, lenJ = segments.length; j < lenJ; j++) switch (segments[j]) {
        case "italic":
          fontStyle = fontStyle | 1;
          break;
        case "bold":
          fontStyle = fontStyle | 2;
          break;
        case "underline":
          fontStyle = fontStyle | 4;
          break;
        case "strikethrough":
          fontStyle = fontStyle | 8;
          break;
      }
    }
    let foreground = null;
    typeof entry.settings.foreground == "string" && isValidHexColor(entry.settings.foreground) && (foreground = entry.settings.foreground);
    let background = null;
    typeof entry.settings.background == "string" && isValidHexColor(entry.settings.background) && (background = entry.settings.background);
    for (let j = 0, lenJ = scopes.length; j < lenJ; j++) {
      let segments = scopes[j].trim().split(" "),
        scope = segments[segments.length - 1],
        parentScopes = null;
      segments.length > 1 && (parentScopes = segments.slice(0, segments.length - 1), parentScopes.reverse()), result[resultLen++] = new ParsedThemeRule(scope, parentScopes, i, fontStyle, foreground, background);
    }
  }
  return result;
},__name(parseTheme, "parseTheme");,var _ParsedThemeRule = class _ParsedThemeRule {
  constructor(scope, parentScopes, index, fontStyle, foreground, background) {
    __publicField(this, "scope");
    __publicField(this, "parentScopes");
    __publicField(this, "index");
    __publicField(this, "fontStyle");
    __publicField(this, "foreground");
    __publicField(this, "background");
    this.scope = scope, this.parentScopes = parentScopes, this.index = index, this.fontStyle = fontStyle, this.foreground = foreground, this.background = background;
  }
};,__name(_ParsedThemeRule, "ParsedThemeRule");,var ParsedThemeRule = _ParsedThemeRule;,function resolveParsedThemeRules(parsedThemeRules, _colorMap) {
  parsedThemeRules.sort((a, b) => {
    let r = strcmp(a.scope, b.scope);
    return r !== 0 || (r = strArrCmp(a.parentScopes, b.parentScopes), r !== 0) ? r : a.index - b.index;
  });
  let defaultFontStyle = 0,
    defaultForeground = "#000000",
    defaultBackground = "#ffffff";
  for (; parsedThemeRules.length >= 1 && parsedThemeRules[0].scope === "";) {
    let incomingDefaults = parsedThemeRules.shift();
    incomingDefaults.fontStyle !== -1 && (defaultFontStyle = incomingDefaults.fontStyle), incomingDefaults.foreground !== null && (defaultForeground = incomingDefaults.foreground), incomingDefaults.background !== null && (defaultBackground = incomingDefaults.background);
  }
  let colorMap = new ColorMap(_colorMap),
    defaults = new StyleAttributes(defaultFontStyle, colorMap.getId(defaultForeground), colorMap.getId(defaultBackground)),
    root = new ThemeTrieElement(new ThemeTrieElementRule(0, null, -1, 0, 0), []);
  for (let i = 0, len = parsedThemeRules.length; i < len; i++) {
    let rule = parsedThemeRules[i];
    root.insert(0, rule.scope, rule.parentScopes, rule.fontStyle, colorMap.getId(rule.foreground), colorMap.getId(rule.background));
  }
  return new Theme(colorMap, defaults, root);
},__name(resolveParsedThemeRules, "resolveParsedThemeRules");,var _ColorMap = class _ColorMap {
  constructor(_colorMap) {
    __publicField(this, "_isFrozen");
    __publicField(this, "_lastColorId");
    __publicField(this, "_id2color");
    __publicField(this, "_color2id");
    if (this._lastColorId = 0, this._id2color = [], this._color2id = Object.create(null), Array.isArray(_colorMap)) {
      this._isFrozen = !0;
      for (let i = 0, len = _colorMap.length; i < len; i++) this._color2id[_colorMap[i]] = i, this._id2color[i] = _colorMap[i];
    } else this._isFrozen = !1;
  }
  getId(color) {
    if (color === null) return 0;
    color = color.toUpperCase();
    let value = this._color2id[color];
    if (value) return value;
    if (this._isFrozen) throw new Error(`Missing color in color map - ${color}`);
    return value = ++this._lastColorId, this._color2id[color] = value, this._id2color[value] = color, value;
  }
  getColorMap() {
    return this._id2color.slice(0);
  }
};,__name(_ColorMap, "ColorMap");,var ColorMap = _ColorMap,
  _ThemeTrieElementRule = class _ThemeTrieElementRule {
    constructor(scopeDepth, parentScopes, fontStyle, foreground, background) {
      __publicField(this, "scopeDepth");
      __publicField(this, "parentScopes");
      __publicField(this, "fontStyle");
      __publicField(this, "foreground");
      __publicField(this, "background");
      this.scopeDepth = scopeDepth, this.parentScopes = parentScopes, this.fontStyle = fontStyle, this.foreground = foreground, this.background = background;
    }
    clone() {
      return new _ThemeTrieElementRule(this.scopeDepth, this.parentScopes, this.fontStyle, this.foreground, this.background);
    }
    static cloneArr(arr) {
      let r = [];
      for (let i = 0, len = arr.length; i < len; i++) r[i] = arr[i].clone();
      return r;
    }
    acceptOverwrite(scopeDepth, fontStyle, foreground, background) {
      this.scopeDepth > scopeDepth ? console.log("how did this happen?") : this.scopeDepth = scopeDepth, fontStyle !== -1 && (this.fontStyle = fontStyle), foreground !== 0 && (this.foreground = foreground), background !== 0 && (this.background = background);
    }
  };,__name(_ThemeTrieElementRule, "ThemeTrieElementRule");,var ThemeTrieElementRule = _ThemeTrieElementRule,
  _ThemeTrieElement = class _ThemeTrieElement {
    constructor(_mainRule, rulesWithParentScopes = [], _children = {}) {
      __publicField(this, "_mainRule");
      __publicField(this, "_children");
      __publicField(this, "_rulesWithParentScopes");
      this._mainRule = _mainRule, this._children = _children, this._rulesWithParentScopes = rulesWithParentScopes;
    }
    static _sortBySpecificity(arr) {
      return arr.length === 1 || arr.sort(this._cmpBySpecificity), arr;
    }
    static _cmpBySpecificity(a, b) {
      if (a.scopeDepth === b.scopeDepth) {
        let aParentScopes = a.parentScopes,
          bParentScopes = b.parentScopes,
          aParentScopesLen = aParentScopes === null ? 0 : aParentScopes.length,
          bParentScopesLen = bParentScopes === null ? 0 : bParentScopes.length;
        if (aParentScopesLen === bParentScopesLen) for (let i = 0; i < aParentScopesLen; i++) {
          let aLen = aParentScopes[i].length,
            bLen = bParentScopes[i].length;
          if (aLen !== bLen) return bLen - aLen;
        }
        return bParentScopesLen - aParentScopesLen;
      }
      return b.scopeDepth - a.scopeDepth;
    }
    match(scope) {
      if (scope === "") return _ThemeTrieElement._sortBySpecificity([].concat(this._mainRule).concat(this._rulesWithParentScopes));
      let dotIndex = scope.indexOf("."),
        head,
        tail;
      return dotIndex === -1 ? (head = scope, tail = "") : (head = scope.substring(0, dotIndex), tail = scope.substring(dotIndex + 1)), this._children.hasOwnProperty(head) ? this._children[head].match(tail) : _ThemeTrieElement._sortBySpecificity([].concat(this._mainRule).concat(this._rulesWithParentScopes));
    }
    insert(scopeDepth, scope, parentScopes, fontStyle, foreground, background) {
      if (scope === "") {
        this._doInsertHere(scopeDepth, parentScopes, fontStyle, foreground, background);
        return;
      }
      let dotIndex = scope.indexOf("."),
        head,
        tail;
      dotIndex === -1 ? (head = scope, tail = "") : (head = scope.substring(0, dotIndex), tail = scope.substring(dotIndex + 1));
      let child;
      this._children.hasOwnProperty(head) ? child = this._children[head] : (child = new _ThemeTrieElement(this._mainRule.clone(), ThemeTrieElementRule.cloneArr(this._rulesWithParentScopes)), this._children[head] = child), child.insert(scopeDepth + 1, tail, parentScopes, fontStyle, foreground, background);
    }
    _doInsertHere(scopeDepth, parentScopes, fontStyle, foreground, background) {
      if (parentScopes === null) {
        this._mainRule.acceptOverwrite(scopeDepth, fontStyle, foreground, background);
        return;
      }
      for (let i = 0, len = this._rulesWithParentScopes.length; i < len; i++) {
        let rule = this._rulesWithParentScopes[i];
        if (strArrCmp(rule.parentScopes, parentScopes) === 0) {
          rule.acceptOverwrite(scopeDepth, fontStyle, foreground, background);
          return;
        }
      }
      fontStyle === -1 && (fontStyle = this._mainRule.fontStyle), foreground === 0 && (foreground = this._mainRule.foreground), background === 0 && (background = this._mainRule.background), this._rulesWithParentScopes.push(new ThemeTrieElementRule(scopeDepth, parentScopes, fontStyle, foreground, background));
    }
  };,__name(_ThemeTrieElement, "ThemeTrieElement");,var ThemeTrieElement = _ThemeTrieElement,
  _BasicScopeAttributes = class _BasicScopeAttributes {
    constructor(languageId, tokenType) {
      __publicField(this, "languageId");
      __publicField(this, "tokenType");
      this.languageId = languageId, this.tokenType = tokenType;
    }
  };,__name(_BasicScopeAttributes, "BasicScopeAttributes");,var BasicScopeAttributes = _BasicScopeAttributes,
  _BasicScopeAttributesProvider = class _BasicScopeAttributesProvider {
    constructor(initialLanguageId, embeddedLanguages) {
      __publicField(this, "_defaultAttributes");
      __publicField(this, "_embeddedLanguagesMatcher");
      __publicField(this, "_getBasicScopeAttributes", new CachedFn(scopeName => {
        let languageId = this._scopeToLanguage(scopeName),
          standardTokenType = this._toStandardTokenType(scopeName);
        return new BasicScopeAttributes(languageId, standardTokenType);
      }));
      this._defaultAttributes = new BasicScopeAttributes(initialLanguageId, 8), this._embeddedLanguagesMatcher = new ScopeMatcher(Object.entries(embeddedLanguages || {}));
    }
    getDefaultAttributes() {
      return this._defaultAttributes;
    }
    getBasicScopeAttributes(scopeName) {
      return scopeName === null ? _BasicScopeAttributesProvider._NULL_SCOPE_METADATA : this._getBasicScopeAttributes.get(scopeName);
    }
    _scopeToLanguage(scope) {
      return this._embeddedLanguagesMatcher.match(scope) || 0;
    }
    _toStandardTokenType(scopeName) {
      let m = scopeName.match(_BasicScopeAttributesProvider.STANDARD_TOKEN_TYPE_REGEXP);
      if (!m) return 8;
      switch (m[1]) {
        case "comment":
          return 1;
        case "string":
          return 2;
        case "regex":
          return 3;
        case "meta.embedded":
          return 0;
      }
      throw new Error("Unexpected match for standard token type!");
    }
  };,__name(_BasicScopeAttributesProvider, "BasicScopeAttributesProvider"), __publicField(_BasicScopeAttributesProvider, "_NULL_SCOPE_METADATA", new BasicScopeAttributes(0, 0)), __publicField(_BasicScopeAttributesProvider, "STANDARD_TOKEN_TYPE_REGEXP", /\b(comment|string|regex|meta\.embedded)\b/);,var BasicScopeAttributesProvider = _BasicScopeAttributesProvider,
  _ScopeMatcher = class _ScopeMatcher {
    constructor(values) {
      __publicField(this, "values");
      __publicField(this, "scopesRegExp");
      if (values.length === 0) this.values = null, this.scopesRegExp = null;else {
        this.values = new Map(values);
        let escapedScopes = values.map(([scopeName, value]) => escapeRegExpCharacters(scopeName));
        escapedScopes.sort(), escapedScopes.reverse(), this.scopesRegExp = new RegExp(`^((${escapedScopes.join(")|(")}))($|\\.)`, "");
      }
    }
    match(scope) {
      if (!this.scopesRegExp) return;
      let m = scope.match(this.scopesRegExp);
      if (m) return this.values.get(m[1]);
    }
  };,__name(_ScopeMatcher, "ScopeMatcher");,var ScopeMatcher = _ScopeMatcher,
  _TokenizeStringResult = class _TokenizeStringResult {
    constructor(stack, stoppedEarly) {
      __publicField(this, "stack");
      __publicField(this, "stoppedEarly");
      this.stack = stack, this.stoppedEarly = stoppedEarly;
    }
  };,__name(_TokenizeStringResult, "TokenizeStringResult");,var TokenizeStringResult = _TokenizeStringResult;,function _tokenizeString(grammar, lineText, isFirstLine, linePos, stack, lineTokens, checkWhileConditions, timeLimit) {
  let lineLength = lineText.content.length,
    STOP = !1,
    anchorPosition = -1;
  if (checkWhileConditions) {
    let whileCheckResult = _checkWhileConditions(grammar, lineText, isFirstLine, linePos, stack, lineTokens);
    stack = whileCheckResult.stack, linePos = whileCheckResult.linePos, isFirstLine = whileCheckResult.isFirstLine, anchorPosition = whileCheckResult.anchorPosition;
  }
  let startTime = Date.now();
  for (; !STOP;) {
    if (timeLimit !== 0 && Date.now() - startTime > timeLimit) return new TokenizeStringResult(stack, !0);
    scanNext();
  }
  return new TokenizeStringResult(stack, !1);
  function scanNext() {
    let r = matchRuleOrInjections(grammar, lineText, isFirstLine, linePos, stack, anchorPosition);
    if (!r) {
      lineTokens.produce(stack, lineLength), STOP = !0;
      return;
    }
    let captureIndices = r.captureIndices,
      matchedRuleId = r.matchedRuleId,
      hasAdvanced = captureIndices && captureIndices.length > 0 ? captureIndices[0].end > linePos : !1;
    if (matchedRuleId === endRuleId) {
      let poppedRule = stack.getRule(grammar);
      lineTokens.produce(stack, captureIndices[0].start), stack = stack.withContentNameScopesList(stack.nameScopesList), handleCaptures(grammar, lineText, isFirstLine, stack, lineTokens, poppedRule.endCaptures, captureIndices), lineTokens.produce(stack, captureIndices[0].end);
      let popped = stack;
      if (stack = stack.parent, anchorPosition = popped.getAnchorPos(), !hasAdvanced && popped.getEnterPos() === linePos) {
        stack = popped, lineTokens.produce(stack, lineLength), STOP = !0;
        return;
      }
    } else {
      let _rule = grammar.getRule(matchedRuleId);
      lineTokens.produce(stack, captureIndices[0].start);
      let beforePush = stack,
        scopeName = _rule.getName(lineText.content, captureIndices),
        nameScopesList = stack.contentNameScopesList.pushAttributed(scopeName, grammar);
      if (stack = stack.push(matchedRuleId, linePos, anchorPosition, captureIndices[0].end === lineLength, null, nameScopesList, nameScopesList), _rule instanceof BeginEndRule) {
        let pushedRule = _rule;
        handleCaptures(grammar, lineText, isFirstLine, stack, lineTokens, pushedRule.beginCaptures, captureIndices), lineTokens.produce(stack, captureIndices[0].end), anchorPosition = captureIndices[0].end;
        let contentName = pushedRule.getContentName(lineText.content, captureIndices),
          contentNameScopesList = nameScopesList.pushAttributed(contentName, grammar);
        if (stack = stack.withContentNameScopesList(contentNameScopesList), pushedRule.endHasBackReferences && (stack = stack.withEndRule(pushedRule.getEndWithResolvedBackReferences(lineText.content, captureIndices))), !hasAdvanced && beforePush.hasSameRuleAs(stack)) {
          stack = stack.pop(), lineTokens.produce(stack, lineLength), STOP = !0;
          return;
        }
      } else if (_rule instanceof BeginWhileRule) {
        let pushedRule = _rule;
        handleCaptures(grammar, lineText, isFirstLine, stack, lineTokens, pushedRule.beginCaptures, captureIndices), lineTokens.produce(stack, captureIndices[0].end), anchorPosition = captureIndices[0].end;
        let contentName = pushedRule.getContentName(lineText.content, captureIndices),
          contentNameScopesList = nameScopesList.pushAttributed(contentName, grammar);
        if (stack = stack.withContentNameScopesList(contentNameScopesList), pushedRule.whileHasBackReferences && (stack = stack.withEndRule(pushedRule.getWhileWithResolvedBackReferences(lineText.content, captureIndices))), !hasAdvanced && beforePush.hasSameRuleAs(stack)) {
          stack = stack.pop(), lineTokens.produce(stack, lineLength), STOP = !0;
          return;
        }
      } else if (handleCaptures(grammar, lineText, isFirstLine, stack, lineTokens, _rule.captures, captureIndices), lineTokens.produce(stack, captureIndices[0].end), stack = stack.pop(), !hasAdvanced) {
        stack = stack.safePop(), lineTokens.produce(stack, lineLength), STOP = !0;
        return;
      }
    }
    captureIndices[0].end > linePos && (linePos = captureIndices[0].end, isFirstLine = !1);
  }
},__name(_tokenizeString, "_tokenizeString");,function _checkWhileConditions(grammar, lineText, isFirstLine, linePos, stack, lineTokens) {
  let anchorPosition = stack.beginRuleCapturedEOL ? 0 : -1,
    whileRules = [];
  for (let node = stack; node; node = node.pop()) {
    let nodeRule = node.getRule(grammar);
    nodeRule instanceof BeginWhileRule && whileRules.push({
      rule: nodeRule,
      stack: node
    });
  }
  for (let whileRule = whileRules.pop(); whileRule; whileRule = whileRules.pop()) {
    let {
        ruleScanner: ruleScanner,
        findOptions: findOptions
      } = prepareRuleWhileSearch(whileRule.rule, grammar, whileRule.stack.endRule, isFirstLine, linePos === anchorPosition),
      r = ruleScanner.findNextMatchSync(lineText, linePos, findOptions);
    if (r) {
      if (r.ruleId !== whileRuleId) {
        stack = whileRule.stack.pop();
        break;
      }
      r.captureIndices && r.captureIndices.length && (lineTokens.produce(whileRule.stack, r.captureIndices[0].start), handleCaptures(grammar, lineText, isFirstLine, whileRule.stack, lineTokens, whileRule.rule.whileCaptures, r.captureIndices), lineTokens.produce(whileRule.stack, r.captureIndices[0].end), anchorPosition = r.captureIndices[0].end, r.captureIndices[0].end > linePos && (linePos = r.captureIndices[0].end, isFirstLine = !1));
    } else {
      stack = whileRule.stack.pop();
      break;
    }
  }
  return {
    stack: stack,
    linePos: linePos,
    anchorPosition: anchorPosition,
    isFirstLine: isFirstLine
  };
},__name(_checkWhileConditions, "_checkWhileConditions");,function matchRuleOrInjections(grammar, lineText, isFirstLine, linePos, stack, anchorPosition) {
  let matchResult = matchRule(grammar, lineText, isFirstLine, linePos, stack, anchorPosition),
    injections = grammar.getInjections();
  if (injections.length === 0) return matchResult;
  let injectionResult = matchInjections(injections, grammar, lineText, isFirstLine, linePos, stack, anchorPosition);
  if (!injectionResult) return matchResult;
  if (!matchResult) return injectionResult;
  let matchResultScore = matchResult.captureIndices[0].start,
    injectionResultScore = injectionResult.captureIndices[0].start;
  return injectionResultScore < matchResultScore || injectionResult.priorityMatch && injectionResultScore === matchResultScore ? injectionResult : matchResult;
},__name(matchRuleOrInjections, "matchRuleOrInjections");,function matchRule(grammar, lineText, isFirstLine, linePos, stack, anchorPosition) {
  let rule = stack.getRule(grammar),
    {
      ruleScanner: ruleScanner,
      findOptions: findOptions
    } = prepareRuleSearch(rule, grammar, stack.endRule, isFirstLine, linePos === anchorPosition),
    r = ruleScanner.findNextMatchSync(lineText, linePos, findOptions);
  return r ? {
    captureIndices: r.captureIndices,
    matchedRuleId: r.ruleId
  } : null;
},__name(matchRule, "matchRule");,function matchInjections(injections, grammar, lineText, isFirstLine, linePos, stack, anchorPosition) {
  let bestMatchRating = Number.MAX_VALUE,
    bestMatchCaptureIndices = null,
    bestMatchRuleId,
    bestMatchResultPriority = 0,
    scopes = stack.contentNameScopesList.getScopeNames();
  for (let i = 0, len = injections.length; i < len; i++) {
    let injection = injections[i];
    if (!injection.matcher(scopes)) continue;
    let rule = grammar.getRule(injection.ruleId),
      {
        ruleScanner: ruleScanner,
        findOptions: findOptions
      } = prepareRuleSearch(rule, grammar, null, isFirstLine, linePos === anchorPosition),
      matchResult = ruleScanner.findNextMatchSync(lineText, linePos, findOptions);
    if (!matchResult) continue;
    let matchRating = matchResult.captureIndices[0].start;
    if (!(matchRating >= bestMatchRating) && (bestMatchRating = matchRating, bestMatchCaptureIndices = matchResult.captureIndices, bestMatchRuleId = matchResult.ruleId, bestMatchResultPriority = injection.priority, bestMatchRating === linePos)) break;
  }
  return bestMatchCaptureIndices ? {
    priorityMatch: bestMatchResultPriority === -1,
    captureIndices: bestMatchCaptureIndices,
    matchedRuleId: bestMatchRuleId
  } : null;
},__name(matchInjections, "matchInjections");,function prepareRuleSearch(rule, grammar, endRegexSource, allowA, allowG) {
  return {
    ruleScanner: rule.compileAG(grammar, endRegexSource, allowA, allowG),
    findOptions: 0
  };
},__name(prepareRuleSearch, "prepareRuleSearch");,function prepareRuleWhileSearch(rule, grammar, endRegexSource, allowA, allowG) {
  return {
    ruleScanner: rule.compileWhileAG(grammar, endRegexSource, allowA, allowG),
    findOptions: 0
  };
},__name(prepareRuleWhileSearch, "prepareRuleWhileSearch");,function handleCaptures(grammar, lineText, isFirstLine, stack, lineTokens, captures, captureIndices) {
  if (captures.length === 0) return;
  let lineTextContent = lineText.content,
    len = Math.min(captures.length, captureIndices.length),
    localStack = [],
    maxEnd = captureIndices[0].end;
  for (let i = 0; i < len; i++) {
    let captureRule = captures[i];
    if (captureRule === null) continue;
    let captureIndex = captureIndices[i];
    if (captureIndex.length === 0) continue;
    if (captureIndex.start > maxEnd) break;
    for (; localStack.length > 0 && localStack[localStack.length - 1].endPos <= captureIndex.start;) lineTokens.produceFromScopes(localStack[localStack.length - 1].scopes, localStack[localStack.length - 1].endPos), localStack.pop();
    if (localStack.length > 0 ? lineTokens.produceFromScopes(localStack[localStack.length - 1].scopes, captureIndex.start) : lineTokens.produce(stack, captureIndex.start), captureRule.retokenizeCapturedWithRuleId) {
      let scopeName = captureRule.getName(lineTextContent, captureIndices),
        nameScopesList = stack.contentNameScopesList.pushAttributed(scopeName, grammar),
        contentName = captureRule.getContentName(lineTextContent, captureIndices),
        contentNameScopesList = nameScopesList.pushAttributed(contentName, grammar),
        stackClone = stack.push(captureRule.retokenizeCapturedWithRuleId, captureIndex.start, -1, !1, null, nameScopesList, contentNameScopesList),
        onigSubStr = grammar.createOnigString(lineTextContent.substring(0, captureIndex.end));
      _tokenizeString(grammar, onigSubStr, isFirstLine && captureIndex.start === 0, captureIndex.start, stackClone, lineTokens, !1, 0), disposeOnigString(onigSubStr);
      continue;
    }
    let captureRuleScopeName = captureRule.getName(lineTextContent, captureIndices);
    if (captureRuleScopeName !== null) {
      let captureRuleScopesList = (localStack.length > 0 ? localStack[localStack.length - 1].scopes : stack.contentNameScopesList).pushAttributed(captureRuleScopeName, grammar);
      localStack.push(new LocalStackElement(captureRuleScopesList, captureIndex.end));
    }
  }
  for (; localStack.length > 0;) lineTokens.produceFromScopes(localStack[localStack.length - 1].scopes, localStack[localStack.length - 1].endPos), localStack.pop();
},__name(handleCaptures, "handleCaptures");,var _LocalStackElement = class _LocalStackElement {
  constructor(scopes, endPos) {
    __publicField(this, "scopes");
    __publicField(this, "endPos");
    this.scopes = scopes, this.endPos = endPos;
  }
};,__name(_LocalStackElement, "LocalStackElement");,var LocalStackElement = _LocalStackElement;,function createGrammar(scopeName, grammar, initialLanguage, embeddedLanguages, tokenTypes, balancedBracketSelectors, grammarRepository, onigLib) {
  return new Grammar(scopeName, grammar, initialLanguage, embeddedLanguages, tokenTypes, balancedBracketSelectors, grammarRepository, onigLib);
},__name(createGrammar, "createGrammar");,function collectInjections(result, selector, rule, ruleFactoryHelper, grammar) {
  let matchers = createMatchers(selector, nameMatcher),
    ruleId = RuleFactory.getCompiledRuleId(rule, ruleFactoryHelper, grammar.repository);
  for (let matcher of matchers) result.push({
    debugSelector: selector,
    matcher: matcher.matcher,
    ruleId: ruleId,
    grammar: grammar,
    priority: matcher.priority
  });
},__name(collectInjections, "collectInjections");,function nameMatcher(identifers, scopes) {
  if (scopes.length < identifers.length) return !1;
  let lastIndex = 0;
  return identifers.every(identifier => {
    for (let i = lastIndex; i < scopes.length; i++) if (scopesAreMatching(scopes[i], identifier)) return lastIndex = i + 1, !0;
    return !1;
  });
},__name(nameMatcher, "nameMatcher");,function scopesAreMatching(thisScopeName, scopeName) {
  if (!thisScopeName) return !1;
  if (thisScopeName === scopeName) return !0;
  let len = scopeName.length;
  return thisScopeName.length > len && thisScopeName.substr(0, len) === scopeName && thisScopeName[len] === ".";
},__name(scopesAreMatching, "scopesAreMatching");,var _Grammar = class _Grammar {
  constructor(_rootScopeName, grammar, initialLanguage, embeddedLanguages, tokenTypes, balancedBracketSelectors, grammarRepository, _onigLib) {
    __publicField(this, "_rootScopeName");
    __publicField(this, "balancedBracketSelectors");
    __publicField(this, "_onigLib");
    __publicField(this, "_rootId");
    __publicField(this, "_lastRuleId");
    __publicField(this, "_ruleId2desc");
    __publicField(this, "_includedGrammars");
    __publicField(this, "_grammarRepository");
    __publicField(this, "_grammar");
    __publicField(this, "_injections");
    __publicField(this, "_basicScopeAttributesProvider");
    __publicField(this, "_tokenTypeMatchers");
    if (this._rootScopeName = _rootScopeName, this.balancedBracketSelectors = balancedBracketSelectors, this._onigLib = _onigLib, this._basicScopeAttributesProvider = new BasicScopeAttributesProvider(initialLanguage, embeddedLanguages), this._rootId = -1, this._lastRuleId = 0, this._ruleId2desc = [null], this._includedGrammars = {}, this._grammarRepository = grammarRepository, this._grammar = initGrammar(grammar, null), this._injections = null, this._tokenTypeMatchers = [], tokenTypes) for (let selector of Object.keys(tokenTypes)) {
      let matchers = createMatchers(selector, nameMatcher);
      for (let matcher of matchers) this._tokenTypeMatchers.push({
        matcher: matcher.matcher,
        type: tokenTypes[selector]
      });
    }
  }
  get themeProvider() {
    return this._grammarRepository;
  }
  dispose() {
    for (let rule of this._ruleId2desc) rule && rule.dispose();
  }
  createOnigScanner(sources) {
    return this._onigLib.createOnigScanner(sources);
  }
  createOnigString(sources) {
    return this._onigLib.createOnigString(sources);
  }
  getMetadataForScope(scope) {
    return this._basicScopeAttributesProvider.getBasicScopeAttributes(scope);
  }
  _collectInjections() {
    let grammarRepository = {
        lookup: __name(scopeName => scopeName === this._rootScopeName ? this._grammar : this.getExternalGrammar(scopeName), "lookup"),
        injections: __name(scopeName => this._grammarRepository.injections(scopeName), "injections")
      },
      result = [],
      scopeName = this._rootScopeName,
      grammar = grammarRepository.lookup(scopeName);
    if (grammar) {
      let rawInjections = grammar.injections;
      if (rawInjections) for (let expression in rawInjections) collectInjections(result, expression, rawInjections[expression], this, grammar);
      let injectionScopeNames = this._grammarRepository.injections(scopeName);
      injectionScopeNames && injectionScopeNames.forEach(injectionScopeName => {
        let injectionGrammar = this.getExternalGrammar(injectionScopeName);
        if (injectionGrammar) {
          let selector = injectionGrammar.injectionSelector;
          selector && collectInjections(result, selector, injectionGrammar, this, injectionGrammar);
        }
      });
    }
    return result.sort((i1, i2) => i1.priority - i2.priority), result;
  }
  getInjections() {
    return this._injections === null && (this._injections = this._collectInjections()), this._injections;
  }
  registerRule(factory) {
    let id = ++this._lastRuleId,
      result = factory(id);
    return this._ruleId2desc[id] = result, result;
  }
  getRule(ruleId) {
    return this._ruleId2desc[ruleId];
  }
  getExternalGrammar(scopeName, repository) {
    if (this._includedGrammars[scopeName]) return this._includedGrammars[scopeName];
    if (this._grammarRepository) {
      let rawIncludedGrammar = this._grammarRepository.lookup(scopeName);
      if (rawIncludedGrammar) return this._includedGrammars[scopeName] = initGrammar(rawIncludedGrammar, repository && repository.$base), this._includedGrammars[scopeName];
    }
  }
  tokenizeLine(lineText, prevState, timeLimit = 0) {
    let r = this._tokenize(lineText, prevState, !1, timeLimit);
    return {
      tokens: r.lineTokens.getResult(r.ruleStack, r.lineLength),
      ruleStack: r.ruleStack,
      stoppedEarly: r.stoppedEarly
    };
  }
  tokenizeLine2(lineText, prevState, timeLimit = 0) {
    let r = this._tokenize(lineText, prevState, !0, timeLimit);
    return {
      tokens: r.lineTokens.getBinaryResult(r.ruleStack, r.lineLength),
      ruleStack: r.ruleStack,
      stoppedEarly: r.stoppedEarly
    };
  }
  _tokenize(lineText, prevState, emitBinaryTokens, timeLimit) {
    this._rootId === -1 && (this._rootId = RuleFactory.getCompiledRuleId(this._grammar.repository.$self, this, this._grammar.repository), this.getInjections());
    let isFirstLine;
    if (!prevState || prevState === StateStackImpl.NULL) {
      isFirstLine = !0;
      let rawDefaultMetadata = this._basicScopeAttributesProvider.getDefaultAttributes(),
        defaultStyle = this.themeProvider.getDefaults(),
        defaultMetadata = EncodedTokenAttributes.set(0, rawDefaultMetadata.languageId, rawDefaultMetadata.tokenType, null, defaultStyle.fontStyle, defaultStyle.foregroundId, defaultStyle.backgroundId),
        rootScopeName = this.getRule(this._rootId).getName(null, null),
        scopeList;
      rootScopeName ? scopeList = AttributedScopeStack.createRootAndLookUpScopeName(rootScopeName, defaultMetadata, this) : scopeList = AttributedScopeStack.createRoot("unknown", defaultMetadata), prevState = new StateStackImpl(null, this._rootId, -1, -1, !1, null, scopeList, scopeList);
    } else isFirstLine = !1, prevState.reset();
    lineText = lineText + `
`;
    let onigLineText = this.createOnigString(lineText),
      lineLength = onigLineText.content.length,
      lineTokens = new LineTokens(emitBinaryTokens, lineText, this._tokenTypeMatchers, this.balancedBracketSelectors),
      r = _tokenizeString(this, onigLineText, isFirstLine, 0, prevState, lineTokens, !0, timeLimit);
    return disposeOnigString(onigLineText), {
      lineLength: lineLength,
      lineTokens: lineTokens,
      ruleStack: r.stack,
      stoppedEarly: r.stoppedEarly
    };
  }
};,__name(_Grammar, "Grammar");,var Grammar = _Grammar;,function initGrammar(grammar, base) {
  return grammar = clone(grammar), grammar.repository = grammar.repository || {}, grammar.repository.$self = {
    $vscodeTextmateLocation: grammar.$vscodeTextmateLocation,
    patterns: grammar.patterns,
    name: grammar.scopeName
  }, grammar.repository.$base = base || grammar.repository.$self, grammar;
},__name(initGrammar, "initGrammar");,var _AttributedScopeStack = class _AttributedScopeStack {
  constructor(parent, scopePath, tokenAttributes) {
    __publicField(this, "parent");
    __publicField(this, "scopePath");
    __publicField(this, "tokenAttributes");
    this.parent = parent, this.scopePath = scopePath, this.tokenAttributes = tokenAttributes;
  }
  static fromExtension(namesScopeList, contentNameScopesList) {
    var _a;
    let current = namesScopeList,
      scopeNames = (_a = namesScopeList == null ? void 0 : namesScopeList.scopePath) != null ? _a : null;
    for (let frame of contentNameScopesList) scopeNames = ScopeStack.push(scopeNames, frame.scopeNames), current = new _AttributedScopeStack(current, scopeNames, frame.encodedTokenAttributes);
    return current;
  }
  static createRoot(scopeName, tokenAttributes) {
    return new _AttributedScopeStack(null, new ScopeStack(null, scopeName), tokenAttributes);
  }
  static createRootAndLookUpScopeName(scopeName, tokenAttributes, grammar) {
    let rawRootMetadata = grammar.getMetadataForScope(scopeName),
      scopePath = new ScopeStack(null, scopeName),
      rootStyle = grammar.themeProvider.themeMatch(scopePath),
      resolvedTokenAttributes = _AttributedScopeStack.mergeAttributes(tokenAttributes, rawRootMetadata, rootStyle);
    return new _AttributedScopeStack(null, scopePath, resolvedTokenAttributes);
  }
  get scopeName() {
    return this.scopePath.scopeName;
  }
  toString() {
    return this.getScopeNames().join(" ");
  }
  equals(other) {
    return _AttributedScopeStack.equals(this, other);
  }
  static equals(a, b) {
    do {
      if (a === b || !a && !b) return !0;
      if (!a || !b || a.scopeName !== b.scopeName || a.tokenAttributes !== b.tokenAttributes) return !1;
      a = a.parent, b = b.parent;
    } while (!0);
  }
  static mergeAttributes(existingTokenAttributes, basicScopeAttributes, styleAttributes) {
    let fontStyle = -1,
      foreground = 0,
      background = 0;
    return styleAttributes !== null && (fontStyle = styleAttributes.fontStyle, foreground = styleAttributes.foregroundId, background = styleAttributes.backgroundId), EncodedTokenAttributes.set(existingTokenAttributes, basicScopeAttributes.languageId, basicScopeAttributes.tokenType, null, fontStyle, foreground, background);
  }
  pushAttributed(scopePath, grammar) {
    if (scopePath === null) return this;
    if (scopePath.indexOf(" ") === -1) return _AttributedScopeStack._pushAttributed(this, scopePath, grammar);
    let scopes = scopePath.split(/ /g),
      result = this;
    for (let scope of scopes) result = _AttributedScopeStack._pushAttributed(result, scope, grammar);
    return result;
  }
  static _pushAttributed(target, scopeName, grammar) {
    let rawMetadata = grammar.getMetadataForScope(scopeName),
      newPath = target.scopePath.push(scopeName),
      scopeThemeMatchResult = grammar.themeProvider.themeMatch(newPath),
      metadata = _AttributedScopeStack.mergeAttributes(target.tokenAttributes, rawMetadata, scopeThemeMatchResult);
    return new _AttributedScopeStack(target, newPath, metadata);
  }
  getScopeNames() {
    return this.scopePath.getSegments();
  }
  getExtensionIfDefined(base) {
    var _a, _b;
    let result = [],
      self = this;
    for (; self && self !== base;) result.push({
      encodedTokenAttributes: self.tokenAttributes,
      scopeNames: self.scopePath.getExtensionIfDefined((_b = (_a = self.parent) == null ? void 0 : _a.scopePath) != null ? _b : null)
    }), self = self.parent;
    return self === base ? result.reverse() : void 0;
  }
};,__name(_AttributedScopeStack, "AttributedScopeStack");,var AttributedScopeStack = _AttributedScopeStack,
  _StateStackImpl = class _StateStackImpl {
    constructor(parent, ruleId, enterPos, anchorPos, beginRuleCapturedEOL, endRule, nameScopesList, contentNameScopesList) {
      __publicField(this, "parent");
      __publicField(this, "ruleId");
      __publicField(this, "beginRuleCapturedEOL");
      __publicField(this, "endRule");
      __publicField(this, "nameScopesList");
      __publicField(this, "contentNameScopesList");
      __publicField(this, "_stackElementBrand");
      __publicField(this, "_enterPos");
      __publicField(this, "_anchorPos");
      __publicField(this, "depth");
      this.parent = parent, this.ruleId = ruleId, this.beginRuleCapturedEOL = beginRuleCapturedEOL, this.endRule = endRule, this.nameScopesList = nameScopesList, this.contentNameScopesList = contentNameScopesList, this.depth = this.parent ? this.parent.depth + 1 : 1, this._enterPos = enterPos, this._anchorPos = anchorPos;
    }
    equals(other) {
      return other === null ? !1 : _StateStackImpl._equals(this, other);
    }
    static _equals(a, b) {
      return a === b ? !0 : this._structuralEquals(a, b) ? AttributedScopeStack.equals(a.contentNameScopesList, b.contentNameScopesList) : !1;
    }
    static _structuralEquals(a, b) {
      do {
        if (a === b || !a && !b) return !0;
        if (!a || !b || a.depth !== b.depth || a.ruleId !== b.ruleId || a.endRule !== b.endRule) return !1;
        a = a.parent, b = b.parent;
      } while (!0);
    }
    clone() {
      return this;
    }
    static _reset(el) {
      for (; el;) el._enterPos = -1, el._anchorPos = -1, el = el.parent;
    }
    reset() {
      _StateStackImpl._reset(this);
    }
    pop() {
      return this.parent;
    }
    safePop() {
      return this.parent ? this.parent : this;
    }
    push(ruleId, enterPos, anchorPos, beginRuleCapturedEOL, endRule, nameScopesList, contentNameScopesList) {
      return new _StateStackImpl(this, ruleId, enterPos, anchorPos, beginRuleCapturedEOL, endRule, nameScopesList, contentNameScopesList);
    }
    getEnterPos() {
      return this._enterPos;
    }
    getAnchorPos() {
      return this._anchorPos;
    }
    getRule(grammar) {
      return grammar.getRule(this.ruleId);
    }
    toString() {
      let r = [];
      return this._writeString(r, 0), "[" + r.join(",") + "]";
    }
    _writeString(res, outIndex) {
      var _a, _b;
      return this.parent && (outIndex = this.parent._writeString(res, outIndex)), res[outIndex++] = `(${this.ruleId}, ${(_a = this.nameScopesList) == null ? void 0 : _a.toString()}, ${(_b = this.contentNameScopesList) == null ? void 0 : _b.toString()})`, outIndex;
    }
    withContentNameScopesList(contentNameScopeStack) {
      return this.contentNameScopesList === contentNameScopeStack ? this : this.parent.push(this.ruleId, this._enterPos, this._anchorPos, this.beginRuleCapturedEOL, this.endRule, this.nameScopesList, contentNameScopeStack);
    }
    withEndRule(endRule) {
      return this.endRule === endRule ? this : new _StateStackImpl(this.parent, this.ruleId, this._enterPos, this._anchorPos, this.beginRuleCapturedEOL, endRule, this.nameScopesList, this.contentNameScopesList);
    }
    hasSameRuleAs(other) {
      let el = this;
      for (; el && el._enterPos === other._enterPos;) {
        if (el.ruleId === other.ruleId) return !0;
        el = el.parent;
      }
      return !1;
    }
    toStateStackFrame() {
      var _a, _b, _c, _d, _e, _f;
      return {
        ruleId: this.ruleId,
        beginRuleCapturedEOL: this.beginRuleCapturedEOL,
        endRule: this.endRule,
        nameScopesList: (_d = (_c = this.nameScopesList) == null ? void 0 : _c.getExtensionIfDefined((_b = (_a = this.parent) == null ? void 0 : _a.nameScopesList) != null ? _b : null)) != null ? _d : [],
        contentNameScopesList: (_f = (_e = this.contentNameScopesList) == null ? void 0 : _e.getExtensionIfDefined(this.nameScopesList)) != null ? _f : []
      };
    }
    static pushFrame(self, frame) {
      var _a, _b, _c;
      let namesScopeList = AttributedScopeStack.fromExtension((_a = self == null ? void 0 : self.nameScopesList) != null ? _a : null, frame.nameScopesList);
      return new _StateStackImpl(self, frame.ruleId, (_b = frame.enterPos) != null ? _b : -1, (_c = frame.anchorPos) != null ? _c : -1, frame.beginRuleCapturedEOL, frame.endRule, namesScopeList, AttributedScopeStack.fromExtension(namesScopeList, frame.contentNameScopesList));
    }
  };,__name(_StateStackImpl, "StateStackImpl"), __publicField(_StateStackImpl, "NULL", new _StateStackImpl(null, 0, 0, 0, !1, null, null, null));,var StateStackImpl = _StateStackImpl,
  _BalancedBracketSelectors = class _BalancedBracketSelectors {
    constructor(balancedBracketScopes, unbalancedBracketScopes) {
      __publicField(this, "balancedBracketScopes");
      __publicField(this, "unbalancedBracketScopes");
      __publicField(this, "allowAny", !1);
      this.balancedBracketScopes = balancedBracketScopes.flatMap(selector => selector === "*" ? (this.allowAny = !0, []) : createMatchers(selector, nameMatcher).map(m => m.matcher)), this.unbalancedBracketScopes = unbalancedBracketScopes.flatMap(selector => createMatchers(selector, nameMatcher).map(m => m.matcher));
    }
    get matchesAlways() {
      return this.allowAny && this.unbalancedBracketScopes.length === 0;
    }
    get matchesNever() {
      return this.balancedBracketScopes.length === 0 && !this.allowAny;
    }
    match(scopes) {
      for (let excluder of this.unbalancedBracketScopes) if (excluder(scopes)) return !1;
      for (let includer of this.balancedBracketScopes) if (includer(scopes)) return !0;
      return this.allowAny;
    }
  };,__name(_BalancedBracketSelectors, "BalancedBracketSelectors");,var BalancedBracketSelectors = _BalancedBracketSelectors,
  _LineTokens = class _LineTokens {
    constructor(emitBinaryTokens, lineText, tokenTypeOverrides, balancedBracketSelectors) {
      __publicField(this, "balancedBracketSelectors");
      __publicField(this, "_emitBinaryTokens");
      __publicField(this, "_lineText");
      __publicField(this, "_tokens");
      __publicField(this, "_binaryTokens");
      __publicField(this, "_lastTokenEndIndex");
      __publicField(this, "_tokenTypeOverrides");
      this.balancedBracketSelectors = balancedBracketSelectors, this._emitBinaryTokens = emitBinaryTokens, this._tokenTypeOverrides = tokenTypeOverrides, this._lineText = null, this._tokens = [], this._binaryTokens = [], this._lastTokenEndIndex = 0;
    }
    produce(stack, endIndex) {
      this.produceFromScopes(stack.contentNameScopesList, endIndex);
    }
    produceFromScopes(scopesList, endIndex) {
      var _a, _b, _c, _d;
      if (this._lastTokenEndIndex >= endIndex) return;
      if (this._emitBinaryTokens) {
        let metadata = (_a = scopesList == null ? void 0 : scopesList.tokenAttributes) != null ? _a : 0,
          containsBalancedBrackets = !1;
        if ((_b = this.balancedBracketSelectors) != null && _b.matchesAlways && (containsBalancedBrackets = !0), this._tokenTypeOverrides.length > 0 || this.balancedBracketSelectors && !this.balancedBracketSelectors.matchesAlways && !this.balancedBracketSelectors.matchesNever) {
          let scopes = (_c = scopesList == null ? void 0 : scopesList.getScopeNames()) != null ? _c : [];
          for (let tokenType of this._tokenTypeOverrides) tokenType.matcher(scopes) && (metadata = EncodedTokenAttributes.set(metadata, 0, tokenType.type, null, -1, 0, 0));
          this.balancedBracketSelectors && (containsBalancedBrackets = this.balancedBracketSelectors.match(scopes));
        }
        if (containsBalancedBrackets && (metadata = EncodedTokenAttributes.set(metadata, 0, 8, containsBalancedBrackets, -1, 0, 0)), this._binaryTokens.length > 0 && this._binaryTokens[this._binaryTokens.length - 1] === metadata) {
          this._lastTokenEndIndex = endIndex;
          return;
        }
        this._binaryTokens.push(this._lastTokenEndIndex), this._binaryTokens.push(metadata), this._lastTokenEndIndex = endIndex;
        return;
      }
      let scopes = (_d = scopesList == null ? void 0 : scopesList.getScopeNames()) != null ? _d : [];
      this._tokens.push({
        startIndex: this._lastTokenEndIndex,
        endIndex: endIndex,
        scopes: scopes
      }), this._lastTokenEndIndex = endIndex;
    }
    getResult(stack, lineLength) {
      return this._tokens.length > 0 && this._tokens[this._tokens.length - 1].startIndex === lineLength - 1 && this._tokens.pop(), this._tokens.length === 0 && (this._lastTokenEndIndex = -1, this.produce(stack, lineLength), this._tokens[this._tokens.length - 1].startIndex = 0), this._tokens;
    }
    getBinaryResult(stack, lineLength) {
      this._binaryTokens.length > 0 && this._binaryTokens[this._binaryTokens.length - 2] === lineLength - 1 && (this._binaryTokens.pop(), this._binaryTokens.pop()), this._binaryTokens.length === 0 && (this._lastTokenEndIndex = -1, this.produce(stack, lineLength), this._binaryTokens[this._binaryTokens.length - 2] = 0);
      let result = new Uint32Array(this._binaryTokens.length);
      for (let i = 0, len = this._binaryTokens.length; i < len; i++) result[i] = this._binaryTokens[i];
      return result;
    }
  };,__name(_LineTokens, "LineTokens");,var LineTokens = _LineTokens,
  _SyncRegistry = class _SyncRegistry {
    constructor(theme, _onigLibPromise) {
      __publicField(this, "_onigLibPromise");
      __publicField(this, "_grammars", new Map());
      __publicField(this, "_rawGrammars", new Map());
      __publicField(this, "_injectionGrammars", new Map());
      __publicField(this, "_theme");
      this._onigLibPromise = _onigLibPromise, this._theme = theme;
    }
    dispose() {
      for (let grammar of this._grammars.values()) grammar.dispose();
    }
    setTheme(theme) {
      this._theme = theme;
    }
    getColorMap() {
      return this._theme.getColorMap();
    }
    addGrammar(grammar, injectionScopeNames) {
      this._rawGrammars.set(grammar.scopeName, grammar), injectionScopeNames && this._injectionGrammars.set(grammar.scopeName, injectionScopeNames);
    }
    lookup(scopeName) {
      return this._rawGrammars.get(scopeName);
    }
    injections(targetScope) {
      return this._injectionGrammars.get(targetScope);
    }
    getDefaults() {
      return this._theme.getDefaults();
    }
    themeMatch(scopePath) {
      return this._theme.match(scopePath);
    }
    async grammarForScopeName(scopeName, initialLanguage, embeddedLanguages, tokenTypes, balancedBracketSelectors) {
      if (!this._grammars.has(scopeName)) {
        let rawGrammar = this._rawGrammars.get(scopeName);
        if (!rawGrammar) return null;
        this._grammars.set(scopeName, createGrammar(scopeName, rawGrammar, initialLanguage, embeddedLanguages, tokenTypes, balancedBracketSelectors, this, await this._onigLibPromise));
      }
      return this._grammars.get(scopeName);
    }
  };,__name(_SyncRegistry, "SyncRegistry");,var SyncRegistry = _SyncRegistry,
  _a,
  Registry$1 = (_a = class {
    constructor(options) {
      __publicField(this, "_options");
      __publicField(this, "_syncRegistry");
      __publicField(this, "_ensureGrammarCache");
      this._options = options, this._syncRegistry = new SyncRegistry(Theme.createFromRawTheme(options.theme, options.colorMap), options.onigLib), this._ensureGrammarCache = new Map();
    }
    dispose() {
      this._syncRegistry.dispose();
    }
    setTheme(theme, colorMap) {
      this._syncRegistry.setTheme(Theme.createFromRawTheme(theme, colorMap));
    }
    getColorMap() {
      return this._syncRegistry.getColorMap();
    }
    loadGrammarWithEmbeddedLanguages(initialScopeName, initialLanguage, embeddedLanguages) {
      return this.loadGrammarWithConfiguration(initialScopeName, initialLanguage, {
        embeddedLanguages: embeddedLanguages
      });
    }
    loadGrammarWithConfiguration(initialScopeName, initialLanguage, configuration) {
      return this._loadGrammar(initialScopeName, initialLanguage, configuration.embeddedLanguages, configuration.tokenTypes, new BalancedBracketSelectors(configuration.balancedBracketSelectors || [], configuration.unbalancedBracketSelectors || []));
    }
    loadGrammar(initialScopeName) {
      return this._loadGrammar(initialScopeName, 0, null, null, null);
    }
    async _loadGrammar(initialScopeName, initialLanguage, embeddedLanguages, tokenTypes, balancedBracketSelectors) {
      let dependencyProcessor = new ScopeDependencyProcessor(this._syncRegistry, initialScopeName);
      for (; dependencyProcessor.Q.length > 0;) await Promise.all(dependencyProcessor.Q.map(request => this._loadSingleGrammar(request.scopeName))), dependencyProcessor.processQueue();
      return this._grammarForScopeName(initialScopeName, initialLanguage, embeddedLanguages, tokenTypes, balancedBracketSelectors);
    }
    async _loadSingleGrammar(scopeName) {
      return this._ensureGrammarCache.has(scopeName) || this._ensureGrammarCache.set(scopeName, this._doLoadSingleGrammar(scopeName)), this._ensureGrammarCache.get(scopeName);
    }
    async _doLoadSingleGrammar(scopeName) {
      let grammar = await this._options.loadGrammar(scopeName);
      if (grammar) {
        let injections = typeof this._options.getInjections == "function" ? this._options.getInjections(scopeName) : void 0;
        this._syncRegistry.addGrammar(grammar, injections);
      }
    }
    async addGrammar(rawGrammar, injections = [], initialLanguage = 0, embeddedLanguages = null) {
      return this._syncRegistry.addGrammar(rawGrammar, injections), await this._grammarForScopeName(rawGrammar.scopeName, initialLanguage, embeddedLanguages);
    }
    _grammarForScopeName(scopeName, initialLanguage = 0, embeddedLanguages = null, tokenTypes = null, balancedBracketSelectors = null) {
      return this._syncRegistry.grammarForScopeName(scopeName, initialLanguage, embeddedLanguages, tokenTypes, balancedBracketSelectors);
    }
  }, __name(_a, "Registry"), _a),
  INITIAL = StateStackImpl.NULL,
  MetadataConsts = {
    LANGUAGEID_MASK: 255,
    TOKEN_TYPE_MASK: 768,
    BALANCED_BRACKETS_MASK: 1024,
    FONT_STYLE_MASK: 14336,
    FOREGROUND_MASK: 8372224,
    BACKGROUND_MASK: 4286578688,
    LANGUAGEID_OFFSET: 0,
    TOKEN_TYPE_OFFSET: 8,
    BALANCED_BRACKETS_OFFSET: 10,
    FONT_STYLE_OFFSET: 11,
    FOREGROUND_OFFSET: 15,
    BACKGROUND_OFFSET: 24
  },
  _StackElementMetadata = class _StackElementMetadata {
    static toBinaryStr(metadata) {
      let r = metadata.toString(2);
      for (; r.length < 32;) r = `0${r}`;
      return r;
    }
    static getLanguageId(metadata) {
      return (metadata & MetadataConsts.LANGUAGEID_MASK) >>> MetadataConsts.LANGUAGEID_OFFSET;
    }
    static getTokenType(metadata) {
      return (metadata & MetadataConsts.TOKEN_TYPE_MASK) >>> MetadataConsts.TOKEN_TYPE_OFFSET;
    }
    static getFontStyle(metadata) {
      return (metadata & MetadataConsts.FONT_STYLE_MASK) >>> MetadataConsts.FONT_STYLE_OFFSET;
    }
    static getForeground(metadata) {
      return (metadata & MetadataConsts.FOREGROUND_MASK) >>> MetadataConsts.FOREGROUND_OFFSET;
    }
    static getBackground(metadata) {
      return (metadata & MetadataConsts.BACKGROUND_MASK) >>> MetadataConsts.BACKGROUND_OFFSET;
    }
    static containsBalancedBrackets(metadata) {
      return (metadata & MetadataConsts.BALANCED_BRACKETS_MASK) !== 0;
    }
    static set(metadata, languageId, tokenType, fontStyle, foreground, background) {
      let _languageId = _StackElementMetadata.getLanguageId(metadata),
        _tokenType = _StackElementMetadata.getTokenType(metadata),
        _fontStyle = _StackElementMetadata.getFontStyle(metadata),
        _foreground = _StackElementMetadata.getForeground(metadata),
        _background = _StackElementMetadata.getBackground(metadata),
        _containsBalancedBracketsBit = _StackElementMetadata.containsBalancedBrackets(metadata) ? 1 : 0;
      return languageId !== 0 && (_languageId = languageId), tokenType !== 0 && (_tokenType = tokenType === 8 ? 0 : tokenType), fontStyle !== FontStyle.NotSet && (_fontStyle = fontStyle), foreground !== 0 && (_foreground = foreground), background !== 0 && (_background = background), (_languageId << MetadataConsts.LANGUAGEID_OFFSET | _tokenType << MetadataConsts.TOKEN_TYPE_OFFSET | _fontStyle << MetadataConsts.FONT_STYLE_OFFSET | _containsBalancedBracketsBit << MetadataConsts.BALANCED_BRACKETS_OFFSET | _foreground << MetadataConsts.FOREGROUND_OFFSET | _background << MetadataConsts.BACKGROUND_OFFSET) >>> 0;
    }
  };,__name(_StackElementMetadata, "StackElementMetadata");,var StackElementMetadata = _StackElementMetadata;