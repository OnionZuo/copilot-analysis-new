var _FullTextDocument = class _FullTextDocument {
  constructor(uri, languageId, version, content) {
    this._uri = uri, this._languageId = languageId, this._version = version, this._content = content, this._lineOffsets = void 0;
  }
  get uri() {
    return this._uri;
  }
  get languageId() {
    return this._languageId;
  }
  get version() {
    return this._version;
  }
  getText(range) {
    if (range) {
      let start = this.offsetAt(range.start),
        end = this.offsetAt(range.end);
      return this._content.substring(start, end);
    }
    return this._content;
  }
  update(changes, version) {
    for (let change of changes) if (_FullTextDocument.isIncremental(change)) {
      let range = getWellformedRange(change.range),
        startOffset = this.offsetAt(range.start),
        endOffset = this.offsetAt(range.end);
      this._content = this._content.substring(0, startOffset) + change.text + this._content.substring(endOffset, this._content.length);
      let startLine = Math.max(range.start.line, 0),
        endLine = Math.max(range.end.line, 0),
        lineOffsets = this._lineOffsets,
        addedLineOffsets = computeLineOffsets(change.text, !1, startOffset);
      if (endLine - startLine === addedLineOffsets.length) for (let i = 0, len = addedLineOffsets.length; i < len; i++) lineOffsets[i + startLine + 1] = addedLineOffsets[i];else addedLineOffsets.length < 1e4 ? lineOffsets.splice(startLine + 1, endLine - startLine, ...addedLineOffsets) : this._lineOffsets = lineOffsets = lineOffsets.slice(0, startLine + 1).concat(addedLineOffsets, lineOffsets.slice(endLine + 1));
      let diff = change.text.length - (endOffset - startOffset);
      if (diff !== 0) for (let i = startLine + 1 + addedLineOffsets.length, len = lineOffsets.length; i < len; i++) lineOffsets[i] = lineOffsets[i] + diff;
    } else if (_FullTextDocument.isFull(change)) this._content = change.text, this._lineOffsets = void 0;else throw new Error("Unknown change event received");
    this._version = version;
  }
  getLineOffsets() {
    return this._lineOffsets === void 0 && (this._lineOffsets = computeLineOffsets(this._content, !0)), this._lineOffsets;
  }
  positionAt(offset) {
    offset = Math.max(Math.min(offset, this._content.length), 0);
    let lineOffsets = this.getLineOffsets(),
      low = 0,
      high = lineOffsets.length;
    if (high === 0) return {
      line: 0,
      character: offset
    };
    for (; low < high;) {
      let mid = Math.floor((low + high) / 2);
      lineOffsets[mid] > offset ? high = mid : low = mid + 1;
    }
    let line = low - 1;
    return offset = this.ensureBeforeEOL(offset, lineOffsets[line]), {
      line: line,
      character: offset - lineOffsets[line]
    };
  }
  offsetAt(position) {
    let lineOffsets = this.getLineOffsets();
    if (position.line >= lineOffsets.length) return this._content.length;
    if (position.line < 0) return 0;
    let lineOffset = lineOffsets[position.line];
    if (position.character <= 0) return lineOffset;
    let nextLineOffset = position.line + 1 < lineOffsets.length ? lineOffsets[position.line + 1] : this._content.length,
      offset = Math.min(lineOffset + position.character, nextLineOffset);
    return this.ensureBeforeEOL(offset, lineOffset);
  }
  ensureBeforeEOL(offset, lineOffset) {
    for (; offset > lineOffset && isEOL(this._content.charCodeAt(offset - 1));) offset--;
    return offset;
  }
  get lineCount() {
    return this.getLineOffsets().length;
  }
  static isIncremental(event) {
    let candidate = event;
    return candidate != null && typeof candidate.text == "string" && candidate.range !== void 0 && (candidate.rangeLength === void 0 || typeof candidate.rangeLength == "number");
  }
  static isFull(event) {
    let candidate = event;
    return candidate != null && typeof candidate.text == "string" && candidate.range === void 0 && candidate.rangeLength === void 0;
  }
};,__name(_FullTextDocument, "FullTextDocument");,var FullTextDocument = _FullTextDocument,
  TextDocument;,(function (TextDocument) {
  function create(uri, languageId, version, content) {
    return new FullTextDocument(uri, languageId, version, content);
  }
  __name(create, "create"), TextDocument.create = create;
  function update(document, changes, version) {
    if (document instanceof FullTextDocument) return document.update(changes, version), document;
    throw new Error("TextDocument.update: document must be created by TextDocument.create");
  }
  __name(update, "update"), TextDocument.update = update;
  function applyEdits(document, edits) {
    let text = document.getText(),
      sortedEdits = mergeSort(edits.map(getWellformedEdit), (a, b) => {
        let diff = a.range.start.line - b.range.start.line;
        return diff === 0 ? a.range.start.character - b.range.start.character : diff;
      }),
      lastModifiedOffset = 0,
      spans = [];
    for (let e of sortedEdits) {
      let startOffset = document.offsetAt(e.range.start);
      if (startOffset < lastModifiedOffset) throw new Error("Overlapping edit");
      startOffset > lastModifiedOffset && spans.push(text.substring(lastModifiedOffset, startOffset)), e.newText.length && spans.push(e.newText), lastModifiedOffset = document.offsetAt(e.range.end);
    }
    return spans.push(text.substr(lastModifiedOffset)), spans.join("");
  }
  __name(applyEdits, "applyEdits"), TextDocument.applyEdits = applyEdits;
})(TextDocument || (TextDocument = {}));,function mergeSort(data, compare) {
  if (data.length <= 1) return data;
  let p = data.length / 2 | 0,
    left = data.slice(0, p),
    right = data.slice(p);
  mergeSort(left, compare), mergeSort(right, compare);
  let leftIdx = 0,
    rightIdx = 0,
    i = 0;
  for (; leftIdx < left.length && rightIdx < right.length;) compare(left[leftIdx], right[rightIdx]) <= 0 ? data[i++] = left[leftIdx++] : data[i++] = right[rightIdx++];
  for (; leftIdx < left.length;) data[i++] = left[leftIdx++];
  for (; rightIdx < right.length;) data[i++] = right[rightIdx++];
  return data;
},__name(mergeSort, "mergeSort");,function computeLineOffsets(text, isAtLineStart, textOffset = 0) {
  let result = isAtLineStart ? [textOffset] : [];
  for (let i = 0; i < text.length; i++) {
    let ch = text.charCodeAt(i);
    isEOL(ch) && (ch === 13 && i + 1 < text.length && text.charCodeAt(i + 1) === 10 && i++, result.push(textOffset + i + 1));
  }
  return result;
},__name(computeLineOffsets, "computeLineOffsets");,function isEOL(char) {
  return char === 13 || char === 10;
},__name(isEOL, "isEOL");,function getWellformedRange(range) {
  let start = range.start,
    end = range.end;
  return start.line > end.line || start.line === end.line && start.character > end.character ? {
    start: end,
    end: start
  } : range;
},__name(getWellformedRange, "getWellformedRange");,function getWellformedEdit(textEdit) {
  let range = getWellformedRange(textEdit.range);
  return range !== textEdit.range ? {
    newText: textEdit.newText,
    range: range
  } : textEdit;
},__name(getWellformedEdit, "getWellformedEdit");