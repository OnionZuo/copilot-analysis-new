var require_main = __commonJSMin(exports => {
  "use strict";

  var __createBinding = exports && exports.__createBinding || (Object.create ? function (o, m, k, k2) {
      k2 === void 0 && (k2 = k);
      var desc = Object.getOwnPropertyDescriptor(m, k);
      (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) && (desc = {
        enumerable: !0,
        get: __name(function () {
          return m[k];
        }, "get")
      }), Object.defineProperty(o, k2, desc);
    } : function (o, m, k, k2) {
      k2 === void 0 && (k2 = k), o[k2] = m[k];
    }),
    __exportStar = exports && exports.__exportStar || function (m, exports) {
      for (var p in m) p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p) && __createBinding(exports, m, p);
    };
  Object.defineProperty(exports, "__esModule", {
    value: !0
  });
  exports.createMessageConnection = exports.createServerSocketTransport = exports.createClientSocketTransport = exports.createServerPipeTransport = exports.createClientPipeTransport = exports.generateRandomPipeName = exports.StreamMessageWriter = exports.StreamMessageReader = exports.SocketMessageWriter = exports.SocketMessageReader = exports.PortMessageWriter = exports.PortMessageReader = exports.IPCMessageWriter = exports.IPCMessageReader = void 0;
  var ril_1 = PQe();
  ril_1.default.install();
  var path = require("path"),
    os = require("os"),
    crypto_1 = require("crypto"),
    net_1 = require("net"),
    api_1 = DL();
  __exportStar(DL(), exports);
  var _IPCMessageReader = class _IPCMessageReader extends api_1.AbstractMessageReader {
    constructor(process) {
      super(), this.process = process;
      let eventEmitter = this.process;
      eventEmitter.on("error", error => this.fireError(error)), eventEmitter.on("close", () => this.fireClose());
    }
    listen(callback) {
      return this.process.on("message", callback), api_1.Disposable.create(() => this.process.off("message", callback));
    }
  };
  __name(_IPCMessageReader, "IPCMessageReader");
  var IPCMessageReader = _IPCMessageReader;
  exports.IPCMessageReader = IPCMessageReader;
  var _IPCMessageWriter = class _IPCMessageWriter extends api_1.AbstractMessageWriter {
    constructor(process) {
      super(), this.process = process, this.errorCount = 0;
      let eventEmitter = this.process;
      eventEmitter.on("error", error => this.fireError(error)), eventEmitter.on("close", () => this.fireClose);
    }
    write(msg) {
      try {
        return typeof this.process.send == "function" && this.process.send(msg, void 0, void 0, error => {
          error ? (this.errorCount++, this.handleError(error, msg)) : this.errorCount = 0;
        }), Promise.resolve();
      } catch (error) {
        return this.handleError(error, msg), Promise.reject(error);
      }
    }
    handleError(error, msg) {
      this.errorCount++, this.fireError(error, msg, this.errorCount);
    }
    end() {}
  };
  __name(_IPCMessageWriter, "IPCMessageWriter");
  var IPCMessageWriter = _IPCMessageWriter;
  exports.IPCMessageWriter = IPCMessageWriter;
  var _PortMessageReader = class _PortMessageReader extends api_1.AbstractMessageReader {
    constructor(port) {
      super(), this.onData = new api_1.Emitter(), port.on("close", () => this.fireClose), port.on("error", error => this.fireError(error)), port.on("message", message => {
        this.onData.fire(message);
      });
    }
    listen(callback) {
      return this.onData.event(callback);
    }
  };
  __name(_PortMessageReader, "PortMessageReader");
  var PortMessageReader = _PortMessageReader;
  exports.PortMessageReader = PortMessageReader;
  var _PortMessageWriter = class _PortMessageWriter extends api_1.AbstractMessageWriter {
    constructor(port) {
      super(), this.port = port, this.errorCount = 0, port.on("close", () => this.fireClose()), port.on("error", error => this.fireError(error));
    }
    write(msg) {
      try {
        return this.port.postMessage(msg), Promise.resolve();
      } catch (error) {
        return this.handleError(error, msg), Promise.reject(error);
      }
    }
    handleError(error, msg) {
      this.errorCount++, this.fireError(error, msg, this.errorCount);
    }
    end() {}
  };
  __name(_PortMessageWriter, "PortMessageWriter");
  var PortMessageWriter = _PortMessageWriter;
  exports.PortMessageWriter = PortMessageWriter;
  var _SocketMessageReader = class _SocketMessageReader extends api_1.ReadableStreamMessageReader {
    constructor(socket, encoding = "utf-8") {
      super((0, ril_1.default)().stream.asReadableStream(socket), encoding);
    }
  };
  __name(_SocketMessageReader, "SocketMessageReader");
  var SocketMessageReader = _SocketMessageReader;
  exports.SocketMessageReader = SocketMessageReader;
  var _SocketMessageWriter = class _SocketMessageWriter extends api_1.WriteableStreamMessageWriter {
    constructor(socket, options) {
      super((0, ril_1.default)().stream.asWritableStream(socket), options), this.socket = socket;
    }
    dispose() {
      super.dispose(), this.socket.destroy();
    }
  };
  __name(_SocketMessageWriter, "SocketMessageWriter");
  var SocketMessageWriter = _SocketMessageWriter;
  exports.SocketMessageWriter = SocketMessageWriter;
  var _StreamMessageReader = class _StreamMessageReader extends api_1.ReadableStreamMessageReader {
    constructor(readable, encoding) {
      super((0, ril_1.default)().stream.asReadableStream(readable), encoding);
    }
  };
  __name(_StreamMessageReader, "StreamMessageReader");
  var StreamMessageReader = _StreamMessageReader;
  exports.StreamMessageReader = StreamMessageReader;
  var _StreamMessageWriter = class _StreamMessageWriter extends api_1.WriteableStreamMessageWriter {
    constructor(writable, options) {
      super((0, ril_1.default)().stream.asWritableStream(writable), options);
    }
  };
  __name(_StreamMessageWriter, "StreamMessageWriter");
  var StreamMessageWriter = _StreamMessageWriter;
  exports.StreamMessageWriter = StreamMessageWriter;
  var XDG_RUNTIME_DIR = process.env.XDG_RUNTIME_DIR,
    safeIpcPathLengths = new Map([["linux", 107], ["darwin", 103]]);
  function generateRandomPipeName() {
    let randomSuffix = (0, crypto_1.randomBytes)(21).toString("hex");
    if (process.platform === "win32") return `\\\\.\\pipe\\vscode-jsonrpc-${randomSuffix}-sock`;
    let result;
    XDG_RUNTIME_DIR ? result = path.join(XDG_RUNTIME_DIR, `vscode-ipc-${randomSuffix}.sock`) : result = path.join(os.tmpdir(), `vscode-${randomSuffix}.sock`);
    let limit = safeIpcPathLengths.get(process.platform);
    return limit !== void 0 && result.length > limit && (0, ril_1.default)().console.warn(`WARNING: IPC handle "${result}" is longer than ${limit} characters.`), result;
  }
  __name(generateRandomPipeName, "generateRandomPipeName");
  exports.generateRandomPipeName = generateRandomPipeName;
  function createClientPipeTransport(pipeName, encoding = "utf-8") {
    let connectResolve,
      connected = new Promise((resolve, _reject) => {
        connectResolve = resolve;
      });
    return new Promise((resolve, reject) => {
      let server = (0, net_1.createServer)(socket => {
        server.close(), connectResolve([new SocketMessageReader(socket, encoding), new SocketMessageWriter(socket, encoding)]);
      });
      server.on("error", reject), server.listen(pipeName, () => {
        server.removeListener("error", reject), resolve({
          onConnected: __name(() => connected, "onConnected")
        });
      });
    });
  }
  __name(createClientPipeTransport, "createClientPipeTransport");
  exports.createClientPipeTransport = createClientPipeTransport;
  function createServerPipeTransport(pipeName, encoding = "utf-8") {
    let socket = (0, net_1.createConnection)(pipeName);
    return [new SocketMessageReader(socket, encoding), new SocketMessageWriter(socket, encoding)];
  }
  __name(createServerPipeTransport, "createServerPipeTransport");
  exports.createServerPipeTransport = createServerPipeTransport;
  function createClientSocketTransport(port, encoding = "utf-8") {
    let connectResolve,
      connected = new Promise((resolve, _reject) => {
        connectResolve = resolve;
      });
    return new Promise((resolve, reject) => {
      let server = (0, net_1.createServer)(socket => {
        server.close(), connectResolve([new SocketMessageReader(socket, encoding), new SocketMessageWriter(socket, encoding)]);
      });
      server.on("error", reject), server.listen(port, "127.0.0.1", () => {
        server.removeListener("error", reject), resolve({
          onConnected: __name(() => connected, "onConnected")
        });
      });
    });
  }
  __name(createClientSocketTransport, "createClientSocketTransport");
  exports.createClientSocketTransport = createClientSocketTransport;
  function createServerSocketTransport(port, encoding = "utf-8") {
    let socket = (0, net_1.createConnection)(port, "127.0.0.1");
    return [new SocketMessageReader(socket, encoding), new SocketMessageWriter(socket, encoding)];
  }
  __name(createServerSocketTransport, "createServerSocketTransport");
  exports.createServerSocketTransport = createServerSocketTransport;
  function isReadableStream(value) {
    let candidate = value;
    return candidate.read !== void 0 && candidate.addListener !== void 0;
  }
  __name(isReadableStream, "isReadableStream");
  function isWritableStream(value) {
    let candidate = value;
    return candidate.write !== void 0 && candidate.addListener !== void 0;
  }
  __name(isWritableStream, "isWritableStream");
  function createMessageConnection(input, output, logger, options) {
    logger || (logger = api_1.NullLogger);
    let reader = isReadableStream(input) ? new StreamMessageReader(input) : input,
      writer = isWritableStream(output) ? new StreamMessageWriter(output) : output;
    return api_1.ConnectionStrategy.is(options) && (options = {
      connectionStrategy: options
    }), (0, api_1.createMessageConnection)(reader, writer, logger, options);
  }
  __name(createMessageConnection, "createMessageConnection");
  exports.createMessageConnection = createMessageConnection;
});