var require_ril = __commonJSMin(exports => {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: !0
  });
  var util_1 = require("util"),
    api_1 = DL(),
    _MessageBuffer = class _MessageBuffer extends api_1.AbstractMessageBuffer {
      constructor(encoding = "utf-8") {
        super(encoding);
      }
      emptyBuffer() {
        return _MessageBuffer.emptyBuffer;
      }
      fromString(value, encoding) {
        return Buffer.from(value, encoding);
      }
      toString(value, encoding) {
        return value instanceof Buffer ? value.toString(encoding) : new util_1.TextDecoder(encoding).decode(value);
      }
      asNative(buffer, length) {
        return length === void 0 ? buffer instanceof Buffer ? buffer : Buffer.from(buffer) : buffer instanceof Buffer ? buffer.slice(0, length) : Buffer.from(buffer, 0, length);
      }
      allocNative(length) {
        return Buffer.allocUnsafe(length);
      }
    };
  __name(_MessageBuffer, "MessageBuffer");
  var MessageBuffer = _MessageBuffer;
  MessageBuffer.emptyBuffer = Buffer.allocUnsafe(0);
  var _ReadableStreamWrapper = class _ReadableStreamWrapper {
    constructor(stream) {
      this.stream = stream;
    }
    onClose(listener) {
      return this.stream.on("close", listener), api_1.Disposable.create(() => this.stream.off("close", listener));
    }
    onError(listener) {
      return this.stream.on("error", listener), api_1.Disposable.create(() => this.stream.off("error", listener));
    }
    onEnd(listener) {
      return this.stream.on("end", listener), api_1.Disposable.create(() => this.stream.off("end", listener));
    }
    onData(listener) {
      return this.stream.on("data", listener), api_1.Disposable.create(() => this.stream.off("data", listener));
    }
  };
  __name(_ReadableStreamWrapper, "ReadableStreamWrapper");
  var ReadableStreamWrapper = _ReadableStreamWrapper,
    _WritableStreamWrapper = class _WritableStreamWrapper {
      constructor(stream) {
        this.stream = stream;
      }
      onClose(listener) {
        return this.stream.on("close", listener), api_1.Disposable.create(() => this.stream.off("close", listener));
      }
      onError(listener) {
        return this.stream.on("error", listener), api_1.Disposable.create(() => this.stream.off("error", listener));
      }
      onEnd(listener) {
        return this.stream.on("end", listener), api_1.Disposable.create(() => this.stream.off("end", listener));
      }
      write(data, encoding) {
        return new Promise((resolve, reject) => {
          let callback = __name(error => {
            error == null ? resolve() : reject(error);
          }, "callback");
          typeof data == "string" ? this.stream.write(data, encoding, callback) : this.stream.write(data, callback);
        });
      }
      end() {
        this.stream.end();
      }
    };
  __name(_WritableStreamWrapper, "WritableStreamWrapper");
  var WritableStreamWrapper = _WritableStreamWrapper,
    _ril = Object.freeze({
      messageBuffer: Object.freeze({
        create: __name(encoding => new MessageBuffer(encoding), "create")
      }),
      applicationJson: Object.freeze({
        encoder: Object.freeze({
          name: "application/json",
          encode: __name((msg, options) => {
            try {
              return Promise.resolve(Buffer.from(JSON.stringify(msg, void 0, 0), options.charset));
            } catch (err) {
              return Promise.reject(err);
            }
          }, "encode")
        }),
        decoder: Object.freeze({
          name: "application/json",
          decode: __name((buffer, options) => {
            try {
              return buffer instanceof Buffer ? Promise.resolve(JSON.parse(buffer.toString(options.charset))) : Promise.resolve(JSON.parse(new util_1.TextDecoder(options.charset).decode(buffer)));
            } catch (err) {
              return Promise.reject(err);
            }
          }, "decode")
        })
      }),
      stream: Object.freeze({
        asReadableStream: __name(stream => new ReadableStreamWrapper(stream), "asReadableStream"),
        asWritableStream: __name(stream => new WritableStreamWrapper(stream), "asWritableStream")
      }),
      console,
      timer: Object.freeze({
        setTimeout(callback, ms, ...args) {
          let handle = setTimeout(callback, ms, ...args);
          return {
            dispose: __name(() => clearTimeout(handle), "dispose")
          };
        },
        setImmediate(callback, ...args) {
          let handle = setImmediate(callback, ...args);
          return {
            dispose: __name(() => clearImmediate(handle), "dispose")
          };
        },
        setInterval(callback, ms, ...args) {
          let handle = setInterval(callback, ms, ...args);
          return {
            dispose: __name(() => clearInterval(handle), "dispose")
          };
        }
      })
    });
  function RIL() {
    return _ril;
  }
  __name(RIL, "RIL");
  (function (RIL) {
    function install() {
      api_1.RAL.install(_ril);
    }
    __name(install, "install"), RIL.install = install;
  })(RIL || (RIL = {}));
  exports.default = RIL;
});