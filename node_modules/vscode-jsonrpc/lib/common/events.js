var require_events = __commonJSMin(exports => {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: !0
  });
  exports.Emitter = exports.Event = void 0;
  var ral_1 = zy(),
    Event;
  (function (Event) {
    let _disposable = {
      dispose() {}
    };
    Event.None = function () {
      return _disposable;
    };
  })(Event || (exports.Event = Event = {}));
  var _CallbackList = class _CallbackList {
    add(callback, context = null, bucket) {
      this._callbacks || (this._callbacks = [], this._contexts = []), this._callbacks.push(callback), this._contexts.push(context), Array.isArray(bucket) && bucket.push({
        dispose: __name(() => this.remove(callback, context), "dispose")
      });
    }
    remove(callback, context = null) {
      if (!this._callbacks) return;
      let foundCallbackWithDifferentContext = !1;
      for (let i = 0, len = this._callbacks.length; i < len; i++) if (this._callbacks[i] === callback) if (this._contexts[i] === context) {
        this._callbacks.splice(i, 1), this._contexts.splice(i, 1);
        return;
      } else foundCallbackWithDifferentContext = !0;
      if (foundCallbackWithDifferentContext) throw new Error("When adding a listener with a context, you should remove it with the same context");
    }
    invoke(...args) {
      if (!this._callbacks) return [];
      let ret = [],
        callbacks = this._callbacks.slice(0),
        contexts = this._contexts.slice(0);
      for (let i = 0, len = callbacks.length; i < len; i++) try {
        ret.push(callbacks[i].apply(contexts[i], args));
      } catch (e) {
        (0, ral_1.default)().console.error(e);
      }
      return ret;
    }
    isEmpty() {
      return !this._callbacks || this._callbacks.length === 0;
    }
    dispose() {
      this._callbacks = void 0, this._contexts = void 0;
    }
  };
  __name(_CallbackList, "CallbackList");
  var CallbackList = _CallbackList,
    _Emitter = class _Emitter {
      constructor(_options) {
        this._options = _options;
      }
      get event() {
        return this._event || (this._event = (listener, thisArgs, disposables) => {
          this._callbacks || (this._callbacks = new CallbackList()), this._options && this._options.onFirstListenerAdd && this._callbacks.isEmpty() && this._options.onFirstListenerAdd(this), this._callbacks.add(listener, thisArgs);
          let result = {
            dispose: __name(() => {
              this._callbacks && (this._callbacks.remove(listener, thisArgs), result.dispose = _Emitter._noop, this._options && this._options.onLastListenerRemove && this._callbacks.isEmpty() && this._options.onLastListenerRemove(this));
            }, "dispose")
          };
          return Array.isArray(disposables) && disposables.push(result), result;
        }), this._event;
      }
      fire(event) {
        this._callbacks && this._callbacks.invoke.call(this._callbacks, event);
      }
      dispose() {
        this._callbacks && (this._callbacks.dispose(), this._callbacks = void 0);
      }
    };
  __name(_Emitter, "Emitter");
  var Emitter = _Emitter;
  exports.Emitter = Emitter;
  Emitter._noop = function () {};
});