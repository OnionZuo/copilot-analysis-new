var require_connection = __commonJSMin(exports => {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: !0
  });
  exports.createMessageConnection = exports.ConnectionOptions = exports.MessageStrategy = exports.CancellationStrategy = exports.CancellationSenderStrategy = exports.CancellationReceiverStrategy = exports.RequestCancellationReceiverStrategy = exports.IdCancellationReceiverStrategy = exports.ConnectionStrategy = exports.ConnectionError = exports.ConnectionErrors = exports.LogTraceNotification = exports.SetTraceNotification = exports.TraceFormat = exports.TraceValues = exports.Trace = exports.NullLogger = exports.ProgressType = exports.ProgressToken = void 0;
  var ral_1 = zy(),
    Is = S1(),
    messages_1 = XJ(),
    linkedMap_1 = aV(),
    events_1 = N1(),
    cancellation_1 = bL(),
    CancelNotification;
  (function (CancelNotification) {
    CancelNotification.type = new messages_1.NotificationType("$/cancelRequest");
  })(CancelNotification || (CancelNotification = {}));
  var ProgressToken;
  (function (ProgressToken) {
    function is(value) {
      return typeof value == "string" || typeof value == "number";
    }
    __name(is, "is"), ProgressToken.is = is;
  })(ProgressToken || (exports.ProgressToken = ProgressToken = {}));
  var ProgressNotification;
  (function (ProgressNotification) {
    ProgressNotification.type = new messages_1.NotificationType("$/progress");
  })(ProgressNotification || (ProgressNotification = {}));
  var _ProgressType = class _ProgressType {
    constructor() {}
  };
  __name(_ProgressType, "ProgressType");
  var ProgressType = _ProgressType;
  exports.ProgressType = ProgressType;
  var StarRequestHandler;
  (function (StarRequestHandler) {
    function is(value) {
      return Is.func(value);
    }
    __name(is, "is"), StarRequestHandler.is = is;
  })(StarRequestHandler || (StarRequestHandler = {}));
  exports.NullLogger = Object.freeze({
    error: __name(() => {}, "error"),
    warn: __name(() => {}, "warn"),
    info: __name(() => {}, "info"),
    log: __name(() => {}, "log")
  });
  var Trace;
  (function (Trace) {
    Trace[Trace.Off = 0] = "Off", Trace[Trace.Messages = 1] = "Messages", Trace[Trace.Compact = 2] = "Compact", Trace[Trace.Verbose = 3] = "Verbose";
  })(Trace || (exports.Trace = Trace = {}));
  var TraceValues;
  (function (TraceValues) {
    TraceValues.Off = "off", TraceValues.Messages = "messages", TraceValues.Compact = "compact", TraceValues.Verbose = "verbose";
  })(TraceValues || (exports.TraceValues = TraceValues = {}));
  (function (Trace) {
    function fromString(value) {
      if (!Is.string(value)) return Trace.Off;
      switch (value = value.toLowerCase(), value) {
        case "off":
          return Trace.Off;
        case "messages":
          return Trace.Messages;
        case "compact":
          return Trace.Compact;
        case "verbose":
          return Trace.Verbose;
        default:
          return Trace.Off;
      }
    }
    __name(fromString, "fromString"), Trace.fromString = fromString;
    function toString(value) {
      switch (value) {
        case Trace.Off:
          return "off";
        case Trace.Messages:
          return "messages";
        case Trace.Compact:
          return "compact";
        case Trace.Verbose:
          return "verbose";
        default:
          return "off";
      }
    }
    __name(toString, "toString"), Trace.toString = toString;
  })(Trace || (exports.Trace = Trace = {}));
  var TraceFormat;
  (function (TraceFormat) {
    TraceFormat.Text = "text", TraceFormat.JSON = "json";
  })(TraceFormat || (exports.TraceFormat = TraceFormat = {}));
  (function (TraceFormat) {
    function fromString(value) {
      return Is.string(value) ? (value = value.toLowerCase(), value === "json" ? TraceFormat.JSON : TraceFormat.Text) : TraceFormat.Text;
    }
    __name(fromString, "fromString"), TraceFormat.fromString = fromString;
  })(TraceFormat || (exports.TraceFormat = TraceFormat = {}));
  var SetTraceNotification;
  (function (SetTraceNotification) {
    SetTraceNotification.type = new messages_1.NotificationType("$/setTrace");
  })(SetTraceNotification || (exports.SetTraceNotification = SetTraceNotification = {}));
  var LogTraceNotification;
  (function (LogTraceNotification) {
    LogTraceNotification.type = new messages_1.NotificationType("$/logTrace");
  })(LogTraceNotification || (exports.LogTraceNotification = LogTraceNotification = {}));
  var ConnectionErrors;
  (function (ConnectionErrors) {
    ConnectionErrors[ConnectionErrors.Closed = 1] = "Closed", ConnectionErrors[ConnectionErrors.Disposed = 2] = "Disposed", ConnectionErrors[ConnectionErrors.AlreadyListening = 3] = "AlreadyListening";
  })(ConnectionErrors || (exports.ConnectionErrors = ConnectionErrors = {}));
  var _ConnectionError = class _ConnectionError extends Error {
    constructor(code, message) {
      super(message), this.code = code, Object.setPrototypeOf(this, _ConnectionError.prototype);
    }
  };
  __name(_ConnectionError, "ConnectionError");
  var ConnectionError = _ConnectionError;
  exports.ConnectionError = ConnectionError;
  var ConnectionStrategy;
  (function (ConnectionStrategy) {
    function is(value) {
      let candidate = value;
      return candidate && Is.func(candidate.cancelUndispatched);
    }
    __name(is, "is"), ConnectionStrategy.is = is;
  })(ConnectionStrategy || (exports.ConnectionStrategy = ConnectionStrategy = {}));
  var IdCancellationReceiverStrategy;
  (function (IdCancellationReceiverStrategy) {
    function is(value) {
      let candidate = value;
      return candidate && (candidate.kind === void 0 || candidate.kind === "id") && Is.func(candidate.createCancellationTokenSource) && (candidate.dispose === void 0 || Is.func(candidate.dispose));
    }
    __name(is, "is"), IdCancellationReceiverStrategy.is = is;
  })(IdCancellationReceiverStrategy || (exports.IdCancellationReceiverStrategy = IdCancellationReceiverStrategy = {}));
  var RequestCancellationReceiverStrategy;
  (function (RequestCancellationReceiverStrategy) {
    function is(value) {
      let candidate = value;
      return candidate && candidate.kind === "request" && Is.func(candidate.createCancellationTokenSource) && (candidate.dispose === void 0 || Is.func(candidate.dispose));
    }
    __name(is, "is"), RequestCancellationReceiverStrategy.is = is;
  })(RequestCancellationReceiverStrategy || (exports.RequestCancellationReceiverStrategy = RequestCancellationReceiverStrategy = {}));
  var CancellationReceiverStrategy;
  (function (CancellationReceiverStrategy) {
    CancellationReceiverStrategy.Message = Object.freeze({
      createCancellationTokenSource(_) {
        return new cancellation_1.CancellationTokenSource();
      }
    });
    function is(value) {
      return IdCancellationReceiverStrategy.is(value) || RequestCancellationReceiverStrategy.is(value);
    }
    __name(is, "is"), CancellationReceiverStrategy.is = is;
  })(CancellationReceiverStrategy || (exports.CancellationReceiverStrategy = CancellationReceiverStrategy = {}));
  var CancellationSenderStrategy;
  (function (CancellationSenderStrategy) {
    CancellationSenderStrategy.Message = Object.freeze({
      sendCancellation(conn, id) {
        return conn.sendNotification(CancelNotification.type, {
          id: id
        });
      },
      cleanup(_) {}
    });
    function is(value) {
      let candidate = value;
      return candidate && Is.func(candidate.sendCancellation) && Is.func(candidate.cleanup);
    }
    __name(is, "is"), CancellationSenderStrategy.is = is;
  })(CancellationSenderStrategy || (exports.CancellationSenderStrategy = CancellationSenderStrategy = {}));
  var CancellationStrategy;
  (function (CancellationStrategy) {
    CancellationStrategy.Message = Object.freeze({
      receiver: CancellationReceiverStrategy.Message,
      sender: CancellationSenderStrategy.Message
    });
    function is(value) {
      let candidate = value;
      return candidate && CancellationReceiverStrategy.is(candidate.receiver) && CancellationSenderStrategy.is(candidate.sender);
    }
    __name(is, "is"), CancellationStrategy.is = is;
  })(CancellationStrategy || (exports.CancellationStrategy = CancellationStrategy = {}));
  var MessageStrategy;
  (function (MessageStrategy) {
    function is(value) {
      let candidate = value;
      return candidate && Is.func(candidate.handleMessage);
    }
    __name(is, "is"), MessageStrategy.is = is;
  })(MessageStrategy || (exports.MessageStrategy = MessageStrategy = {}));
  var ConnectionOptions;
  (function (ConnectionOptions) {
    function is(value) {
      let candidate = value;
      return candidate && (CancellationStrategy.is(candidate.cancellationStrategy) || ConnectionStrategy.is(candidate.connectionStrategy) || MessageStrategy.is(candidate.messageStrategy));
    }
    __name(is, "is"), ConnectionOptions.is = is;
  })(ConnectionOptions || (exports.ConnectionOptions = ConnectionOptions = {}));
  var ConnectionState;
  (function (ConnectionState) {
    ConnectionState[ConnectionState.New = 1] = "New", ConnectionState[ConnectionState.Listening = 2] = "Listening", ConnectionState[ConnectionState.Closed = 3] = "Closed", ConnectionState[ConnectionState.Disposed = 4] = "Disposed";
  })(ConnectionState || (ConnectionState = {}));
  function createMessageConnection(messageReader, messageWriter, _logger, options) {
    let logger = _logger !== void 0 ? _logger : exports.NullLogger,
      sequenceNumber = 0,
      notificationSequenceNumber = 0,
      unknownResponseSequenceNumber = 0,
      version = "2.0",
      starRequestHandler,
      requestHandlers = new Map(),
      starNotificationHandler,
      notificationHandlers = new Map(),
      progressHandlers = new Map(),
      timer,
      messageQueue = new linkedMap_1.LinkedMap(),
      responsePromises = new Map(),
      knownCanceledRequests = new Set(),
      requestTokens = new Map(),
      trace = Trace.Off,
      traceFormat = TraceFormat.Text,
      tracer,
      state = ConnectionState.New,
      errorEmitter = new events_1.Emitter(),
      closeEmitter = new events_1.Emitter(),
      unhandledNotificationEmitter = new events_1.Emitter(),
      unhandledProgressEmitter = new events_1.Emitter(),
      disposeEmitter = new events_1.Emitter(),
      cancellationStrategy = options && options.cancellationStrategy ? options.cancellationStrategy : CancellationStrategy.Message;
    function createRequestQueueKey(id) {
      if (id === null) throw new Error("Can't send requests with id null since the response can't be correlated.");
      return "req-" + id.toString();
    }
    __name(createRequestQueueKey, "createRequestQueueKey");
    function createResponseQueueKey(id) {
      return id === null ? "res-unknown-" + (++unknownResponseSequenceNumber).toString() : "res-" + id.toString();
    }
    __name(createResponseQueueKey, "createResponseQueueKey");
    function createNotificationQueueKey() {
      return "not-" + (++notificationSequenceNumber).toString();
    }
    __name(createNotificationQueueKey, "createNotificationQueueKey");
    function addMessageToQueue(queue, message) {
      messages_1.Message.isRequest(message) ? queue.set(createRequestQueueKey(message.id), message) : messages_1.Message.isResponse(message) ? queue.set(createResponseQueueKey(message.id), message) : queue.set(createNotificationQueueKey(), message);
    }
    __name(addMessageToQueue, "addMessageToQueue");
    function cancelUndispatched(_message) {}
    __name(cancelUndispatched, "cancelUndispatched");
    function isListening() {
      return state === ConnectionState.Listening;
    }
    __name(isListening, "isListening");
    function isClosed() {
      return state === ConnectionState.Closed;
    }
    __name(isClosed, "isClosed");
    function isDisposed() {
      return state === ConnectionState.Disposed;
    }
    __name(isDisposed, "isDisposed");
    function closeHandler() {
      (state === ConnectionState.New || state === ConnectionState.Listening) && (state = ConnectionState.Closed, closeEmitter.fire(void 0));
    }
    __name(closeHandler, "closeHandler");
    function readErrorHandler(error) {
      errorEmitter.fire([error, void 0, void 0]);
    }
    __name(readErrorHandler, "readErrorHandler");
    function writeErrorHandler(data) {
      errorEmitter.fire(data);
    }
    __name(writeErrorHandler, "writeErrorHandler"), messageReader.onClose(closeHandler), messageReader.onError(readErrorHandler), messageWriter.onClose(closeHandler), messageWriter.onError(writeErrorHandler);
    function triggerMessageQueue() {
      timer || messageQueue.size === 0 || (timer = (0, ral_1.default)().timer.setImmediate(() => {
        timer = void 0, processMessageQueue();
      }));
    }
    __name(triggerMessageQueue, "triggerMessageQueue");
    function handleMessage(message) {
      messages_1.Message.isRequest(message) ? handleRequest(message) : messages_1.Message.isNotification(message) ? handleNotification(message) : messages_1.Message.isResponse(message) ? handleResponse(message) : handleInvalidMessage(message);
    }
    __name(handleMessage, "handleMessage");
    function processMessageQueue() {
      if (messageQueue.size === 0) return;
      let message = messageQueue.shift();
      try {
        let messageStrategy = options == null ? void 0 : options.messageStrategy;
        MessageStrategy.is(messageStrategy) ? messageStrategy.handleMessage(message, handleMessage) : handleMessage(message);
      } finally {
        triggerMessageQueue();
      }
    }
    __name(processMessageQueue, "processMessageQueue");
    let callback = __name(message => {
      try {
        if (messages_1.Message.isNotification(message) && message.method === CancelNotification.type.method) {
          let cancelId = message.params.id,
            key = createRequestQueueKey(cancelId),
            toCancel = messageQueue.get(key);
          if (messages_1.Message.isRequest(toCancel)) {
            let strategy = options == null ? void 0 : options.connectionStrategy,
              response = strategy && strategy.cancelUndispatched ? strategy.cancelUndispatched(toCancel, cancelUndispatched) : void 0;
            if (response && (response.error !== void 0 || response.result !== void 0)) {
              messageQueue.delete(key), requestTokens.delete(cancelId), response.id = toCancel.id, traceSendingResponse(response, message.method, Date.now()), messageWriter.write(response).catch(() => logger.error("Sending response for canceled message failed."));
              return;
            }
          }
          let cancellationToken = requestTokens.get(cancelId);
          if (cancellationToken !== void 0) {
            cancellationToken.cancel(), traceReceivedNotification(message);
            return;
          } else knownCanceledRequests.add(cancelId);
        }
        addMessageToQueue(messageQueue, message);
      } finally {
        triggerMessageQueue();
      }
    }, "callback");
    function handleRequest(requestMessage) {
      var _a;
      if (isDisposed()) return;
      function reply(resultOrError, method, startTime) {
        let message = {
          jsonrpc: version,
          id: requestMessage.id
        };
        resultOrError instanceof messages_1.ResponseError ? message.error = resultOrError.toJson() : message.result = resultOrError === void 0 ? null : resultOrError, traceSendingResponse(message, method, startTime), messageWriter.write(message).catch(() => logger.error("Sending response failed."));
      }
      __name(reply, "reply");
      function replyError(error, method, startTime) {
        let message = {
          jsonrpc: version,
          id: requestMessage.id,
          error: error.toJson()
        };
        traceSendingResponse(message, method, startTime), messageWriter.write(message).catch(() => logger.error("Sending response failed."));
      }
      __name(replyError, "replyError");
      function replySuccess(result, method, startTime) {
        result === void 0 && (result = null);
        let message = {
          jsonrpc: version,
          id: requestMessage.id,
          result: result
        };
        traceSendingResponse(message, method, startTime), messageWriter.write(message).catch(() => logger.error("Sending response failed."));
      }
      __name(replySuccess, "replySuccess"), traceReceivedRequest(requestMessage);
      let element = requestHandlers.get(requestMessage.method),
        type,
        requestHandler;
      element && (type = element.type, requestHandler = element.handler);
      let startTime = Date.now();
      if (requestHandler || starRequestHandler) {
        let tokenKey = (_a = requestMessage.id) != null ? _a : String(Date.now()),
          cancellationSource = IdCancellationReceiverStrategy.is(cancellationStrategy.receiver) ? cancellationStrategy.receiver.createCancellationTokenSource(tokenKey) : cancellationStrategy.receiver.createCancellationTokenSource(requestMessage);
        requestMessage.id !== null && knownCanceledRequests.has(requestMessage.id) && cancellationSource.cancel(), requestMessage.id !== null && requestTokens.set(tokenKey, cancellationSource);
        try {
          let handlerResult;
          if (requestHandler) {
            if (requestMessage.params === void 0) {
              if (type !== void 0 && type.numberOfParams !== 0) {
                replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines ${type.numberOfParams} params but received none.`), requestMessage.method, startTime);
                return;
              }
              handlerResult = requestHandler(cancellationSource.token);
            } else if (Array.isArray(requestMessage.params)) {
              if (type !== void 0 && type.parameterStructures === messages_1.ParameterStructures.byName) {
                replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by name but received parameters by position`), requestMessage.method, startTime);
                return;
              }
              handlerResult = requestHandler(...requestMessage.params, cancellationSource.token);
            } else {
              if (type !== void 0 && type.parameterStructures === messages_1.ParameterStructures.byPosition) {
                replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by position but received parameters by name`), requestMessage.method, startTime);
                return;
              }
              handlerResult = requestHandler(requestMessage.params, cancellationSource.token);
            }
          } else starRequestHandler && (handlerResult = starRequestHandler(requestMessage.method, requestMessage.params, cancellationSource.token));
          let promise = handlerResult;
          handlerResult ? promise.then ? promise.then(resultOrError => {
            requestTokens.delete(tokenKey), reply(resultOrError, requestMessage.method, startTime);
          }, error => {
            requestTokens.delete(tokenKey), error instanceof messages_1.ResponseError ? replyError(error, requestMessage.method, startTime) : error && Is.string(error.message) ? replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime) : replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
          }) : (requestTokens.delete(tokenKey), reply(handlerResult, requestMessage.method, startTime)) : (requestTokens.delete(tokenKey), replySuccess(handlerResult, requestMessage.method, startTime));
        } catch (error) {
          requestTokens.delete(tokenKey), error instanceof messages_1.ResponseError ? reply(error, requestMessage.method, startTime) : error && Is.string(error.message) ? replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime) : replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
        }
      } else replyError(new messages_1.ResponseError(messages_1.ErrorCodes.MethodNotFound, `Unhandled method ${requestMessage.method}`), requestMessage.method, startTime);
    }
    __name(handleRequest, "handleRequest");
    function handleResponse(responseMessage) {
      if (!isDisposed()) if (responseMessage.id === null) responseMessage.error ? logger.error(`Received response message without id: Error is: 
${JSON.stringify(responseMessage.error, void 0, 4)}`) : logger.error("Received response message without id. No further error information provided.");else {
        let key = responseMessage.id,
          responsePromise = responsePromises.get(key);
        if (traceReceivedResponse(responseMessage, responsePromise), responsePromise !== void 0) {
          responsePromises.delete(key);
          try {
            if (responseMessage.error) {
              let error = responseMessage.error;
              responsePromise.reject(new messages_1.ResponseError(error.code, error.message, error.data));
            } else if (responseMessage.result !== void 0) responsePromise.resolve(responseMessage.result);else throw new Error("Should never happen.");
          } catch (error) {
            error.message ? logger.error(`Response handler '${responsePromise.method}' failed with message: ${error.message}`) : logger.error(`Response handler '${responsePromise.method}' failed unexpectedly.`);
          }
        }
      }
    }
    __name(handleResponse, "handleResponse");
    function handleNotification(message) {
      if (isDisposed()) return;
      let type, notificationHandler;
      if (message.method === CancelNotification.type.method) {
        let cancelId = message.params.id;
        knownCanceledRequests.delete(cancelId), traceReceivedNotification(message);
        return;
      } else {
        let element = notificationHandlers.get(message.method);
        element && (notificationHandler = element.handler, type = element.type);
      }
      if (notificationHandler || starNotificationHandler) try {
        if (traceReceivedNotification(message), notificationHandler) {
          if (message.params === void 0) type !== void 0 && type.numberOfParams !== 0 && type.parameterStructures !== messages_1.ParameterStructures.byName && logger.error(`Notification ${message.method} defines ${type.numberOfParams} params but received none.`), notificationHandler();else if (Array.isArray(message.params)) {
            let params = message.params;
            message.method === ProgressNotification.type.method && params.length === 2 && ProgressToken.is(params[0]) ? notificationHandler({
              token: params[0],
              value: params[1]
            }) : (type !== void 0 && (type.parameterStructures === messages_1.ParameterStructures.byName && logger.error(`Notification ${message.method} defines parameters by name but received parameters by position`), type.numberOfParams !== message.params.length && logger.error(`Notification ${message.method} defines ${type.numberOfParams} params but received ${params.length} arguments`)), notificationHandler(...params));
          } else type !== void 0 && type.parameterStructures === messages_1.ParameterStructures.byPosition && logger.error(`Notification ${message.method} defines parameters by position but received parameters by name`), notificationHandler(message.params);
        } else starNotificationHandler && starNotificationHandler(message.method, message.params);
      } catch (error) {
        error.message ? logger.error(`Notification handler '${message.method}' failed with message: ${error.message}`) : logger.error(`Notification handler '${message.method}' failed unexpectedly.`);
      } else unhandledNotificationEmitter.fire(message);
    }
    __name(handleNotification, "handleNotification");
    function handleInvalidMessage(message) {
      if (!message) {
        logger.error("Received empty message.");
        return;
      }
      logger.error(`Received message which is neither a response nor a notification message:
${JSON.stringify(message, null, 4)}`);
      let responseMessage = message;
      if (Is.string(responseMessage.id) || Is.number(responseMessage.id)) {
        let key = responseMessage.id,
          responseHandler = responsePromises.get(key);
        responseHandler && responseHandler.reject(new Error("The received response has neither a result nor an error property."));
      }
    }
    __name(handleInvalidMessage, "handleInvalidMessage");
    function stringifyTrace(params) {
      if (params != null) switch (trace) {
        case Trace.Verbose:
          return JSON.stringify(params, null, 4);
        case Trace.Compact:
          return JSON.stringify(params);
        default:
          return;
      }
    }
    __name(stringifyTrace, "stringifyTrace");
    function traceSendingRequest(message) {
      if (!(trace === Trace.Off || !tracer)) if (traceFormat === TraceFormat.Text) {
        let data;
        (trace === Trace.Verbose || trace === Trace.Compact) && message.params && (data = `Params: ${stringifyTrace(message.params)}

`), tracer.log(`Sending request '${message.method} - (${message.id})'.`, data);
      } else logLSPMessage("send-request", message);
    }
    __name(traceSendingRequest, "traceSendingRequest");
    function traceSendingNotification(message) {
      if (!(trace === Trace.Off || !tracer)) if (traceFormat === TraceFormat.Text) {
        let data;
        (trace === Trace.Verbose || trace === Trace.Compact) && (message.params ? data = `Params: ${stringifyTrace(message.params)}

` : data = `No parameters provided.

`), tracer.log(`Sending notification '${message.method}'.`, data);
      } else logLSPMessage("send-notification", message);
    }
    __name(traceSendingNotification, "traceSendingNotification");
    function traceSendingResponse(message, method, startTime) {
      if (!(trace === Trace.Off || !tracer)) if (traceFormat === TraceFormat.Text) {
        let data;
        (trace === Trace.Verbose || trace === Trace.Compact) && (message.error && message.error.data ? data = `Error data: ${stringifyTrace(message.error.data)}

` : message.result ? data = `Result: ${stringifyTrace(message.result)}

` : message.error === void 0 && (data = `No result returned.

`)), tracer.log(`Sending response '${method} - (${message.id})'. Processing request took ${Date.now() - startTime}ms`, data);
      } else logLSPMessage("send-response", message);
    }
    __name(traceSendingResponse, "traceSendingResponse");
    function traceReceivedRequest(message) {
      if (!(trace === Trace.Off || !tracer)) if (traceFormat === TraceFormat.Text) {
        let data;
        (trace === Trace.Verbose || trace === Trace.Compact) && message.params && (data = `Params: ${stringifyTrace(message.params)}

`), tracer.log(`Received request '${message.method} - (${message.id})'.`, data);
      } else logLSPMessage("receive-request", message);
    }
    __name(traceReceivedRequest, "traceReceivedRequest");
    function traceReceivedNotification(message) {
      if (!(trace === Trace.Off || !tracer || message.method === LogTraceNotification.type.method)) if (traceFormat === TraceFormat.Text) {
        let data;
        (trace === Trace.Verbose || trace === Trace.Compact) && (message.params ? data = `Params: ${stringifyTrace(message.params)}

` : data = `No parameters provided.

`), tracer.log(`Received notification '${message.method}'.`, data);
      } else logLSPMessage("receive-notification", message);
    }
    __name(traceReceivedNotification, "traceReceivedNotification");
    function traceReceivedResponse(message, responsePromise) {
      if (!(trace === Trace.Off || !tracer)) if (traceFormat === TraceFormat.Text) {
        let data;
        if ((trace === Trace.Verbose || trace === Trace.Compact) && (message.error && message.error.data ? data = `Error data: ${stringifyTrace(message.error.data)}

` : message.result ? data = `Result: ${stringifyTrace(message.result)}

` : message.error === void 0 && (data = `No result returned.

`)), responsePromise) {
          let error = message.error ? ` Request failed: ${message.error.message} (${message.error.code}).` : "";
          tracer.log(`Received response '${responsePromise.method} - (${message.id})' in ${Date.now() - responsePromise.timerStart}ms.${error}`, data);
        } else tracer.log(`Received response ${message.id} without active response promise.`, data);
      } else logLSPMessage("receive-response", message);
    }
    __name(traceReceivedResponse, "traceReceivedResponse");
    function logLSPMessage(type, message) {
      if (!tracer || trace === Trace.Off) return;
      let lspMessage = {
        isLSPMessage: !0,
        type: type,
        message: message,
        timestamp: Date.now()
      };
      tracer.log(lspMessage);
    }
    __name(logLSPMessage, "logLSPMessage");
    function throwIfClosedOrDisposed() {
      if (isClosed()) throw new ConnectionError(ConnectionErrors.Closed, "Connection is closed.");
      if (isDisposed()) throw new ConnectionError(ConnectionErrors.Disposed, "Connection is disposed.");
    }
    __name(throwIfClosedOrDisposed, "throwIfClosedOrDisposed");
    function throwIfListening() {
      if (isListening()) throw new ConnectionError(ConnectionErrors.AlreadyListening, "Connection is already listening");
    }
    __name(throwIfListening, "throwIfListening");
    function throwIfNotListening() {
      if (!isListening()) throw new Error("Call listen() first.");
    }
    __name(throwIfNotListening, "throwIfNotListening");
    function undefinedToNull(param) {
      return param === void 0 ? null : param;
    }
    __name(undefinedToNull, "undefinedToNull");
    function nullToUndefined(param) {
      if (param !== null) return param;
    }
    __name(nullToUndefined, "nullToUndefined");
    function isNamedParam(param) {
      return param != null && !Array.isArray(param) && typeof param == "object";
    }
    __name(isNamedParam, "isNamedParam");
    function computeSingleParam(parameterStructures, param) {
      switch (parameterStructures) {
        case messages_1.ParameterStructures.auto:
          return isNamedParam(param) ? nullToUndefined(param) : [undefinedToNull(param)];
        case messages_1.ParameterStructures.byName:
          if (!isNamedParam(param)) throw new Error("Received parameters by name but param is not an object literal.");
          return nullToUndefined(param);
        case messages_1.ParameterStructures.byPosition:
          return [undefinedToNull(param)];
        default:
          throw new Error(`Unknown parameter structure ${parameterStructures.toString()}`);
      }
    }
    __name(computeSingleParam, "computeSingleParam");
    function computeMessageParams(type, params) {
      let result,
        numberOfParams = type.numberOfParams;
      switch (numberOfParams) {
        case 0:
          result = void 0;
          break;
        case 1:
          result = computeSingleParam(type.parameterStructures, params[0]);
          break;
        default:
          result = [];
          for (let i = 0; i < params.length && i < numberOfParams; i++) result.push(undefinedToNull(params[i]));
          if (params.length < numberOfParams) for (let i = params.length; i < numberOfParams; i++) result.push(null);
          break;
      }
      return result;
    }
    __name(computeMessageParams, "computeMessageParams");
    let connection = {
      sendNotification: __name((type, ...args) => {
        throwIfClosedOrDisposed();
        let method, messageParams;
        if (Is.string(type)) {
          method = type;
          let first = args[0],
            paramStart = 0,
            parameterStructures = messages_1.ParameterStructures.auto;
          messages_1.ParameterStructures.is(first) && (paramStart = 1, parameterStructures = first);
          let paramEnd = args.length,
            numberOfParams = paramEnd - paramStart;
          switch (numberOfParams) {
            case 0:
              messageParams = void 0;
              break;
            case 1:
              messageParams = computeSingleParam(parameterStructures, args[paramStart]);
              break;
            default:
              if (parameterStructures === messages_1.ParameterStructures.byName) throw new Error(`Received ${numberOfParams} parameters for 'by Name' notification parameter structure.`);
              messageParams = args.slice(paramStart, paramEnd).map(value => undefinedToNull(value));
              break;
          }
        } else {
          let params = args;
          method = type.method, messageParams = computeMessageParams(type, params);
        }
        let notificationMessage = {
          jsonrpc: version,
          method: method,
          params: messageParams
        };
        return traceSendingNotification(notificationMessage), messageWriter.write(notificationMessage).catch(error => {
          throw logger.error("Sending notification failed."), error;
        });
      }, "sendNotification"),
      onNotification: __name((type, handler) => {
        throwIfClosedOrDisposed();
        let method;
        return Is.func(type) ? starNotificationHandler = type : handler && (Is.string(type) ? (method = type, notificationHandlers.set(type, {
          type: void 0,
          handler: handler
        })) : (method = type.method, notificationHandlers.set(type.method, {
          type: type,
          handler: handler
        }))), {
          dispose: __name(() => {
            method !== void 0 ? notificationHandlers.delete(method) : starNotificationHandler = void 0;
          }, "dispose")
        };
      }, "onNotification"),
      onProgress: __name((_type, token, handler) => {
        if (progressHandlers.has(token)) throw new Error(`Progress handler for token ${token} already registered`);
        return progressHandlers.set(token, handler), {
          dispose: __name(() => {
            progressHandlers.delete(token);
          }, "dispose")
        };
      }, "onProgress"),
      sendProgress: __name((_type, token, value) => connection.sendNotification(ProgressNotification.type, {
        token: token,
        value: value
      }), "sendProgress"),
      onUnhandledProgress: unhandledProgressEmitter.event,
      sendRequest: __name((type, ...args) => {
        throwIfClosedOrDisposed(), throwIfNotListening();
        let method, messageParams, token;
        if (Is.string(type)) {
          method = type;
          let first = args[0],
            last = args[args.length - 1],
            paramStart = 0,
            parameterStructures = messages_1.ParameterStructures.auto;
          messages_1.ParameterStructures.is(first) && (paramStart = 1, parameterStructures = first);
          let paramEnd = args.length;
          cancellation_1.CancellationToken.is(last) && (paramEnd = paramEnd - 1, token = last);
          let numberOfParams = paramEnd - paramStart;
          switch (numberOfParams) {
            case 0:
              messageParams = void 0;
              break;
            case 1:
              messageParams = computeSingleParam(parameterStructures, args[paramStart]);
              break;
            default:
              if (parameterStructures === messages_1.ParameterStructures.byName) throw new Error(`Received ${numberOfParams} parameters for 'by Name' request parameter structure.`);
              messageParams = args.slice(paramStart, paramEnd).map(value => undefinedToNull(value));
              break;
          }
        } else {
          let params = args;
          method = type.method, messageParams = computeMessageParams(type, params);
          let numberOfParams = type.numberOfParams;
          token = cancellation_1.CancellationToken.is(params[numberOfParams]) ? params[numberOfParams] : void 0;
        }
        let id = sequenceNumber++,
          disposable;
        token && (disposable = token.onCancellationRequested(() => {
          let p = cancellationStrategy.sender.sendCancellation(connection, id);
          return p === void 0 ? (logger.log(`Received no promise from cancellation strategy when cancelling id ${id}`), Promise.resolve()) : p.catch(() => {
            logger.log(`Sending cancellation messages for id ${id} failed`);
          });
        }));
        let requestMessage = {
          jsonrpc: version,
          id: id,
          method: method,
          params: messageParams
        };
        return traceSendingRequest(requestMessage), typeof cancellationStrategy.sender.enableCancellation == "function" && cancellationStrategy.sender.enableCancellation(requestMessage), new Promise(async (resolve, reject) => {
          let resolveWithCleanup = __name(r => {
              resolve(r), cancellationStrategy.sender.cleanup(id), disposable == null || disposable.dispose();
            }, "resolveWithCleanup"),
            rejectWithCleanup = __name(r => {
              reject(r), cancellationStrategy.sender.cleanup(id), disposable == null || disposable.dispose();
            }, "rejectWithCleanup"),
            responsePromise = {
              method: method,
              timerStart: Date.now(),
              resolve: resolveWithCleanup,
              reject: rejectWithCleanup
            };
          try {
            await messageWriter.write(requestMessage), responsePromises.set(id, responsePromise);
          } catch (error) {
            throw logger.error("Sending request failed."), responsePromise.reject(new messages_1.ResponseError(messages_1.ErrorCodes.MessageWriteError, error.message ? error.message : "Unknown reason")), error;
          }
        });
      }, "sendRequest"),
      onRequest: __name((type, handler) => {
        throwIfClosedOrDisposed();
        let method = null;
        return StarRequestHandler.is(type) ? (method = void 0, starRequestHandler = type) : Is.string(type) ? (method = null, handler !== void 0 && (method = type, requestHandlers.set(type, {
          handler: handler,
          type: void 0
        }))) : handler !== void 0 && (method = type.method, requestHandlers.set(type.method, {
          type: type,
          handler: handler
        })), {
          dispose: __name(() => {
            method !== null && (method !== void 0 ? requestHandlers.delete(method) : starRequestHandler = void 0);
          }, "dispose")
        };
      }, "onRequest"),
      hasPendingResponse: __name(() => responsePromises.size > 0, "hasPendingResponse"),
      trace: __name(async (_value, _tracer, sendNotificationOrTraceOptions) => {
        let _sendNotification = !1,
          _traceFormat = TraceFormat.Text;
        sendNotificationOrTraceOptions !== void 0 && (Is.boolean(sendNotificationOrTraceOptions) ? _sendNotification = sendNotificationOrTraceOptions : (_sendNotification = sendNotificationOrTraceOptions.sendNotification || !1, _traceFormat = sendNotificationOrTraceOptions.traceFormat || TraceFormat.Text)), trace = _value, traceFormat = _traceFormat, trace === Trace.Off ? tracer = void 0 : tracer = _tracer, _sendNotification && !isClosed() && !isDisposed() && (await connection.sendNotification(SetTraceNotification.type, {
          value: Trace.toString(_value)
        }));
      }, "trace"),
      onError: errorEmitter.event,
      onClose: closeEmitter.event,
      onUnhandledNotification: unhandledNotificationEmitter.event,
      onDispose: disposeEmitter.event,
      end: __name(() => {
        messageWriter.end();
      }, "end"),
      dispose: __name(() => {
        if (isDisposed()) return;
        state = ConnectionState.Disposed, disposeEmitter.fire(void 0);
        let error = new messages_1.ResponseError(messages_1.ErrorCodes.PendingResponseRejected, "Pending response rejected since connection got disposed");
        for (let promise of responsePromises.values()) promise.reject(error);
        responsePromises = new Map(), requestTokens = new Map(), knownCanceledRequests = new Set(), messageQueue = new linkedMap_1.LinkedMap(), Is.func(messageWriter.dispose) && messageWriter.dispose(), Is.func(messageReader.dispose) && messageReader.dispose();
      }, "dispose"),
      listen: __name(() => {
        throwIfClosedOrDisposed(), throwIfListening(), state = ConnectionState.Listening, messageReader.listen(callback);
      }, "listen"),
      inspect: __name(() => {
        (0, ral_1.default)().console.log("inspect");
      }, "inspect")
    };
    return connection.onNotification(LogTraceNotification.type, params => {
      if (trace === Trace.Off || !tracer) return;
      let verbose = trace === Trace.Verbose || trace === Trace.Compact;
      tracer.log(params.message, verbose ? params.verbose : void 0);
    }), connection.onNotification(ProgressNotification.type, params => {
      let handler = progressHandlers.get(params.token);
      handler ? handler(params.value) : unhandledProgressEmitter.fire(params);
    }), connection;
  }
  __name(createMessageConnection, "createMessageConnection");
  exports.createMessageConnection = createMessageConnection;
});