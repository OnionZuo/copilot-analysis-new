var require_messageWriter = __commonJSMin(exports => {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: !0
  });
  exports.WriteableStreamMessageWriter = exports.AbstractMessageWriter = exports.MessageWriter = void 0;
  var ral_1 = zy(),
    Is = S1(),
    semaphore_1 = xV(),
    events_1 = N1(),
    ContentLength = "Content-Length: ",
    CRLF = `\r
`,
    MessageWriter;
  (function (MessageWriter) {
    function is(value) {
      let candidate = value;
      return candidate && Is.func(candidate.dispose) && Is.func(candidate.onClose) && Is.func(candidate.onError) && Is.func(candidate.write);
    }
    __name(is, "is"), MessageWriter.is = is;
  })(MessageWriter || (exports.MessageWriter = MessageWriter = {}));
  var _AbstractMessageWriter = class _AbstractMessageWriter {
    constructor() {
      this.errorEmitter = new events_1.Emitter(), this.closeEmitter = new events_1.Emitter();
    }
    dispose() {
      this.errorEmitter.dispose(), this.closeEmitter.dispose();
    }
    get onError() {
      return this.errorEmitter.event;
    }
    fireError(error, message, count) {
      this.errorEmitter.fire([this.asError(error), message, count]);
    }
    get onClose() {
      return this.closeEmitter.event;
    }
    fireClose() {
      this.closeEmitter.fire(void 0);
    }
    asError(error) {
      return error instanceof Error ? error : new Error(`Writer received error. Reason: ${Is.string(error.message) ? error.message : "unknown"}`);
    }
  };
  __name(_AbstractMessageWriter, "AbstractMessageWriter");
  var AbstractMessageWriter = _AbstractMessageWriter;
  exports.AbstractMessageWriter = AbstractMessageWriter;
  var ResolvedMessageWriterOptions;
  (function (ResolvedMessageWriterOptions) {
    function fromOptions(options) {
      var _a, _b;
      return options === void 0 || typeof options == "string" ? {
        charset: options != null ? options : "utf-8",
        contentTypeEncoder: (0, ral_1.default)().applicationJson.encoder
      } : {
        charset: (_a = options.charset) != null ? _a : "utf-8",
        contentEncoder: options.contentEncoder,
        contentTypeEncoder: (_b = options.contentTypeEncoder) != null ? _b : (0, ral_1.default)().applicationJson.encoder
      };
    }
    __name(fromOptions, "fromOptions"), ResolvedMessageWriterOptions.fromOptions = fromOptions;
  })(ResolvedMessageWriterOptions || (ResolvedMessageWriterOptions = {}));
  var _WriteableStreamMessageWriter = class _WriteableStreamMessageWriter extends AbstractMessageWriter {
    constructor(writable, options) {
      super(), this.writable = writable, this.options = ResolvedMessageWriterOptions.fromOptions(options), this.errorCount = 0, this.writeSemaphore = new semaphore_1.Semaphore(1), this.writable.onError(error => this.fireError(error)), this.writable.onClose(() => this.fireClose());
    }
    async write(msg) {
      return this.writeSemaphore.lock(async () => this.options.contentTypeEncoder.encode(msg, this.options).then(buffer => this.options.contentEncoder !== void 0 ? this.options.contentEncoder.encode(buffer) : buffer).then(buffer => {
        let headers = [];
        return headers.push(ContentLength, buffer.byteLength.toString(), CRLF), headers.push(CRLF), this.doWrite(msg, headers, buffer);
      }, error => {
        throw this.fireError(error), error;
      }));
    }
    async doWrite(msg, headers, data) {
      try {
        return await this.writable.write(headers.join(""), "ascii"), this.writable.write(data);
      } catch (error) {
        return this.handleError(error, msg), Promise.reject(error);
      }
    }
    handleError(error, msg) {
      this.errorCount++, this.fireError(error, msg, this.errorCount);
    }
    end() {
      this.writable.end();
    }
  };
  __name(_WriteableStreamMessageWriter, "WriteableStreamMessageWriter");
  var WriteableStreamMessageWriter = _WriteableStreamMessageWriter;
  exports.WriteableStreamMessageWriter = WriteableStreamMessageWriter;
});