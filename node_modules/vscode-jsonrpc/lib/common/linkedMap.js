var require_linkedMap = __commonJSMin(exports => {
  "use strict";

  var _a;
  Object.defineProperty(exports, "__esModule", {
    value: !0
  });
  exports.LRUCache = exports.LinkedMap = exports.Touch = void 0;
  var Touch;
  (function (Touch) {
    Touch.None = 0, Touch.First = 1, Touch.AsOld = Touch.First, Touch.Last = 2, Touch.AsNew = Touch.Last;
  })(Touch || (exports.Touch = Touch = {}));
  var _LinkedMap = class _LinkedMap {
    constructor() {
      this[_a] = "LinkedMap", this._map = new Map(), this._head = void 0, this._tail = void 0, this._size = 0, this._state = 0;
    }
    clear() {
      this._map.clear(), this._head = void 0, this._tail = void 0, this._size = 0, this._state++;
    }
    isEmpty() {
      return !this._head && !this._tail;
    }
    get size() {
      return this._size;
    }
    get first() {
      var _a;
      return (_a = this._head) == null ? void 0 : _a.value;
    }
    get last() {
      var _a;
      return (_a = this._tail) == null ? void 0 : _a.value;
    }
    has(key) {
      return this._map.has(key);
    }
    get(key, touch = Touch.None) {
      let item = this._map.get(key);
      if (item) return touch !== Touch.None && this.touch(item, touch), item.value;
    }
    set(key, value, touch = Touch.None) {
      let item = this._map.get(key);
      if (item) item.value = value, touch !== Touch.None && this.touch(item, touch);else {
        switch (item = {
          key: key,
          value: value,
          next: void 0,
          previous: void 0
        }, touch) {
          case Touch.None:
            this.addItemLast(item);
            break;
          case Touch.First:
            this.addItemFirst(item);
            break;
          case Touch.Last:
            this.addItemLast(item);
            break;
          default:
            this.addItemLast(item);
            break;
        }
        this._map.set(key, item), this._size++;
      }
      return this;
    }
    delete(key) {
      return !!this.remove(key);
    }
    remove(key) {
      let item = this._map.get(key);
      if (item) return this._map.delete(key), this.removeItem(item), this._size--, item.value;
    }
    shift() {
      if (!this._head && !this._tail) return;
      if (!this._head || !this._tail) throw new Error("Invalid list");
      let item = this._head;
      return this._map.delete(item.key), this.removeItem(item), this._size--, item.value;
    }
    forEach(callbackfn, thisArg) {
      let state = this._state,
        current = this._head;
      for (; current;) {
        if (thisArg ? callbackfn.bind(thisArg)(current.value, current.key, this) : callbackfn(current.value, current.key, this), this._state !== state) throw new Error("LinkedMap got modified during iteration.");
        current = current.next;
      }
    }
    keys() {
      let state = this._state,
        current = this._head,
        iterator = {
          [Symbol.iterator]: () => iterator,
          next: __name(() => {
            if (this._state !== state) throw new Error("LinkedMap got modified during iteration.");
            if (current) {
              let result = {
                value: current.key,
                done: !1
              };
              return current = current.next, result;
            } else return {
              value: void 0,
              done: !0
            };
          }, "next")
        };
      return iterator;
    }
    values() {
      let state = this._state,
        current = this._head,
        iterator = {
          [Symbol.iterator]: () => iterator,
          next: __name(() => {
            if (this._state !== state) throw new Error("LinkedMap got modified during iteration.");
            if (current) {
              let result = {
                value: current.value,
                done: !1
              };
              return current = current.next, result;
            } else return {
              value: void 0,
              done: !0
            };
          }, "next")
        };
      return iterator;
    }
    entries() {
      let state = this._state,
        current = this._head,
        iterator = {
          [Symbol.iterator]: () => iterator,
          next: __name(() => {
            if (this._state !== state) throw new Error("LinkedMap got modified during iteration.");
            if (current) {
              let result = {
                value: [current.key, current.value],
                done: !1
              };
              return current = current.next, result;
            } else return {
              value: void 0,
              done: !0
            };
          }, "next")
        };
      return iterator;
    }
    [(_a = Symbol.toStringTag, Symbol.iterator)]() {
      return this.entries();
    }
    trimOld(newSize) {
      if (newSize >= this.size) return;
      if (newSize === 0) {
        this.clear();
        return;
      }
      let current = this._head,
        currentSize = this.size;
      for (; current && currentSize > newSize;) this._map.delete(current.key), current = current.next, currentSize--;
      this._head = current, this._size = currentSize, current && (current.previous = void 0), this._state++;
    }
    addItemFirst(item) {
      if (!this._head && !this._tail) this._tail = item;else if (this._head) item.next = this._head, this._head.previous = item;else throw new Error("Invalid list");
      this._head = item, this._state++;
    }
    addItemLast(item) {
      if (!this._head && !this._tail) this._head = item;else if (this._tail) item.previous = this._tail, this._tail.next = item;else throw new Error("Invalid list");
      this._tail = item, this._state++;
    }
    removeItem(item) {
      if (item === this._head && item === this._tail) this._head = void 0, this._tail = void 0;else if (item === this._head) {
        if (!item.next) throw new Error("Invalid list");
        item.next.previous = void 0, this._head = item.next;
      } else if (item === this._tail) {
        if (!item.previous) throw new Error("Invalid list");
        item.previous.next = void 0, this._tail = item.previous;
      } else {
        let next = item.next,
          previous = item.previous;
        if (!next || !previous) throw new Error("Invalid list");
        next.previous = previous, previous.next = next;
      }
      item.next = void 0, item.previous = void 0, this._state++;
    }
    touch(item, touch) {
      if (!this._head || !this._tail) throw new Error("Invalid list");
      if (!(touch !== Touch.First && touch !== Touch.Last)) {
        if (touch === Touch.First) {
          if (item === this._head) return;
          let next = item.next,
            previous = item.previous;
          item === this._tail ? (previous.next = void 0, this._tail = previous) : (next.previous = previous, previous.next = next), item.previous = void 0, item.next = this._head, this._head.previous = item, this._head = item, this._state++;
        } else if (touch === Touch.Last) {
          if (item === this._tail) return;
          let next = item.next,
            previous = item.previous;
          item === this._head ? (next.previous = void 0, this._head = next) : (next.previous = previous, previous.next = next), item.next = void 0, item.previous = this._tail, this._tail.next = item, this._tail = item, this._state++;
        }
      }
    }
    toJSON() {
      let data = [];
      return this.forEach((value, key) => {
        data.push([key, value]);
      }), data;
    }
    fromJSON(data) {
      this.clear();
      for (let [key, value] of data) this.set(key, value);
    }
  };
  __name(_LinkedMap, "LinkedMap");
  var LinkedMap = _LinkedMap;
  exports.LinkedMap = LinkedMap;
  var _LRUCache = class _LRUCache extends LinkedMap {
    constructor(limit, ratio = 1) {
      super(), this._limit = limit, this._ratio = Math.min(Math.max(0, ratio), 1);
    }
    get limit() {
      return this._limit;
    }
    set limit(limit) {
      this._limit = limit, this.checkTrim();
    }
    get ratio() {
      return this._ratio;
    }
    set ratio(ratio) {
      this._ratio = Math.min(Math.max(0, ratio), 1), this.checkTrim();
    }
    get(key, touch = Touch.AsNew) {
      return super.get(key, touch);
    }
    peek(key) {
      return super.get(key, Touch.None);
    }
    set(key, value) {
      return super.set(key, value, Touch.Last), this.checkTrim(), this;
    }
    checkTrim() {
      this.size > this._limit && this.trimOld(Math.round(this._limit * this._ratio));
    }
  };
  __name(_LRUCache, "LRUCache");
  var LRUCache = _LRUCache;
  exports.LRUCache = LRUCache;
});