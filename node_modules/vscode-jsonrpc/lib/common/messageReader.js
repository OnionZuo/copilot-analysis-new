var require_messageReader = __commonJSMin(exports => {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: !0
  });
  exports.ReadableStreamMessageReader = exports.AbstractMessageReader = exports.MessageReader = void 0;
  var ral_1 = zy(),
    Is = S1(),
    events_1 = N1(),
    semaphore_1 = xV(),
    MessageReader;
  (function (MessageReader) {
    function is(value) {
      let candidate = value;
      return candidate && Is.func(candidate.listen) && Is.func(candidate.dispose) && Is.func(candidate.onError) && Is.func(candidate.onClose) && Is.func(candidate.onPartialMessage);
    }
    __name(is, "is"), MessageReader.is = is;
  })(MessageReader || (exports.MessageReader = MessageReader = {}));
  var _AbstractMessageReader = class _AbstractMessageReader {
    constructor() {
      this.errorEmitter = new events_1.Emitter(), this.closeEmitter = new events_1.Emitter(), this.partialMessageEmitter = new events_1.Emitter();
    }
    dispose() {
      this.errorEmitter.dispose(), this.closeEmitter.dispose();
    }
    get onError() {
      return this.errorEmitter.event;
    }
    fireError(error) {
      this.errorEmitter.fire(this.asError(error));
    }
    get onClose() {
      return this.closeEmitter.event;
    }
    fireClose() {
      this.closeEmitter.fire(void 0);
    }
    get onPartialMessage() {
      return this.partialMessageEmitter.event;
    }
    firePartialMessage(info) {
      this.partialMessageEmitter.fire(info);
    }
    asError(error) {
      return error instanceof Error ? error : new Error(`Reader received error. Reason: ${Is.string(error.message) ? error.message : "unknown"}`);
    }
  };
  __name(_AbstractMessageReader, "AbstractMessageReader");
  var AbstractMessageReader = _AbstractMessageReader;
  exports.AbstractMessageReader = AbstractMessageReader;
  var ResolvedMessageReaderOptions;
  (function (ResolvedMessageReaderOptions) {
    function fromOptions(options) {
      var _a;
      let charset,
        result,
        contentDecoder,
        contentDecoders = new Map(),
        contentTypeDecoder,
        contentTypeDecoders = new Map();
      if (options === void 0 || typeof options == "string") charset = options != null ? options : "utf-8";else {
        if (charset = (_a = options.charset) != null ? _a : "utf-8", options.contentDecoder !== void 0 && (contentDecoder = options.contentDecoder, contentDecoders.set(contentDecoder.name, contentDecoder)), options.contentDecoders !== void 0) for (let decoder of options.contentDecoders) contentDecoders.set(decoder.name, decoder);
        if (options.contentTypeDecoder !== void 0 && (contentTypeDecoder = options.contentTypeDecoder, contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder)), options.contentTypeDecoders !== void 0) for (let decoder of options.contentTypeDecoders) contentTypeDecoders.set(decoder.name, decoder);
      }
      return contentTypeDecoder === void 0 && (contentTypeDecoder = (0, ral_1.default)().applicationJson.decoder, contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder)), {
        charset: charset,
        contentDecoder: contentDecoder,
        contentDecoders: contentDecoders,
        contentTypeDecoder: contentTypeDecoder,
        contentTypeDecoders: contentTypeDecoders
      };
    }
    __name(fromOptions, "fromOptions"), ResolvedMessageReaderOptions.fromOptions = fromOptions;
  })(ResolvedMessageReaderOptions || (ResolvedMessageReaderOptions = {}));
  var _ReadableStreamMessageReader = class _ReadableStreamMessageReader extends AbstractMessageReader {
    constructor(readable, options) {
      super(), this.readable = readable, this.options = ResolvedMessageReaderOptions.fromOptions(options), this.buffer = (0, ral_1.default)().messageBuffer.create(this.options.charset), this._partialMessageTimeout = 1e4, this.nextMessageLength = -1, this.messageToken = 0, this.readSemaphore = new semaphore_1.Semaphore(1);
    }
    set partialMessageTimeout(timeout) {
      this._partialMessageTimeout = timeout;
    }
    get partialMessageTimeout() {
      return this._partialMessageTimeout;
    }
    listen(callback) {
      this.nextMessageLength = -1, this.messageToken = 0, this.partialMessageTimer = void 0, this.callback = callback;
      let result = this.readable.onData(data => {
        this.onData(data);
      });
      return this.readable.onError(error => this.fireError(error)), this.readable.onClose(() => this.fireClose()), result;
    }
    onData(data) {
      try {
        for (this.buffer.append(data);;) {
          if (this.nextMessageLength === -1) {
            let headers = this.buffer.tryReadHeaders(!0);
            if (!headers) return;
            let contentLength = headers.get("content-length");
            if (!contentLength) {
              this.fireError(new Error(`Header must provide a Content-Length property.
${JSON.stringify(Object.fromEntries(headers))}`));
              return;
            }
            let length = parseInt(contentLength);
            if (isNaN(length)) {
              this.fireError(new Error(`Content-Length value must be a number. Got ${contentLength}`));
              return;
            }
            this.nextMessageLength = length;
          }
          let body = this.buffer.tryReadBody(this.nextMessageLength);
          if (body === void 0) {
            this.setPartialMessageTimer();
            return;
          }
          this.clearPartialMessageTimer(), this.nextMessageLength = -1, this.readSemaphore.lock(async () => {
            let bytes = this.options.contentDecoder !== void 0 ? await this.options.contentDecoder.decode(body) : body,
              message = await this.options.contentTypeDecoder.decode(bytes, this.options);
            this.callback(message);
          }).catch(error => {
            this.fireError(error);
          });
        }
      } catch (error) {
        this.fireError(error);
      }
    }
    clearPartialMessageTimer() {
      this.partialMessageTimer && (this.partialMessageTimer.dispose(), this.partialMessageTimer = void 0);
    }
    setPartialMessageTimer() {
      this.clearPartialMessageTimer(), !(this._partialMessageTimeout <= 0) && (this.partialMessageTimer = (0, ral_1.default)().timer.setTimeout((token, timeout) => {
        this.partialMessageTimer = void 0, token === this.messageToken && (this.firePartialMessage({
          messageToken: token,
          waitingTime: timeout
        }), this.setPartialMessageTimer());
      }, this._partialMessageTimeout, this.messageToken, this._partialMessageTimeout));
    }
  };
  __name(_ReadableStreamMessageReader, "ReadableStreamMessageReader");
  var ReadableStreamMessageReader = _ReadableStreamMessageReader;
  exports.ReadableStreamMessageReader = ReadableStreamMessageReader;
});