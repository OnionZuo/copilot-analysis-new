var require_messageBuffer = __commonJSMin(exports => {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: !0
  });
  exports.AbstractMessageBuffer = void 0;
  var CR = 13,
    LF = 10,
    CRLF = `\r
`,
    _AbstractMessageBuffer = class _AbstractMessageBuffer {
      constructor(encoding = "utf-8") {
        this._encoding = encoding, this._chunks = [], this._totalLength = 0;
      }
      get encoding() {
        return this._encoding;
      }
      append(chunk) {
        let toAppend = typeof chunk == "string" ? this.fromString(chunk, this._encoding) : chunk;
        this._chunks.push(toAppend), this._totalLength += toAppend.byteLength;
      }
      tryReadHeaders(lowerCaseKeys = !1) {
        if (this._chunks.length === 0) return;
        let state = 0,
          chunkIndex = 0,
          offset = 0,
          chunkBytesRead = 0;
        row: for (; chunkIndex < this._chunks.length;) {
          let chunk = this._chunks[chunkIndex];
          for (offset = 0; offset < chunk.length;) {
            switch (chunk[offset]) {
              case CR:
                switch (state) {
                  case 0:
                    state = 1;
                    break;
                  case 2:
                    state = 3;
                    break;
                  default:
                    state = 0;
                }
                break;
              case LF:
                switch (state) {
                  case 1:
                    state = 2;
                    break;
                  case 3:
                    state = 4, offset++;
                    break row;
                  default:
                    state = 0;
                }
                break;
              default:
                state = 0;
            }
            offset++;
          }
          chunkBytesRead += chunk.byteLength, chunkIndex++;
        }
        if (state !== 4) return;
        let buffer = this._read(chunkBytesRead + offset),
          result = new Map(),
          headers = this.toString(buffer, "ascii").split(CRLF);
        if (headers.length < 2) return result;
        for (let i = 0; i < headers.length - 2; i++) {
          let header = headers[i],
            index = header.indexOf(":");
          if (index === -1) throw new Error(`Message header must separate key and value using ':'
${header}`);
          let key = header.substr(0, index),
            value = header.substr(index + 1).trim();
          result.set(lowerCaseKeys ? key.toLowerCase() : key, value);
        }
        return result;
      }
      tryReadBody(length) {
        if (!(this._totalLength < length)) return this._read(length);
      }
      get numberOfBytes() {
        return this._totalLength;
      }
      _read(byteCount) {
        if (byteCount === 0) return this.emptyBuffer();
        if (byteCount > this._totalLength) throw new Error("Cannot read so many bytes!");
        if (this._chunks[0].byteLength === byteCount) {
          let chunk = this._chunks[0];
          return this._chunks.shift(), this._totalLength -= byteCount, this.asNative(chunk);
        }
        if (this._chunks[0].byteLength > byteCount) {
          let chunk = this._chunks[0],
            result = this.asNative(chunk, byteCount);
          return this._chunks[0] = chunk.slice(byteCount), this._totalLength -= byteCount, result;
        }
        let result = this.allocNative(byteCount),
          resultOffset = 0,
          chunkIndex = 0;
        for (; byteCount > 0;) {
          let chunk = this._chunks[chunkIndex];
          if (chunk.byteLength > byteCount) {
            let chunkPart = chunk.slice(0, byteCount);
            result.set(chunkPart, resultOffset), resultOffset += byteCount, this._chunks[chunkIndex] = chunk.slice(byteCount), this._totalLength -= byteCount, byteCount -= byteCount;
          } else result.set(chunk, resultOffset), resultOffset += chunk.byteLength, this._chunks.shift(), this._totalLength -= chunk.byteLength, byteCount -= chunk.byteLength;
        }
        return result;
      }
    };
  __name(_AbstractMessageBuffer, "AbstractMessageBuffer");
  var AbstractMessageBuffer = _AbstractMessageBuffer;
  exports.AbstractMessageBuffer = AbstractMessageBuffer;
});