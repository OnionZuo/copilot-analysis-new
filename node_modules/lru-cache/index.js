var require_lru_cache = __commonJSMin((exports, module) => {
  var perf = typeof performance == "object" && performance && typeof performance.now == "function" ? performance : Date,
    hasAbortController = typeof AbortController == "function",
    _a,
    AC = hasAbortController ? AbortController : (_a = class {
      constructor() {
        this.signal = new AS();
      }
      abort() {
        this.signal.dispatchEvent("abort");
      }
    }, __name(_a, "AbortController"), _a),
    hasAbortSignal = typeof AbortSignal == "function",
    hasACAbortSignal = typeof AC.AbortSignal == "function",
    _a,
    AS = hasAbortSignal ? AbortSignal : hasACAbortSignal ? AC.AbortController : (_a = class {
      constructor() {
        this.aborted = !1, this._listeners = [];
      }
      dispatchEvent(type) {
        if (type === "abort") {
          this.aborted = !0;
          let e = {
            type: type,
            target: this
          };
          this.onabort(e), this._listeners.forEach(f => f(e), this);
        }
      }
      onabort() {}
      addEventListener(ev, fn) {
        ev === "abort" && this._listeners.push(fn);
      }
      removeEventListener(ev, fn) {
        ev === "abort" && (this._listeners = this._listeners.filter(f => f !== fn));
      }
    }, __name(_a, "AbortSignal"), _a),
    warned = new Set(),
    deprecatedOption = __name((opt, instead) => {
      let code = `LRU_CACHE_OPTION_${opt}`;
      shouldWarn(code) && warn(code, `${opt} option`, `options.${instead}`, LRUCache);
    }, "deprecatedOption"),
    deprecatedMethod = __name((method, instead) => {
      let code = `LRU_CACHE_METHOD_${method}`;
      if (shouldWarn(code)) {
        let {
            prototype: prototype
          } = LRUCache,
          {
            get: get
          } = Object.getOwnPropertyDescriptor(prototype, method);
        warn(code, `${method} method`, `cache.${instead}()`, get);
      }
    }, "deprecatedMethod"),
    deprecatedProperty = __name((field, instead) => {
      let code = `LRU_CACHE_PROPERTY_${field}`;
      if (shouldWarn(code)) {
        let {
            prototype: prototype
          } = LRUCache,
          {
            get: get
          } = Object.getOwnPropertyDescriptor(prototype, field);
        warn(code, `${field} property`, `cache.${instead}`, get);
      }
    }, "deprecatedProperty"),
    emitWarning = __name((...a) => {
      typeof process == "object" && process && typeof process.emitWarning == "function" ? process.emitWarning(...a) : console.error(...a);
    }, "emitWarning"),
    shouldWarn = __name(code => !warned.has(code), "shouldWarn"),
    warn = __name((code, what, instead, fn) => {
      warned.add(code);
      let msg = `The ${what} is deprecated. Please use ${instead} instead.`;
      emitWarning(msg, "DeprecationWarning", code, fn);
    }, "warn"),
    isPosInt = __name(n => n && n === Math.floor(n) && n > 0 && isFinite(n), "isPosInt"),
    getUintArray = __name(max => isPosInt(max) ? max <= Math.pow(2, 8) ? Uint8Array : max <= Math.pow(2, 16) ? Uint16Array : max <= Math.pow(2, 32) ? Uint32Array : max <= Number.MAX_SAFE_INTEGER ? ZeroArray : null : null, "getUintArray"),
    _ZeroArray = class _ZeroArray extends Array {
      constructor(size) {
        super(size), this.fill(0);
      }
    };
  __name(_ZeroArray, "ZeroArray");
  var ZeroArray = _ZeroArray,
    _Stack = class _Stack {
      constructor(max) {
        if (max === 0) return [];
        let UintArray = getUintArray(max);
        this.heap = new UintArray(max), this.length = 0;
      }
      push(n) {
        this.heap[this.length++] = n;
      }
      pop() {
        return this.heap[--this.length];
      }
    };
  __name(_Stack, "Stack");
  var Stack = _Stack,
    _LRUCache = class _LRUCache {
      constructor(options = {}) {
        let {
            max = 0,
            ttl: ttl,
            ttlResolution = 1,
            ttlAutopurge: ttlAutopurge,
            updateAgeOnGet: updateAgeOnGet,
            updateAgeOnHas: updateAgeOnHas,
            allowStale: allowStale,
            dispose: dispose,
            disposeAfter: disposeAfter,
            noDisposeOnSet: noDisposeOnSet,
            noUpdateTTL: noUpdateTTL,
            maxSize = 0,
            sizeCalculation: sizeCalculation,
            fetchMethod: fetchMethod,
            fetchContext: fetchContext,
            noDeleteOnFetchRejection: noDeleteOnFetchRejection,
            noDeleteOnStaleGet: noDeleteOnStaleGet
          } = options,
          {
            length: length,
            maxAge: maxAge,
            stale: stale
          } = options instanceof _LRUCache ? {} : options;
        if (max !== 0 && !isPosInt(max)) throw new TypeError("max option must be a nonnegative integer");
        let UintArray = max ? getUintArray(max) : Array;
        if (!UintArray) throw new Error("invalid max value: " + max);
        if (this.max = max, this.maxSize = maxSize, this.sizeCalculation = sizeCalculation || length, this.sizeCalculation) {
          if (!this.maxSize) throw new TypeError("cannot set sizeCalculation without setting maxSize");
          if (typeof this.sizeCalculation != "function") throw new TypeError("sizeCalculation set to non-function");
        }
        if (this.fetchMethod = fetchMethod || null, this.fetchMethod && typeof this.fetchMethod != "function") throw new TypeError("fetchMethod must be a function if specified");
        if (this.fetchContext = fetchContext, !this.fetchMethod && fetchContext !== void 0) throw new TypeError("cannot set fetchContext without fetchMethod");
        if (this.keyMap = new Map(), this.keyList = new Array(max).fill(null), this.valList = new Array(max).fill(null), this.next = new UintArray(max), this.prev = new UintArray(max), this.head = 0, this.tail = 0, this.free = new Stack(max), this.initialFill = 1, this.size = 0, typeof dispose == "function" && (this.dispose = dispose), typeof disposeAfter == "function" ? (this.disposeAfter = disposeAfter, this.disposed = []) : (this.disposeAfter = null, this.disposed = null), this.noDisposeOnSet = !!noDisposeOnSet, this.noUpdateTTL = !!noUpdateTTL, this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection, this.maxSize !== 0) {
          if (!isPosInt(this.maxSize)) throw new TypeError("maxSize must be a positive integer if specified");
          this.initializeSizeTracking();
        }
        if (this.allowStale = !!allowStale || !!stale, this.noDeleteOnStaleGet = !!noDeleteOnStaleGet, this.updateAgeOnGet = !!updateAgeOnGet, this.updateAgeOnHas = !!updateAgeOnHas, this.ttlResolution = isPosInt(ttlResolution) || ttlResolution === 0 ? ttlResolution : 1, this.ttlAutopurge = !!ttlAutopurge, this.ttl = ttl || maxAge || 0, this.ttl) {
          if (!isPosInt(this.ttl)) throw new TypeError("ttl must be a positive integer if specified");
          this.initializeTTLTracking();
        }
        if (this.max === 0 && this.ttl === 0 && this.maxSize === 0) throw new TypeError("At least one of max, maxSize, or ttl is required");
        if (!this.ttlAutopurge && !this.max && !this.maxSize) {
          let code = "LRU_CACHE_UNBOUNDED";
          shouldWarn(code) && (warned.add(code), emitWarning("TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.", "UnboundedCacheWarning", code, _LRUCache));
        }
        stale && deprecatedOption("stale", "allowStale"), maxAge && deprecatedOption("maxAge", "ttl"), length && deprecatedOption("length", "sizeCalculation");
      }
      getRemainingTTL(key) {
        return this.has(key, {
          updateAgeOnHas: !1
        }) ? 1 / 0 : 0;
      }
      initializeTTLTracking() {
        this.ttls = new ZeroArray(this.max), this.starts = new ZeroArray(this.max), this.setItemTTL = (index, ttl, start = perf.now()) => {
          if (this.starts[index] = ttl !== 0 ? start : 0, this.ttls[index] = ttl, ttl !== 0 && this.ttlAutopurge) {
            let t = setTimeout(() => {
              this.isStale(index) && this.delete(this.keyList[index]);
            }, ttl + 1);
            t.unref && t.unref();
          }
        }, this.updateItemAge = index => {
          this.starts[index] = this.ttls[index] !== 0 ? perf.now() : 0;
        };
        let cachedNow = 0,
          getNow = __name(() => {
            let n = perf.now();
            if (this.ttlResolution > 0) {
              cachedNow = n;
              let t = setTimeout(() => cachedNow = 0, this.ttlResolution);
              t.unref && t.unref();
            }
            return n;
          }, "getNow");
        this.getRemainingTTL = key => {
          let index = this.keyMap.get(key);
          return index === void 0 ? 0 : this.ttls[index] === 0 || this.starts[index] === 0 ? 1 / 0 : this.starts[index] + this.ttls[index] - (cachedNow || getNow());
        }, this.isStale = index => this.ttls[index] !== 0 && this.starts[index] !== 0 && (cachedNow || getNow()) - this.starts[index] > this.ttls[index];
      }
      updateItemAge(index) {}
      setItemTTL(index, ttl, start) {}
      isStale(index) {
        return !1;
      }
      initializeSizeTracking() {
        this.calculatedSize = 0, this.sizes = new ZeroArray(this.max), this.removeItemSize = index => {
          this.calculatedSize -= this.sizes[index], this.sizes[index] = 0;
        }, this.requireSize = (k, v, size, sizeCalculation) => {
          if (!isPosInt(size)) if (sizeCalculation) {
            if (typeof sizeCalculation != "function") throw new TypeError("sizeCalculation must be a function");
            if (size = sizeCalculation(v, k), !isPosInt(size)) throw new TypeError("sizeCalculation return invalid (expect positive integer)");
          } else throw new TypeError("invalid size value (must be positive integer)");
          return size;
        }, this.addItemSize = (index, size) => {
          this.sizes[index] = size;
          let maxSize = this.maxSize - this.sizes[index];
          for (; this.calculatedSize > maxSize;) this.evict(!0);
          this.calculatedSize += this.sizes[index];
        };
      }
      removeItemSize(index) {}
      addItemSize(index, size) {}
      requireSize(k, v, size, sizeCalculation) {
        if (size || sizeCalculation) throw new TypeError("cannot set size without setting maxSize on cache");
      }
      *indexes({
        allowStale = this.allowStale
      } = {}) {
        if (this.size) for (let i = this.tail; !(!this.isValidIndex(i) || ((allowStale || !this.isStale(i)) && (yield i), i === this.head));) i = this.prev[i];
      }
      *rindexes({
        allowStale = this.allowStale
      } = {}) {
        if (this.size) for (let i = this.head; !(!this.isValidIndex(i) || ((allowStale || !this.isStale(i)) && (yield i), i === this.tail));) i = this.next[i];
      }
      isValidIndex(index) {
        return this.keyMap.get(this.keyList[index]) === index;
      }
      *entries() {
        for (let i of this.indexes()) yield [this.keyList[i], this.valList[i]];
      }
      *rentries() {
        for (let i of this.rindexes()) yield [this.keyList[i], this.valList[i]];
      }
      *keys() {
        for (let i of this.indexes()) yield this.keyList[i];
      }
      *rkeys() {
        for (let i of this.rindexes()) yield this.keyList[i];
      }
      *values() {
        for (let i of this.indexes()) yield this.valList[i];
      }
      *rvalues() {
        for (let i of this.rindexes()) yield this.valList[i];
      }
      [Symbol.iterator]() {
        return this.entries();
      }
      find(fn, getOptions = {}) {
        for (let i of this.indexes()) if (fn(this.valList[i], this.keyList[i], this)) return this.get(this.keyList[i], getOptions);
      }
      forEach(fn, thisp = this) {
        for (let i of this.indexes()) fn.call(thisp, this.valList[i], this.keyList[i], this);
      }
      rforEach(fn, thisp = this) {
        for (let i of this.rindexes()) fn.call(thisp, this.valList[i], this.keyList[i], this);
      }
      get prune() {
        return deprecatedMethod("prune", "purgeStale"), this.purgeStale;
      }
      purgeStale() {
        let deleted = !1;
        for (let i of this.rindexes({
          allowStale: !0
        })) this.isStale(i) && (this.delete(this.keyList[i]), deleted = !0);
        return deleted;
      }
      dump() {
        let arr = [];
        for (let i of this.indexes({
          allowStale: !0
        })) {
          let key = this.keyList[i],
            v = this.valList[i],
            entry = {
              value: this.isBackgroundFetch(v) ? v.__staleWhileFetching : v
            };
          if (this.ttls) {
            entry.ttl = this.ttls[i];
            let age = perf.now() - this.starts[i];
            entry.start = Math.floor(Date.now() - age);
          }
          this.sizes && (entry.size = this.sizes[i]), arr.unshift([key, entry]);
        }
        return arr;
      }
      load(arr) {
        this.clear();
        for (let [key, entry] of arr) {
          if (entry.start) {
            let age = Date.now() - entry.start;
            entry.start = perf.now() - age;
          }
          this.set(key, entry.value, entry);
        }
      }
      dispose(v, k, reason) {}
      set(k, v, {
        ttl = this.ttl,
        start: start,
        noDisposeOnSet = this.noDisposeOnSet,
        size = 0,
        sizeCalculation = this.sizeCalculation,
        noUpdateTTL = this.noUpdateTTL
      } = {}) {
        if (size = this.requireSize(k, v, size, sizeCalculation), this.maxSize && size > this.maxSize) return this;
        let index = this.size === 0 ? void 0 : this.keyMap.get(k);
        if (index === void 0) index = this.newIndex(), this.keyList[index] = k, this.valList[index] = v, this.keyMap.set(k, index), this.next[this.tail] = index, this.prev[index] = this.tail, this.tail = index, this.size++, this.addItemSize(index, size), noUpdateTTL = !1;else {
          let oldVal = this.valList[index];
          v !== oldVal && (this.isBackgroundFetch(oldVal) ? oldVal.__abortController.abort() : noDisposeOnSet || (this.dispose(oldVal, k, "set"), this.disposeAfter && this.disposed.push([oldVal, k, "set"])), this.removeItemSize(index), this.valList[index] = v, this.addItemSize(index, size)), this.moveToTail(index);
        }
        if (ttl !== 0 && this.ttl === 0 && !this.ttls && this.initializeTTLTracking(), noUpdateTTL || this.setItemTTL(index, ttl, start), this.disposeAfter) for (; this.disposed.length;) this.disposeAfter(...this.disposed.shift());
        return this;
      }
      newIndex() {
        return this.size === 0 ? this.tail : this.size === this.max && this.max !== 0 ? this.evict(!1) : this.free.length !== 0 ? this.free.pop() : this.initialFill++;
      }
      pop() {
        if (this.size) {
          let val = this.valList[this.head];
          return this.evict(!0), val;
        }
      }
      evict(free) {
        let head = this.head,
          k = this.keyList[head],
          v = this.valList[head];
        return this.isBackgroundFetch(v) ? v.__abortController.abort() : (this.dispose(v, k, "evict"), this.disposeAfter && this.disposed.push([v, k, "evict"])), this.removeItemSize(head), free && (this.keyList[head] = null, this.valList[head] = null, this.free.push(head)), this.head = this.next[head], this.keyMap.delete(k), this.size--, head;
      }
      has(k, {
        updateAgeOnHas = this.updateAgeOnHas
      } = {}) {
        let index = this.keyMap.get(k);
        return index !== void 0 && !this.isStale(index) ? (updateAgeOnHas && this.updateItemAge(index), !0) : !1;
      }
      peek(k, {
        allowStale = this.allowStale
      } = {}) {
        let index = this.keyMap.get(k);
        if (index !== void 0 && (allowStale || !this.isStale(index))) {
          let v = this.valList[index];
          return this.isBackgroundFetch(v) ? v.__staleWhileFetching : v;
        }
      }
      backgroundFetch(k, index, options, context) {
        let v = index === void 0 ? void 0 : this.valList[index];
        if (this.isBackgroundFetch(v)) return v;
        let ac = new AC(),
          fetchOpts = {
            signal: ac.signal,
            options: options,
            context: context
          },
          cb = __name(v => (ac.signal.aborted || this.set(k, v, fetchOpts.options), v), "cb"),
          eb = __name(er => {
            if (this.valList[index] === p && (!options.noDeleteOnFetchRejection || p.__staleWhileFetching === void 0 ? this.delete(k) : this.valList[index] = p.__staleWhileFetching), p.__returned === p) throw er;
          }, "eb"),
          pcall = __name(res => res(this.fetchMethod(k, v, fetchOpts)), "pcall"),
          p = new Promise(pcall).then(cb, eb);
        return p.__abortController = ac, p.__staleWhileFetching = v, p.__returned = null, index === void 0 ? (this.set(k, p, fetchOpts.options), index = this.keyMap.get(k)) : this.valList[index] = p, p;
      }
      isBackgroundFetch(p) {
        return p && typeof p == "object" && typeof p.then == "function" && Object.prototype.hasOwnProperty.call(p, "__staleWhileFetching") && Object.prototype.hasOwnProperty.call(p, "__returned") && (p.__returned === p || p.__returned === null);
      }
      async fetch(k, {
        allowStale = this.allowStale,
        updateAgeOnGet = this.updateAgeOnGet,
        noDeleteOnStaleGet = this.noDeleteOnStaleGet,
        ttl = this.ttl,
        noDisposeOnSet = this.noDisposeOnSet,
        size = 0,
        sizeCalculation = this.sizeCalculation,
        noUpdateTTL = this.noUpdateTTL,
        noDeleteOnFetchRejection = this.noDeleteOnFetchRejection,
        fetchContext = this.fetchContext,
        forceRefresh = !1
      } = {}) {
        if (!this.fetchMethod) return this.get(k, {
          allowStale: allowStale,
          updateAgeOnGet: updateAgeOnGet,
          noDeleteOnStaleGet: noDeleteOnStaleGet
        });
        let options = {
            allowStale: allowStale,
            updateAgeOnGet: updateAgeOnGet,
            noDeleteOnStaleGet: noDeleteOnStaleGet,
            ttl: ttl,
            noDisposeOnSet: noDisposeOnSet,
            size: size,
            sizeCalculation: sizeCalculation,
            noUpdateTTL: noUpdateTTL,
            noDeleteOnFetchRejection: noDeleteOnFetchRejection
          },
          index = this.keyMap.get(k);
        if (index === void 0) {
          let p = this.backgroundFetch(k, index, options, fetchContext);
          return p.__returned = p;
        } else {
          let v = this.valList[index];
          if (this.isBackgroundFetch(v)) return allowStale && v.__staleWhileFetching !== void 0 ? v.__staleWhileFetching : v.__returned = v;
          if (!forceRefresh && !this.isStale(index)) return this.moveToTail(index), updateAgeOnGet && this.updateItemAge(index), v;
          let p = this.backgroundFetch(k, index, options, fetchContext);
          return allowStale && p.__staleWhileFetching !== void 0 ? p.__staleWhileFetching : p.__returned = p;
        }
      }
      get(k, {
        allowStale = this.allowStale,
        updateAgeOnGet = this.updateAgeOnGet,
        noDeleteOnStaleGet = this.noDeleteOnStaleGet
      } = {}) {
        let index = this.keyMap.get(k);
        if (index !== void 0) {
          let value = this.valList[index],
            fetching = this.isBackgroundFetch(value);
          return this.isStale(index) ? fetching ? allowStale ? value.__staleWhileFetching : void 0 : (noDeleteOnStaleGet || this.delete(k), allowStale ? value : void 0) : fetching ? void 0 : (this.moveToTail(index), updateAgeOnGet && this.updateItemAge(index), value);
        }
      }
      connect(p, n) {
        this.prev[n] = p, this.next[p] = n;
      }
      moveToTail(index) {
        index !== this.tail && (index === this.head ? this.head = this.next[index] : this.connect(this.prev[index], this.next[index]), this.connect(this.tail, index), this.tail = index);
      }
      get del() {
        return deprecatedMethod("del", "delete"), this.delete;
      }
      delete(k) {
        let deleted = !1;
        if (this.size !== 0) {
          let index = this.keyMap.get(k);
          if (index !== void 0) if (deleted = !0, this.size === 1) this.clear();else {
            this.removeItemSize(index);
            let v = this.valList[index];
            this.isBackgroundFetch(v) ? v.__abortController.abort() : (this.dispose(v, k, "delete"), this.disposeAfter && this.disposed.push([v, k, "delete"])), this.keyMap.delete(k), this.keyList[index] = null, this.valList[index] = null, index === this.tail ? this.tail = this.prev[index] : index === this.head ? this.head = this.next[index] : (this.next[this.prev[index]] = this.next[index], this.prev[this.next[index]] = this.prev[index]), this.size--, this.free.push(index);
          }
        }
        if (this.disposed) for (; this.disposed.length;) this.disposeAfter(...this.disposed.shift());
        return deleted;
      }
      clear() {
        for (let index of this.rindexes({
          allowStale: !0
        })) {
          let v = this.valList[index];
          if (this.isBackgroundFetch(v)) v.__abortController.abort();else {
            let k = this.keyList[index];
            this.dispose(v, k, "delete"), this.disposeAfter && this.disposed.push([v, k, "delete"]);
          }
        }
        if (this.keyMap.clear(), this.valList.fill(null), this.keyList.fill(null), this.ttls && (this.ttls.fill(0), this.starts.fill(0)), this.sizes && this.sizes.fill(0), this.head = 0, this.tail = 0, this.initialFill = 1, this.free.length = 0, this.calculatedSize = 0, this.size = 0, this.disposed) for (; this.disposed.length;) this.disposeAfter(...this.disposed.shift());
      }
      get reset() {
        return deprecatedMethod("reset", "clear"), this.clear;
      }
      get length() {
        return deprecatedProperty("length", "size"), this.size;
      }
      static get AbortController() {
        return AC;
      }
      static get AbortSignal() {
        return AS;
      }
    };
  __name(_LRUCache, "LRUCache");
  var LRUCache = _LRUCache;
  module.exports = LRUCache;
});