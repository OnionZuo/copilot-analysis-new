var require_source_map_generator = __commonJSMin(exports => {
  var base64VLQ = qG(),
    util = yB(),
    ArraySet = GG().ArraySet,
    MappingList = C_e().MappingList;
  function SourceMapGenerator(aArgs) {
    aArgs || (aArgs = {}), this._file = util.getArg(aArgs, "file", null), this._sourceRoot = util.getArg(aArgs, "sourceRoot", null), this._skipValidation = util.getArg(aArgs, "skipValidation", !1), this._sources = new ArraySet(), this._names = new ArraySet(), this._mappings = new MappingList(), this._sourcesContents = null;
  }
  __name(SourceMapGenerator, "SourceMapGenerator");
  SourceMapGenerator.prototype._version = 3;
  SourceMapGenerator.fromSourceMap = __name(function (aSourceMapConsumer) {
    var sourceRoot = aSourceMapConsumer.sourceRoot,
      generator = new SourceMapGenerator({
        file: aSourceMapConsumer.file,
        sourceRoot: sourceRoot
      });
    return aSourceMapConsumer.eachMapping(function (mapping) {
      var newMapping = {
        generated: {
          line: mapping.generatedLine,
          column: mapping.generatedColumn
        }
      };
      mapping.source != null && (newMapping.source = mapping.source, sourceRoot != null && (newMapping.source = util.relative(sourceRoot, newMapping.source)), newMapping.original = {
        line: mapping.originalLine,
        column: mapping.originalColumn
      }, mapping.name != null && (newMapping.name = mapping.name)), generator.addMapping(newMapping);
    }), aSourceMapConsumer.sources.forEach(function (sourceFile) {
      var sourceRelative = sourceFile;
      sourceRoot !== null && (sourceRelative = util.relative(sourceRoot, sourceFile)), generator._sources.has(sourceRelative) || generator._sources.add(sourceRelative);
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      content != null && generator.setSourceContent(sourceFile, content);
    }), generator;
  }, "SourceMapGenerator_fromSourceMap");
  SourceMapGenerator.prototype.addMapping = __name(function (aArgs) {
    var generated = util.getArg(aArgs, "generated"),
      original = util.getArg(aArgs, "original", null),
      source = util.getArg(aArgs, "source", null),
      name = util.getArg(aArgs, "name", null);
    this._skipValidation || this._validateMapping(generated, original, source, name), source != null && (source = String(source), this._sources.has(source) || this._sources.add(source)), name != null && (name = String(name), this._names.has(name) || this._names.add(name)), this._mappings.add({
      generatedLine: generated.line,
      generatedColumn: generated.column,
      originalLine: original != null && original.line,
      originalColumn: original != null && original.column,
      source: source,
      name: name
    });
  }, "SourceMapGenerator_addMapping");
  SourceMapGenerator.prototype.setSourceContent = __name(function (aSourceFile, aSourceContent) {
    var source = aSourceFile;
    this._sourceRoot != null && (source = util.relative(this._sourceRoot, source)), aSourceContent != null ? (this._sourcesContents || (this._sourcesContents = Object.create(null)), this._sourcesContents[util.toSetString(source)] = aSourceContent) : this._sourcesContents && (delete this._sourcesContents[util.toSetString(source)], Object.keys(this._sourcesContents).length === 0 && (this._sourcesContents = null));
  }, "SourceMapGenerator_setSourceContent");
  SourceMapGenerator.prototype.applySourceMap = __name(function (aSourceMapConsumer, aSourceFile, aSourceMapPath) {
    var sourceFile = aSourceFile;
    if (aSourceFile == null) {
      if (aSourceMapConsumer.file == null) throw new Error(`SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map's "file" property. Both were omitted.`);
      sourceFile = aSourceMapConsumer.file;
    }
    var sourceRoot = this._sourceRoot;
    sourceRoot != null && (sourceFile = util.relative(sourceRoot, sourceFile));
    var newSources = new ArraySet(),
      newNames = new ArraySet();
    this._mappings.unsortedForEach(function (mapping) {
      if (mapping.source === sourceFile && mapping.originalLine != null) {
        var original = aSourceMapConsumer.originalPositionFor({
          line: mapping.originalLine,
          column: mapping.originalColumn
        });
        original.source != null && (mapping.source = original.source, aSourceMapPath != null && (mapping.source = util.join(aSourceMapPath, mapping.source)), sourceRoot != null && (mapping.source = util.relative(sourceRoot, mapping.source)), mapping.originalLine = original.line, mapping.originalColumn = original.column, original.name != null && (mapping.name = original.name));
      }
      var source = mapping.source;
      source != null && !newSources.has(source) && newSources.add(source);
      var name = mapping.name;
      name != null && !newNames.has(name) && newNames.add(name);
    }, this), this._sources = newSources, this._names = newNames, aSourceMapConsumer.sources.forEach(function (sourceFile) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      content != null && (aSourceMapPath != null && (sourceFile = util.join(aSourceMapPath, sourceFile)), sourceRoot != null && (sourceFile = util.relative(sourceRoot, sourceFile)), this.setSourceContent(sourceFile, content));
    }, this);
  }, "SourceMapGenerator_applySourceMap");
  SourceMapGenerator.prototype._validateMapping = __name(function (aGenerated, aOriginal, aSource, aName) {
    if (aOriginal && typeof aOriginal.line != "number" && typeof aOriginal.column != "number") throw new Error("original.line and original.column are not numbers -- you probably meant to omit the original mapping entirely and only map the generated position. If so, pass null for the original mapping instead of an object with empty or null values.");
    if (!(aGenerated && "line" in aGenerated && "column" in aGenerated && aGenerated.line > 0 && aGenerated.column >= 0 && !aOriginal && !aSource && !aName)) {
      if (aGenerated && "line" in aGenerated && "column" in aGenerated && aOriginal && "line" in aOriginal && "column" in aOriginal && aGenerated.line > 0 && aGenerated.column >= 0 && aOriginal.line > 0 && aOriginal.column >= 0 && aSource) return;
      throw new Error("Invalid mapping: " + JSON.stringify({
        generated: aGenerated,
        source: aSource,
        original: aOriginal,
        name: aName
      }));
    }
  }, "SourceMapGenerator_validateMapping");
  SourceMapGenerator.prototype._serializeMappings = __name(function () {
    for (var previousGeneratedColumn = 0, previousGeneratedLine = 1, previousOriginalColumn = 0, previousOriginalLine = 0, previousName = 0, previousSource = 0, result = "", next, mapping, nameIdx, sourceIdx, mappings = this._mappings.toArray(), i = 0, len = mappings.length; i < len; i++) {
      if (mapping = mappings[i], next = "", mapping.generatedLine !== previousGeneratedLine) for (previousGeneratedColumn = 0; mapping.generatedLine !== previousGeneratedLine;) next += ";", previousGeneratedLine++;else if (i > 0) {
        if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) continue;
        next += ",";
      }
      next += base64VLQ.encode(mapping.generatedColumn - previousGeneratedColumn), previousGeneratedColumn = mapping.generatedColumn, mapping.source != null && (sourceIdx = this._sources.indexOf(mapping.source), next += base64VLQ.encode(sourceIdx - previousSource), previousSource = sourceIdx, next += base64VLQ.encode(mapping.originalLine - 1 - previousOriginalLine), previousOriginalLine = mapping.originalLine - 1, next += base64VLQ.encode(mapping.originalColumn - previousOriginalColumn), previousOriginalColumn = mapping.originalColumn, mapping.name != null && (nameIdx = this._names.indexOf(mapping.name), next += base64VLQ.encode(nameIdx - previousName), previousName = nameIdx)), result += next;
    }
    return result;
  }, "SourceMapGenerator_serializeMappings");
  SourceMapGenerator.prototype._generateSourcesContent = __name(function (aSources, aSourceRoot) {
    return aSources.map(function (source) {
      if (!this._sourcesContents) return null;
      aSourceRoot != null && (source = util.relative(aSourceRoot, source));
      var key = util.toSetString(source);
      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key) ? this._sourcesContents[key] : null;
    }, this);
  }, "SourceMapGenerator_generateSourcesContent");
  SourceMapGenerator.prototype.toJSON = __name(function () {
    var map = {
      version: this._version,
      sources: this._sources.toArray(),
      names: this._names.toArray(),
      mappings: this._serializeMappings()
    };
    return this._file != null && (map.file = this._file), this._sourceRoot != null && (map.sourceRoot = this._sourceRoot), this._sourcesContents && (map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot)), map;
  }, "SourceMapGenerator_toJSON");
  SourceMapGenerator.prototype.toString = __name(function () {
    return JSON.stringify(this.toJSON());
  }, "SourceMapGenerator_toString");
  exports.SourceMapGenerator = SourceMapGenerator;
});