var require_source_node = __commonJSMin(exports => {
  var SourceMapGenerator = ZG().SourceMapGenerator,
    util = yB(),
    REGEX_NEWLINE = /(\r?\n)/,
    NEWLINE_CODE = 10,
    isSourceNode = "$$$isSourceNode$$$";
  function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
    this.children = [], this.sourceContents = {}, this.line = aLine == null ? null : aLine, this.column = aColumn == null ? null : aColumn, this.source = aSource == null ? null : aSource, this.name = aName == null ? null : aName, this[isSourceNode] = !0, aChunks != null && this.add(aChunks);
  }
  __name(SourceNode, "SourceNode");
  SourceNode.fromStringWithSourceMap = __name(function (aGeneratedCode, aSourceMapConsumer, aRelativePath) {
    var node = new SourceNode(),
      remainingLines = aGeneratedCode.split(REGEX_NEWLINE),
      remainingLinesIndex = 0,
      shiftNextLine = __name(function () {
        var lineContents = getNextLine(),
          newLine = getNextLine() || "";
        return lineContents + newLine;
        function getNextLine() {
          return remainingLinesIndex < remainingLines.length ? remainingLines[remainingLinesIndex++] : void 0;
        }
      }, "shiftNextLine"),
      lastGeneratedLine = 1,
      lastGeneratedColumn = 0,
      lastMapping = null;
    return aSourceMapConsumer.eachMapping(function (mapping) {
      if (lastMapping !== null) if (lastGeneratedLine < mapping.generatedLine) addMappingWithCode(lastMapping, shiftNextLine()), lastGeneratedLine++, lastGeneratedColumn = 0;else {
        var nextLine = remainingLines[remainingLinesIndex] || "",
          code = nextLine.substr(0, mapping.generatedColumn - lastGeneratedColumn);
        remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn - lastGeneratedColumn), lastGeneratedColumn = mapping.generatedColumn, addMappingWithCode(lastMapping, code), lastMapping = mapping;
        return;
      }
      for (; lastGeneratedLine < mapping.generatedLine;) node.add(shiftNextLine()), lastGeneratedLine++;
      if (lastGeneratedColumn < mapping.generatedColumn) {
        var nextLine = remainingLines[remainingLinesIndex] || "";
        node.add(nextLine.substr(0, mapping.generatedColumn)), remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn), lastGeneratedColumn = mapping.generatedColumn;
      }
      lastMapping = mapping;
    }, this), remainingLinesIndex < remainingLines.length && (lastMapping && addMappingWithCode(lastMapping, shiftNextLine()), node.add(remainingLines.splice(remainingLinesIndex).join(""))), aSourceMapConsumer.sources.forEach(function (sourceFile) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      content != null && (aRelativePath != null && (sourceFile = util.join(aRelativePath, sourceFile)), node.setSourceContent(sourceFile, content));
    }), node;
    function addMappingWithCode(mapping, code) {
      if (mapping === null || mapping.source === void 0) node.add(code);else {
        var source = aRelativePath ? util.join(aRelativePath, mapping.source) : mapping.source;
        node.add(new SourceNode(mapping.originalLine, mapping.originalColumn, source, code, mapping.name));
      }
    }
    __name(addMappingWithCode, "addMappingWithCode");
  }, "SourceNode_fromStringWithSourceMap");
  SourceNode.prototype.add = __name(function (aChunk) {
    if (Array.isArray(aChunk)) aChunk.forEach(function (chunk) {
      this.add(chunk);
    }, this);else if (aChunk[isSourceNode] || typeof aChunk == "string") aChunk && this.children.push(aChunk);else throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);
    return this;
  }, "SourceNode_add");
  SourceNode.prototype.prepend = __name(function (aChunk) {
    if (Array.isArray(aChunk)) for (var i = aChunk.length - 1; i >= 0; i--) this.prepend(aChunk[i]);else if (aChunk[isSourceNode] || typeof aChunk == "string") this.children.unshift(aChunk);else throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);
    return this;
  }, "SourceNode_prepend");
  SourceNode.prototype.walk = __name(function (aFn) {
    for (var chunk, i = 0, len = this.children.length; i < len; i++) chunk = this.children[i], chunk[isSourceNode] ? chunk.walk(aFn) : chunk !== "" && aFn(chunk, {
      source: this.source,
      line: this.line,
      column: this.column,
      name: this.name
    });
  }, "SourceNode_walk");
  SourceNode.prototype.join = __name(function (aSep) {
    var newChildren,
      i,
      len = this.children.length;
    if (len > 0) {
      for (newChildren = [], i = 0; i < len - 1; i++) newChildren.push(this.children[i]), newChildren.push(aSep);
      newChildren.push(this.children[i]), this.children = newChildren;
    }
    return this;
  }, "SourceNode_join");
  SourceNode.prototype.replaceRight = __name(function (aPattern, aReplacement) {
    var lastChild = this.children[this.children.length - 1];
    return lastChild[isSourceNode] ? lastChild.replaceRight(aPattern, aReplacement) : typeof lastChild == "string" ? this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement) : this.children.push("".replace(aPattern, aReplacement)), this;
  }, "SourceNode_replaceRight");
  SourceNode.prototype.setSourceContent = __name(function (aSourceFile, aSourceContent) {
    this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
  }, "SourceNode_setSourceContent");
  SourceNode.prototype.walkSourceContents = __name(function (aFn) {
    for (var i = 0, len = this.children.length; i < len; i++) this.children[i][isSourceNode] && this.children[i].walkSourceContents(aFn);
    for (var sources = Object.keys(this.sourceContents), i = 0, len = sources.length; i < len; i++) aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
  }, "SourceNode_walkSourceContents");
  SourceNode.prototype.toString = __name(function () {
    var str = "";
    return this.walk(function (chunk) {
      str += chunk;
    }), str;
  }, "SourceNode_toString");
  SourceNode.prototype.toStringWithSourceMap = __name(function (aArgs) {
    var generated = {
        code: "",
        line: 1,
        column: 0
      },
      map = new SourceMapGenerator(aArgs),
      sourceMappingActive = !1,
      lastOriginalSource = null,
      lastOriginalLine = null,
      lastOriginalColumn = null,
      lastOriginalName = null;
    return this.walk(function (chunk, original) {
      generated.code += chunk, original.source !== null && original.line !== null && original.column !== null ? ((lastOriginalSource !== original.source || lastOriginalLine !== original.line || lastOriginalColumn !== original.column || lastOriginalName !== original.name) && map.addMapping({
        source: original.source,
        original: {
          line: original.line,
          column: original.column
        },
        generated: {
          line: generated.line,
          column: generated.column
        },
        name: original.name
      }), lastOriginalSource = original.source, lastOriginalLine = original.line, lastOriginalColumn = original.column, lastOriginalName = original.name, sourceMappingActive = !0) : sourceMappingActive && (map.addMapping({
        generated: {
          line: generated.line,
          column: generated.column
        }
      }), lastOriginalSource = null, sourceMappingActive = !1);
      for (var idx = 0, length = chunk.length; idx < length; idx++) chunk.charCodeAt(idx) === NEWLINE_CODE ? (generated.line++, generated.column = 0, idx + 1 === length ? (lastOriginalSource = null, sourceMappingActive = !1) : sourceMappingActive && map.addMapping({
        source: original.source,
        original: {
          line: original.line,
          column: original.column
        },
        generated: {
          line: generated.line,
          column: generated.column
        },
        name: original.name
      })) : generated.column++;
    }), this.walkSourceContents(function (sourceFile, sourceContent) {
      map.setSourceContent(sourceFile, sourceContent);
    }), {
      code: generated.code,
      map: map
    };
  }, "SourceNode_toStringWithSourceMap");
  exports.SourceNode = SourceNode;
});