var require_worker_pool = __commonJSMin(exports => {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: !0
  });
  var worker_threads_1 = require("worker_threads"),
    v8_1 = require("v8"),
    os_1 = require("os"),
    worker_1 = F$e(),
    WORKER_STATE_READY = "ready",
    WORKER_STATE_SPAWNING = "spawning",
    WORKER_STATE_BUSY = "busy",
    WORKER_STATE_OFF = "off",
    AVAILABLE_CPUS = os_1.cpus().length,
    NODE_VERSION_SPLIT = process.version.replace("v", "").split("."),
    NODE_VERSION_MAJOR = parseInt(NODE_VERSION_SPLIT[0]),
    NODE_VERSION_MINOR = parseInt(NODE_VERSION_SPLIT[1]),
    _WorkerPool = class _WorkerPool {
      constructor() {
        this.maxWorkers = AVAILABLE_CPUS, this.taskQueue = [], this.workers = [];
      }
      resurrect(deadWorker) {
        let worker = new worker_threads_1.Worker(worker_1.workerFile, {
          eval: !0
        });
        deadWorker.status = WORKER_STATE_SPAWNING, deadWorker.worker = worker, worker.once("online", () => process.nextTick(() => {
          deadWorker.status = WORKER_STATE_READY, worker.removeAllListeners(), this.tick();
        })), worker.once("error", error => {
          console.error(error), deadWorker.status = WORKER_STATE_OFF, worker.removeAllListeners(), this.tick();
        });
      }
      tick() {
        if (this.workers.filter(({
          status: status
        }) => status === WORKER_STATE_OFF).forEach(deadWorker => this.resurrect(deadWorker)), this.taskQueue.length === 0) return;
        let availableWorker;
        for (let i = 0; i < this.workers.length; i++) if (this.workers[i].status === WORKER_STATE_READY) {
          availableWorker = this.workers[i];
          break;
        }
        if (typeof availableWorker > "u") return;
        let work = this.taskQueue.shift();
        availableWorker.status = WORKER_STATE_BUSY;
        let {
            worker: worker
          } = availableWorker,
          {
            handler: handler,
            config: config,
            resolve: resolve,
            reject: reject
          } = work;
        try {
          let variables = "";
          for (let key in config.ctx) {
            if (!config.ctx.hasOwnProperty(key)) continue;
            let variable;
            switch (typeof config.ctx[key]) {
              case "string":
                variable = `'${config.ctx[key]}'`;
                break;
              case "object":
                variable = JSON.stringify(config.ctx[key]);
                break;
              default:
                variable = config.ctx[key];
            }
            variables += `let ${key} = ${variable}
`;
          }
          let dataSerialized = v8_1.serialize(config.data),
            dataStr = JSON.stringify(dataSerialized),
            workerStr = `
      async function __executor__() {
        const v8 = require('v8')
        ${variables}
        const dataParsed = JSON.parse('${dataStr}')
        const dataBuffer = Buffer.from(dataParsed.data)
        const dataDeserialized = v8.deserialize(dataBuffer)
        return await (${handler.toString()})(dataDeserialized)
      }
      `;
          worker.once("message", message => {
            if (this.free(worker), typeof message.error > "u" || message.error === null) return resolve(message.data);
            let error = new Error(message.error.message);
            error.stack = message.error.stack, reject(error);
          }), worker.once("error", error => {
            availableWorker.status = WORKER_STATE_OFF, reject(error), this.tick();
          }), worker.postMessage(workerStr);
        } catch (err) {
          this.free(worker), reject(err);
        }
      }
      enqueue({
        handler: handler,
        config: config,
        resolve: resolve,
        reject: reject
      }) {
        this.taskQueue.push({
          handler: handler,
          config: config,
          resolve: resolve,
          reject: reject
        }), this.tick();
      }
      free(worker) {
        for (let i = 0; i < this.workers.length; i++) if (worker.threadId === this.workers[i].worker.threadId) {
          this.workers[i].status = WORKER_STATE_READY, this.workers[i].worker.removeAllListeners(), this.tick();
          break;
        }
      }
      setup(config = {}) {
        return this.maxWorkers = config.maxWorkers > 0 ? config.maxWorkers : AVAILABLE_CPUS, this.maxWorkers > 10 && console.warn(`Worker pool has more than 10 workers.
You should also increase the Max Listeners of Node.js (https://nodejs.org/docs/latest/api/events.html#events_emitter_setmaxlisteners_n)
Otherwise, limit them with start({maxWorkers: 10})`), new Promise((resolve, reject) => {
          let counterSuccess = 0,
            counterFailure = 0;
          for (let i = 0; i < this.maxWorkers; i++) {
            let worker = new worker_threads_1.Worker(worker_1.workerFile, {
              eval: !0
            });
            this.workers.push({
              status: WORKER_STATE_SPAWNING,
              worker: worker
            }), worker.once("online", (index => () => {
              process.nextTick(() => {
                this.workers[index].status = WORKER_STATE_READY, this.workers[index].worker.removeAllListeners(), counterSuccess++, counterSuccess > 0 && counterSuccess + counterFailure === this.maxWorkers && resolve();
              });
            })(i)), worker.once("error", (index => error => {
              this.workers[index].status = WORKER_STATE_OFF, this.workers[index].worker.removeAllListeners(), counterFailure++, counterFailure === this.maxWorkers && reject(error);
            })(i));
          }
        });
      }
      async teardown() {
        if (NODE_VERSION_MAJOR >= 12 && NODE_VERSION_MINOR >= 5) {
          let terminationPromises = [];
          for (let {
            worker: worker
          } of this.workers) terminationPromises.push(worker.terminate());
          await Promise.all(terminationPromises), this.workers = [];
        } else await new Promise(resolve => {
          let counter = 0;
          for (let i = 0; i < this.workers.length; i++) this.workers[i].worker.terminate(() => {
            counter++, counter === this.workers.length && (this.workers = [], resolve());
          });
        });
      }
    };
  __name(_WorkerPool, "WorkerPool");
  var WorkerPool = _WorkerPool;
  exports.default = new WorkerPool();
});