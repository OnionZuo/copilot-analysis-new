var require_http_cache_semantics = __commonJSMin((exports, module) => {
  "use strict";

  var statusCodeCacheableByDefault = new Set([200, 203, 204, 206, 300, 301, 308, 404, 405, 410, 414, 501]),
    understoodStatuses = new Set([200, 203, 204, 300, 301, 302, 303, 307, 308, 404, 405, 410, 414, 501]),
    errorStatusCodes = new Set([500, 502, 503, 504]),
    hopByHopHeaders = {
      date: !0,
      connection: !0,
      "keep-alive": !0,
      "proxy-authenticate": !0,
      "proxy-authorization": !0,
      te: !0,
      trailer: !0,
      "transfer-encoding": !0,
      upgrade: !0
    },
    excludedFromRevalidationUpdate = {
      "content-length": !0,
      "content-encoding": !0,
      "transfer-encoding": !0,
      "content-range": !0
    };
  function toNumberOrZero(s) {
    let n = parseInt(s, 10);
    return isFinite(n) ? n : 0;
  }
  __name(toNumberOrZero, "toNumberOrZero");
  function isErrorResponse(response) {
    return response ? errorStatusCodes.has(response.status) : !0;
  }
  __name(isErrorResponse, "isErrorResponse");
  function parseCacheControl(header) {
    let cc = {};
    if (!header) return cc;
    let parts = header.trim().split(/,/);
    for (let part of parts) {
      let [k, v] = part.split(/=/, 2);
      cc[k.trim()] = v === void 0 ? !0 : v.trim().replace(/^"|"$/g, "");
    }
    return cc;
  }
  __name(parseCacheControl, "parseCacheControl");
  function formatCacheControl(cc) {
    let parts = [];
    for (let k in cc) {
      let v = cc[k];
      parts.push(v === !0 ? k : k + "=" + v);
    }
    if (parts.length) return parts.join(", ");
  }
  __name(formatCacheControl, "formatCacheControl");
  var _a;
  module.exports = (_a = class {
    constructor(req, res, {
      shared: shared,
      cacheHeuristic: cacheHeuristic,
      immutableMinTimeToLive: immutableMinTimeToLive,
      ignoreCargoCult: ignoreCargoCult,
      _fromObject: _fromObject
    } = {}) {
      if (_fromObject) {
        this._fromObject(_fromObject);
        return;
      }
      if (!res || !res.headers) throw Error("Response headers missing");
      this._assertRequestHasHeaders(req), this._responseTime = this.now(), this._isShared = shared !== !1, this._cacheHeuristic = cacheHeuristic !== void 0 ? cacheHeuristic : .1, this._immutableMinTtl = immutableMinTimeToLive !== void 0 ? immutableMinTimeToLive : 24 * 3600 * 1e3, this._status = "status" in res ? res.status : 200, this._resHeaders = res.headers, this._rescc = parseCacheControl(res.headers["cache-control"]), this._method = "method" in req ? req.method : "GET", this._url = req.url, this._host = req.headers.host, this._noAuthorization = !req.headers.authorization, this._reqHeaders = res.headers.vary ? req.headers : null, this._reqcc = parseCacheControl(req.headers["cache-control"]), ignoreCargoCult && "pre-check" in this._rescc && "post-check" in this._rescc && (delete this._rescc["pre-check"], delete this._rescc["post-check"], delete this._rescc["no-cache"], delete this._rescc["no-store"], delete this._rescc["must-revalidate"], this._resHeaders = Object.assign({}, this._resHeaders, {
        "cache-control": formatCacheControl(this._rescc)
      }), delete this._resHeaders.expires, delete this._resHeaders.pragma), res.headers["cache-control"] == null && /no-cache/.test(res.headers.pragma) && (this._rescc["no-cache"] = !0);
    }
    now() {
      return Date.now();
    }
    storable() {
      return !!(!this._reqcc["no-store"] && (this._method === "GET" || this._method === "HEAD" || this._method === "POST" && this._hasExplicitExpiration()) && understoodStatuses.has(this._status) && !this._rescc["no-store"] && (!this._isShared || !this._rescc.private) && (!this._isShared || this._noAuthorization || this._allowsStoringAuthenticated()) && (this._resHeaders.expires || this._rescc["max-age"] || this._isShared && this._rescc["s-maxage"] || this._rescc.public || statusCodeCacheableByDefault.has(this._status)));
    }
    _hasExplicitExpiration() {
      return this._isShared && this._rescc["s-maxage"] || this._rescc["max-age"] || this._resHeaders.expires;
    }
    _assertRequestHasHeaders(req) {
      if (!req || !req.headers) throw Error("Request headers missing");
    }
    satisfiesWithoutRevalidation(req) {
      this._assertRequestHasHeaders(req);
      let requestCC = parseCacheControl(req.headers["cache-control"]);
      return requestCC["no-cache"] || /no-cache/.test(req.headers.pragma) || requestCC["max-age"] && this.age() > requestCC["max-age"] || requestCC["min-fresh"] && this.timeToLive() < 1e3 * requestCC["min-fresh"] || this.stale() && !(requestCC["max-stale"] && !this._rescc["must-revalidate"] && (requestCC["max-stale"] === !0 || requestCC["max-stale"] > this.age() - this.maxAge())) ? !1 : this._requestMatches(req, !1);
    }
    _requestMatches(req, allowHeadMethod) {
      return (!this._url || this._url === req.url) && this._host === req.headers.host && (!req.method || this._method === req.method || allowHeadMethod && req.method === "HEAD") && this._varyMatches(req);
    }
    _allowsStoringAuthenticated() {
      return this._rescc["must-revalidate"] || this._rescc.public || this._rescc["s-maxage"];
    }
    _varyMatches(req) {
      if (!this._resHeaders.vary) return !0;
      if (this._resHeaders.vary === "*") return !1;
      let fields = this._resHeaders.vary.trim().toLowerCase().split(/\s*,\s*/);
      for (let name of fields) if (req.headers[name] !== this._reqHeaders[name]) return !1;
      return !0;
    }
    _copyWithoutHopByHopHeaders(inHeaders) {
      let headers = {};
      for (let name in inHeaders) hopByHopHeaders[name] || (headers[name] = inHeaders[name]);
      if (inHeaders.connection) {
        let tokens = inHeaders.connection.trim().split(/\s*,\s*/);
        for (let name of tokens) delete headers[name];
      }
      if (headers.warning) {
        let warnings = headers.warning.split(/,/).filter(warning => !/^\s*1[0-9][0-9]/.test(warning));
        warnings.length ? headers.warning = warnings.join(",").trim() : delete headers.warning;
      }
      return headers;
    }
    responseHeaders() {
      let headers = this._copyWithoutHopByHopHeaders(this._resHeaders),
        age = this.age();
      return age > 3600 * 24 && !this._hasExplicitExpiration() && this.maxAge() > 3600 * 24 && (headers.warning = (headers.warning ? `${headers.warning}, ` : "") + '113 - "rfc7234 5.5.4"'), headers.age = `${Math.round(age)}`, headers.date = new Date(this.now()).toUTCString(), headers;
    }
    date() {
      let serverDate = Date.parse(this._resHeaders.date);
      return isFinite(serverDate) ? serverDate : this._responseTime;
    }
    age() {
      let age = this._ageValue(),
        residentTime = (this.now() - this._responseTime) / 1e3;
      return age + residentTime;
    }
    _ageValue() {
      return toNumberOrZero(this._resHeaders.age);
    }
    maxAge() {
      if (!this.storable() || this._rescc["no-cache"] || this._isShared && this._resHeaders["set-cookie"] && !this._rescc.public && !this._rescc.immutable || this._resHeaders.vary === "*") return 0;
      if (this._isShared) {
        if (this._rescc["proxy-revalidate"]) return 0;
        if (this._rescc["s-maxage"]) return toNumberOrZero(this._rescc["s-maxage"]);
      }
      if (this._rescc["max-age"]) return toNumberOrZero(this._rescc["max-age"]);
      let defaultMinTtl = this._rescc.immutable ? this._immutableMinTtl : 0,
        serverDate = this.date();
      if (this._resHeaders.expires) {
        let expires = Date.parse(this._resHeaders.expires);
        return Number.isNaN(expires) || expires < serverDate ? 0 : Math.max(defaultMinTtl, (expires - serverDate) / 1e3);
      }
      if (this._resHeaders["last-modified"]) {
        let lastModified = Date.parse(this._resHeaders["last-modified"]);
        if (isFinite(lastModified) && serverDate > lastModified) return Math.max(defaultMinTtl, (serverDate - lastModified) / 1e3 * this._cacheHeuristic);
      }
      return defaultMinTtl;
    }
    timeToLive() {
      let age = this.maxAge() - this.age(),
        staleIfErrorAge = age + toNumberOrZero(this._rescc["stale-if-error"]),
        staleWhileRevalidateAge = age + toNumberOrZero(this._rescc["stale-while-revalidate"]);
      return Math.max(0, age, staleIfErrorAge, staleWhileRevalidateAge) * 1e3;
    }
    stale() {
      return this.maxAge() <= this.age();
    }
    _useStaleIfError() {
      return this.maxAge() + toNumberOrZero(this._rescc["stale-if-error"]) > this.age();
    }
    useStaleWhileRevalidate() {
      return this.maxAge() + toNumberOrZero(this._rescc["stale-while-revalidate"]) > this.age();
    }
    static fromObject(obj) {
      return new this(void 0, void 0, {
        _fromObject: obj
      });
    }
    _fromObject(obj) {
      if (this._responseTime) throw Error("Reinitialized");
      if (!obj || obj.v !== 1) throw Error("Invalid serialization");
      this._responseTime = obj.t, this._isShared = obj.sh, this._cacheHeuristic = obj.ch, this._immutableMinTtl = obj.imm !== void 0 ? obj.imm : 24 * 3600 * 1e3, this._status = obj.st, this._resHeaders = obj.resh, this._rescc = obj.rescc, this._method = obj.m, this._url = obj.u, this._host = obj.h, this._noAuthorization = obj.a, this._reqHeaders = obj.reqh, this._reqcc = obj.reqcc;
    }
    toObject() {
      return {
        v: 1,
        t: this._responseTime,
        sh: this._isShared,
        ch: this._cacheHeuristic,
        imm: this._immutableMinTtl,
        st: this._status,
        resh: this._resHeaders,
        rescc: this._rescc,
        m: this._method,
        u: this._url,
        h: this._host,
        a: this._noAuthorization,
        reqh: this._reqHeaders,
        reqcc: this._reqcc
      };
    }
    revalidationHeaders(incomingReq) {
      this._assertRequestHasHeaders(incomingReq);
      let headers = this._copyWithoutHopByHopHeaders(incomingReq.headers);
      if (delete headers["if-range"], !this._requestMatches(incomingReq, !0) || !this.storable()) return delete headers["if-none-match"], delete headers["if-modified-since"], headers;
      if (this._resHeaders.etag && (headers["if-none-match"] = headers["if-none-match"] ? `${headers["if-none-match"]}, ${this._resHeaders.etag}` : this._resHeaders.etag), headers["accept-ranges"] || headers["if-match"] || headers["if-unmodified-since"] || this._method && this._method != "GET") {
        if (delete headers["if-modified-since"], headers["if-none-match"]) {
          let etags = headers["if-none-match"].split(/,/).filter(etag => !/^\s*W\//.test(etag));
          etags.length ? headers["if-none-match"] = etags.join(",").trim() : delete headers["if-none-match"];
        }
      } else this._resHeaders["last-modified"] && !headers["if-modified-since"] && (headers["if-modified-since"] = this._resHeaders["last-modified"]);
      return headers;
    }
    revalidatedPolicy(request, response) {
      if (this._assertRequestHasHeaders(request), this._useStaleIfError() && isErrorResponse(response)) return {
        modified: !1,
        matches: !1,
        policy: this
      };
      if (!response || !response.headers) throw Error("Response headers missing");
      let matches = !1;
      if (response.status !== void 0 && response.status != 304 ? matches = !1 : response.headers.etag && !/^\s*W\//.test(response.headers.etag) ? matches = this._resHeaders.etag && this._resHeaders.etag.replace(/^\s*W\//, "") === response.headers.etag : this._resHeaders.etag && response.headers.etag ? matches = this._resHeaders.etag.replace(/^\s*W\//, "") === response.headers.etag.replace(/^\s*W\//, "") : this._resHeaders["last-modified"] ? matches = this._resHeaders["last-modified"] === response.headers["last-modified"] : !this._resHeaders.etag && !this._resHeaders["last-modified"] && !response.headers.etag && !response.headers["last-modified"] && (matches = !0), !matches) return {
        policy: new this.constructor(request, response),
        modified: response.status != 304,
        matches: !1
      };
      let headers = {};
      for (let k in this._resHeaders) headers[k] = k in response.headers && !excludedFromRevalidationUpdate[k] ? response.headers[k] : this._resHeaders[k];
      let newResponse = Object.assign({}, response, {
        status: this._status,
        method: this._method,
        headers: headers
      });
      return {
        policy: new this.constructor(request, newResponse, {
          shared: this._isShared,
          cacheHeuristic: this._cacheHeuristic,
          immutableMinTimeToLive: this._immutableMinTtl
        }),
        modified: !1,
        matches: !0
      };
    }
  }, __name(_a, "CachePolicy"), _a);
});