var require_main = __commonJSMin(exports => {
  "use strict";

  var __createBinding = exports && exports.__createBinding || (Object.create ? function (o, m, k, k2) {
      k2 === void 0 && (k2 = k);
      var desc = Object.getOwnPropertyDescriptor(m, k);
      (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) && (desc = {
        enumerable: !0,
        get: __name(function () {
          return m[k];
        }, "get")
      }), Object.defineProperty(o, k2, desc);
    } : function (o, m, k, k2) {
      k2 === void 0 && (k2 = k), o[k2] = m[k];
    }),
    __exportStar = exports && exports.__exportStar || function (m, exports) {
      for (var p in m) p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p) && __createBinding(exports, m, p);
    };
  Object.defineProperty(exports, "__esModule", {
    value: !0
  });
  exports.SettingMonitor = exports.LanguageClient = exports.TransportKind = void 0;
  var cp = require("child_process"),
    fs = require("fs"),
    path = require("path"),
    vscode_1 = require("vscode"),
    Is = yp(),
    client_1 = Ahe(),
    processes_1 = bOe(),
    node_1 = uhe(),
    semverParse = tC(),
    semverSatisfies = ZQ();
  __exportStar(uhe(), exports);
  __exportStar(nGe(), exports);
  var REQUIRED_VSCODE_VERSION = "^1.82.0",
    TransportKind;
  (function (TransportKind) {
    TransportKind[TransportKind.stdio = 0] = "stdio", TransportKind[TransportKind.ipc = 1] = "ipc", TransportKind[TransportKind.pipe = 2] = "pipe", TransportKind[TransportKind.socket = 3] = "socket";
  })(TransportKind || (exports.TransportKind = TransportKind = {}));
  var Transport;
  (function (Transport) {
    function isSocket(value) {
      let candidate = value;
      return candidate && candidate.kind === TransportKind.socket && Is.number(candidate.port);
    }
    __name(isSocket, "isSocket"), Transport.isSocket = isSocket;
  })(Transport || (Transport = {}));
  var Executable;
  (function (Executable) {
    function is(value) {
      return Is.string(value.command);
    }
    __name(is, "is"), Executable.is = is;
  })(Executable || (Executable = {}));
  var NodeModule;
  (function (NodeModule) {
    function is(value) {
      return Is.string(value.module);
    }
    __name(is, "is"), NodeModule.is = is;
  })(NodeModule || (NodeModule = {}));
  var StreamInfo;
  (function (StreamInfo) {
    function is(value) {
      let candidate = value;
      return candidate && candidate.writer !== void 0 && candidate.reader !== void 0;
    }
    __name(is, "is"), StreamInfo.is = is;
  })(StreamInfo || (StreamInfo = {}));
  var ChildProcessInfo;
  (function (ChildProcessInfo) {
    function is(value) {
      let candidate = value;
      return candidate && candidate.process !== void 0 && typeof candidate.detached == "boolean";
    }
    __name(is, "is"), ChildProcessInfo.is = is;
  })(ChildProcessInfo || (ChildProcessInfo = {}));
  var _LanguageClient = class _LanguageClient extends client_1.BaseLanguageClient {
    constructor(arg1, arg2, arg3, arg4, arg5) {
      let id, name, serverOptions, clientOptions, forceDebug;
      Is.string(arg2) ? (id = arg1, name = arg2, serverOptions = arg3, clientOptions = arg4, forceDebug = !!arg5) : (id = arg1.toLowerCase(), name = arg1, serverOptions = arg2, clientOptions = arg3, forceDebug = arg4), forceDebug === void 0 && (forceDebug = !1), super(id, name, clientOptions), this._serverOptions = serverOptions, this._forceDebug = forceDebug, this._isInDebugMode = forceDebug;
      try {
        this.checkVersion();
      } catch (error) {
        throw Is.string(error.message) && this.outputChannel.appendLine(error.message), error;
      }
    }
    checkVersion() {
      let codeVersion = semverParse(vscode_1.version);
      if (!codeVersion) throw new Error(`No valid VS Code version detected. Version string is: ${vscode_1.version}`);
      if (codeVersion.prerelease && codeVersion.prerelease.length > 0 && (codeVersion.prerelease = []), !semverSatisfies(codeVersion, REQUIRED_VSCODE_VERSION)) throw new Error(`The language client requires VS Code version ${REQUIRED_VSCODE_VERSION} but received version ${vscode_1.version}`);
    }
    get isInDebugMode() {
      return this._isInDebugMode;
    }
    async restart() {
      await this.stop(), this.isInDebugMode ? (await new Promise(resolve => setTimeout(resolve, 1e3)), await this.start()) : await this.start();
    }
    stop(timeout = 2e3) {
      return super.stop(timeout).finally(() => {
        if (this._serverProcess) {
          let toCheck = this._serverProcess;
          this._serverProcess = void 0, (this._isDetached === void 0 || !this._isDetached) && this.checkProcessDied(toCheck), this._isDetached = void 0;
        }
      });
    }
    checkProcessDied(childProcess) {
      !childProcess || childProcess.pid === void 0 || setTimeout(() => {
        try {
          childProcess.pid !== void 0 && (process.kill(childProcess.pid, 0), (0, processes_1.terminate)(childProcess));
        } catch {}
      }, 2e3);
    }
    handleConnectionClosed() {
      return this._serverProcess = void 0, super.handleConnectionClosed();
    }
    fillInitializeParams(params) {
      super.fillInitializeParams(params), params.processId === null && (params.processId = process.pid);
    }
    createMessageTransports(encoding) {
      function getEnvironment(env, fork) {
        if (!env && !fork) return;
        let result = Object.create(null);
        return Object.keys(process.env).forEach(key => result[key] = process.env[key]), fork && (result.ELECTRON_RUN_AS_NODE = "1", result.ELECTRON_NO_ASAR = "1"), env && Object.keys(env).forEach(key => result[key] = env[key]), result;
      }
      __name(getEnvironment, "getEnvironment");
      let debugStartWith = ["--debug=", "--debug-brk=", "--inspect=", "--inspect-brk="],
        debugEquals = ["--debug", "--debug-brk", "--inspect", "--inspect-brk"];
      function startedInDebugMode() {
        let args = process.execArgv;
        return args ? args.some(arg => debugStartWith.some(value => arg.startsWith(value)) || debugEquals.some(value => arg === value)) : !1;
      }
      __name(startedInDebugMode, "startedInDebugMode");
      function assertStdio(process) {
        if (process.stdin === null || process.stdout === null || process.stderr === null) throw new Error("Process created without stdio streams");
      }
      __name(assertStdio, "assertStdio");
      let server = this._serverOptions;
      if (Is.func(server)) return server().then(result => {
        if (client_1.MessageTransports.is(result)) return this._isDetached = !!result.detached, result;
        if (StreamInfo.is(result)) return this._isDetached = !!result.detached, {
          reader: new node_1.StreamMessageReader(result.reader),
          writer: new node_1.StreamMessageWriter(result.writer)
        };
        {
          let cp;
          return ChildProcessInfo.is(result) ? (cp = result.process, this._isDetached = result.detached) : (cp = result, this._isDetached = !1), cp.stderr.on("data", data => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding))), {
            reader: new node_1.StreamMessageReader(cp.stdout),
            writer: new node_1.StreamMessageWriter(cp.stdin)
          };
        }
      });
      let json,
        runDebug = server;
      return runDebug.run || runDebug.debug ? this._forceDebug || startedInDebugMode() ? (json = runDebug.debug, this._isInDebugMode = !0) : (json = runDebug.run, this._isInDebugMode = !1) : json = server, this._getServerWorkingDir(json.options).then(serverWorkingDir => {
        var _a;
        if (NodeModule.is(json) && json.module) {
          let node = json,
            transport = node.transport || TransportKind.stdio;
          if (node.runtime) {
            let args = [],
              options = (_a = node.options) != null ? _a : Object.create(null);
            options.execArgv && options.execArgv.forEach(element => args.push(element)), args.push(node.module), node.args && node.args.forEach(element => args.push(element));
            let execOptions = Object.create(null);
            execOptions.cwd = serverWorkingDir, execOptions.env = getEnvironment(options.env, !1);
            let runtime = this._getRuntimePath(node.runtime, serverWorkingDir),
              pipeName;
            if (transport === TransportKind.ipc ? (execOptions.stdio = [null, null, null, "ipc"], args.push("--node-ipc")) : transport === TransportKind.stdio ? args.push("--stdio") : transport === TransportKind.pipe ? (pipeName = (0, node_1.generateRandomPipeName)(), args.push(`--pipe=${pipeName}`)) : Transport.isSocket(transport) && args.push(`--socket=${transport.port}`), args.push(`--clientProcessId=${process.pid.toString()}`), transport === TransportKind.ipc || transport === TransportKind.stdio) {
              let serverProcess = cp.spawn(runtime, args, execOptions);
              return !serverProcess || !serverProcess.pid ? handleChildProcessStartError(serverProcess, `Launching server using runtime ${runtime} failed.`) : (this._serverProcess = serverProcess, serverProcess.stderr.on("data", data => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding))), transport === TransportKind.ipc ? (serverProcess.stdout.on("data", data => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding))), Promise.resolve({
                reader: new node_1.IPCMessageReader(serverProcess),
                writer: new node_1.IPCMessageWriter(serverProcess)
              })) : Promise.resolve({
                reader: new node_1.StreamMessageReader(serverProcess.stdout),
                writer: new node_1.StreamMessageWriter(serverProcess.stdin)
              }));
            } else {
              if (transport === TransportKind.pipe) return (0, node_1.createClientPipeTransport)(pipeName).then(transport => {
                let process = cp.spawn(runtime, args, execOptions);
                return !process || !process.pid ? handleChildProcessStartError(process, `Launching server using runtime ${runtime} failed.`) : (this._serverProcess = process, process.stderr.on("data", data => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding))), process.stdout.on("data", data => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding))), transport.onConnected().then(protocol => ({
                  reader: protocol[0],
                  writer: protocol[1]
                })));
              });
              if (Transport.isSocket(transport)) return (0, node_1.createClientSocketTransport)(transport.port).then(transport => {
                let process = cp.spawn(runtime, args, execOptions);
                return !process || !process.pid ? handleChildProcessStartError(process, `Launching server using runtime ${runtime} failed.`) : (this._serverProcess = process, process.stderr.on("data", data => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding))), process.stdout.on("data", data => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding))), transport.onConnected().then(protocol => ({
                  reader: protocol[0],
                  writer: protocol[1]
                })));
              });
            }
          } else {
            let pipeName;
            return new Promise((resolve, reject) => {
              var _a, _b;
              let args = (_a = node.args && node.args.slice()) != null ? _a : [];
              transport === TransportKind.ipc ? args.push("--node-ipc") : transport === TransportKind.stdio ? args.push("--stdio") : transport === TransportKind.pipe ? (pipeName = (0, node_1.generateRandomPipeName)(), args.push(`--pipe=${pipeName}`)) : Transport.isSocket(transport) && args.push(`--socket=${transport.port}`), args.push(`--clientProcessId=${process.pid.toString()}`);
              let options = (_b = node.options) != null ? _b : Object.create(null);
              if (options.env = getEnvironment(options.env, !0), options.execArgv = options.execArgv || [], options.cwd = serverWorkingDir, options.silent = !0, transport === TransportKind.ipc || transport === TransportKind.stdio) {
                let sp = cp.fork(node.module, args || [], options);
                assertStdio(sp), this._serverProcess = sp, sp.stderr.on("data", data => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding))), transport === TransportKind.ipc ? (sp.stdout.on("data", data => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding))), resolve({
                  reader: new node_1.IPCMessageReader(this._serverProcess),
                  writer: new node_1.IPCMessageWriter(this._serverProcess)
                })) : resolve({
                  reader: new node_1.StreamMessageReader(sp.stdout),
                  writer: new node_1.StreamMessageWriter(sp.stdin)
                });
              } else transport === TransportKind.pipe ? (0, node_1.createClientPipeTransport)(pipeName).then(transport => {
                let sp = cp.fork(node.module, args || [], options);
                assertStdio(sp), this._serverProcess = sp, sp.stderr.on("data", data => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding))), sp.stdout.on("data", data => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding))), transport.onConnected().then(protocol => {
                  resolve({
                    reader: protocol[0],
                    writer: protocol[1]
                  });
                }, reject);
              }, reject) : Transport.isSocket(transport) && (0, node_1.createClientSocketTransport)(transport.port).then(transport => {
                let sp = cp.fork(node.module, args || [], options);
                assertStdio(sp), this._serverProcess = sp, sp.stderr.on("data", data => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding))), sp.stdout.on("data", data => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding))), transport.onConnected().then(protocol => {
                  resolve({
                    reader: protocol[0],
                    writer: protocol[1]
                  });
                }, reject);
              }, reject);
            });
          }
        } else if (Executable.is(json) && json.command) {
          let command = json,
            args = json.args !== void 0 ? json.args.slice(0) : [],
            pipeName,
            transport = json.transport;
          if (transport === TransportKind.stdio) args.push("--stdio");else if (transport === TransportKind.pipe) pipeName = (0, node_1.generateRandomPipeName)(), args.push(`--pipe=${pipeName}`);else if (Transport.isSocket(transport)) args.push(`--socket=${transport.port}`);else if (transport === TransportKind.ipc) throw new Error("Transport kind ipc is not support for command executable");
          let options = Object.assign({}, command.options);
          if (options.cwd = options.cwd || serverWorkingDir, transport === void 0 || transport === TransportKind.stdio) {
            let serverProcess = cp.spawn(command.command, args, options);
            return !serverProcess || !serverProcess.pid ? handleChildProcessStartError(serverProcess, `Launching server using command ${command.command} failed.`) : (serverProcess.stderr.on("data", data => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding))), this._serverProcess = serverProcess, this._isDetached = !!options.detached, Promise.resolve({
              reader: new node_1.StreamMessageReader(serverProcess.stdout),
              writer: new node_1.StreamMessageWriter(serverProcess.stdin)
            }));
          } else {
            if (transport === TransportKind.pipe) return (0, node_1.createClientPipeTransport)(pipeName).then(transport => {
              let serverProcess = cp.spawn(command.command, args, options);
              return !serverProcess || !serverProcess.pid ? handleChildProcessStartError(serverProcess, `Launching server using command ${command.command} failed.`) : (this._serverProcess = serverProcess, this._isDetached = !!options.detached, serverProcess.stderr.on("data", data => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding))), serverProcess.stdout.on("data", data => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding))), transport.onConnected().then(protocol => ({
                reader: protocol[0],
                writer: protocol[1]
              })));
            });
            if (Transport.isSocket(transport)) return (0, node_1.createClientSocketTransport)(transport.port).then(transport => {
              let serverProcess = cp.spawn(command.command, args, options);
              return !serverProcess || !serverProcess.pid ? handleChildProcessStartError(serverProcess, `Launching server using command ${command.command} failed.`) : (this._serverProcess = serverProcess, this._isDetached = !!options.detached, serverProcess.stderr.on("data", data => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding))), serverProcess.stdout.on("data", data => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding))), transport.onConnected().then(protocol => ({
                reader: protocol[0],
                writer: protocol[1]
              })));
            });
          }
        }
        return Promise.reject(new Error("Unsupported server configuration " + JSON.stringify(server, null, 4)));
      }).finally(() => {
        this._serverProcess !== void 0 && this._serverProcess.on("exit", (code, signal) => {
          code !== null && this.error(`Server process exited with code ${code}.`, void 0, !1), signal !== null && this.error(`Server process exited with signal ${signal}.`, void 0, !1);
        });
      });
    }
    _getRuntimePath(runtime, serverWorkingDirectory) {
      if (path.isAbsolute(runtime)) return runtime;
      let mainRootPath = this._mainGetRootPath();
      if (mainRootPath !== void 0) {
        let result = path.join(mainRootPath, runtime);
        if (fs.existsSync(result)) return result;
      }
      if (serverWorkingDirectory !== void 0) {
        let result = path.join(serverWorkingDirectory, runtime);
        if (fs.existsSync(result)) return result;
      }
      return runtime;
    }
    _mainGetRootPath() {
      let folders = vscode_1.workspace.workspaceFolders;
      if (!folders || folders.length === 0) return;
      let folder = folders[0];
      if (folder.uri.scheme === "file") return folder.uri.fsPath;
    }
    _getServerWorkingDir(options) {
      let cwd = options && options.cwd;
      return cwd || (cwd = this.clientOptions.workspaceFolder ? this.clientOptions.workspaceFolder.uri.fsPath : this._mainGetRootPath()), cwd ? new Promise(s => {
        fs.lstat(cwd, (err, stats) => {
          s(!err && stats.isDirectory() ? cwd : void 0);
        });
      }) : Promise.resolve(void 0);
    }
  };
  __name(_LanguageClient, "LanguageClient");
  var LanguageClient = _LanguageClient;
  exports.LanguageClient = LanguageClient;
  var _SettingMonitor = class _SettingMonitor {
    constructor(_client, _setting) {
      this._client = _client, this._setting = _setting, this._listeners = [];
    }
    start() {
      return vscode_1.workspace.onDidChangeConfiguration(this.onDidChangeConfiguration, this, this._listeners), this.onDidChangeConfiguration(), new vscode_1.Disposable(() => {
        this._client.needsStop() && this._client.stop();
      });
    }
    onDidChangeConfiguration() {
      let index = this._setting.indexOf("."),
        primary = index >= 0 ? this._setting.substr(0, index) : this._setting,
        rest = index >= 0 ? this._setting.substr(index + 1) : void 0,
        enabled = rest ? vscode_1.workspace.getConfiguration(primary).get(rest, !1) : vscode_1.workspace.getConfiguration(primary);
      enabled && this._client.needsStart() ? this._client.start().catch(error => this._client.error("Start failed after configuration change", error, "force")) : !enabled && this._client.needsStop() && this._client.stop().catch(error => this._client.error("Stop failed after configuration change", error, "force"));
    }
  };
  __name(_SettingMonitor, "SettingMonitor");
  var SettingMonitor = _SettingMonitor;
  exports.SettingMonitor = SettingMonitor;
  function handleChildProcessStartError(process, message) {
    return process === null ? Promise.reject(message) : new Promise((_, reject) => {
      process.on("error", err => {
        reject(`${message} ${err}`);
      }), setImmediate(() => reject(message));
    });
  }
  __name(handleChildProcessStartError, "handleChildProcessStartError");
});