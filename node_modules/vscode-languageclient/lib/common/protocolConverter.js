var require_protocolConverter = __commonJSMin(exports => {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: !0
  });
  exports.createConverter = void 0;
  var code = require("vscode"),
    ls = Un(),
    Is = yp(),
    async = rq(),
    protocolCompletionItem_1 = hpe(),
    protocolCodeLens_1 = Cpe(),
    protocolDocumentLink_1 = Epe(),
    protocolCodeAction_1 = Qpe(),
    protocolDiagnostic_1 = Tpe(),
    protocolCallHierarchyItem_1 = Ppe(),
    protocolTypeHierarchyItem_1 = qpe(),
    protocolWorkspaceSymbol_1 = Gpe(),
    protocolInlayHint_1 = Ype(),
    vscode_languageserver_protocol_1 = Un(),
    CodeBlock;
  (function (CodeBlock) {
    function is(value) {
      let candidate = value;
      return candidate && Is.string(candidate.language) && Is.string(candidate.value);
    }
    __name(is, "is"), CodeBlock.is = is;
  })(CodeBlock || (CodeBlock = {}));
  function createConverter(uriConverter, trustMarkdown, supportHtml) {
    let _uriConverter = uriConverter || __name(value => code.Uri.parse(value), "nullConverter");
    function asUri(value) {
      return _uriConverter(value);
    }
    __name(asUri, "asUri");
    function asDocumentSelector(selector) {
      var _a;
      let result = [];
      for (let filter of selector) if (typeof filter == "string") result.push(filter);else if (vscode_languageserver_protocol_1.NotebookCellTextDocumentFilter.is(filter)) {
        if (typeof filter.notebook == "string") result.push({
          notebookType: filter.notebook,
          language: filter.language
        });else {
          let notebookType = (_a = filter.notebook.notebookType) != null ? _a : "*";
          result.push({
            notebookType: notebookType,
            scheme: filter.notebook.scheme,
            pattern: filter.notebook.pattern,
            language: filter.language
          });
        }
      } else vscode_languageserver_protocol_1.TextDocumentFilter.is(filter) && result.push({
        language: filter.language,
        scheme: filter.scheme,
        pattern: filter.pattern
      });
      return result;
    }
    __name(asDocumentSelector, "asDocumentSelector");
    async function asDiagnostics(diagnostics, token) {
      return async.map(diagnostics, asDiagnostic, token);
    }
    __name(asDiagnostics, "asDiagnostics");
    function asDiagnosticsSync(diagnostics) {
      let result = new Array(diagnostics.length);
      for (let i = 0; i < diagnostics.length; i++) result[i] = asDiagnostic(diagnostics[i]);
      return result;
    }
    __name(asDiagnosticsSync, "asDiagnosticsSync");
    function asDiagnostic(diagnostic) {
      let result = new protocolDiagnostic_1.ProtocolDiagnostic(asRange(diagnostic.range), diagnostic.message, asDiagnosticSeverity(diagnostic.severity), diagnostic.data);
      if (diagnostic.code !== void 0) {
        if (typeof diagnostic.code == "string" || typeof diagnostic.code == "number") ls.CodeDescription.is(diagnostic.codeDescription) ? result.code = {
          value: diagnostic.code,
          target: asUri(diagnostic.codeDescription.href)
        } : result.code = diagnostic.code;else if (protocolDiagnostic_1.DiagnosticCode.is(diagnostic.code)) {
          result.hasDiagnosticCode = !0;
          let diagnosticCode = diagnostic.code;
          result.code = {
            value: diagnosticCode.value,
            target: asUri(diagnosticCode.target)
          };
        }
      }
      return diagnostic.source && (result.source = diagnostic.source), diagnostic.relatedInformation && (result.relatedInformation = asRelatedInformation(diagnostic.relatedInformation)), Array.isArray(diagnostic.tags) && (result.tags = asDiagnosticTags(diagnostic.tags)), result;
    }
    __name(asDiagnostic, "asDiagnostic");
    function asRelatedInformation(relatedInformation) {
      let result = new Array(relatedInformation.length);
      for (let i = 0; i < relatedInformation.length; i++) {
        let info = relatedInformation[i];
        result[i] = new code.DiagnosticRelatedInformation(asLocation(info.location), info.message);
      }
      return result;
    }
    __name(asRelatedInformation, "asRelatedInformation");
    function asDiagnosticTags(tags) {
      if (!tags) return;
      let result = [];
      for (let tag of tags) {
        let converted = asDiagnosticTag(tag);
        converted !== void 0 && result.push(converted);
      }
      return result.length > 0 ? result : void 0;
    }
    __name(asDiagnosticTags, "asDiagnosticTags");
    function asDiagnosticTag(tag) {
      switch (tag) {
        case ls.DiagnosticTag.Unnecessary:
          return code.DiagnosticTag.Unnecessary;
        case ls.DiagnosticTag.Deprecated:
          return code.DiagnosticTag.Deprecated;
        default:
          return;
      }
    }
    __name(asDiagnosticTag, "asDiagnosticTag");
    function asPosition(value) {
      return value ? new code.Position(value.line, value.character) : void 0;
    }
    __name(asPosition, "asPosition");
    function asRange(value) {
      return value ? new code.Range(value.start.line, value.start.character, value.end.line, value.end.character) : void 0;
    }
    __name(asRange, "asRange");
    async function asRanges(items, token) {
      return async.map(items, range => new code.Range(range.start.line, range.start.character, range.end.line, range.end.character), token);
    }
    __name(asRanges, "asRanges");
    function asDiagnosticSeverity(value) {
      if (value == null) return code.DiagnosticSeverity.Error;
      switch (value) {
        case ls.DiagnosticSeverity.Error:
          return code.DiagnosticSeverity.Error;
        case ls.DiagnosticSeverity.Warning:
          return code.DiagnosticSeverity.Warning;
        case ls.DiagnosticSeverity.Information:
          return code.DiagnosticSeverity.Information;
        case ls.DiagnosticSeverity.Hint:
          return code.DiagnosticSeverity.Hint;
      }
      return code.DiagnosticSeverity.Error;
    }
    __name(asDiagnosticSeverity, "asDiagnosticSeverity");
    function asHoverContent(value) {
      if (Is.string(value)) return asMarkdownString(value);
      if (CodeBlock.is(value)) return asMarkdownString().appendCodeblock(value.value, value.language);
      if (Array.isArray(value)) {
        let result = [];
        for (let element of value) {
          let item = asMarkdownString();
          CodeBlock.is(element) ? item.appendCodeblock(element.value, element.language) : item.appendMarkdown(element), result.push(item);
        }
        return result;
      } else return asMarkdownString(value);
    }
    __name(asHoverContent, "asHoverContent");
    function asDocumentation(value) {
      if (Is.string(value)) return value;
      switch (value.kind) {
        case ls.MarkupKind.Markdown:
          return asMarkdownString(value.value);
        case ls.MarkupKind.PlainText:
          return value.value;
        default:
          return `Unsupported Markup content received. Kind is: ${value.kind}`;
      }
    }
    __name(asDocumentation, "asDocumentation");
    function asMarkdownString(value) {
      let result;
      if (value === void 0 || typeof value == "string") result = new code.MarkdownString(value);else switch (value.kind) {
        case ls.MarkupKind.Markdown:
          result = new code.MarkdownString(value.value);
          break;
        case ls.MarkupKind.PlainText:
          result = new code.MarkdownString(), result.appendText(value.value);
          break;
        default:
          result = new code.MarkdownString(), result.appendText(`Unsupported Markup content received. Kind is: ${value.kind}`);
          break;
      }
      return result.isTrusted = trustMarkdown, result.supportHtml = supportHtml, result;
    }
    __name(asMarkdownString, "asMarkdownString");
    function asHover(hover) {
      if (hover) return new code.Hover(asHoverContent(hover.contents), asRange(hover.range));
    }
    __name(asHover, "asHover");
    async function asCompletionResult(value, allCommitCharacters, token) {
      if (!value) return;
      if (Array.isArray(value)) return async.map(value, item => asCompletionItem(item, allCommitCharacters), token);
      let list = value,
        {
          defaultRange: defaultRange,
          commitCharacters: commitCharacters
        } = getCompletionItemDefaults(list, allCommitCharacters),
        converted = await async.map(list.items, item => {
          var _a, _b, _c;
          return asCompletionItem(item, commitCharacters, defaultRange, (_a = list.itemDefaults) == null ? void 0 : _a.insertTextMode, (_b = list.itemDefaults) == null ? void 0 : _b.insertTextFormat, (_c = list.itemDefaults) == null ? void 0 : _c.data);
        }, token);
      return new code.CompletionList(converted, list.isIncomplete);
    }
    __name(asCompletionResult, "asCompletionResult");
    function getCompletionItemDefaults(list, allCommitCharacters) {
      var _a, _b, _c;
      let rangeDefaults = (_a = list.itemDefaults) == null ? void 0 : _a.editRange,
        commitCharacters = (_c = (_b = list.itemDefaults) == null ? void 0 : _b.commitCharacters) != null ? _c : allCommitCharacters;
      return ls.Range.is(rangeDefaults) ? {
        defaultRange: asRange(rangeDefaults),
        commitCharacters: commitCharacters
      } : rangeDefaults !== void 0 ? {
        defaultRange: {
          inserting: asRange(rangeDefaults.insert),
          replacing: asRange(rangeDefaults.replace)
        },
        commitCharacters: commitCharacters
      } : {
        defaultRange: void 0,
        commitCharacters: commitCharacters
      };
    }
    __name(getCompletionItemDefaults, "getCompletionItemDefaults");
    function asCompletionItemKind(value) {
      return ls.CompletionItemKind.Text <= value && value <= ls.CompletionItemKind.TypeParameter ? [value - 1, void 0] : [code.CompletionItemKind.Text, value];
    }
    __name(asCompletionItemKind, "asCompletionItemKind");
    function asCompletionItemTag(tag) {
      switch (tag) {
        case ls.CompletionItemTag.Deprecated:
          return code.CompletionItemTag.Deprecated;
      }
    }
    __name(asCompletionItemTag, "asCompletionItemTag");
    function asCompletionItemTags(tags) {
      if (tags == null) return [];
      let result = [];
      for (let tag of tags) {
        let converted = asCompletionItemTag(tag);
        converted !== void 0 && result.push(converted);
      }
      return result;
    }
    __name(asCompletionItemTags, "asCompletionItemTags");
    function asCompletionItem(item, defaultCommitCharacters, defaultRange, defaultInsertTextMode, defaultInsertTextFormat, defaultData) {
      var _a, _b;
      let tags = asCompletionItemTags(item.tags),
        label = asCompletionItemLabel(item),
        result = new protocolCompletionItem_1.default(label);
      item.detail && (result.detail = item.detail), item.documentation && (result.documentation = asDocumentation(item.documentation), result.documentationFormat = Is.string(item.documentation) ? "$string" : item.documentation.kind), item.filterText && (result.filterText = item.filterText);
      let insertText = asCompletionInsertText(item, defaultRange, defaultInsertTextFormat);
      if (insertText && (result.insertText = insertText.text, result.range = insertText.range, result.fromEdit = insertText.fromEdit), Is.number(item.kind)) {
        let [itemKind, original] = asCompletionItemKind(item.kind);
        result.kind = itemKind, original && (result.originalItemKind = original);
      }
      item.sortText && (result.sortText = item.sortText), item.additionalTextEdits && (result.additionalTextEdits = asTextEditsSync(item.additionalTextEdits));
      let commitCharacters = item.commitCharacters !== void 0 ? Is.stringArray(item.commitCharacters) ? item.commitCharacters : void 0 : defaultCommitCharacters;
      commitCharacters && (result.commitCharacters = commitCharacters.slice()), item.command && (result.command = asCommand(item.command)), (item.deprecated === !0 || item.deprecated === !1) && (result.deprecated = item.deprecated, item.deprecated === !0 && tags.push(code.CompletionItemTag.Deprecated)), (item.preselect === !0 || item.preselect === !1) && (result.preselect = item.preselect);
      let data = (_a = item.data) != null ? _a : defaultData;
      data !== void 0 && (result.data = data), tags.length > 0 && (result.tags = tags);
      let insertTextMode = (_b = item.insertTextMode) != null ? _b : defaultInsertTextMode;
      return insertTextMode !== void 0 && (result.insertTextMode = insertTextMode, insertTextMode === ls.InsertTextMode.asIs && (result.keepWhitespace = !0)), result;
    }
    __name(asCompletionItem, "asCompletionItem");
    function asCompletionItemLabel(item) {
      return ls.CompletionItemLabelDetails.is(item.labelDetails) ? {
        label: item.label,
        detail: item.labelDetails.detail,
        description: item.labelDetails.description
      } : item.label;
    }
    __name(asCompletionItemLabel, "asCompletionItemLabel");
    function asCompletionInsertText(item, defaultRange, defaultInsertTextFormat) {
      var _a, _b;
      let insertTextFormat = (_a = item.insertTextFormat) != null ? _a : defaultInsertTextFormat;
      if (item.textEdit !== void 0 || defaultRange !== void 0) {
        let [range, newText] = item.textEdit !== void 0 ? getCompletionRangeAndText(item.textEdit) : [defaultRange, (_b = item.textEditText) != null ? _b : item.label];
        return insertTextFormat === ls.InsertTextFormat.Snippet ? {
          text: new code.SnippetString(newText),
          range: range,
          fromEdit: !0
        } : {
          text: newText,
          range: range,
          fromEdit: !0
        };
      } else return item.insertText ? insertTextFormat === ls.InsertTextFormat.Snippet ? {
        text: new code.SnippetString(item.insertText),
        fromEdit: !1
      } : {
        text: item.insertText,
        fromEdit: !1
      } : void 0;
    }
    __name(asCompletionInsertText, "asCompletionInsertText");
    function getCompletionRangeAndText(value) {
      return ls.InsertReplaceEdit.is(value) ? [{
        inserting: asRange(value.insert),
        replacing: asRange(value.replace)
      }, value.newText] : [asRange(value.range), value.newText];
    }
    __name(getCompletionRangeAndText, "getCompletionRangeAndText");
    function asTextEdit(edit) {
      if (edit) return new code.TextEdit(asRange(edit.range), edit.newText);
    }
    __name(asTextEdit, "asTextEdit");
    async function asTextEdits(items, token) {
      if (items) return async.map(items, asTextEdit, token);
    }
    __name(asTextEdits, "asTextEdits");
    function asTextEditsSync(items) {
      if (!items) return;
      let result = new Array(items.length);
      for (let i = 0; i < items.length; i++) result[i] = asTextEdit(items[i]);
      return result;
    }
    __name(asTextEditsSync, "asTextEditsSync");
    async function asSignatureHelp(item, token) {
      if (!item) return;
      let result = new code.SignatureHelp();
      return Is.number(item.activeSignature) ? result.activeSignature = item.activeSignature : result.activeSignature = 0, Is.number(item.activeParameter) ? result.activeParameter = item.activeParameter : result.activeParameter = 0, item.signatures && (result.signatures = await asSignatureInformations(item.signatures, token)), result;
    }
    __name(asSignatureHelp, "asSignatureHelp");
    async function asSignatureInformations(items, token) {
      return async.mapAsync(items, asSignatureInformation, token);
    }
    __name(asSignatureInformations, "asSignatureInformations");
    async function asSignatureInformation(item, token) {
      let result = new code.SignatureInformation(item.label);
      return item.documentation !== void 0 && (result.documentation = asDocumentation(item.documentation)), item.parameters !== void 0 && (result.parameters = await asParameterInformations(item.parameters, token)), item.activeParameter !== void 0 && (result.activeParameter = item.activeParameter), result;
    }
    __name(asSignatureInformation, "asSignatureInformation");
    function asParameterInformations(items, token) {
      return async.map(items, asParameterInformation, token);
    }
    __name(asParameterInformations, "asParameterInformations");
    function asParameterInformation(item) {
      let result = new code.ParameterInformation(item.label);
      return item.documentation && (result.documentation = asDocumentation(item.documentation)), result;
    }
    __name(asParameterInformation, "asParameterInformation");
    function asLocation(item) {
      return item ? new code.Location(_uriConverter(item.uri), asRange(item.range)) : void 0;
    }
    __name(asLocation, "asLocation");
    async function asDeclarationResult(item, token) {
      if (item) return asLocationResult(item, token);
    }
    __name(asDeclarationResult, "asDeclarationResult");
    async function asDefinitionResult(item, token) {
      if (item) return asLocationResult(item, token);
    }
    __name(asDefinitionResult, "asDefinitionResult");
    function asLocationLink(item) {
      if (!item) return;
      let result = {
        targetUri: _uriConverter(item.targetUri),
        targetRange: asRange(item.targetRange),
        originSelectionRange: asRange(item.originSelectionRange),
        targetSelectionRange: asRange(item.targetSelectionRange)
      };
      if (!result.targetSelectionRange) throw new Error("targetSelectionRange must not be undefined or null");
      return result;
    }
    __name(asLocationLink, "asLocationLink");
    async function asLocationResult(item, token) {
      if (item) if (Is.array(item)) {
        if (item.length === 0) return [];
        if (ls.LocationLink.is(item[0])) {
          let links = item;
          return async.map(links, asLocationLink, token);
        } else {
          let locations = item;
          return async.map(locations, asLocation, token);
        }
      } else return ls.LocationLink.is(item) ? [asLocationLink(item)] : asLocation(item);
    }
    __name(asLocationResult, "asLocationResult");
    async function asReferences(values, token) {
      if (values) return async.map(values, asLocation, token);
    }
    __name(asReferences, "asReferences");
    async function asDocumentHighlights(values, token) {
      if (values) return async.map(values, asDocumentHighlight, token);
    }
    __name(asDocumentHighlights, "asDocumentHighlights");
    function asDocumentHighlight(item) {
      let result = new code.DocumentHighlight(asRange(item.range));
      return Is.number(item.kind) && (result.kind = asDocumentHighlightKind(item.kind)), result;
    }
    __name(asDocumentHighlight, "asDocumentHighlight");
    function asDocumentHighlightKind(item) {
      switch (item) {
        case ls.DocumentHighlightKind.Text:
          return code.DocumentHighlightKind.Text;
        case ls.DocumentHighlightKind.Read:
          return code.DocumentHighlightKind.Read;
        case ls.DocumentHighlightKind.Write:
          return code.DocumentHighlightKind.Write;
      }
      return code.DocumentHighlightKind.Text;
    }
    __name(asDocumentHighlightKind, "asDocumentHighlightKind");
    async function asSymbolInformations(values, token) {
      if (values) return async.map(values, asSymbolInformation, token);
    }
    __name(asSymbolInformations, "asSymbolInformations");
    function asSymbolKind(item) {
      return item <= ls.SymbolKind.TypeParameter ? item - 1 : code.SymbolKind.Property;
    }
    __name(asSymbolKind, "asSymbolKind");
    function asSymbolTag(value) {
      switch (value) {
        case ls.SymbolTag.Deprecated:
          return code.SymbolTag.Deprecated;
        default:
          return;
      }
    }
    __name(asSymbolTag, "asSymbolTag");
    function asSymbolTags(items) {
      if (items == null) return;
      let result = [];
      for (let item of items) {
        let converted = asSymbolTag(item);
        converted !== void 0 && result.push(converted);
      }
      return result.length === 0 ? void 0 : result;
    }
    __name(asSymbolTags, "asSymbolTags");
    function asSymbolInformation(item) {
      var _a, _b;
      let data = item.data,
        location = item.location,
        result = location.range === void 0 || data !== void 0 ? new protocolWorkspaceSymbol_1.default(item.name, asSymbolKind(item.kind), (_a = item.containerName) != null ? _a : "", location.range === void 0 ? _uriConverter(location.uri) : new code.Location(_uriConverter(item.location.uri), asRange(location.range)), data) : new code.SymbolInformation(item.name, asSymbolKind(item.kind), (_b = item.containerName) != null ? _b : "", new code.Location(_uriConverter(item.location.uri), asRange(location.range)));
      return fillTags(result, item), result;
    }
    __name(asSymbolInformation, "asSymbolInformation");
    async function asDocumentSymbols(values, token) {
      if (values != null) return async.map(values, asDocumentSymbol, token);
    }
    __name(asDocumentSymbols, "asDocumentSymbols");
    function asDocumentSymbol(value) {
      let result = new code.DocumentSymbol(value.name, value.detail || "", asSymbolKind(value.kind), asRange(value.range), asRange(value.selectionRange));
      if (fillTags(result, value), value.children !== void 0 && value.children.length > 0) {
        let children = [];
        for (let child of value.children) children.push(asDocumentSymbol(child));
        result.children = children;
      }
      return result;
    }
    __name(asDocumentSymbol, "asDocumentSymbol");
    function fillTags(result, value) {
      result.tags = asSymbolTags(value.tags), value.deprecated && (result.tags ? result.tags.includes(code.SymbolTag.Deprecated) || (result.tags = result.tags.concat(code.SymbolTag.Deprecated)) : result.tags = [code.SymbolTag.Deprecated]);
    }
    __name(fillTags, "fillTags");
    function asCommand(item) {
      let result = {
        title: item.title,
        command: item.command
      };
      return item.arguments && (result.arguments = item.arguments), result;
    }
    __name(asCommand, "asCommand");
    async function asCommands(items, token) {
      if (items) return async.map(items, asCommand, token);
    }
    __name(asCommands, "asCommands");
    let kindMapping = new Map();
    kindMapping.set(ls.CodeActionKind.Empty, code.CodeActionKind.Empty), kindMapping.set(ls.CodeActionKind.QuickFix, code.CodeActionKind.QuickFix), kindMapping.set(ls.CodeActionKind.Refactor, code.CodeActionKind.Refactor), kindMapping.set(ls.CodeActionKind.RefactorExtract, code.CodeActionKind.RefactorExtract), kindMapping.set(ls.CodeActionKind.RefactorInline, code.CodeActionKind.RefactorInline), kindMapping.set(ls.CodeActionKind.RefactorRewrite, code.CodeActionKind.RefactorRewrite), kindMapping.set(ls.CodeActionKind.Source, code.CodeActionKind.Source), kindMapping.set(ls.CodeActionKind.SourceOrganizeImports, code.CodeActionKind.SourceOrganizeImports);
    function asCodeActionKind(item) {
      if (item == null) return;
      let result = kindMapping.get(item);
      if (result) return result;
      let parts = item.split(".");
      result = code.CodeActionKind.Empty;
      for (let part of parts) result = result.append(part);
      return result;
    }
    __name(asCodeActionKind, "asCodeActionKind");
    function asCodeActionKinds(items) {
      if (items != null) return items.map(kind => asCodeActionKind(kind));
    }
    __name(asCodeActionKinds, "asCodeActionKinds");
    async function asCodeAction(item, token) {
      if (item == null) return;
      let result = new protocolCodeAction_1.default(item.title, item.data);
      return item.kind !== void 0 && (result.kind = asCodeActionKind(item.kind)), item.diagnostics !== void 0 && (result.diagnostics = asDiagnosticsSync(item.diagnostics)), item.edit !== void 0 && (result.edit = await asWorkspaceEdit(item.edit, token)), item.command !== void 0 && (result.command = asCommand(item.command)), item.isPreferred !== void 0 && (result.isPreferred = item.isPreferred), item.disabled !== void 0 && (result.disabled = {
        reason: item.disabled.reason
      }), result;
    }
    __name(asCodeAction, "asCodeAction");
    function asCodeActionResult(items, token) {
      return async.mapAsync(items, async item => ls.Command.is(item) ? asCommand(item) : asCodeAction(item, token), token);
    }
    __name(asCodeActionResult, "asCodeActionResult");
    function asCodeLens(item) {
      if (!item) return;
      let result = new protocolCodeLens_1.default(asRange(item.range));
      return item.command && (result.command = asCommand(item.command)), item.data !== void 0 && item.data !== null && (result.data = item.data), result;
    }
    __name(asCodeLens, "asCodeLens");
    async function asCodeLenses(items, token) {
      if (items) return async.map(items, asCodeLens, token);
    }
    __name(asCodeLenses, "asCodeLenses");
    async function asWorkspaceEdit(item, token) {
      if (!item) return;
      let sharedMetadata = new Map();
      if (item.changeAnnotations !== void 0) {
        let changeAnnotations = item.changeAnnotations;
        await async.forEach(Object.keys(changeAnnotations), key => {
          let metaData = asWorkspaceEditEntryMetadata(changeAnnotations[key]);
          sharedMetadata.set(key, metaData);
        }, token);
      }
      let asMetadata = __name(annotation => {
          if (annotation !== void 0) return sharedMetadata.get(annotation);
        }, "asMetadata"),
        result = new code.WorkspaceEdit();
      if (item.documentChanges) {
        let documentChanges = item.documentChanges;
        await async.forEach(documentChanges, change => {
          if (ls.CreateFile.is(change)) result.createFile(_uriConverter(change.uri), change.options, asMetadata(change.annotationId));else if (ls.RenameFile.is(change)) result.renameFile(_uriConverter(change.oldUri), _uriConverter(change.newUri), change.options, asMetadata(change.annotationId));else if (ls.DeleteFile.is(change)) result.deleteFile(_uriConverter(change.uri), change.options, asMetadata(change.annotationId));else if (ls.TextDocumentEdit.is(change)) {
            let uri = _uriConverter(change.textDocument.uri);
            for (let edit of change.edits) ls.AnnotatedTextEdit.is(edit) ? result.replace(uri, asRange(edit.range), edit.newText, asMetadata(edit.annotationId)) : result.replace(uri, asRange(edit.range), edit.newText);
          } else throw new Error(`Unknown workspace edit change received:
${JSON.stringify(change, void 0, 4)}`);
        }, token);
      } else if (item.changes) {
        let changes = item.changes;
        await async.forEach(Object.keys(changes), key => {
          result.set(_uriConverter(key), asTextEditsSync(changes[key]));
        }, token);
      }
      return result;
    }
    __name(asWorkspaceEdit, "asWorkspaceEdit");
    function asWorkspaceEditEntryMetadata(annotation) {
      if (annotation !== void 0) return {
        label: annotation.label,
        needsConfirmation: !!annotation.needsConfirmation,
        description: annotation.description
      };
    }
    __name(asWorkspaceEditEntryMetadata, "asWorkspaceEditEntryMetadata");
    function asDocumentLink(item) {
      let range = asRange(item.range),
        target = item.target ? asUri(item.target) : void 0,
        link = new protocolDocumentLink_1.default(range, target);
      return item.tooltip !== void 0 && (link.tooltip = item.tooltip), item.data !== void 0 && item.data !== null && (link.data = item.data), link;
    }
    __name(asDocumentLink, "asDocumentLink");
    async function asDocumentLinks(items, token) {
      if (items) return async.map(items, asDocumentLink, token);
    }
    __name(asDocumentLinks, "asDocumentLinks");
    function asColor(color) {
      return new code.Color(color.red, color.green, color.blue, color.alpha);
    }
    __name(asColor, "asColor");
    function asColorInformation(ci) {
      return new code.ColorInformation(asRange(ci.range), asColor(ci.color));
    }
    __name(asColorInformation, "asColorInformation");
    async function asColorInformations(colorInformation, token) {
      if (colorInformation) return async.map(colorInformation, asColorInformation, token);
    }
    __name(asColorInformations, "asColorInformations");
    function asColorPresentation(cp) {
      let presentation = new code.ColorPresentation(cp.label);
      return presentation.additionalTextEdits = asTextEditsSync(cp.additionalTextEdits), cp.textEdit && (presentation.textEdit = asTextEdit(cp.textEdit)), presentation;
    }
    __name(asColorPresentation, "asColorPresentation");
    async function asColorPresentations(colorPresentations, token) {
      if (colorPresentations) return async.map(colorPresentations, asColorPresentation, token);
    }
    __name(asColorPresentations, "asColorPresentations");
    function asFoldingRangeKind(kind) {
      if (kind) switch (kind) {
        case ls.FoldingRangeKind.Comment:
          return code.FoldingRangeKind.Comment;
        case ls.FoldingRangeKind.Imports:
          return code.FoldingRangeKind.Imports;
        case ls.FoldingRangeKind.Region:
          return code.FoldingRangeKind.Region;
      }
    }
    __name(asFoldingRangeKind, "asFoldingRangeKind");
    function asFoldingRange(r) {
      return new code.FoldingRange(r.startLine, r.endLine, asFoldingRangeKind(r.kind));
    }
    __name(asFoldingRange, "asFoldingRange");
    async function asFoldingRanges(foldingRanges, token) {
      if (foldingRanges) return async.map(foldingRanges, asFoldingRange, token);
    }
    __name(asFoldingRanges, "asFoldingRanges");
    function asSelectionRange(selectionRange) {
      return new code.SelectionRange(asRange(selectionRange.range), selectionRange.parent ? asSelectionRange(selectionRange.parent) : void 0);
    }
    __name(asSelectionRange, "asSelectionRange");
    async function asSelectionRanges(selectionRanges, token) {
      return Array.isArray(selectionRanges) ? async.map(selectionRanges, asSelectionRange, token) : [];
    }
    __name(asSelectionRanges, "asSelectionRanges");
    function asInlineValue(inlineValue) {
      return ls.InlineValueText.is(inlineValue) ? new code.InlineValueText(asRange(inlineValue.range), inlineValue.text) : ls.InlineValueVariableLookup.is(inlineValue) ? new code.InlineValueVariableLookup(asRange(inlineValue.range), inlineValue.variableName, inlineValue.caseSensitiveLookup) : new code.InlineValueEvaluatableExpression(asRange(inlineValue.range), inlineValue.expression);
    }
    __name(asInlineValue, "asInlineValue");
    async function asInlineValues(inlineValues, token) {
      return Array.isArray(inlineValues) ? async.map(inlineValues, asInlineValue, token) : [];
    }
    __name(asInlineValues, "asInlineValues");
    async function asInlayHint(value, token) {
      let label = typeof value.label == "string" ? value.label : await async.map(value.label, asInlayHintLabelPart, token),
        result = new protocolInlayHint_1.default(asPosition(value.position), label);
      return value.kind !== void 0 && (result.kind = value.kind), value.textEdits !== void 0 && (result.textEdits = await asTextEdits(value.textEdits, token)), value.tooltip !== void 0 && (result.tooltip = asTooltip(value.tooltip)), value.paddingLeft !== void 0 && (result.paddingLeft = value.paddingLeft), value.paddingRight !== void 0 && (result.paddingRight = value.paddingRight), value.data !== void 0 && (result.data = value.data), result;
    }
    __name(asInlayHint, "asInlayHint");
    function asInlayHintLabelPart(part) {
      let result = new code.InlayHintLabelPart(part.value);
      return part.location !== void 0 && (result.location = asLocation(part.location)), part.tooltip !== void 0 && (result.tooltip = asTooltip(part.tooltip)), part.command !== void 0 && (result.command = asCommand(part.command)), result;
    }
    __name(asInlayHintLabelPart, "asInlayHintLabelPart");
    function asTooltip(value) {
      return typeof value == "string" ? value : asMarkdownString(value);
    }
    __name(asTooltip, "asTooltip");
    async function asInlayHints(values, token) {
      if (Array.isArray(values)) return async.mapAsync(values, asInlayHint, token);
    }
    __name(asInlayHints, "asInlayHints");
    function asCallHierarchyItem(item) {
      if (item === null) return;
      let result = new protocolCallHierarchyItem_1.default(asSymbolKind(item.kind), item.name, item.detail || "", asUri(item.uri), asRange(item.range), asRange(item.selectionRange), item.data);
      return item.tags !== void 0 && (result.tags = asSymbolTags(item.tags)), result;
    }
    __name(asCallHierarchyItem, "asCallHierarchyItem");
    async function asCallHierarchyItems(items, token) {
      if (items !== null) return async.map(items, asCallHierarchyItem, token);
    }
    __name(asCallHierarchyItems, "asCallHierarchyItems");
    async function asCallHierarchyIncomingCall(item, token) {
      return new code.CallHierarchyIncomingCall(asCallHierarchyItem(item.from), await asRanges(item.fromRanges, token));
    }
    __name(asCallHierarchyIncomingCall, "asCallHierarchyIncomingCall");
    async function asCallHierarchyIncomingCalls(items, token) {
      if (items !== null) return async.mapAsync(items, asCallHierarchyIncomingCall, token);
    }
    __name(asCallHierarchyIncomingCalls, "asCallHierarchyIncomingCalls");
    async function asCallHierarchyOutgoingCall(item, token) {
      return new code.CallHierarchyOutgoingCall(asCallHierarchyItem(item.to), await asRanges(item.fromRanges, token));
    }
    __name(asCallHierarchyOutgoingCall, "asCallHierarchyOutgoingCall");
    async function asCallHierarchyOutgoingCalls(items, token) {
      if (items !== null) return async.mapAsync(items, asCallHierarchyOutgoingCall, token);
    }
    __name(asCallHierarchyOutgoingCalls, "asCallHierarchyOutgoingCalls");
    async function asSemanticTokens(value, _token) {
      if (value != null) return new code.SemanticTokens(new Uint32Array(value.data), value.resultId);
    }
    __name(asSemanticTokens, "asSemanticTokens");
    function asSemanticTokensEdit(value) {
      return new code.SemanticTokensEdit(value.start, value.deleteCount, value.data !== void 0 ? new Uint32Array(value.data) : void 0);
    }
    __name(asSemanticTokensEdit, "asSemanticTokensEdit");
    async function asSemanticTokensEdits(value, _token) {
      if (value != null) return new code.SemanticTokensEdits(value.edits.map(asSemanticTokensEdit), value.resultId);
    }
    __name(asSemanticTokensEdits, "asSemanticTokensEdits");
    function asSemanticTokensLegend(value) {
      return value;
    }
    __name(asSemanticTokensLegend, "asSemanticTokensLegend");
    async function asLinkedEditingRanges(value, token) {
      if (value != null) return new code.LinkedEditingRanges(await asRanges(value.ranges, token), asRegularExpression(value.wordPattern));
    }
    __name(asLinkedEditingRanges, "asLinkedEditingRanges");
    function asRegularExpression(value) {
      if (value != null) return new RegExp(value);
    }
    __name(asRegularExpression, "asRegularExpression");
    function asTypeHierarchyItem(item) {
      if (item === null) return;
      let result = new protocolTypeHierarchyItem_1.default(asSymbolKind(item.kind), item.name, item.detail || "", asUri(item.uri), asRange(item.range), asRange(item.selectionRange), item.data);
      return item.tags !== void 0 && (result.tags = asSymbolTags(item.tags)), result;
    }
    __name(asTypeHierarchyItem, "asTypeHierarchyItem");
    async function asTypeHierarchyItems(items, token) {
      if (items !== null) return async.map(items, asTypeHierarchyItem, token);
    }
    __name(asTypeHierarchyItems, "asTypeHierarchyItems");
    function asGlobPattern(pattern) {
      if (Is.string(pattern)) return pattern;
      if (ls.RelativePattern.is(pattern)) {
        if (ls.URI.is(pattern.baseUri)) return new code.RelativePattern(asUri(pattern.baseUri), pattern.pattern);
        if (ls.WorkspaceFolder.is(pattern.baseUri)) {
          let workspaceFolder = code.workspace.getWorkspaceFolder(asUri(pattern.baseUri.uri));
          return workspaceFolder !== void 0 ? new code.RelativePattern(workspaceFolder, pattern.pattern) : void 0;
        }
      }
    }
    __name(asGlobPattern, "asGlobPattern");
    async function asInlineCompletionResult(value, token) {
      if (!value) return;
      if (Array.isArray(value)) return async.map(value, item => asInlineCompletionItem(item), token);
      let list = value,
        converted = await async.map(list.items, item => asInlineCompletionItem(item), token);
      return new code.InlineCompletionList(converted);
    }
    __name(asInlineCompletionResult, "asInlineCompletionResult");
    function asInlineCompletionItem(item) {
      let insertText;
      typeof item.insertText == "string" ? insertText = item.insertText : insertText = new code.SnippetString(item.insertText.value);
      let command;
      item.command && (command = asCommand(item.command));
      let inlineCompletionItem = new code.InlineCompletionItem(insertText, asRange(item.range), command);
      return item.filterText && (inlineCompletionItem.filterText = item.filterText), inlineCompletionItem;
    }
    return __name(asInlineCompletionItem, "asInlineCompletionItem"), {
      asUri: asUri,
      asDocumentSelector: asDocumentSelector,
      asDiagnostics: asDiagnostics,
      asDiagnostic: asDiagnostic,
      asRange: asRange,
      asRanges: asRanges,
      asPosition: asPosition,
      asDiagnosticSeverity: asDiagnosticSeverity,
      asDiagnosticTag: asDiagnosticTag,
      asHover: asHover,
      asCompletionResult: asCompletionResult,
      asCompletionItem: asCompletionItem,
      asTextEdit: asTextEdit,
      asTextEdits: asTextEdits,
      asSignatureHelp: asSignatureHelp,
      asSignatureInformations: asSignatureInformations,
      asSignatureInformation: asSignatureInformation,
      asParameterInformations: asParameterInformations,
      asParameterInformation: asParameterInformation,
      asDeclarationResult: asDeclarationResult,
      asDefinitionResult: asDefinitionResult,
      asLocation: asLocation,
      asReferences: asReferences,
      asDocumentHighlights: asDocumentHighlights,
      asDocumentHighlight: asDocumentHighlight,
      asDocumentHighlightKind: asDocumentHighlightKind,
      asSymbolKind: asSymbolKind,
      asSymbolTag: asSymbolTag,
      asSymbolTags: asSymbolTags,
      asSymbolInformations: asSymbolInformations,
      asSymbolInformation: asSymbolInformation,
      asDocumentSymbols: asDocumentSymbols,
      asDocumentSymbol: asDocumentSymbol,
      asCommand: asCommand,
      asCommands: asCommands,
      asCodeAction: asCodeAction,
      asCodeActionKind: asCodeActionKind,
      asCodeActionKinds: asCodeActionKinds,
      asCodeActionResult: asCodeActionResult,
      asCodeLens: asCodeLens,
      asCodeLenses: asCodeLenses,
      asWorkspaceEdit: asWorkspaceEdit,
      asDocumentLink: asDocumentLink,
      asDocumentLinks: asDocumentLinks,
      asFoldingRangeKind: asFoldingRangeKind,
      asFoldingRange: asFoldingRange,
      asFoldingRanges: asFoldingRanges,
      asColor: asColor,
      asColorInformation: asColorInformation,
      asColorInformations: asColorInformations,
      asColorPresentation: asColorPresentation,
      asColorPresentations: asColorPresentations,
      asSelectionRange: asSelectionRange,
      asSelectionRanges: asSelectionRanges,
      asInlineValue: asInlineValue,
      asInlineValues: asInlineValues,
      asInlayHint: asInlayHint,
      asInlayHints: asInlayHints,
      asSemanticTokensLegend: asSemanticTokensLegend,
      asSemanticTokens: asSemanticTokens,
      asSemanticTokensEdit: asSemanticTokensEdit,
      asSemanticTokensEdits: asSemanticTokensEdits,
      asCallHierarchyItem: asCallHierarchyItem,
      asCallHierarchyItems: asCallHierarchyItems,
      asCallHierarchyIncomingCall: asCallHierarchyIncomingCall,
      asCallHierarchyIncomingCalls: asCallHierarchyIncomingCalls,
      asCallHierarchyOutgoingCall: asCallHierarchyOutgoingCall,
      asCallHierarchyOutgoingCalls: asCallHierarchyOutgoingCalls,
      asLinkedEditingRanges: asLinkedEditingRanges,
      asTypeHierarchyItem: asTypeHierarchyItem,
      asTypeHierarchyItems: asTypeHierarchyItems,
      asGlobPattern: asGlobPattern,
      asInlineCompletionResult: asInlineCompletionResult,
      asInlineCompletionItem: asInlineCompletionItem
    };
  }
  __name(createConverter, "createConverter");
  exports.createConverter = createConverter;
});