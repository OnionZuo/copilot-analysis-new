var require_notebook = __commonJSMin(exports => {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: !0
  });
  exports.NotebookDocumentSyncFeature = void 0;
  var vscode = require("vscode"),
    minimatch = mq(),
    proto = Un(),
    UUID = yo(),
    Is = yp();
  function ensure(target, key) {
    return target[key] === void 0 && (target[key] = {}), target[key];
  }
  __name(ensure, "ensure");
  var Converter;
  (function (Converter) {
    let c2p;
    (function (c2p) {
      function asVersionedNotebookDocumentIdentifier(notebookDocument, base) {
        return {
          version: notebookDocument.version,
          uri: base.asUri(notebookDocument.uri)
        };
      }
      __name(asVersionedNotebookDocumentIdentifier, "asVersionedNotebookDocumentIdentifier"), c2p.asVersionedNotebookDocumentIdentifier = asVersionedNotebookDocumentIdentifier;
      function asNotebookDocument(notebookDocument, cells, base) {
        let result = proto.NotebookDocument.create(base.asUri(notebookDocument.uri), notebookDocument.notebookType, notebookDocument.version, asNotebookCells(cells, base));
        return Object.keys(notebookDocument.metadata).length > 0 && (result.metadata = asMetadata(notebookDocument.metadata)), result;
      }
      __name(asNotebookDocument, "asNotebookDocument"), c2p.asNotebookDocument = asNotebookDocument;
      function asNotebookCells(cells, base) {
        return cells.map(cell => asNotebookCell(cell, base));
      }
      __name(asNotebookCells, "asNotebookCells"), c2p.asNotebookCells = asNotebookCells;
      function asMetadata(metadata) {
        return deepCopy(new Set(), metadata);
      }
      __name(asMetadata, "asMetadata"), c2p.asMetadata = asMetadata;
      function asNotebookCell(cell, base) {
        let result = proto.NotebookCell.create(asNotebookCellKind(cell.kind), base.asUri(cell.document.uri));
        return Object.keys(cell.metadata).length > 0 && (result.metadata = asMetadata(cell.metadata)), cell.executionSummary !== void 0 && Is.number(cell.executionSummary.executionOrder) && Is.boolean(cell.executionSummary.success) && (result.executionSummary = {
          executionOrder: cell.executionSummary.executionOrder,
          success: cell.executionSummary.success
        }), result;
      }
      __name(asNotebookCell, "asNotebookCell"), c2p.asNotebookCell = asNotebookCell;
      function asNotebookCellKind(kind) {
        switch (kind) {
          case vscode.NotebookCellKind.Markup:
            return proto.NotebookCellKind.Markup;
          case vscode.NotebookCellKind.Code:
            return proto.NotebookCellKind.Code;
        }
      }
      __name(asNotebookCellKind, "asNotebookCellKind");
      function deepCopy(seen, value) {
        if (seen.has(value)) throw new Error("Can't deep copy cyclic structures.");
        if (Array.isArray(value)) {
          let result = [];
          for (let elem of value) if (elem !== null && typeof elem == "object" || Array.isArray(elem)) result.push(deepCopy(seen, elem));else {
            if (elem instanceof RegExp) throw new Error("Can't transfer regular expressions to the server");
            result.push(elem);
          }
          return result;
        } else {
          let props = Object.keys(value),
            result = Object.create(null);
          for (let prop of props) {
            let elem = value[prop];
            if (elem !== null && typeof elem == "object" || Array.isArray(elem)) result[prop] = deepCopy(seen, elem);else {
              if (elem instanceof RegExp) throw new Error("Can't transfer regular expressions to the server");
              result[prop] = elem;
            }
          }
          return result;
        }
      }
      __name(deepCopy, "deepCopy");
      function asTextContentChange(event, base) {
        let params = base.asChangeTextDocumentParams(event, event.document.uri, event.document.version);
        return {
          document: params.textDocument,
          changes: params.contentChanges
        };
      }
      __name(asTextContentChange, "asTextContentChange"), c2p.asTextContentChange = asTextContentChange;
      function asNotebookDocumentChangeEvent(event, base) {
        let result = Object.create(null);
        if (event.metadata && (result.metadata = Converter.c2p.asMetadata(event.metadata)), event.cells !== void 0) {
          let cells = Object.create(null),
            changedCells = event.cells;
          changedCells.structure && (cells.structure = {
            array: {
              start: changedCells.structure.array.start,
              deleteCount: changedCells.structure.array.deleteCount,
              cells: changedCells.structure.array.cells !== void 0 ? changedCells.structure.array.cells.map(cell => Converter.c2p.asNotebookCell(cell, base)) : void 0
            },
            didOpen: changedCells.structure.didOpen !== void 0 ? changedCells.structure.didOpen.map(cell => base.asOpenTextDocumentParams(cell.document).textDocument) : void 0,
            didClose: changedCells.structure.didClose !== void 0 ? changedCells.structure.didClose.map(cell => base.asCloseTextDocumentParams(cell.document).textDocument) : void 0
          }), changedCells.data !== void 0 && (cells.data = changedCells.data.map(cell => Converter.c2p.asNotebookCell(cell, base))), changedCells.textContent !== void 0 && (cells.textContent = changedCells.textContent.map(event => Converter.c2p.asTextContentChange(event, base))), Object.keys(cells).length > 0 && (result.cells = cells);
        }
        return result;
      }
      __name(asNotebookDocumentChangeEvent, "asNotebookDocumentChangeEvent"), c2p.asNotebookDocumentChangeEvent = asNotebookDocumentChangeEvent;
    })(c2p = Converter.c2p || (Converter.c2p = {}));
  })(Converter || (Converter = {}));
  var $NotebookCell;
  (function ($NotebookCell) {
    function computeDiff(originalCells, modifiedCells, compareMetadata) {
      let originalLength = originalCells.length,
        modifiedLength = modifiedCells.length,
        startIndex = 0;
      for (; startIndex < modifiedLength && startIndex < originalLength && equals(originalCells[startIndex], modifiedCells[startIndex], compareMetadata);) startIndex++;
      if (startIndex < modifiedLength && startIndex < originalLength) {
        let originalEndIndex = originalLength - 1,
          modifiedEndIndex = modifiedLength - 1;
        for (; originalEndIndex >= 0 && modifiedEndIndex >= 0 && equals(originalCells[originalEndIndex], modifiedCells[modifiedEndIndex], compareMetadata);) originalEndIndex--, modifiedEndIndex--;
        let deleteCount = originalEndIndex + 1 - startIndex,
          newCells = startIndex === modifiedEndIndex + 1 ? void 0 : modifiedCells.slice(startIndex, modifiedEndIndex + 1);
        return newCells !== void 0 ? {
          start: startIndex,
          deleteCount: deleteCount,
          cells: newCells
        } : {
          start: startIndex,
          deleteCount: deleteCount
        };
      } else return startIndex < modifiedLength ? {
        start: startIndex,
        deleteCount: 0,
        cells: modifiedCells.slice(startIndex)
      } : startIndex < originalLength ? {
        start: startIndex,
        deleteCount: originalLength - startIndex
      } : void 0;
    }
    __name(computeDiff, "computeDiff"), $NotebookCell.computeDiff = computeDiff;
    function equals(one, other, compareMetaData = !0) {
      return one.kind !== other.kind || one.document.uri.toString() !== other.document.uri.toString() || one.document.languageId !== other.document.languageId || !equalsExecution(one.executionSummary, other.executionSummary) ? !1 : !compareMetaData || compareMetaData && equalsMetadata(one.metadata, other.metadata);
    }
    __name(equals, "equals");
    function equalsExecution(one, other) {
      return one === other ? !0 : one === void 0 || other === void 0 ? !1 : one.executionOrder === other.executionOrder && one.success === other.success && equalsTiming(one.timing, other.timing);
    }
    __name(equalsExecution, "equalsExecution");
    function equalsTiming(one, other) {
      return one === other ? !0 : one === void 0 || other === void 0 ? !1 : one.startTime === other.startTime && one.endTime === other.endTime;
    }
    __name(equalsTiming, "equalsTiming");
    function equalsMetadata(one, other) {
      if (one === other) return !0;
      if (one == null || other === null || other === void 0 || typeof one != typeof other || typeof one != "object") return !1;
      let oneArray = Array.isArray(one),
        otherArray = Array.isArray(other);
      if (oneArray !== otherArray) return !1;
      if (oneArray && otherArray) {
        if (one.length !== other.length) return !1;
        for (let i = 0; i < one.length; i++) if (!equalsMetadata(one[i], other[i])) return !1;
      }
      if (isObjectLiteral(one) && isObjectLiteral(other)) {
        let oneKeys = Object.keys(one),
          otherKeys = Object.keys(other);
        if (oneKeys.length !== otherKeys.length || (oneKeys.sort(), otherKeys.sort(), !equalsMetadata(oneKeys, otherKeys))) return !1;
        for (let i = 0; i < oneKeys.length; i++) {
          let prop = oneKeys[i];
          if (!equalsMetadata(one[prop], other[prop])) return !1;
        }
        return !0;
      }
      return !1;
    }
    __name(equalsMetadata, "equalsMetadata");
    function isObjectLiteral(value) {
      return value !== null && typeof value == "object";
    }
    __name(isObjectLiteral, "isObjectLiteral"), $NotebookCell.isObjectLiteral = isObjectLiteral;
  })($NotebookCell || ($NotebookCell = {}));
  var $NotebookDocumentFilter;
  (function ($NotebookDocumentFilter) {
    function matchNotebook(filter, notebookDocument) {
      if (typeof filter == "string") return filter === "*" || notebookDocument.notebookType === filter;
      if (filter.notebookType !== void 0 && filter.notebookType !== "*" && notebookDocument.notebookType !== filter.notebookType) return !1;
      let uri = notebookDocument.uri;
      if (filter.scheme !== void 0 && filter.scheme !== "*" && uri.scheme !== filter.scheme) return !1;
      if (filter.pattern !== void 0) {
        let matcher = new minimatch.Minimatch(filter.pattern, {
          noext: !0
        });
        if (!matcher.makeRe() || !matcher.match(uri.fsPath)) return !1;
      }
      return !0;
    }
    __name(matchNotebook, "matchNotebook"), $NotebookDocumentFilter.matchNotebook = matchNotebook;
  })($NotebookDocumentFilter || ($NotebookDocumentFilter = {}));
  var $NotebookDocumentSyncOptions;
  (function ($NotebookDocumentSyncOptions) {
    function asDocumentSelector(options) {
      var _a, _b, _c, _d;
      let selector = options.notebookSelector,
        result = [];
      for (let element of selector) {
        let notebookType = (_b = typeof element.notebook == "string" ? element.notebook : (_a = element.notebook) == null ? void 0 : _a.notebookType) != null ? _b : "*",
          scheme = typeof element.notebook == "string" || (_c = element.notebook) == null ? void 0 : _c.scheme,
          pattern = typeof element.notebook == "string" || (_d = element.notebook) == null ? void 0 : _d.pattern;
        if (element.cells !== void 0) for (let cell of element.cells) result.push(asDocumentFilter(notebookType, scheme, pattern, cell.language));else result.push(asDocumentFilter(notebookType, scheme, pattern, void 0));
      }
      return result;
    }
    __name(asDocumentSelector, "asDocumentSelector"), $NotebookDocumentSyncOptions.asDocumentSelector = asDocumentSelector;
    function asDocumentFilter(notebookType, scheme, pattern, language) {
      return scheme === void 0 && pattern === void 0 ? {
        notebook: notebookType,
        language: language
      } : {
        notebook: {
          notebookType: notebookType,
          scheme: scheme,
          pattern: pattern
        },
        language: language
      };
    }
    __name(asDocumentFilter, "asDocumentFilter");
  })($NotebookDocumentSyncOptions || ($NotebookDocumentSyncOptions = {}));
  var SyncInfo;
  (function (SyncInfo) {
    function create(cells) {
      return {
        cells: cells,
        uris: new Set(cells.map(cell => cell.document.uri.toString()))
      };
    }
    __name(create, "create"), SyncInfo.create = create;
  })(SyncInfo || (SyncInfo = {}));
  var _NotebookDocumentSyncFeatureProvider = class _NotebookDocumentSyncFeatureProvider {
    constructor(client, options) {
      this.client = client, this.options = options, this.notebookSyncInfo = new Map(), this.notebookDidOpen = new Set(), this.disposables = [], this.selector = client.protocol2CodeConverter.asDocumentSelector($NotebookDocumentSyncOptions.asDocumentSelector(options)), vscode.workspace.onDidOpenNotebookDocument(notebookDocument => {
        this.notebookDidOpen.add(notebookDocument.uri.toString()), this.didOpen(notebookDocument);
      }, void 0, this.disposables);
      for (let notebookDocument of vscode.workspace.notebookDocuments) this.notebookDidOpen.add(notebookDocument.uri.toString()), this.didOpen(notebookDocument);
      vscode.workspace.onDidChangeNotebookDocument(event => this.didChangeNotebookDocument(event), void 0, this.disposables), this.options.save === !0 && vscode.workspace.onDidSaveNotebookDocument(notebookDocument => this.didSave(notebookDocument), void 0, this.disposables), vscode.workspace.onDidCloseNotebookDocument(notebookDocument => {
        this.didClose(notebookDocument), this.notebookDidOpen.delete(notebookDocument.uri.toString());
      }, void 0, this.disposables);
    }
    getState() {
      for (let notebook of vscode.workspace.notebookDocuments) if (this.getMatchingCells(notebook) !== void 0) return {
        kind: "document",
        id: "$internal",
        registrations: !0,
        matches: !0
      };
      return {
        kind: "document",
        id: "$internal",
        registrations: !0,
        matches: !1
      };
    }
    get mode() {
      return "notebook";
    }
    handles(textDocument) {
      return vscode.languages.match(this.selector, textDocument) > 0;
    }
    didOpenNotebookCellTextDocument(notebookDocument, cell) {
      if (vscode.languages.match(this.selector, cell.document) === 0 || !this.notebookDidOpen.has(notebookDocument.uri.toString())) return;
      let syncInfo = this.notebookSyncInfo.get(notebookDocument.uri.toString()),
        cellMatches = this.cellMatches(notebookDocument, cell);
      if (syncInfo !== void 0) {
        let cellIsSynced = syncInfo.uris.has(cell.document.uri.toString());
        if (cellMatches && cellIsSynced || !cellMatches && !cellIsSynced) return;
        if (cellMatches) {
          let matchingCells = this.getMatchingCells(notebookDocument);
          if (matchingCells !== void 0) {
            let event = this.asNotebookDocumentChangeEvent(notebookDocument, void 0, syncInfo, matchingCells);
            event !== void 0 && this.doSendChange(event, matchingCells).catch(() => {});
          }
        }
      } else cellMatches && this.doSendOpen(notebookDocument, [cell]).catch(() => {});
    }
    didChangeNotebookCellTextDocument(notebookDocument, event) {
      vscode.languages.match(this.selector, event.document) !== 0 && this.doSendChange({
        notebook: notebookDocument,
        cells: {
          textContent: [event]
        }
      }, void 0).catch(() => {});
    }
    didCloseNotebookCellTextDocument(notebookDocument, cell) {
      let syncInfo = this.notebookSyncInfo.get(notebookDocument.uri.toString());
      if (syncInfo === void 0) return;
      let cellUri = cell.document.uri,
        index = syncInfo.cells.findIndex(item => item.document.uri.toString() === cellUri.toString());
      if (index !== -1) if (index === 0 && syncInfo.cells.length === 1) this.doSendClose(notebookDocument, syncInfo.cells).catch(() => {});else {
        let newCells = syncInfo.cells.slice(),
          deleted = newCells.splice(index, 1);
        this.doSendChange({
          notebook: notebookDocument,
          cells: {
            structure: {
              array: {
                start: index,
                deleteCount: 1
              },
              didClose: deleted
            }
          }
        }, newCells).catch(() => {});
      }
    }
    dispose() {
      for (let disposable of this.disposables) disposable.dispose();
    }
    didOpen(notebookDocument, matchingCells = this.getMatchingCells(notebookDocument), syncInfo = this.notebookSyncInfo.get(notebookDocument.uri.toString())) {
      if (syncInfo !== void 0) {
        if (matchingCells !== void 0) {
          let event = this.asNotebookDocumentChangeEvent(notebookDocument, void 0, syncInfo, matchingCells);
          event !== void 0 && this.doSendChange(event, matchingCells).catch(() => {});
        } else this.doSendClose(notebookDocument, []).catch(() => {});
      } else {
        if (matchingCells === void 0) return;
        this.doSendOpen(notebookDocument, matchingCells).catch(() => {});
      }
    }
    didChangeNotebookDocument(event) {
      let notebookDocument = event.notebook,
        syncInfo = this.notebookSyncInfo.get(notebookDocument.uri.toString());
      if (syncInfo === void 0) {
        if (event.contentChanges.length === 0) return;
        let cells = this.getMatchingCells(notebookDocument);
        if (cells === void 0) return;
        this.didOpen(notebookDocument, cells, syncInfo);
      } else {
        let cells = this.getMatchingCells(notebookDocument);
        if (cells === void 0) {
          this.didClose(notebookDocument, syncInfo);
          return;
        }
        let newEvent = this.asNotebookDocumentChangeEvent(event.notebook, event, syncInfo, cells);
        newEvent !== void 0 && this.doSendChange(newEvent, cells).catch(() => {});
      }
    }
    didSave(notebookDocument) {
      this.notebookSyncInfo.get(notebookDocument.uri.toString()) !== void 0 && this.doSendSave(notebookDocument).catch(() => {});
    }
    didClose(notebookDocument, syncInfo = this.notebookSyncInfo.get(notebookDocument.uri.toString())) {
      if (syncInfo === void 0) return;
      let syncedCells = notebookDocument.getCells().filter(cell => syncInfo.uris.has(cell.document.uri.toString()));
      this.doSendClose(notebookDocument, syncedCells).catch(() => {});
    }
    async sendDidOpenNotebookDocument(notebookDocument) {
      let cells = this.getMatchingCells(notebookDocument);
      if (cells !== void 0) return this.doSendOpen(notebookDocument, cells);
    }
    async doSendOpen(notebookDocument, cells) {
      var _a;
      let send = __name(async (notebookDocument, cells) => {
          let nb = Converter.c2p.asNotebookDocument(notebookDocument, cells, this.client.code2ProtocolConverter),
            cellDocuments = cells.map(cell => this.client.code2ProtocolConverter.asTextDocumentItem(cell.document));
          try {
            await this.client.sendNotification(proto.DidOpenNotebookDocumentNotification.type, {
              notebookDocument: nb,
              cellTextDocuments: cellDocuments
            });
          } catch (error) {
            throw this.client.error("Sending DidOpenNotebookDocumentNotification failed", error), error;
          }
        }, "send"),
        middleware = (_a = this.client.middleware) == null ? void 0 : _a.notebooks;
      return this.notebookSyncInfo.set(notebookDocument.uri.toString(), SyncInfo.create(cells)), (middleware == null ? void 0 : middleware.didOpen) !== void 0 ? middleware.didOpen(notebookDocument, cells, send) : send(notebookDocument, cells);
    }
    async sendDidChangeNotebookDocument(event) {
      return this.doSendChange(event, void 0);
    }
    async doSendChange(event, cells = this.getMatchingCells(event.notebook)) {
      var _a, _b;
      let send = __name(async event => {
          try {
            await this.client.sendNotification(proto.DidChangeNotebookDocumentNotification.type, {
              notebookDocument: Converter.c2p.asVersionedNotebookDocumentIdentifier(event.notebook, this.client.code2ProtocolConverter),
              change: Converter.c2p.asNotebookDocumentChangeEvent(event, this.client.code2ProtocolConverter)
            });
          } catch (error) {
            throw this.client.error("Sending DidChangeNotebookDocumentNotification failed", error), error;
          }
        }, "send"),
        middleware = (_a = this.client.middleware) == null ? void 0 : _a.notebooks;
      return ((_b = event.cells) == null ? void 0 : _b.structure) !== void 0 && this.notebookSyncInfo.set(event.notebook.uri.toString(), SyncInfo.create(cells != null ? cells : [])), (middleware == null ? void 0 : middleware.didChange) !== void 0 ? middleware == null ? void 0 : middleware.didChange(event, send) : send(event);
    }
    async sendDidSaveNotebookDocument(notebookDocument) {
      return this.doSendSave(notebookDocument);
    }
    async doSendSave(notebookDocument) {
      var _a;
      let send = __name(async notebookDocument => {
          try {
            await this.client.sendNotification(proto.DidSaveNotebookDocumentNotification.type, {
              notebookDocument: {
                uri: this.client.code2ProtocolConverter.asUri(notebookDocument.uri)
              }
            });
          } catch (error) {
            throw this.client.error("Sending DidSaveNotebookDocumentNotification failed", error), error;
          }
        }, "send"),
        middleware = (_a = this.client.middleware) == null ? void 0 : _a.notebooks;
      return (middleware == null ? void 0 : middleware.didSave) !== void 0 ? middleware.didSave(notebookDocument, send) : send(notebookDocument);
    }
    async sendDidCloseNotebookDocument(notebookDocument) {
      var _a;
      return this.doSendClose(notebookDocument, (_a = this.getMatchingCells(notebookDocument)) != null ? _a : []);
    }
    async doSendClose(notebookDocument, cells) {
      var _a;
      let send = __name(async (notebookDocument, cells) => {
          try {
            await this.client.sendNotification(proto.DidCloseNotebookDocumentNotification.type, {
              notebookDocument: {
                uri: this.client.code2ProtocolConverter.asUri(notebookDocument.uri)
              },
              cellTextDocuments: cells.map(cell => this.client.code2ProtocolConverter.asTextDocumentIdentifier(cell.document))
            });
          } catch (error) {
            throw this.client.error("Sending DidCloseNotebookDocumentNotification failed", error), error;
          }
        }, "send"),
        middleware = (_a = this.client.middleware) == null ? void 0 : _a.notebooks;
      return this.notebookSyncInfo.delete(notebookDocument.uri.toString()), (middleware == null ? void 0 : middleware.didClose) !== void 0 ? middleware.didClose(notebookDocument, cells, send) : send(notebookDocument, cells);
    }
    asNotebookDocumentChangeEvent(notebook, event, syncInfo, matchingCells) {
      var _a, _b;
      if (event !== void 0 && event.notebook !== notebook) throw new Error("Notebook must be identical");
      let result = {
        notebook: notebook
      };
      (event == null ? void 0 : event.metadata) !== void 0 && (result.metadata = Converter.c2p.asMetadata(event.metadata));
      let matchingCellsSet;
      if ((event == null ? void 0 : event.cellChanges) !== void 0 && event.cellChanges.length > 0) {
        let data = [];
        matchingCellsSet = new Set(matchingCells.map(cell => cell.document.uri.toString()));
        for (let cellChange of event.cellChanges) matchingCellsSet.has(cellChange.cell.document.uri.toString()) && (cellChange.executionSummary !== void 0 || cellChange.metadata !== void 0) && data.push(cellChange.cell);
        data.length > 0 && (result.cells = (_a = result.cells) != null ? _a : {}, result.cells.data = data);
      }
      if (((event == null ? void 0 : event.contentChanges) !== void 0 && event.contentChanges.length > 0 || event === void 0) && syncInfo !== void 0 && matchingCells !== void 0) {
        let oldCells = syncInfo.cells,
          newCells = matchingCells,
          diff = $NotebookCell.computeDiff(oldCells, newCells, !1),
          addedCells,
          removedCells;
        if (diff !== void 0) {
          addedCells = diff.cells === void 0 ? new Map() : new Map(diff.cells.map(cell => [cell.document.uri.toString(), cell])), removedCells = diff.deleteCount === 0 ? new Map() : new Map(oldCells.slice(diff.start, diff.start + diff.deleteCount).map(cell => [cell.document.uri.toString(), cell]));
          for (let key of Array.from(removedCells.keys())) addedCells.has(key) && (removedCells.delete(key), addedCells.delete(key));
          result.cells = (_b = result.cells) != null ? _b : {};
          let didOpen = [],
            didClose = [];
          if (addedCells.size > 0 || removedCells.size > 0) {
            for (let cell of addedCells.values()) didOpen.push(cell);
            for (let cell of removedCells.values()) didClose.push(cell);
          }
          result.cells.structure = {
            array: diff,
            didOpen: didOpen,
            didClose: didClose
          };
        }
      }
      return Object.keys(result).length > 1 ? result : void 0;
    }
    getMatchingCells(notebookDocument, cells = notebookDocument.getCells()) {
      if (this.options.notebookSelector !== void 0) {
        for (let item of this.options.notebookSelector) if (item.notebook === void 0 || $NotebookDocumentFilter.matchNotebook(item.notebook, notebookDocument)) {
          let filtered = this.filterCells(notebookDocument, cells, item.cells);
          return filtered.length === 0 ? void 0 : filtered;
        }
      }
    }
    cellMatches(notebookDocument, cell) {
      let cells = this.getMatchingCells(notebookDocument, [cell]);
      return cells !== void 0 && cells[0] === cell;
    }
    filterCells(notebookDocument, cells, cellSelector) {
      var _a;
      let filtered = cellSelector !== void 0 ? cells.filter(cell => {
        let cellLanguage = cell.document.languageId;
        return cellSelector.some(filter => filter.language === "*" || cellLanguage === filter.language);
      }) : cells;
      return typeof ((_a = this.client.clientOptions.notebookDocumentOptions) == null ? void 0 : _a.filterCells) == "function" ? this.client.clientOptions.notebookDocumentOptions.filterCells(notebookDocument, filtered) : filtered;
    }
  };
  __name(_NotebookDocumentSyncFeatureProvider, "NotebookDocumentSyncFeatureProvider");
  var NotebookDocumentSyncFeatureProvider = _NotebookDocumentSyncFeatureProvider,
    _NotebookDocumentSyncFeature = class _NotebookDocumentSyncFeature {
      constructor(client) {
        this.client = client, this.registrations = new Map(), this.registrationType = proto.NotebookDocumentSyncRegistrationType.type, vscode.workspace.onDidOpenTextDocument(textDocument => {
          if (textDocument.uri.scheme !== _NotebookDocumentSyncFeature.CellScheme) return;
          let [notebookDocument, notebookCell] = this.findNotebookDocumentAndCell(textDocument);
          if (!(notebookDocument === void 0 || notebookCell === void 0)) for (let provider of this.registrations.values()) provider instanceof NotebookDocumentSyncFeatureProvider && provider.didOpenNotebookCellTextDocument(notebookDocument, notebookCell);
        }), vscode.workspace.onDidChangeTextDocument(event => {
          if (event.contentChanges.length === 0) return;
          let textDocument = event.document;
          if (textDocument.uri.scheme !== _NotebookDocumentSyncFeature.CellScheme) return;
          let [notebookDocument] = this.findNotebookDocumentAndCell(textDocument);
          if (notebookDocument !== void 0) for (let provider of this.registrations.values()) provider instanceof NotebookDocumentSyncFeatureProvider && provider.didChangeNotebookCellTextDocument(notebookDocument, event);
        }), vscode.workspace.onDidCloseTextDocument(textDocument => {
          if (textDocument.uri.scheme !== _NotebookDocumentSyncFeature.CellScheme) return;
          let [notebookDocument, notebookCell] = this.findNotebookDocumentAndCell(textDocument);
          if (!(notebookDocument === void 0 || notebookCell === void 0)) for (let provider of this.registrations.values()) provider instanceof NotebookDocumentSyncFeatureProvider && provider.didCloseNotebookCellTextDocument(notebookDocument, notebookCell);
        });
      }
      getState() {
        if (this.registrations.size === 0) return {
          kind: "document",
          id: this.registrationType.method,
          registrations: !1,
          matches: !1
        };
        for (let provider of this.registrations.values()) {
          let state = provider.getState();
          if (state.kind === "document" && state.registrations === !0 && state.matches === !0) return {
            kind: "document",
            id: this.registrationType.method,
            registrations: !0,
            matches: !0
          };
        }
        return {
          kind: "document",
          id: this.registrationType.method,
          registrations: !0,
          matches: !1
        };
      }
      fillClientCapabilities(capabilities) {
        let synchronization = ensure(ensure(capabilities, "notebookDocument"), "synchronization");
        synchronization.dynamicRegistration = !0, synchronization.executionSummarySupport = !0;
      }
      preInitialize(capabilities) {
        let options = capabilities.notebookDocumentSync;
        options !== void 0 && (this.dedicatedChannel = this.client.protocol2CodeConverter.asDocumentSelector($NotebookDocumentSyncOptions.asDocumentSelector(options)));
      }
      initialize(capabilities) {
        var _a;
        let options = capabilities.notebookDocumentSync;
        if (options === void 0) return;
        let id = (_a = options.id) != null ? _a : UUID.generateUuid();
        this.register({
          id: id,
          registerOptions: options
        });
      }
      register(data) {
        let provider = new NotebookDocumentSyncFeatureProvider(this.client, data.registerOptions);
        this.registrations.set(data.id, provider);
      }
      unregister(id) {
        let provider = this.registrations.get(id);
        provider && provider.dispose();
      }
      clear() {
        for (let provider of this.registrations.values()) provider.dispose();
        this.registrations.clear();
      }
      handles(textDocument) {
        if (textDocument.uri.scheme !== _NotebookDocumentSyncFeature.CellScheme) return !1;
        if (this.dedicatedChannel !== void 0 && vscode.languages.match(this.dedicatedChannel, textDocument) > 0) return !0;
        for (let provider of this.registrations.values()) if (provider.handles(textDocument)) return !0;
        return !1;
      }
      getProvider(notebookCell) {
        for (let provider of this.registrations.values()) if (provider.handles(notebookCell.document)) return provider;
      }
      findNotebookDocumentAndCell(textDocument) {
        let uri = textDocument.uri.toString();
        for (let notebookDocument of vscode.workspace.notebookDocuments) for (let cell of notebookDocument.getCells()) if (cell.document.uri.toString() === uri) return [notebookDocument, cell];
        return [void 0, void 0];
      }
    };
  __name(_NotebookDocumentSyncFeature, "NotebookDocumentSyncFeature");
  var NotebookDocumentSyncFeature = _NotebookDocumentSyncFeature;
  exports.NotebookDocumentSyncFeature = NotebookDocumentSyncFeature;
  NotebookDocumentSyncFeature.CellScheme = "vscode-notebook-cell";
});