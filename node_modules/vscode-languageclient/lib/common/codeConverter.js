var require_codeConverter = __commonJSMin(exports => {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: !0
  });
  exports.createConverter = void 0;
  var code = require("vscode"),
    proto = Un(),
    Is = yp(),
    async = rq(),
    protocolCompletionItem_1 = hpe(),
    protocolCodeLens_1 = Cpe(),
    protocolDocumentLink_1 = Epe(),
    protocolCodeAction_1 = Qpe(),
    protocolDiagnostic_1 = Tpe(),
    protocolCallHierarchyItem_1 = Ppe(),
    protocolTypeHierarchyItem_1 = qpe(),
    protocolWorkspaceSymbol_1 = Gpe(),
    protocolInlayHint_1 = Ype(),
    InsertReplaceRange;
  (function (InsertReplaceRange) {
    function is(value) {
      let candidate = value;
      return candidate && !!candidate.inserting && !!candidate.replacing;
    }
    __name(is, "is"), InsertReplaceRange.is = is;
  })(InsertReplaceRange || (InsertReplaceRange = {}));
  function createConverter(uriConverter) {
    let _uriConverter = uriConverter || __name(value => value.toString(), "nullConverter");
    function asUri(value) {
      return _uriConverter(value);
    }
    __name(asUri, "asUri");
    function asTextDocumentIdentifier(textDocument) {
      return {
        uri: _uriConverter(textDocument.uri)
      };
    }
    __name(asTextDocumentIdentifier, "asTextDocumentIdentifier");
    function asTextDocumentItem(textDocument) {
      return {
        uri: _uriConverter(textDocument.uri),
        languageId: textDocument.languageId,
        version: textDocument.version,
        text: textDocument.getText()
      };
    }
    __name(asTextDocumentItem, "asTextDocumentItem");
    function asVersionedTextDocumentIdentifier(textDocument) {
      return {
        uri: _uriConverter(textDocument.uri),
        version: textDocument.version
      };
    }
    __name(asVersionedTextDocumentIdentifier, "asVersionedTextDocumentIdentifier");
    function asOpenTextDocumentParams(textDocument) {
      return {
        textDocument: asTextDocumentItem(textDocument)
      };
    }
    __name(asOpenTextDocumentParams, "asOpenTextDocumentParams");
    function isTextDocumentChangeEvent(value) {
      let candidate = value;
      return !!candidate.document && !!candidate.contentChanges;
    }
    __name(isTextDocumentChangeEvent, "isTextDocumentChangeEvent");
    function isTextDocument(value) {
      let candidate = value;
      return !!candidate.uri && !!candidate.version;
    }
    __name(isTextDocument, "isTextDocument");
    function asChangeTextDocumentParams(arg0, arg1, arg2) {
      if (isTextDocument(arg0)) return {
        textDocument: {
          uri: _uriConverter(arg0.uri),
          version: arg0.version
        },
        contentChanges: [{
          text: arg0.getText()
        }]
      };
      if (isTextDocumentChangeEvent(arg0)) {
        let uri = arg1,
          version = arg2;
        return {
          textDocument: {
            uri: _uriConverter(uri),
            version: version
          },
          contentChanges: arg0.contentChanges.map(change => {
            let range = change.range;
            return {
              range: {
                start: {
                  line: range.start.line,
                  character: range.start.character
                },
                end: {
                  line: range.end.line,
                  character: range.end.character
                }
              },
              rangeLength: change.rangeLength,
              text: change.text
            };
          })
        };
      } else throw Error("Unsupported text document change parameter");
    }
    __name(asChangeTextDocumentParams, "asChangeTextDocumentParams");
    function asCloseTextDocumentParams(textDocument) {
      return {
        textDocument: asTextDocumentIdentifier(textDocument)
      };
    }
    __name(asCloseTextDocumentParams, "asCloseTextDocumentParams");
    function asSaveTextDocumentParams(textDocument, includeContent = !1) {
      let result = {
        textDocument: asTextDocumentIdentifier(textDocument)
      };
      return includeContent && (result.text = textDocument.getText()), result;
    }
    __name(asSaveTextDocumentParams, "asSaveTextDocumentParams");
    function asTextDocumentSaveReason(reason) {
      switch (reason) {
        case code.TextDocumentSaveReason.Manual:
          return proto.TextDocumentSaveReason.Manual;
        case code.TextDocumentSaveReason.AfterDelay:
          return proto.TextDocumentSaveReason.AfterDelay;
        case code.TextDocumentSaveReason.FocusOut:
          return proto.TextDocumentSaveReason.FocusOut;
      }
      return proto.TextDocumentSaveReason.Manual;
    }
    __name(asTextDocumentSaveReason, "asTextDocumentSaveReason");
    function asWillSaveTextDocumentParams(event) {
      return {
        textDocument: asTextDocumentIdentifier(event.document),
        reason: asTextDocumentSaveReason(event.reason)
      };
    }
    __name(asWillSaveTextDocumentParams, "asWillSaveTextDocumentParams");
    function asDidCreateFilesParams(event) {
      return {
        files: event.files.map(fileUri => ({
          uri: _uriConverter(fileUri)
        }))
      };
    }
    __name(asDidCreateFilesParams, "asDidCreateFilesParams");
    function asDidRenameFilesParams(event) {
      return {
        files: event.files.map(file => ({
          oldUri: _uriConverter(file.oldUri),
          newUri: _uriConverter(file.newUri)
        }))
      };
    }
    __name(asDidRenameFilesParams, "asDidRenameFilesParams");
    function asDidDeleteFilesParams(event) {
      return {
        files: event.files.map(fileUri => ({
          uri: _uriConverter(fileUri)
        }))
      };
    }
    __name(asDidDeleteFilesParams, "asDidDeleteFilesParams");
    function asWillCreateFilesParams(event) {
      return {
        files: event.files.map(fileUri => ({
          uri: _uriConverter(fileUri)
        }))
      };
    }
    __name(asWillCreateFilesParams, "asWillCreateFilesParams");
    function asWillRenameFilesParams(event) {
      return {
        files: event.files.map(file => ({
          oldUri: _uriConverter(file.oldUri),
          newUri: _uriConverter(file.newUri)
        }))
      };
    }
    __name(asWillRenameFilesParams, "asWillRenameFilesParams");
    function asWillDeleteFilesParams(event) {
      return {
        files: event.files.map(fileUri => ({
          uri: _uriConverter(fileUri)
        }))
      };
    }
    __name(asWillDeleteFilesParams, "asWillDeleteFilesParams");
    function asTextDocumentPositionParams(textDocument, position) {
      return {
        textDocument: asTextDocumentIdentifier(textDocument),
        position: asWorkerPosition(position)
      };
    }
    __name(asTextDocumentPositionParams, "asTextDocumentPositionParams");
    function asCompletionTriggerKind(triggerKind) {
      switch (triggerKind) {
        case code.CompletionTriggerKind.TriggerCharacter:
          return proto.CompletionTriggerKind.TriggerCharacter;
        case code.CompletionTriggerKind.TriggerForIncompleteCompletions:
          return proto.CompletionTriggerKind.TriggerForIncompleteCompletions;
        default:
          return proto.CompletionTriggerKind.Invoked;
      }
    }
    __name(asCompletionTriggerKind, "asCompletionTriggerKind");
    function asCompletionParams(textDocument, position, context) {
      return {
        textDocument: asTextDocumentIdentifier(textDocument),
        position: asWorkerPosition(position),
        context: {
          triggerKind: asCompletionTriggerKind(context.triggerKind),
          triggerCharacter: context.triggerCharacter
        }
      };
    }
    __name(asCompletionParams, "asCompletionParams");
    function asSignatureHelpTriggerKind(triggerKind) {
      switch (triggerKind) {
        case code.SignatureHelpTriggerKind.Invoke:
          return proto.SignatureHelpTriggerKind.Invoked;
        case code.SignatureHelpTriggerKind.TriggerCharacter:
          return proto.SignatureHelpTriggerKind.TriggerCharacter;
        case code.SignatureHelpTriggerKind.ContentChange:
          return proto.SignatureHelpTriggerKind.ContentChange;
      }
    }
    __name(asSignatureHelpTriggerKind, "asSignatureHelpTriggerKind");
    function asParameterInformation(value) {
      return {
        label: value.label
      };
    }
    __name(asParameterInformation, "asParameterInformation");
    function asParameterInformations(values) {
      return values.map(asParameterInformation);
    }
    __name(asParameterInformations, "asParameterInformations");
    function asSignatureInformation(value) {
      return {
        label: value.label,
        parameters: asParameterInformations(value.parameters)
      };
    }
    __name(asSignatureInformation, "asSignatureInformation");
    function asSignatureInformations(values) {
      return values.map(asSignatureInformation);
    }
    __name(asSignatureInformations, "asSignatureInformations");
    function asSignatureHelp(value) {
      return value === void 0 ? value : {
        signatures: asSignatureInformations(value.signatures),
        activeSignature: value.activeSignature,
        activeParameter: value.activeParameter
      };
    }
    __name(asSignatureHelp, "asSignatureHelp");
    function asSignatureHelpParams(textDocument, position, context) {
      return {
        textDocument: asTextDocumentIdentifier(textDocument),
        position: asWorkerPosition(position),
        context: {
          isRetrigger: context.isRetrigger,
          triggerCharacter: context.triggerCharacter,
          triggerKind: asSignatureHelpTriggerKind(context.triggerKind),
          activeSignatureHelp: asSignatureHelp(context.activeSignatureHelp)
        }
      };
    }
    __name(asSignatureHelpParams, "asSignatureHelpParams");
    function asWorkerPosition(position) {
      return {
        line: position.line,
        character: position.character
      };
    }
    __name(asWorkerPosition, "asWorkerPosition");
    function asPosition(value) {
      return value == null ? value : {
        line: value.line > proto.uinteger.MAX_VALUE ? proto.uinteger.MAX_VALUE : value.line,
        character: value.character > proto.uinteger.MAX_VALUE ? proto.uinteger.MAX_VALUE : value.character
      };
    }
    __name(asPosition, "asPosition");
    function asPositions(values, token) {
      return async.map(values, asPosition, token);
    }
    __name(asPositions, "asPositions");
    function asPositionsSync(values) {
      return values.map(asPosition);
    }
    __name(asPositionsSync, "asPositionsSync");
    function asRange(value) {
      return value == null ? value : {
        start: asPosition(value.start),
        end: asPosition(value.end)
      };
    }
    __name(asRange, "asRange");
    function asRanges(values) {
      return values.map(asRange);
    }
    __name(asRanges, "asRanges");
    function asLocation(value) {
      return value == null ? value : proto.Location.create(asUri(value.uri), asRange(value.range));
    }
    __name(asLocation, "asLocation");
    function asDiagnosticSeverity(value) {
      switch (value) {
        case code.DiagnosticSeverity.Error:
          return proto.DiagnosticSeverity.Error;
        case code.DiagnosticSeverity.Warning:
          return proto.DiagnosticSeverity.Warning;
        case code.DiagnosticSeverity.Information:
          return proto.DiagnosticSeverity.Information;
        case code.DiagnosticSeverity.Hint:
          return proto.DiagnosticSeverity.Hint;
      }
    }
    __name(asDiagnosticSeverity, "asDiagnosticSeverity");
    function asDiagnosticTags(tags) {
      if (!tags) return;
      let result = [];
      for (let tag of tags) {
        let converted = asDiagnosticTag(tag);
        converted !== void 0 && result.push(converted);
      }
      return result.length > 0 ? result : void 0;
    }
    __name(asDiagnosticTags, "asDiagnosticTags");
    function asDiagnosticTag(tag) {
      switch (tag) {
        case code.DiagnosticTag.Unnecessary:
          return proto.DiagnosticTag.Unnecessary;
        case code.DiagnosticTag.Deprecated:
          return proto.DiagnosticTag.Deprecated;
        default:
          return;
      }
    }
    __name(asDiagnosticTag, "asDiagnosticTag");
    function asRelatedInformation(item) {
      return {
        message: item.message,
        location: asLocation(item.location)
      };
    }
    __name(asRelatedInformation, "asRelatedInformation");
    function asRelatedInformations(items) {
      return items.map(asRelatedInformation);
    }
    __name(asRelatedInformations, "asRelatedInformations");
    function asDiagnosticCode(value) {
      if (value != null) return Is.number(value) || Is.string(value) ? value : {
        value: value.value,
        target: asUri(value.target)
      };
    }
    __name(asDiagnosticCode, "asDiagnosticCode");
    function asDiagnostic(item) {
      let result = proto.Diagnostic.create(asRange(item.range), item.message),
        protocolDiagnostic = item instanceof protocolDiagnostic_1.ProtocolDiagnostic ? item : void 0;
      protocolDiagnostic !== void 0 && protocolDiagnostic.data !== void 0 && (result.data = protocolDiagnostic.data);
      let code = asDiagnosticCode(item.code);
      return protocolDiagnostic_1.DiagnosticCode.is(code) ? protocolDiagnostic !== void 0 && protocolDiagnostic.hasDiagnosticCode ? result.code = code : (result.code = code.value, result.codeDescription = {
        href: code.target
      }) : result.code = code, Is.number(item.severity) && (result.severity = asDiagnosticSeverity(item.severity)), Array.isArray(item.tags) && (result.tags = asDiagnosticTags(item.tags)), item.relatedInformation && (result.relatedInformation = asRelatedInformations(item.relatedInformation)), item.source && (result.source = item.source), result;
    }
    __name(asDiagnostic, "asDiagnostic");
    function asDiagnostics(items, token) {
      return items == null ? items : async.map(items, asDiagnostic, token);
    }
    __name(asDiagnostics, "asDiagnostics");
    function asDiagnosticsSync(items) {
      return items == null ? items : items.map(asDiagnostic);
    }
    __name(asDiagnosticsSync, "asDiagnosticsSync");
    function asDocumentation(format, documentation) {
      switch (format) {
        case "$string":
          return documentation;
        case proto.MarkupKind.PlainText:
          return {
            kind: format,
            value: documentation
          };
        case proto.MarkupKind.Markdown:
          return {
            kind: format,
            value: documentation.value
          };
        default:
          return `Unsupported Markup content received. Kind is: ${format}`;
      }
    }
    __name(asDocumentation, "asDocumentation");
    function asCompletionItemTag(tag) {
      switch (tag) {
        case code.CompletionItemTag.Deprecated:
          return proto.CompletionItemTag.Deprecated;
      }
    }
    __name(asCompletionItemTag, "asCompletionItemTag");
    function asCompletionItemTags(tags) {
      if (tags === void 0) return tags;
      let result = [];
      for (let tag of tags) {
        let converted = asCompletionItemTag(tag);
        converted !== void 0 && result.push(converted);
      }
      return result;
    }
    __name(asCompletionItemTags, "asCompletionItemTags");
    function asCompletionItemKind(value, original) {
      return original !== void 0 ? original : value + 1;
    }
    __name(asCompletionItemKind, "asCompletionItemKind");
    function asCompletionItem(item, labelDetailsSupport = !1) {
      let label, labelDetails;
      Is.string(item.label) ? label = item.label : (label = item.label.label, labelDetailsSupport && (item.label.detail !== void 0 || item.label.description !== void 0) && (labelDetails = {
        detail: item.label.detail,
        description: item.label.description
      }));
      let result = {
        label: label
      };
      labelDetails !== void 0 && (result.labelDetails = labelDetails);
      let protocolItem = item instanceof protocolCompletionItem_1.default ? item : void 0;
      item.detail && (result.detail = item.detail), item.documentation && (!protocolItem || protocolItem.documentationFormat === "$string" ? result.documentation = item.documentation : result.documentation = asDocumentation(protocolItem.documentationFormat, item.documentation)), item.filterText && (result.filterText = item.filterText), fillPrimaryInsertText(result, item), Is.number(item.kind) && (result.kind = asCompletionItemKind(item.kind, protocolItem && protocolItem.originalItemKind)), item.sortText && (result.sortText = item.sortText), item.additionalTextEdits && (result.additionalTextEdits = asTextEdits(item.additionalTextEdits)), item.commitCharacters && (result.commitCharacters = item.commitCharacters.slice()), item.command && (result.command = asCommand(item.command)), (item.preselect === !0 || item.preselect === !1) && (result.preselect = item.preselect);
      let tags = asCompletionItemTags(item.tags);
      if (protocolItem) {
        if (protocolItem.data !== void 0 && (result.data = protocolItem.data), protocolItem.deprecated === !0 || protocolItem.deprecated === !1) {
          if (protocolItem.deprecated === !0 && tags !== void 0 && tags.length > 0) {
            let index = tags.indexOf(code.CompletionItemTag.Deprecated);
            index !== -1 && tags.splice(index, 1);
          }
          result.deprecated = protocolItem.deprecated;
        }
        protocolItem.insertTextMode !== void 0 && (result.insertTextMode = protocolItem.insertTextMode);
      }
      return tags !== void 0 && tags.length > 0 && (result.tags = tags), result.insertTextMode === void 0 && item.keepWhitespace === !0 && (result.insertTextMode = proto.InsertTextMode.adjustIndentation), result;
    }
    __name(asCompletionItem, "asCompletionItem");
    function fillPrimaryInsertText(target, source) {
      let format = proto.InsertTextFormat.PlainText,
        text,
        range;
      source.textEdit ? (text = source.textEdit.newText, range = source.textEdit.range) : source.insertText instanceof code.SnippetString ? (format = proto.InsertTextFormat.Snippet, text = source.insertText.value) : text = source.insertText, source.range && (range = source.range), target.insertTextFormat = format, source.fromEdit && text !== void 0 && range !== void 0 ? target.textEdit = asCompletionTextEdit(text, range) : target.insertText = text;
    }
    __name(fillPrimaryInsertText, "fillPrimaryInsertText");
    function asCompletionTextEdit(newText, range) {
      return InsertReplaceRange.is(range) ? proto.InsertReplaceEdit.create(newText, asRange(range.inserting), asRange(range.replacing)) : {
        newText: newText,
        range: asRange(range)
      };
    }
    __name(asCompletionTextEdit, "asCompletionTextEdit");
    function asTextEdit(edit) {
      return {
        range: asRange(edit.range),
        newText: edit.newText
      };
    }
    __name(asTextEdit, "asTextEdit");
    function asTextEdits(edits) {
      return edits == null ? edits : edits.map(asTextEdit);
    }
    __name(asTextEdits, "asTextEdits");
    function asSymbolKind(item) {
      return item <= code.SymbolKind.TypeParameter ? item + 1 : proto.SymbolKind.Property;
    }
    __name(asSymbolKind, "asSymbolKind");
    function asSymbolTag(item) {
      return item;
    }
    __name(asSymbolTag, "asSymbolTag");
    function asSymbolTags(items) {
      return items.map(asSymbolTag);
    }
    __name(asSymbolTags, "asSymbolTags");
    function asReferenceParams(textDocument, position, options) {
      return {
        textDocument: asTextDocumentIdentifier(textDocument),
        position: asWorkerPosition(position),
        context: {
          includeDeclaration: options.includeDeclaration
        }
      };
    }
    __name(asReferenceParams, "asReferenceParams");
    async function asCodeAction(item, token) {
      let result = proto.CodeAction.create(item.title);
      if (item instanceof protocolCodeAction_1.default && item.data !== void 0 && (result.data = item.data), item.kind !== void 0 && (result.kind = asCodeActionKind(item.kind)), item.diagnostics !== void 0 && (result.diagnostics = await asDiagnostics(item.diagnostics, token)), item.edit !== void 0) throw new Error("VS Code code actions can only be converted to a protocol code action without an edit.");
      return item.command !== void 0 && (result.command = asCommand(item.command)), item.isPreferred !== void 0 && (result.isPreferred = item.isPreferred), item.disabled !== void 0 && (result.disabled = {
        reason: item.disabled.reason
      }), result;
    }
    __name(asCodeAction, "asCodeAction");
    function asCodeActionSync(item) {
      let result = proto.CodeAction.create(item.title);
      if (item instanceof protocolCodeAction_1.default && item.data !== void 0 && (result.data = item.data), item.kind !== void 0 && (result.kind = asCodeActionKind(item.kind)), item.diagnostics !== void 0 && (result.diagnostics = asDiagnosticsSync(item.diagnostics)), item.edit !== void 0) throw new Error("VS Code code actions can only be converted to a protocol code action without an edit.");
      return item.command !== void 0 && (result.command = asCommand(item.command)), item.isPreferred !== void 0 && (result.isPreferred = item.isPreferred), item.disabled !== void 0 && (result.disabled = {
        reason: item.disabled.reason
      }), result;
    }
    __name(asCodeActionSync, "asCodeActionSync");
    async function asCodeActionContext(context, token) {
      if (context == null) return context;
      let only;
      return context.only && Is.string(context.only.value) && (only = [context.only.value]), proto.CodeActionContext.create(await asDiagnostics(context.diagnostics, token), only, asCodeActionTriggerKind(context.triggerKind));
    }
    __name(asCodeActionContext, "asCodeActionContext");
    function asCodeActionContextSync(context) {
      if (context == null) return context;
      let only;
      return context.only && Is.string(context.only.value) && (only = [context.only.value]), proto.CodeActionContext.create(asDiagnosticsSync(context.diagnostics), only, asCodeActionTriggerKind(context.triggerKind));
    }
    __name(asCodeActionContextSync, "asCodeActionContextSync");
    function asCodeActionTriggerKind(kind) {
      switch (kind) {
        case code.CodeActionTriggerKind.Invoke:
          return proto.CodeActionTriggerKind.Invoked;
        case code.CodeActionTriggerKind.Automatic:
          return proto.CodeActionTriggerKind.Automatic;
        default:
          return;
      }
    }
    __name(asCodeActionTriggerKind, "asCodeActionTriggerKind");
    function asCodeActionKind(item) {
      if (item != null) return item.value;
    }
    __name(asCodeActionKind, "asCodeActionKind");
    function asInlineValueContext(context) {
      return context == null ? context : proto.InlineValueContext.create(context.frameId, asRange(context.stoppedLocation));
    }
    __name(asInlineValueContext, "asInlineValueContext");
    function asInlineCompletionParams(document, position, context) {
      return {
        context: proto.InlineCompletionContext.create(context.triggerKind, context.selectedCompletionInfo),
        textDocument: asTextDocumentIdentifier(document),
        position: asPosition(position)
      };
    }
    __name(asInlineCompletionParams, "asInlineCompletionParams");
    function asCommand(item) {
      let result = proto.Command.create(item.title, item.command);
      return item.arguments && (result.arguments = item.arguments), result;
    }
    __name(asCommand, "asCommand");
    function asCodeLens(item) {
      let result = proto.CodeLens.create(asRange(item.range));
      return item.command && (result.command = asCommand(item.command)), item instanceof protocolCodeLens_1.default && item.data && (result.data = item.data), result;
    }
    __name(asCodeLens, "asCodeLens");
    function asFormattingOptions(options, fileOptions) {
      let result = {
        tabSize: options.tabSize,
        insertSpaces: options.insertSpaces
      };
      return fileOptions.trimTrailingWhitespace && (result.trimTrailingWhitespace = !0), fileOptions.trimFinalNewlines && (result.trimFinalNewlines = !0), fileOptions.insertFinalNewline && (result.insertFinalNewline = !0), result;
    }
    __name(asFormattingOptions, "asFormattingOptions");
    function asDocumentSymbolParams(textDocument) {
      return {
        textDocument: asTextDocumentIdentifier(textDocument)
      };
    }
    __name(asDocumentSymbolParams, "asDocumentSymbolParams");
    function asCodeLensParams(textDocument) {
      return {
        textDocument: asTextDocumentIdentifier(textDocument)
      };
    }
    __name(asCodeLensParams, "asCodeLensParams");
    function asDocumentLink(item) {
      let result = proto.DocumentLink.create(asRange(item.range));
      item.target && (result.target = asUri(item.target)), item.tooltip !== void 0 && (result.tooltip = item.tooltip);
      let protocolItem = item instanceof protocolDocumentLink_1.default ? item : void 0;
      return protocolItem && protocolItem.data && (result.data = protocolItem.data), result;
    }
    __name(asDocumentLink, "asDocumentLink");
    function asDocumentLinkParams(textDocument) {
      return {
        textDocument: asTextDocumentIdentifier(textDocument)
      };
    }
    __name(asDocumentLinkParams, "asDocumentLinkParams");
    function asCallHierarchyItem(value) {
      let result = {
        name: value.name,
        kind: asSymbolKind(value.kind),
        uri: asUri(value.uri),
        range: asRange(value.range),
        selectionRange: asRange(value.selectionRange)
      };
      return value.detail !== void 0 && value.detail.length > 0 && (result.detail = value.detail), value.tags !== void 0 && (result.tags = asSymbolTags(value.tags)), value instanceof protocolCallHierarchyItem_1.default && value.data !== void 0 && (result.data = value.data), result;
    }
    __name(asCallHierarchyItem, "asCallHierarchyItem");
    function asTypeHierarchyItem(value) {
      let result = {
        name: value.name,
        kind: asSymbolKind(value.kind),
        uri: asUri(value.uri),
        range: asRange(value.range),
        selectionRange: asRange(value.selectionRange)
      };
      return value.detail !== void 0 && value.detail.length > 0 && (result.detail = value.detail), value.tags !== void 0 && (result.tags = asSymbolTags(value.tags)), value instanceof protocolTypeHierarchyItem_1.default && value.data !== void 0 && (result.data = value.data), result;
    }
    __name(asTypeHierarchyItem, "asTypeHierarchyItem");
    function asWorkspaceSymbol(item) {
      let result = item instanceof protocolWorkspaceSymbol_1.default ? {
        name: item.name,
        kind: asSymbolKind(item.kind),
        location: item.hasRange ? asLocation(item.location) : {
          uri: _uriConverter(item.location.uri)
        },
        data: item.data
      } : {
        name: item.name,
        kind: asSymbolKind(item.kind),
        location: asLocation(item.location)
      };
      return item.tags !== void 0 && (result.tags = asSymbolTags(item.tags)), item.containerName !== "" && (result.containerName = item.containerName), result;
    }
    __name(asWorkspaceSymbol, "asWorkspaceSymbol");
    function asInlayHint(item) {
      let label = typeof item.label == "string" ? item.label : item.label.map(asInlayHintLabelPart),
        result = proto.InlayHint.create(asPosition(item.position), label);
      return item.kind !== void 0 && (result.kind = item.kind), item.textEdits !== void 0 && (result.textEdits = asTextEdits(item.textEdits)), item.tooltip !== void 0 && (result.tooltip = asTooltip(item.tooltip)), item.paddingLeft !== void 0 && (result.paddingLeft = item.paddingLeft), item.paddingRight !== void 0 && (result.paddingRight = item.paddingRight), item instanceof protocolInlayHint_1.default && item.data !== void 0 && (result.data = item.data), result;
    }
    __name(asInlayHint, "asInlayHint");
    function asInlayHintLabelPart(item) {
      let result = proto.InlayHintLabelPart.create(item.value);
      return item.location !== void 0 && (result.location = asLocation(item.location)), item.command !== void 0 && (result.command = asCommand(item.command)), item.tooltip !== void 0 && (result.tooltip = asTooltip(item.tooltip)), result;
    }
    __name(asInlayHintLabelPart, "asInlayHintLabelPart");
    function asTooltip(value) {
      return typeof value == "string" ? value : {
        kind: proto.MarkupKind.Markdown,
        value: value.value
      };
    }
    return __name(asTooltip, "asTooltip"), {
      asUri: asUri,
      asTextDocumentIdentifier: asTextDocumentIdentifier,
      asTextDocumentItem: asTextDocumentItem,
      asVersionedTextDocumentIdentifier: asVersionedTextDocumentIdentifier,
      asOpenTextDocumentParams: asOpenTextDocumentParams,
      asChangeTextDocumentParams: asChangeTextDocumentParams,
      asCloseTextDocumentParams: asCloseTextDocumentParams,
      asSaveTextDocumentParams: asSaveTextDocumentParams,
      asWillSaveTextDocumentParams: asWillSaveTextDocumentParams,
      asDidCreateFilesParams: asDidCreateFilesParams,
      asDidRenameFilesParams: asDidRenameFilesParams,
      asDidDeleteFilesParams: asDidDeleteFilesParams,
      asWillCreateFilesParams: asWillCreateFilesParams,
      asWillRenameFilesParams: asWillRenameFilesParams,
      asWillDeleteFilesParams: asWillDeleteFilesParams,
      asTextDocumentPositionParams: asTextDocumentPositionParams,
      asCompletionParams: asCompletionParams,
      asSignatureHelpParams: asSignatureHelpParams,
      asWorkerPosition: asWorkerPosition,
      asRange: asRange,
      asRanges: asRanges,
      asPosition: asPosition,
      asPositions: asPositions,
      asPositionsSync: asPositionsSync,
      asLocation: asLocation,
      asDiagnosticSeverity: asDiagnosticSeverity,
      asDiagnosticTag: asDiagnosticTag,
      asDiagnostic: asDiagnostic,
      asDiagnostics: asDiagnostics,
      asDiagnosticsSync: asDiagnosticsSync,
      asCompletionItem: asCompletionItem,
      asTextEdit: asTextEdit,
      asSymbolKind: asSymbolKind,
      asSymbolTag: asSymbolTag,
      asSymbolTags: asSymbolTags,
      asReferenceParams: asReferenceParams,
      asCodeAction: asCodeAction,
      asCodeActionSync: asCodeActionSync,
      asCodeActionContext: asCodeActionContext,
      asCodeActionContextSync: asCodeActionContextSync,
      asInlineValueContext: asInlineValueContext,
      asCommand: asCommand,
      asCodeLens: asCodeLens,
      asFormattingOptions: asFormattingOptions,
      asDocumentSymbolParams: asDocumentSymbolParams,
      asCodeLensParams: asCodeLensParams,
      asDocumentLink: asDocumentLink,
      asDocumentLinkParams: asDocumentLinkParams,
      asCallHierarchyItem: asCallHierarchyItem,
      asTypeHierarchyItem: asTypeHierarchyItem,
      asInlayHint: asInlayHint,
      asWorkspaceSymbol: asWorkspaceSymbol,
      asInlineCompletionParams: asInlineCompletionParams
    };
  }
  __name(createConverter, "createConverter");
  exports.createConverter = createConverter;
});