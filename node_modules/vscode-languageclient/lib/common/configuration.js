var require_configuration = __commonJSMin(exports => {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: !0
  });
  exports.SyncConfigurationFeature = exports.toJSONObject = exports.ConfigurationFeature = void 0;
  var vscode_1 = require("vscode"),
    vscode_languageserver_protocol_1 = Un(),
    Is = yp(),
    UUID = yo(),
    features_1 = Oi(),
    _ConfigurationFeature = class _ConfigurationFeature {
      constructor(client) {
        this._client = client;
      }
      getState() {
        return {
          kind: "static"
        };
      }
      fillClientCapabilities(capabilities) {
        capabilities.workspace = capabilities.workspace || {}, capabilities.workspace.configuration = !0;
      }
      initialize() {
        let client = this._client;
        client.onRequest(vscode_languageserver_protocol_1.ConfigurationRequest.type, (params, token) => {
          let configuration = __name(params => {
              let result = [];
              for (let item of params.items) {
                let resource = item.scopeUri !== void 0 && item.scopeUri !== null ? this._client.protocol2CodeConverter.asUri(item.scopeUri) : void 0;
                result.push(this.getConfiguration(resource, item.section !== null ? item.section : void 0));
              }
              return result;
            }, "configuration"),
            middleware = client.middleware.workspace;
          return middleware && middleware.configuration ? middleware.configuration(params, token, configuration) : configuration(params, token);
        });
      }
      getConfiguration(resource, section) {
        let result = null;
        if (section) {
          let index = section.lastIndexOf(".");
          if (index === -1) result = toJSONObject(vscode_1.workspace.getConfiguration(void 0, resource).get(section));else {
            let config = vscode_1.workspace.getConfiguration(section.substr(0, index), resource);
            config && (result = toJSONObject(config.get(section.substr(index + 1))));
          }
        } else {
          let config = vscode_1.workspace.getConfiguration(void 0, resource);
          result = {};
          for (let key of Object.keys(config)) config.has(key) && (result[key] = toJSONObject(config.get(key)));
        }
        return result === void 0 && (result = null), result;
      }
      clear() {}
    };
  __name(_ConfigurationFeature, "ConfigurationFeature");
  var ConfigurationFeature = _ConfigurationFeature;
  exports.ConfigurationFeature = ConfigurationFeature;
  function toJSONObject(obj) {
    if (obj) {
      if (Array.isArray(obj)) return obj.map(toJSONObject);
      if (typeof obj == "object") {
        let res = Object.create(null);
        for (let key in obj) Object.prototype.hasOwnProperty.call(obj, key) && (res[key] = toJSONObject(obj[key]));
        return res;
      }
    }
    return obj;
  }
  __name(toJSONObject, "toJSONObject");
  exports.toJSONObject = toJSONObject;
  var _SyncConfigurationFeature = class _SyncConfigurationFeature {
    constructor(_client) {
      this._client = _client, this.isCleared = !1, this._listeners = new Map();
    }
    getState() {
      return {
        kind: "workspace",
        id: this.registrationType.method,
        registrations: this._listeners.size > 0
      };
    }
    get registrationType() {
      return vscode_languageserver_protocol_1.DidChangeConfigurationNotification.type;
    }
    fillClientCapabilities(capabilities) {
      (0, features_1.ensure)((0, features_1.ensure)(capabilities, "workspace"), "didChangeConfiguration").dynamicRegistration = !0;
    }
    initialize() {
      var _a;
      this.isCleared = !1;
      let section = (_a = this._client.clientOptions.synchronize) == null ? void 0 : _a.configurationSection;
      section !== void 0 && this.register({
        id: UUID.generateUuid(),
        registerOptions: {
          section: section
        }
      });
    }
    register(data) {
      let disposable = vscode_1.workspace.onDidChangeConfiguration(event => {
        this.onDidChangeConfiguration(data.registerOptions.section, event);
      });
      this._listeners.set(data.id, disposable), data.registerOptions.section !== void 0 && this.onDidChangeConfiguration(data.registerOptions.section, void 0);
    }
    unregister(id) {
      let disposable = this._listeners.get(id);
      disposable && (this._listeners.delete(id), disposable.dispose());
    }
    clear() {
      for (let disposable of this._listeners.values()) disposable.dispose();
      this._listeners.clear(), this.isCleared = !0;
    }
    onDidChangeConfiguration(configurationSection, event) {
      var _a;
      if (this.isCleared) return;
      let sections;
      if (Is.string(configurationSection) ? sections = [configurationSection] : sections = configurationSection, sections !== void 0 && event !== void 0 && !sections.some(section => event.affectsConfiguration(section))) return;
      let didChangeConfiguration = __name(async sections => sections === void 0 ? this._client.sendNotification(vscode_languageserver_protocol_1.DidChangeConfigurationNotification.type, {
          settings: null
        }) : this._client.sendNotification(vscode_languageserver_protocol_1.DidChangeConfigurationNotification.type, {
          settings: this.extractSettingsInformation(sections)
        }), "didChangeConfiguration"),
        middleware = (_a = this._client.middleware.workspace) == null ? void 0 : _a.didChangeConfiguration;
      (middleware ? middleware(sections, didChangeConfiguration) : didChangeConfiguration(sections)).catch(error => {
        this._client.error(`Sending notification ${vscode_languageserver_protocol_1.DidChangeConfigurationNotification.type.method} failed`, error);
      });
    }
    extractSettingsInformation(keys) {
      function ensurePath(config, path) {
        let current = config;
        for (let i = 0; i < path.length - 1; i++) {
          let obj = current[path[i]];
          obj || (obj = Object.create(null), current[path[i]] = obj), current = obj;
        }
        return current;
      }
      __name(ensurePath, "ensurePath");
      let resource = this._client.clientOptions.workspaceFolder ? this._client.clientOptions.workspaceFolder.uri : void 0,
        result = Object.create(null);
      for (let i = 0; i < keys.length; i++) {
        let key = keys[i],
          index = key.indexOf("."),
          config = null;
        if (index >= 0 ? config = vscode_1.workspace.getConfiguration(key.substr(0, index), resource).get(key.substr(index + 1)) : config = vscode_1.workspace.getConfiguration(void 0, resource).get(key), config) {
          let path = keys[i].split(".");
          ensurePath(result, path)[path[path.length - 1]] = toJSONObject(config);
        }
      }
      return result;
    }
  };
  __name(_SyncConfigurationFeature, "SyncConfigurationFeature");
  var SyncConfigurationFeature = _SyncConfigurationFeature;
  exports.SyncConfigurationFeature = SyncConfigurationFeature;
});