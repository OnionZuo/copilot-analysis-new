var require_executeCommand = __commonJSMin(exports => {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: !0
  });
  exports.ExecuteCommandFeature = void 0;
  var vscode_1 = require("vscode"),
    vscode_languageserver_protocol_1 = Un(),
    UUID = yo(),
    features_1 = Oi(),
    _ExecuteCommandFeature = class _ExecuteCommandFeature {
      constructor(client) {
        this._client = client, this._commands = new Map();
      }
      getState() {
        return {
          kind: "workspace",
          id: this.registrationType.method,
          registrations: this._commands.size > 0
        };
      }
      get registrationType() {
        return vscode_languageserver_protocol_1.ExecuteCommandRequest.type;
      }
      fillClientCapabilities(capabilities) {
        (0, features_1.ensure)((0, features_1.ensure)(capabilities, "workspace"), "executeCommand").dynamicRegistration = !0;
      }
      initialize(capabilities) {
        capabilities.executeCommandProvider && this.register({
          id: UUID.generateUuid(),
          registerOptions: Object.assign({}, capabilities.executeCommandProvider)
        });
      }
      register(data) {
        let client = this._client,
          middleware = client.middleware,
          executeCommand = __name((command, args) => {
            let params = {
              command: command,
              arguments: args
            };
            return client.sendRequest(vscode_languageserver_protocol_1.ExecuteCommandRequest.type, params).then(void 0, error => client.handleFailedRequest(vscode_languageserver_protocol_1.ExecuteCommandRequest.type, void 0, error, void 0));
          }, "executeCommand");
        if (data.registerOptions.commands) {
          let disposables = [];
          for (let command of data.registerOptions.commands) disposables.push(vscode_1.commands.registerCommand(command, (...args) => middleware.executeCommand ? middleware.executeCommand(command, args, executeCommand) : executeCommand(command, args)));
          this._commands.set(data.id, disposables);
        }
      }
      unregister(id) {
        let disposables = this._commands.get(id);
        disposables && disposables.forEach(disposable => disposable.dispose());
      }
      clear() {
        this._commands.forEach(value => {
          value.forEach(disposable => disposable.dispose());
        }), this._commands.clear();
      }
    };
  __name(_ExecuteCommandFeature, "ExecuteCommandFeature");
  var ExecuteCommandFeature = _ExecuteCommandFeature;
  exports.ExecuteCommandFeature = ExecuteCommandFeature;
});