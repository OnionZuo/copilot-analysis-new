var require_codeLens = __commonJSMin(exports => {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: !0
  });
  exports.CodeLensFeature = void 0;
  var vscode_1 = require("vscode"),
    vscode_languageserver_protocol_1 = Un(),
    UUID = yo(),
    features_1 = Oi(),
    _CodeLensFeature = class _CodeLensFeature extends features_1.TextDocumentLanguageFeature {
      constructor(client) {
        super(client, vscode_languageserver_protocol_1.CodeLensRequest.type);
      }
      fillClientCapabilities(capabilities) {
        (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "codeLens").dynamicRegistration = !0, (0, features_1.ensure)((0, features_1.ensure)(capabilities, "workspace"), "codeLens").refreshSupport = !0;
      }
      initialize(capabilities, documentSelector) {
        this._client.onRequest(vscode_languageserver_protocol_1.CodeLensRefreshRequest.type, async () => {
          for (let provider of this.getAllProviders()) provider.onDidChangeCodeLensEmitter.fire();
        });
        let options = this.getRegistrationOptions(documentSelector, capabilities.codeLensProvider);
        options && this.register({
          id: UUID.generateUuid(),
          registerOptions: options
        });
      }
      registerLanguageProvider(options) {
        let selector = options.documentSelector,
          eventEmitter = new vscode_1.EventEmitter(),
          provider = {
            onDidChangeCodeLenses: eventEmitter.event,
            provideCodeLenses: __name((document, token) => {
              let client = this._client,
                provideCodeLenses = __name((document, token) => client.sendRequest(vscode_languageserver_protocol_1.CodeLensRequest.type, client.code2ProtocolConverter.asCodeLensParams(document), token).then(result => token.isCancellationRequested ? null : client.protocol2CodeConverter.asCodeLenses(result, token), error => client.handleFailedRequest(vscode_languageserver_protocol_1.CodeLensRequest.type, token, error, null)), "provideCodeLenses"),
                middleware = client.middleware;
              return middleware.provideCodeLenses ? middleware.provideCodeLenses(document, token, provideCodeLenses) : provideCodeLenses(document, token);
            }, "provideCodeLenses"),
            resolveCodeLens: options.resolveProvider ? (codeLens, token) => {
              let client = this._client,
                resolveCodeLens = __name((codeLens, token) => client.sendRequest(vscode_languageserver_protocol_1.CodeLensResolveRequest.type, client.code2ProtocolConverter.asCodeLens(codeLens), token).then(result => token.isCancellationRequested ? codeLens : client.protocol2CodeConverter.asCodeLens(result), error => client.handleFailedRequest(vscode_languageserver_protocol_1.CodeLensResolveRequest.type, token, error, codeLens)), "resolveCodeLens"),
                middleware = client.middleware;
              return middleware.resolveCodeLens ? middleware.resolveCodeLens(codeLens, token, resolveCodeLens) : resolveCodeLens(codeLens, token);
            } : void 0
          };
        return [vscode_1.languages.registerCodeLensProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider), {
          provider: provider,
          onDidChangeCodeLensEmitter: eventEmitter
        }];
      }
    };
  __name(_CodeLensFeature, "CodeLensFeature");
  var CodeLensFeature = _CodeLensFeature;
  exports.CodeLensFeature = CodeLensFeature;
});