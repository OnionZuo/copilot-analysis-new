var require_fileOperations = __commonJSMin(exports => {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: !0
  });
  exports.WillDeleteFilesFeature = exports.WillRenameFilesFeature = exports.WillCreateFilesFeature = exports.DidDeleteFilesFeature = exports.DidRenameFilesFeature = exports.DidCreateFilesFeature = void 0;
  var code = require("vscode"),
    minimatch = mq(),
    proto = Un(),
    UUID = yo();
  function ensure(target, key) {
    return target[key] === void 0 && (target[key] = {}), target[key];
  }
  __name(ensure, "ensure");
  function access(target, key) {
    return target[key];
  }
  __name(access, "access");
  function assign(target, key, value) {
    target[key] = value;
  }
  __name(assign, "assign");
  var _FileOperationFeature = class _FileOperationFeature {
    constructor(client, event, registrationType, clientCapability, serverCapability) {
      this._client = client, this._event = event, this._registrationType = registrationType, this._clientCapability = clientCapability, this._serverCapability = serverCapability, this._filters = new Map();
    }
    getState() {
      return {
        kind: "workspace",
        id: this._registrationType.method,
        registrations: this._filters.size > 0
      };
    }
    filterSize() {
      return this._filters.size;
    }
    get registrationType() {
      return this._registrationType;
    }
    fillClientCapabilities(capabilities) {
      let value = ensure(ensure(capabilities, "workspace"), "fileOperations");
      assign(value, "dynamicRegistration", !0), assign(value, this._clientCapability, !0);
    }
    initialize(capabilities) {
      var _a;
      let options = (_a = capabilities.workspace) == null ? void 0 : _a.fileOperations,
        capability = options !== void 0 ? access(options, this._serverCapability) : void 0;
      if ((capability == null ? void 0 : capability.filters) !== void 0) try {
        this.register({
          id: UUID.generateUuid(),
          registerOptions: {
            filters: capability.filters
          }
        });
      } catch (e) {
        this._client.warn(`Ignoring invalid glob pattern for ${this._serverCapability} registration: ${e}`);
      }
    }
    register(data) {
      this._listener || (this._listener = this._event(this.send, this));
      let minimatchFilter = data.registerOptions.filters.map(filter => {
        let matcher = new minimatch.Minimatch(filter.pattern.glob, _FileOperationFeature.asMinimatchOptions(filter.pattern.options));
        if (!matcher.makeRe()) throw new Error(`Invalid pattern ${filter.pattern.glob}!`);
        return {
          scheme: filter.scheme,
          matcher: matcher,
          kind: filter.pattern.matches
        };
      });
      this._filters.set(data.id, minimatchFilter);
    }
    unregister(id) {
      this._filters.delete(id), this._filters.size === 0 && this._listener && (this._listener.dispose(), this._listener = void 0);
    }
    clear() {
      this._filters.clear(), this._listener && (this._listener.dispose(), this._listener = void 0);
    }
    getFileType(uri) {
      return _FileOperationFeature.getFileType(uri);
    }
    async filter(event, prop) {
      let fileMatches = await Promise.all(event.files.map(async item => {
          let uri = prop(item),
            path = uri.fsPath.replace(/\\/g, "/");
          for (let filters of this._filters.values()) for (let filter of filters) if (!(filter.scheme !== void 0 && filter.scheme !== uri.scheme)) {
            if (filter.matcher.match(path)) {
              if (filter.kind === void 0) return !0;
              let fileType = await this.getFileType(uri);
              if (fileType === void 0) return this._client.error(`Failed to determine file type for ${uri.toString()}.`), !0;
              if (fileType === code.FileType.File && filter.kind === proto.FileOperationPatternKind.file || fileType === code.FileType.Directory && filter.kind === proto.FileOperationPatternKind.folder) return !0;
            } else if (filter.kind === proto.FileOperationPatternKind.folder && (await _FileOperationFeature.getFileType(uri)) === code.FileType.Directory && filter.matcher.match(`${path}/`)) return !0;
          }
          return !1;
        })),
        files = event.files.filter((_, index) => fileMatches[index]);
      return {
        ...event,
        files: files
      };
    }
    static async getFileType(uri) {
      try {
        return (await code.workspace.fs.stat(uri)).type;
      } catch {
        return;
      }
    }
    static asMinimatchOptions(options) {
      let result = {
        dot: !0
      };
      return (options == null ? void 0 : options.ignoreCase) === !0 && (result.nocase = !0), result;
    }
  };
  __name(_FileOperationFeature, "FileOperationFeature");
  var FileOperationFeature = _FileOperationFeature,
    _NotificationFileOperationFeature = class _NotificationFileOperationFeature extends FileOperationFeature {
      constructor(client, event, notificationType, clientCapability, serverCapability, accessUri, createParams) {
        super(client, event, notificationType, clientCapability, serverCapability), this._notificationType = notificationType, this._accessUri = accessUri, this._createParams = createParams;
      }
      async send(originalEvent) {
        let filteredEvent = await this.filter(originalEvent, this._accessUri);
        if (filteredEvent.files.length) {
          let next = __name(async event => this._client.sendNotification(this._notificationType, this._createParams(event)), "next");
          return this.doSend(filteredEvent, next);
        }
      }
    };
  __name(_NotificationFileOperationFeature, "NotificationFileOperationFeature");
  var NotificationFileOperationFeature = _NotificationFileOperationFeature,
    _CachingNotificationFileOperationFeature = class _CachingNotificationFileOperationFeature extends NotificationFileOperationFeature {
      constructor() {
        super(...arguments), this._fsPathFileTypes = new Map();
      }
      async getFileType(uri) {
        let fsPath = uri.fsPath;
        if (this._fsPathFileTypes.has(fsPath)) return this._fsPathFileTypes.get(fsPath);
        let type = await FileOperationFeature.getFileType(uri);
        return type && this._fsPathFileTypes.set(fsPath, type), type;
      }
      async cacheFileTypes(event, prop) {
        await this.filter(event, prop);
      }
      clearFileTypeCache() {
        this._fsPathFileTypes.clear();
      }
      unregister(id) {
        super.unregister(id), this.filterSize() === 0 && this._willListener && (this._willListener.dispose(), this._willListener = void 0);
      }
      clear() {
        super.clear(), this._willListener && (this._willListener.dispose(), this._willListener = void 0);
      }
    };
  __name(_CachingNotificationFileOperationFeature, "CachingNotificationFileOperationFeature");
  var CachingNotificationFileOperationFeature = _CachingNotificationFileOperationFeature,
    _DidCreateFilesFeature = class _DidCreateFilesFeature extends NotificationFileOperationFeature {
      constructor(client) {
        super(client, code.workspace.onDidCreateFiles, proto.DidCreateFilesNotification.type, "didCreate", "didCreate", i => i, client.code2ProtocolConverter.asDidCreateFilesParams);
      }
      doSend(event, next) {
        let middleware = this._client.middleware.workspace;
        return middleware != null && middleware.didCreateFiles ? middleware.didCreateFiles(event, next) : next(event);
      }
    };
  __name(_DidCreateFilesFeature, "DidCreateFilesFeature");
  var DidCreateFilesFeature = _DidCreateFilesFeature;
  exports.DidCreateFilesFeature = DidCreateFilesFeature;
  var _DidRenameFilesFeature = class _DidRenameFilesFeature extends CachingNotificationFileOperationFeature {
    constructor(client) {
      super(client, code.workspace.onDidRenameFiles, proto.DidRenameFilesNotification.type, "didRename", "didRename", i => i.oldUri, client.code2ProtocolConverter.asDidRenameFilesParams);
    }
    register(data) {
      this._willListener || (this._willListener = code.workspace.onWillRenameFiles(this.willRename, this)), super.register(data);
    }
    willRename(e) {
      e.waitUntil(this.cacheFileTypes(e, i => i.oldUri));
    }
    doSend(event, next) {
      this.clearFileTypeCache();
      let middleware = this._client.middleware.workspace;
      return middleware != null && middleware.didRenameFiles ? middleware.didRenameFiles(event, next) : next(event);
    }
  };
  __name(_DidRenameFilesFeature, "DidRenameFilesFeature");
  var DidRenameFilesFeature = _DidRenameFilesFeature;
  exports.DidRenameFilesFeature = DidRenameFilesFeature;
  var _DidDeleteFilesFeature = class _DidDeleteFilesFeature extends CachingNotificationFileOperationFeature {
    constructor(client) {
      super(client, code.workspace.onDidDeleteFiles, proto.DidDeleteFilesNotification.type, "didDelete", "didDelete", i => i, client.code2ProtocolConverter.asDidDeleteFilesParams);
    }
    register(data) {
      this._willListener || (this._willListener = code.workspace.onWillDeleteFiles(this.willDelete, this)), super.register(data);
    }
    willDelete(e) {
      e.waitUntil(this.cacheFileTypes(e, i => i));
    }
    doSend(event, next) {
      this.clearFileTypeCache();
      let middleware = this._client.middleware.workspace;
      return middleware != null && middleware.didDeleteFiles ? middleware.didDeleteFiles(event, next) : next(event);
    }
  };
  __name(_DidDeleteFilesFeature, "DidDeleteFilesFeature");
  var DidDeleteFilesFeature = _DidDeleteFilesFeature;
  exports.DidDeleteFilesFeature = DidDeleteFilesFeature;
  var _RequestFileOperationFeature = class _RequestFileOperationFeature extends FileOperationFeature {
    constructor(client, event, requestType, clientCapability, serverCapability, accessUri, createParams) {
      super(client, event, requestType, clientCapability, serverCapability), this._requestType = requestType, this._accessUri = accessUri, this._createParams = createParams;
    }
    async send(originalEvent) {
      let waitUntil = this.waitUntil(originalEvent);
      originalEvent.waitUntil(waitUntil);
    }
    async waitUntil(originalEvent) {
      let filteredEvent = await this.filter(originalEvent, this._accessUri);
      if (filteredEvent.files.length) {
        let next = __name(event => this._client.sendRequest(this._requestType, this._createParams(event), event.token).then(this._client.protocol2CodeConverter.asWorkspaceEdit), "next");
        return this.doSend(filteredEvent, next);
      } else return;
    }
  };
  __name(_RequestFileOperationFeature, "RequestFileOperationFeature");
  var RequestFileOperationFeature = _RequestFileOperationFeature,
    _WillCreateFilesFeature = class _WillCreateFilesFeature extends RequestFileOperationFeature {
      constructor(client) {
        super(client, code.workspace.onWillCreateFiles, proto.WillCreateFilesRequest.type, "willCreate", "willCreate", i => i, client.code2ProtocolConverter.asWillCreateFilesParams);
      }
      doSend(event, next) {
        let middleware = this._client.middleware.workspace;
        return middleware != null && middleware.willCreateFiles ? middleware.willCreateFiles(event, next) : next(event);
      }
    };
  __name(_WillCreateFilesFeature, "WillCreateFilesFeature");
  var WillCreateFilesFeature = _WillCreateFilesFeature;
  exports.WillCreateFilesFeature = WillCreateFilesFeature;
  var _WillRenameFilesFeature = class _WillRenameFilesFeature extends RequestFileOperationFeature {
    constructor(client) {
      super(client, code.workspace.onWillRenameFiles, proto.WillRenameFilesRequest.type, "willRename", "willRename", i => i.oldUri, client.code2ProtocolConverter.asWillRenameFilesParams);
    }
    doSend(event, next) {
      let middleware = this._client.middleware.workspace;
      return middleware != null && middleware.willRenameFiles ? middleware.willRenameFiles(event, next) : next(event);
    }
  };
  __name(_WillRenameFilesFeature, "WillRenameFilesFeature");
  var WillRenameFilesFeature = _WillRenameFilesFeature;
  exports.WillRenameFilesFeature = WillRenameFilesFeature;
  var _WillDeleteFilesFeature = class _WillDeleteFilesFeature extends RequestFileOperationFeature {
    constructor(client) {
      super(client, code.workspace.onWillDeleteFiles, proto.WillDeleteFilesRequest.type, "willDelete", "willDelete", i => i, client.code2ProtocolConverter.asWillDeleteFilesParams);
    }
    doSend(event, next) {
      let middleware = this._client.middleware.workspace;
      return middleware != null && middleware.willDeleteFiles ? middleware.willDeleteFiles(event, next) : next(event);
    }
  };
  __name(_WillDeleteFilesFeature, "WillDeleteFilesFeature");
  var WillDeleteFilesFeature = _WillDeleteFilesFeature;
  exports.WillDeleteFilesFeature = WillDeleteFilesFeature;
});