var require_signatureHelp = __commonJSMin(exports => {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: !0
  });
  exports.SignatureHelpFeature = void 0;
  var vscode_1 = require("vscode"),
    vscode_languageserver_protocol_1 = Un(),
    features_1 = Oi(),
    UUID = yo(),
    _SignatureHelpFeature = class _SignatureHelpFeature extends features_1.TextDocumentLanguageFeature {
      constructor(client) {
        super(client, vscode_languageserver_protocol_1.SignatureHelpRequest.type);
      }
      fillClientCapabilities(capabilities) {
        let config = (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "signatureHelp");
        config.dynamicRegistration = !0, config.signatureInformation = {
          documentationFormat: [vscode_languageserver_protocol_1.MarkupKind.Markdown, vscode_languageserver_protocol_1.MarkupKind.PlainText]
        }, config.signatureInformation.parameterInformation = {
          labelOffsetSupport: !0
        }, config.signatureInformation.activeParameterSupport = !0, config.contextSupport = !0;
      }
      initialize(capabilities, documentSelector) {
        let options = this.getRegistrationOptions(documentSelector, capabilities.signatureHelpProvider);
        options && this.register({
          id: UUID.generateUuid(),
          registerOptions: options
        });
      }
      registerLanguageProvider(options) {
        let provider = {
          provideSignatureHelp: __name((document, position, token, context) => {
            let client = this._client,
              providerSignatureHelp = __name((document, position, context, token) => client.sendRequest(vscode_languageserver_protocol_1.SignatureHelpRequest.type, client.code2ProtocolConverter.asSignatureHelpParams(document, position, context), token).then(result => token.isCancellationRequested ? null : client.protocol2CodeConverter.asSignatureHelp(result, token), error => client.handleFailedRequest(vscode_languageserver_protocol_1.SignatureHelpRequest.type, token, error, null)), "providerSignatureHelp"),
              middleware = client.middleware;
            return middleware.provideSignatureHelp ? middleware.provideSignatureHelp(document, position, context, token, providerSignatureHelp) : providerSignatureHelp(document, position, context, token);
          }, "provideSignatureHelp")
        };
        return [this.registerProvider(options, provider), provider];
      }
      registerProvider(options, provider) {
        let selector = this._client.protocol2CodeConverter.asDocumentSelector(options.documentSelector);
        if (options.retriggerCharacters === void 0) {
          let triggerCharacters = options.triggerCharacters || [];
          return vscode_1.languages.registerSignatureHelpProvider(selector, provider, ...triggerCharacters);
        } else {
          let metaData = {
            triggerCharacters: options.triggerCharacters || [],
            retriggerCharacters: options.retriggerCharacters || []
          };
          return vscode_1.languages.registerSignatureHelpProvider(selector, provider, metaData);
        }
      }
    };
  __name(_SignatureHelpFeature, "SignatureHelpFeature");
  var SignatureHelpFeature = _SignatureHelpFeature;
  exports.SignatureHelpFeature = SignatureHelpFeature;
});