var require_formatting = __commonJSMin(exports => {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: !0
  });
  exports.DocumentOnTypeFormattingFeature = exports.DocumentRangeFormattingFeature = exports.DocumentFormattingFeature = void 0;
  var vscode_1 = require("vscode"),
    vscode_languageserver_protocol_1 = Un(),
    UUID = yo(),
    features_1 = Oi(),
    FileFormattingOptions;
  (function (FileFormattingOptions) {
    function fromConfiguration(document) {
      let filesConfig = vscode_1.workspace.getConfiguration("files", document);
      return {
        trimTrailingWhitespace: filesConfig.get("trimTrailingWhitespace"),
        trimFinalNewlines: filesConfig.get("trimFinalNewlines"),
        insertFinalNewline: filesConfig.get("insertFinalNewline")
      };
    }
    __name(fromConfiguration, "fromConfiguration"), FileFormattingOptions.fromConfiguration = fromConfiguration;
  })(FileFormattingOptions || (FileFormattingOptions = {}));
  var _DocumentFormattingFeature = class _DocumentFormattingFeature extends features_1.TextDocumentLanguageFeature {
    constructor(client) {
      super(client, vscode_languageserver_protocol_1.DocumentFormattingRequest.type);
    }
    fillClientCapabilities(capabilities) {
      (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "formatting").dynamicRegistration = !0;
    }
    initialize(capabilities, documentSelector) {
      let options = this.getRegistrationOptions(documentSelector, capabilities.documentFormattingProvider);
      options && this.register({
        id: UUID.generateUuid(),
        registerOptions: options
      });
    }
    registerLanguageProvider(options) {
      let selector = options.documentSelector,
        provider = {
          provideDocumentFormattingEdits: __name((document, options, token) => {
            let client = this._client,
              provideDocumentFormattingEdits = __name((document, options, token) => {
                let params = {
                  textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document),
                  options: client.code2ProtocolConverter.asFormattingOptions(options, FileFormattingOptions.fromConfiguration(document))
                };
                return client.sendRequest(vscode_languageserver_protocol_1.DocumentFormattingRequest.type, params, token).then(result => token.isCancellationRequested ? null : client.protocol2CodeConverter.asTextEdits(result, token), error => client.handleFailedRequest(vscode_languageserver_protocol_1.DocumentFormattingRequest.type, token, error, null));
              }, "provideDocumentFormattingEdits"),
              middleware = client.middleware;
            return middleware.provideDocumentFormattingEdits ? middleware.provideDocumentFormattingEdits(document, options, token, provideDocumentFormattingEdits) : provideDocumentFormattingEdits(document, options, token);
          }, "provideDocumentFormattingEdits")
        };
      return [vscode_1.languages.registerDocumentFormattingEditProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider), provider];
    }
  };
  __name(_DocumentFormattingFeature, "DocumentFormattingFeature");
  var DocumentFormattingFeature = _DocumentFormattingFeature;
  exports.DocumentFormattingFeature = DocumentFormattingFeature;
  var _DocumentRangeFormattingFeature = class _DocumentRangeFormattingFeature extends features_1.TextDocumentLanguageFeature {
    constructor(client) {
      super(client, vscode_languageserver_protocol_1.DocumentRangeFormattingRequest.type);
    }
    fillClientCapabilities(capabilities) {
      let capability = (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "rangeFormatting");
      capability.dynamicRegistration = !0, capability.rangesSupport = !0;
    }
    initialize(capabilities, documentSelector) {
      let options = this.getRegistrationOptions(documentSelector, capabilities.documentRangeFormattingProvider);
      options && this.register({
        id: UUID.generateUuid(),
        registerOptions: options
      });
    }
    registerLanguageProvider(options) {
      let selector = options.documentSelector,
        provider = {
          provideDocumentRangeFormattingEdits: __name((document, range, options, token) => {
            let client = this._client,
              provideDocumentRangeFormattingEdits = __name((document, range, options, token) => {
                let params = {
                  textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document),
                  range: client.code2ProtocolConverter.asRange(range),
                  options: client.code2ProtocolConverter.asFormattingOptions(options, FileFormattingOptions.fromConfiguration(document))
                };
                return client.sendRequest(vscode_languageserver_protocol_1.DocumentRangeFormattingRequest.type, params, token).then(result => token.isCancellationRequested ? null : client.protocol2CodeConverter.asTextEdits(result, token), error => client.handleFailedRequest(vscode_languageserver_protocol_1.DocumentRangeFormattingRequest.type, token, error, null));
              }, "provideDocumentRangeFormattingEdits"),
              middleware = client.middleware;
            return middleware.provideDocumentRangeFormattingEdits ? middleware.provideDocumentRangeFormattingEdits(document, range, options, token, provideDocumentRangeFormattingEdits) : provideDocumentRangeFormattingEdits(document, range, options, token);
          }, "provideDocumentRangeFormattingEdits")
        };
      return options.rangesSupport && (provider.provideDocumentRangesFormattingEdits = (document, ranges, options, token) => {
        let client = this._client,
          provideDocumentRangesFormattingEdits = __name((document, ranges, options, token) => {
            let params = {
              textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document),
              ranges: client.code2ProtocolConverter.asRanges(ranges),
              options: client.code2ProtocolConverter.asFormattingOptions(options, FileFormattingOptions.fromConfiguration(document))
            };
            return client.sendRequest(vscode_languageserver_protocol_1.DocumentRangesFormattingRequest.type, params, token).then(result => token.isCancellationRequested ? null : client.protocol2CodeConverter.asTextEdits(result, token), error => client.handleFailedRequest(vscode_languageserver_protocol_1.DocumentRangesFormattingRequest.type, token, error, null));
          }, "provideDocumentRangesFormattingEdits"),
          middleware = client.middleware;
        return middleware.provideDocumentRangesFormattingEdits ? middleware.provideDocumentRangesFormattingEdits(document, ranges, options, token, provideDocumentRangesFormattingEdits) : provideDocumentRangesFormattingEdits(document, ranges, options, token);
      }), [vscode_1.languages.registerDocumentRangeFormattingEditProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider), provider];
    }
  };
  __name(_DocumentRangeFormattingFeature, "DocumentRangeFormattingFeature");
  var DocumentRangeFormattingFeature = _DocumentRangeFormattingFeature;
  exports.DocumentRangeFormattingFeature = DocumentRangeFormattingFeature;
  var _DocumentOnTypeFormattingFeature = class _DocumentOnTypeFormattingFeature extends features_1.TextDocumentLanguageFeature {
    constructor(client) {
      super(client, vscode_languageserver_protocol_1.DocumentOnTypeFormattingRequest.type);
    }
    fillClientCapabilities(capabilities) {
      (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "onTypeFormatting").dynamicRegistration = !0;
    }
    initialize(capabilities, documentSelector) {
      let options = this.getRegistrationOptions(documentSelector, capabilities.documentOnTypeFormattingProvider);
      options && this.register({
        id: UUID.generateUuid(),
        registerOptions: options
      });
    }
    registerLanguageProvider(options) {
      let selector = options.documentSelector,
        provider = {
          provideOnTypeFormattingEdits: __name((document, position, ch, options, token) => {
            let client = this._client,
              provideOnTypeFormattingEdits = __name((document, position, ch, options, token) => {
                let params = {
                  textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document),
                  position: client.code2ProtocolConverter.asPosition(position),
                  ch: ch,
                  options: client.code2ProtocolConverter.asFormattingOptions(options, FileFormattingOptions.fromConfiguration(document))
                };
                return client.sendRequest(vscode_languageserver_protocol_1.DocumentOnTypeFormattingRequest.type, params, token).then(result => token.isCancellationRequested ? null : client.protocol2CodeConverter.asTextEdits(result, token), error => client.handleFailedRequest(vscode_languageserver_protocol_1.DocumentOnTypeFormattingRequest.type, token, error, null));
              }, "provideOnTypeFormattingEdits"),
              middleware = client.middleware;
            return middleware.provideOnTypeFormattingEdits ? middleware.provideOnTypeFormattingEdits(document, position, ch, options, token, provideOnTypeFormattingEdits) : provideOnTypeFormattingEdits(document, position, ch, options, token);
          }, "provideOnTypeFormattingEdits")
        },
        moreTriggerCharacter = options.moreTriggerCharacter || [];
      return [vscode_1.languages.registerOnTypeFormattingEditProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider, options.firstTriggerCharacter, ...moreTriggerCharacter), provider];
    }
  };
  __name(_DocumentOnTypeFormattingFeature, "DocumentOnTypeFormattingFeature");
  var DocumentOnTypeFormattingFeature = _DocumentOnTypeFormattingFeature;
  exports.DocumentOnTypeFormattingFeature = DocumentOnTypeFormattingFeature;
});