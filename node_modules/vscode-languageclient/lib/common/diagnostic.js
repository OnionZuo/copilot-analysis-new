var require_diagnostic = __commonJSMin(exports => {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: !0
  });
  exports.DiagnosticFeature = exports.DiagnosticPullMode = exports.vsdiag = void 0;
  var minimatch = mq(),
    vscode_1 = require("vscode"),
    vscode_languageserver_protocol_1 = Un(),
    uuid_1 = yo(),
    features_1 = Oi();
  function ensure(target, key) {
    return target[key] === void 0 && (target[key] = {}), target[key];
  }
  __name(ensure, "ensure");
  var vsdiag;
  (function (vsdiag) {
    let DocumentDiagnosticReportKind;
    (function (DocumentDiagnosticReportKind) {
      DocumentDiagnosticReportKind.full = "full", DocumentDiagnosticReportKind.unChanged = "unChanged";
    })(DocumentDiagnosticReportKind = vsdiag.DocumentDiagnosticReportKind || (vsdiag.DocumentDiagnosticReportKind = {}));
  })(vsdiag || (exports.vsdiag = vsdiag = {}));
  var DiagnosticPullMode;
  (function (DiagnosticPullMode) {
    DiagnosticPullMode.onType = "onType", DiagnosticPullMode.onSave = "onSave";
  })(DiagnosticPullMode || (exports.DiagnosticPullMode = DiagnosticPullMode = {}));
  var RequestStateKind;
  (function (RequestStateKind) {
    RequestStateKind.active = "open", RequestStateKind.reschedule = "reschedule", RequestStateKind.outDated = "drop";
  })(RequestStateKind || (RequestStateKind = {}));
  var _Tabs = class _Tabs {
    constructor() {
      this.open = new Set(), this._onOpen = new vscode_1.EventEmitter(), this._onClose = new vscode_1.EventEmitter(), _Tabs.fillTabResources(this.open);
      let openTabsHandler = __name(event => {
        if (event.closed.length === 0 && event.opened.length === 0) return;
        let oldTabs = this.open,
          currentTabs = new Set();
        _Tabs.fillTabResources(currentTabs);
        let closed = new Set(),
          opened = new Set(currentTabs);
        for (let tab of oldTabs.values()) currentTabs.has(tab) ? opened.delete(tab) : closed.add(tab);
        if (this.open = currentTabs, closed.size > 0) {
          let toFire = new Set();
          for (let item of closed) toFire.add(vscode_1.Uri.parse(item));
          this._onClose.fire(toFire);
        }
        if (opened.size > 0) {
          let toFire = new Set();
          for (let item of opened) toFire.add(vscode_1.Uri.parse(item));
          this._onOpen.fire(toFire);
        }
      }, "openTabsHandler");
      vscode_1.window.tabGroups.onDidChangeTabs !== void 0 ? this.disposable = vscode_1.window.tabGroups.onDidChangeTabs(openTabsHandler) : this.disposable = {
        dispose: __name(() => {}, "dispose")
      };
    }
    get onClose() {
      return this._onClose.event;
    }
    get onOpen() {
      return this._onOpen.event;
    }
    dispose() {
      this.disposable.dispose();
    }
    isActive(document) {
      var _a, _b;
      return document instanceof vscode_1.Uri ? ((_a = vscode_1.window.activeTextEditor) == null ? void 0 : _a.document.uri) === document : ((_b = vscode_1.window.activeTextEditor) == null ? void 0 : _b.document) === document;
    }
    isVisible(document) {
      let uri = document instanceof vscode_1.Uri ? document : document.uri;
      return this.open.has(uri.toString());
    }
    getTabResources() {
      let result = new Set();
      return _Tabs.fillTabResources(new Set(), result), result;
    }
    static fillTabResources(strings, uris) {
      let seen = strings != null ? strings : new Set();
      for (let group of vscode_1.window.tabGroups.all) for (let tab of group.tabs) {
        let input = tab.input,
          uri;
        input instanceof vscode_1.TabInputText ? uri = input.uri : input instanceof vscode_1.TabInputTextDiff ? uri = input.modified : input instanceof vscode_1.TabInputCustom && (uri = input.uri), uri !== void 0 && !seen.has(uri.toString()) && (seen.add(uri.toString()), uris !== void 0 && uris.add(uri));
      }
    }
  };
  __name(_Tabs, "Tabs");
  var Tabs = _Tabs,
    PullState;
  (function (PullState) {
    PullState[PullState.document = 1] = "document", PullState[PullState.workspace = 2] = "workspace";
  })(PullState || (PullState = {}));
  var DocumentOrUri;
  (function (DocumentOrUri) {
    function asKey(document) {
      return document instanceof vscode_1.Uri ? document.toString() : document.uri.toString();
    }
    __name(asKey, "asKey"), DocumentOrUri.asKey = asKey;
  })(DocumentOrUri || (DocumentOrUri = {}));
  var _DocumentPullStateTracker = class _DocumentPullStateTracker {
    constructor() {
      this.documentPullStates = new Map(), this.workspacePullStates = new Map();
    }
    track(kind, document, arg1) {
      let states = kind === PullState.document ? this.documentPullStates : this.workspacePullStates,
        [key, uri, version] = document instanceof vscode_1.Uri ? [document.toString(), document, arg1] : [document.uri.toString(), document.uri, document.version],
        state = states.get(key);
      return state === void 0 && (state = {
        document: uri,
        pulledVersion: version,
        resultId: void 0
      }, states.set(key, state)), state;
    }
    update(kind, document, arg1, arg2) {
      let states = kind === PullState.document ? this.documentPullStates : this.workspacePullStates,
        [key, uri, version, resultId] = document instanceof vscode_1.Uri ? [document.toString(), document, arg1, arg2] : [document.uri.toString(), document.uri, document.version, arg1],
        state = states.get(key);
      state === void 0 ? (state = {
        document: uri,
        pulledVersion: version,
        resultId: resultId
      }, states.set(key, state)) : (state.pulledVersion = version, state.resultId = resultId);
    }
    unTrack(kind, document) {
      let key = DocumentOrUri.asKey(document);
      (kind === PullState.document ? this.documentPullStates : this.workspacePullStates).delete(key);
    }
    tracks(kind, document) {
      let key = DocumentOrUri.asKey(document);
      return (kind === PullState.document ? this.documentPullStates : this.workspacePullStates).has(key);
    }
    getResultId(kind, document) {
      var _a;
      let key = DocumentOrUri.asKey(document);
      return (_a = (kind === PullState.document ? this.documentPullStates : this.workspacePullStates).get(key)) == null ? void 0 : _a.resultId;
    }
    getAllResultIds() {
      let result = [];
      for (let [uri, value] of this.workspacePullStates) this.documentPullStates.has(uri) && (value = this.documentPullStates.get(uri)), value.resultId !== void 0 && result.push({
        uri: uri,
        value: value.resultId
      });
      return result;
    }
  };
  __name(_DocumentPullStateTracker, "DocumentPullStateTracker");
  var DocumentPullStateTracker = _DocumentPullStateTracker,
    _DiagnosticRequestor = class _DiagnosticRequestor {
      constructor(client, tabs, options) {
        this.client = client, this.tabs = tabs, this.options = options, this.isDisposed = !1, this.onDidChangeDiagnosticsEmitter = new vscode_1.EventEmitter(), this.provider = this.createProvider(), this.diagnostics = vscode_1.languages.createDiagnosticCollection(options.identifier), this.openRequests = new Map(), this.documentStates = new DocumentPullStateTracker(), this.workspaceErrorCounter = 0;
      }
      knows(kind, document) {
        let uri = document instanceof vscode_1.Uri ? document : document.uri;
        return this.documentStates.tracks(kind, document) || this.openRequests.has(uri.toString());
      }
      forget(kind, document) {
        this.documentStates.unTrack(kind, document);
      }
      pull(document, cb) {
        if (this.isDisposed) return;
        let uri = document instanceof vscode_1.Uri ? document : document.uri;
        this.pullAsync(document).then(() => {
          cb && cb();
        }, error => {
          this.client.error(`Document pull failed for text document ${uri.toString()}`, error, !1);
        });
      }
      async pullAsync(document, version) {
        var _a;
        if (this.isDisposed) return;
        let isUri = document instanceof vscode_1.Uri,
          uri = isUri ? document : document.uri,
          key = uri.toString();
        version = isUri ? version : document.version;
        let currentRequestState = this.openRequests.get(key),
          documentState = isUri ? this.documentStates.track(PullState.document, document, version) : this.documentStates.track(PullState.document, document);
        if (currentRequestState === void 0) {
          let tokenSource = new vscode_1.CancellationTokenSource();
          this.openRequests.set(key, {
            state: RequestStateKind.active,
            document: document,
            version: version,
            tokenSource: tokenSource
          });
          let report, afterState;
          try {
            report = (_a = await this.provider.provideDiagnostics(document, documentState.resultId, tokenSource.token)) != null ? _a : {
              kind: vsdiag.DocumentDiagnosticReportKind.full,
              items: []
            };
          } catch (error) {
            if (error instanceof features_1.LSPCancellationError && vscode_languageserver_protocol_1.DiagnosticServerCancellationData.is(error.data) && error.data.retriggerRequest === !1 && (afterState = {
              state: RequestStateKind.outDated,
              document: document
            }), afterState === void 0 && error instanceof vscode_1.CancellationError) afterState = {
              state: RequestStateKind.reschedule,
              document: document
            };else throw error;
          }
          if (afterState = afterState != null ? afterState : this.openRequests.get(key), afterState === void 0) {
            this.client.error(`Lost request state in diagnostic pull model. Clearing diagnostics for ${key}`), this.diagnostics.delete(uri);
            return;
          }
          if (this.openRequests.delete(key), !this.tabs.isVisible(document)) {
            this.documentStates.unTrack(PullState.document, document);
            return;
          }
          if (afterState.state === RequestStateKind.outDated) return;
          report !== void 0 && (report.kind === vsdiag.DocumentDiagnosticReportKind.full && this.diagnostics.set(uri, report.items), documentState.pulledVersion = version, documentState.resultId = report.resultId), afterState.state === RequestStateKind.reschedule && this.pull(document);
        } else currentRequestState.state === RequestStateKind.active ? (currentRequestState.tokenSource.cancel(), this.openRequests.set(key, {
          state: RequestStateKind.reschedule,
          document: currentRequestState.document
        })) : currentRequestState.state === RequestStateKind.outDated && this.openRequests.set(key, {
          state: RequestStateKind.reschedule,
          document: currentRequestState.document
        });
      }
      forgetDocument(document) {
        let uri = document instanceof vscode_1.Uri ? document : document.uri,
          key = uri.toString(),
          request = this.openRequests.get(key);
        this.options.workspaceDiagnostics ? request !== void 0 ? this.openRequests.set(key, {
          state: RequestStateKind.reschedule,
          document: document
        }) : this.pull(document, () => {
          this.forget(PullState.document, document);
        }) : (request !== void 0 && (request.state === RequestStateKind.active && request.tokenSource.cancel(), this.openRequests.set(key, {
          state: RequestStateKind.outDated,
          document: document
        })), this.diagnostics.delete(uri), this.forget(PullState.document, document));
      }
      pullWorkspace() {
        this.isDisposed || this.pullWorkspaceAsync().then(() => {
          this.workspaceTimeout = (0, vscode_languageserver_protocol_1.RAL)().timer.setTimeout(() => {
            this.pullWorkspace();
          }, 2e3);
        }, error => {
          !(error instanceof features_1.LSPCancellationError) && !vscode_languageserver_protocol_1.DiagnosticServerCancellationData.is(error.data) && (this.client.error("Workspace diagnostic pull failed.", error, !1), this.workspaceErrorCounter++), this.workspaceErrorCounter <= 5 && (this.workspaceTimeout = (0, vscode_languageserver_protocol_1.RAL)().timer.setTimeout(() => {
            this.pullWorkspace();
          }, 2e3));
        });
      }
      async pullWorkspaceAsync() {
        if (!this.provider.provideWorkspaceDiagnostics || this.isDisposed) return;
        this.workspaceCancellation !== void 0 && (this.workspaceCancellation.cancel(), this.workspaceCancellation = void 0), this.workspaceCancellation = new vscode_1.CancellationTokenSource();
        let previousResultIds = this.documentStates.getAllResultIds().map(item => ({
          uri: this.client.protocol2CodeConverter.asUri(item.uri),
          value: item.value
        }));
        await this.provider.provideWorkspaceDiagnostics(previousResultIds, this.workspaceCancellation.token, chunk => {
          var _a;
          if (!(!chunk || this.isDisposed)) for (let item of chunk.items) item.kind === vsdiag.DocumentDiagnosticReportKind.full && (this.documentStates.tracks(PullState.document, item.uri) || this.diagnostics.set(item.uri, item.items)), this.documentStates.update(PullState.workspace, item.uri, (_a = item.version) != null ? _a : void 0, item.resultId);
        });
      }
      createProvider() {
        let result = {
          onDidChangeDiagnostics: this.onDidChangeDiagnosticsEmitter.event,
          provideDiagnostics: __name((document, previousResultId, token) => {
            let provideDiagnostics = __name((document, previousResultId, token) => {
                let params = {
                  identifier: this.options.identifier,
                  textDocument: {
                    uri: this.client.code2ProtocolConverter.asUri(document instanceof vscode_1.Uri ? document : document.uri)
                  },
                  previousResultId: previousResultId
                };
                return this.isDisposed === !0 || !this.client.isRunning() ? {
                  kind: vsdiag.DocumentDiagnosticReportKind.full,
                  items: []
                } : this.client.sendRequest(vscode_languageserver_protocol_1.DocumentDiagnosticRequest.type, params, token).then(async result => result == null || this.isDisposed || token.isCancellationRequested ? {
                  kind: vsdiag.DocumentDiagnosticReportKind.full,
                  items: []
                } : result.kind === vscode_languageserver_protocol_1.DocumentDiagnosticReportKind.Full ? {
                  kind: vsdiag.DocumentDiagnosticReportKind.full,
                  resultId: result.resultId,
                  items: await this.client.protocol2CodeConverter.asDiagnostics(result.items, token)
                } : {
                  kind: vsdiag.DocumentDiagnosticReportKind.unChanged,
                  resultId: result.resultId
                }, error => this.client.handleFailedRequest(vscode_languageserver_protocol_1.DocumentDiagnosticRequest.type, token, error, {
                  kind: vsdiag.DocumentDiagnosticReportKind.full,
                  items: []
                }));
              }, "provideDiagnostics"),
              middleware = this.client.middleware;
            return middleware.provideDiagnostics ? middleware.provideDiagnostics(document, previousResultId, token, provideDiagnostics) : provideDiagnostics(document, previousResultId, token);
          }, "provideDiagnostics")
        };
        return this.options.workspaceDiagnostics && (result.provideWorkspaceDiagnostics = (resultIds, token, resultReporter) => {
          let convertReport = __name(async report => report.kind === vscode_languageserver_protocol_1.DocumentDiagnosticReportKind.Full ? {
              kind: vsdiag.DocumentDiagnosticReportKind.full,
              uri: this.client.protocol2CodeConverter.asUri(report.uri),
              resultId: report.resultId,
              version: report.version,
              items: await this.client.protocol2CodeConverter.asDiagnostics(report.items, token)
            } : {
              kind: vsdiag.DocumentDiagnosticReportKind.unChanged,
              uri: this.client.protocol2CodeConverter.asUri(report.uri),
              resultId: report.resultId,
              version: report.version
            }, "convertReport"),
            convertPreviousResultIds = __name(resultIds => {
              let converted = [];
              for (let item of resultIds) converted.push({
                uri: this.client.code2ProtocolConverter.asUri(item.uri),
                value: item.value
              });
              return converted;
            }, "convertPreviousResultIds"),
            provideDiagnostics = __name((resultIds, token) => {
              let partialResultToken = (0, uuid_1.generateUuid)(),
                disposable = this.client.onProgress(vscode_languageserver_protocol_1.WorkspaceDiagnosticRequest.partialResult, partialResultToken, async partialResult => {
                  if (partialResult == null) {
                    resultReporter(null);
                    return;
                  }
                  let converted = {
                    items: []
                  };
                  for (let item of partialResult.items) try {
                    converted.items.push(await convertReport(item));
                  } catch (error) {
                    this.client.error("Converting workspace diagnostics failed.", error);
                  }
                  resultReporter(converted);
                }),
                params = {
                  identifier: this.options.identifier,
                  previousResultIds: convertPreviousResultIds(resultIds),
                  partialResultToken: partialResultToken
                };
              return this.isDisposed === !0 || !this.client.isRunning() ? {
                items: []
              } : this.client.sendRequest(vscode_languageserver_protocol_1.WorkspaceDiagnosticRequest.type, params, token).then(async result => {
                if (token.isCancellationRequested) return {
                  items: []
                };
                let converted = {
                  items: []
                };
                for (let item of result.items) converted.items.push(await convertReport(item));
                return disposable.dispose(), resultReporter(converted), {
                  items: []
                };
              }, error => (disposable.dispose(), this.client.handleFailedRequest(vscode_languageserver_protocol_1.DocumentDiagnosticRequest.type, token, error, {
                items: []
              })));
            }, "provideDiagnostics"),
            middleware = this.client.middleware;
          return middleware.provideWorkspaceDiagnostics ? middleware.provideWorkspaceDiagnostics(resultIds, token, resultReporter, provideDiagnostics) : provideDiagnostics(resultIds, token, resultReporter);
        }), result;
      }
      dispose() {
        var _a, _b;
        this.isDisposed = !0, (_a = this.workspaceCancellation) == null || _a.cancel(), (_b = this.workspaceTimeout) == null || _b.dispose();
        for (let [key, request] of this.openRequests) request.state === RequestStateKind.active && request.tokenSource.cancel(), this.openRequests.set(key, {
          state: RequestStateKind.outDated,
          document: request.document
        });
        this.diagnostics.dispose();
      }
    };
  __name(_DiagnosticRequestor, "DiagnosticRequestor");
  var DiagnosticRequestor = _DiagnosticRequestor,
    _BackgroundScheduler = class _BackgroundScheduler {
      constructor(diagnosticRequestor) {
        this.diagnosticRequestor = diagnosticRequestor, this.documents = new vscode_languageserver_protocol_1.LinkedMap(), this.isDisposed = !1;
      }
      add(document) {
        if (this.isDisposed === !0) return;
        let key = DocumentOrUri.asKey(document);
        this.documents.has(key) || (this.documents.set(key, document, vscode_languageserver_protocol_1.Touch.Last), this.trigger());
      }
      remove(document) {
        let key = DocumentOrUri.asKey(document);
        this.documents.delete(key), this.documents.size === 0 ? this.stop() : key === this.endDocumentKey() && (this.endDocument = this.documents.last);
      }
      trigger() {
        if (this.isDisposed !== !0) {
          if (this.intervalHandle !== void 0) {
            this.endDocument = this.documents.last;
            return;
          }
          this.endDocument = this.documents.last, this.intervalHandle = (0, vscode_languageserver_protocol_1.RAL)().timer.setInterval(() => {
            let document = this.documents.first;
            if (document !== void 0) {
              let key = DocumentOrUri.asKey(document);
              this.diagnosticRequestor.pull(document), this.documents.set(key, document, vscode_languageserver_protocol_1.Touch.Last), key === this.endDocumentKey() && this.stop();
            }
          }, 200);
        }
      }
      dispose() {
        this.isDisposed = !0, this.stop(), this.documents.clear();
      }
      stop() {
        var _a;
        (_a = this.intervalHandle) == null || _a.dispose(), this.intervalHandle = void 0, this.endDocument = void 0;
      }
      endDocumentKey() {
        return this.endDocument !== void 0 ? DocumentOrUri.asKey(this.endDocument) : void 0;
      }
    };
  __name(_BackgroundScheduler, "BackgroundScheduler");
  var BackgroundScheduler = _BackgroundScheduler,
    _DiagnosticFeatureProviderImpl = class _DiagnosticFeatureProviderImpl {
      constructor(client, tabs, options) {
        var _a, _b;
        let diagnosticPullOptions = (_a = client.clientOptions.diagnosticPullOptions) != null ? _a : {
            onChange: !0,
            onSave: !1
          },
          documentSelector = client.protocol2CodeConverter.asDocumentSelector(options.documentSelector),
          disposables = [],
          matchResource = __name(resource => {
            let selector = options.documentSelector;
            if (diagnosticPullOptions.match !== void 0) return diagnosticPullOptions.match(selector, resource);
            for (let filter of selector) if (vscode_languageserver_protocol_1.TextDocumentFilter.is(filter)) {
              if (typeof filter == "string" || filter.language !== void 0 && filter.language !== "*" || filter.scheme !== void 0 && filter.scheme !== "*" && filter.scheme !== resource.scheme) return !1;
              if (filter.pattern !== void 0) {
                let matcher = new minimatch.Minimatch(filter.pattern, {
                  noext: !0
                });
                if (!matcher.makeRe() || !matcher.match(resource.fsPath)) return !1;
              }
            }
            return !0;
          }, "matchResource"),
          matches = __name(document => document instanceof vscode_1.Uri ? matchResource(document) : vscode_1.languages.match(documentSelector, document) > 0 && tabs.isVisible(document), "matches"),
          isActiveDocument = __name(document => {
            var _a;
            return document instanceof vscode_1.Uri ? ((_a = this.activeTextDocument) == null ? void 0 : _a.uri.toString()) === document.toString() : this.activeTextDocument === document;
          }, "isActiveDocument");
        this.diagnosticRequestor = new DiagnosticRequestor(client, tabs, options), this.backgroundScheduler = new BackgroundScheduler(this.diagnosticRequestor);
        let addToBackgroundIfNeeded = __name(document => {
          !matches(document) || !options.interFileDependencies || isActiveDocument(document) || this.backgroundScheduler.add(document);
        }, "addToBackgroundIfNeeded");
        this.activeTextDocument = (_b = vscode_1.window.activeTextEditor) == null ? void 0 : _b.document, vscode_1.window.onDidChangeActiveTextEditor(editor => {
          let oldActive = this.activeTextDocument;
          this.activeTextDocument = editor == null ? void 0 : editor.document, oldActive !== void 0 && addToBackgroundIfNeeded(oldActive), this.activeTextDocument !== void 0 && this.backgroundScheduler.remove(this.activeTextDocument);
        });
        let openFeature = client.getFeature(vscode_languageserver_protocol_1.DidOpenTextDocumentNotification.method);
        disposables.push(openFeature.onNotificationSent(event => {
          let textDocument = event.textDocument;
          this.diagnosticRequestor.knows(PullState.document, textDocument) || matches(textDocument) && this.diagnosticRequestor.pull(textDocument, () => {
            addToBackgroundIfNeeded(textDocument);
          });
        })), disposables.push(tabs.onOpen(opened => {
          for (let resource of opened) {
            if (this.diagnosticRequestor.knows(PullState.document, resource)) continue;
            let uriStr = resource.toString(),
              textDocument;
            for (let item of vscode_1.workspace.textDocuments) if (uriStr === item.uri.toString()) {
              textDocument = item;
              break;
            }
            textDocument !== void 0 && matches(textDocument) && this.diagnosticRequestor.pull(textDocument, () => {
              addToBackgroundIfNeeded(textDocument);
            });
          }
        }));
        let pulledTextDocuments = new Set();
        for (let textDocument of vscode_1.workspace.textDocuments) matches(textDocument) && (this.diagnosticRequestor.pull(textDocument, () => {
          addToBackgroundIfNeeded(textDocument);
        }), pulledTextDocuments.add(textDocument.uri.toString()));
        if (diagnosticPullOptions.onTabs === !0) for (let resource of tabs.getTabResources()) !pulledTextDocuments.has(resource.toString()) && matches(resource) && this.diagnosticRequestor.pull(resource, () => {
          addToBackgroundIfNeeded(resource);
        });
        if (diagnosticPullOptions.onChange === !0) {
          let changeFeature = client.getFeature(vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.method);
          disposables.push(changeFeature.onNotificationSent(async event => {
            let textDocument = event.textDocument;
            (diagnosticPullOptions.filter === void 0 || !diagnosticPullOptions.filter(textDocument, DiagnosticPullMode.onType)) && this.diagnosticRequestor.knows(PullState.document, textDocument) && this.diagnosticRequestor.pull(textDocument, () => {
              this.backgroundScheduler.trigger();
            });
          }));
        }
        if (diagnosticPullOptions.onSave === !0) {
          let saveFeature = client.getFeature(vscode_languageserver_protocol_1.DidSaveTextDocumentNotification.method);
          disposables.push(saveFeature.onNotificationSent(event => {
            let textDocument = event.textDocument;
            (diagnosticPullOptions.filter === void 0 || !diagnosticPullOptions.filter(textDocument, DiagnosticPullMode.onSave)) && this.diagnosticRequestor.knows(PullState.document, textDocument) && this.diagnosticRequestor.pull(event.textDocument, () => {
              this.backgroundScheduler.trigger();
            });
          }));
        }
        let closeFeature = client.getFeature(vscode_languageserver_protocol_1.DidCloseTextDocumentNotification.method);
        disposables.push(closeFeature.onNotificationSent(event => {
          this.cleanUpDocument(event.textDocument);
        })), tabs.onClose(closed => {
          for (let document of closed) this.cleanUpDocument(document);
        }), this.diagnosticRequestor.onDidChangeDiagnosticsEmitter.event(() => {
          for (let textDocument of vscode_1.workspace.textDocuments) matches(textDocument) && this.diagnosticRequestor.pull(textDocument);
        }), options.workspaceDiagnostics === !0 && options.identifier !== "da348dc5-c30a-4515-9d98-31ff3be38d14" && this.diagnosticRequestor.pullWorkspace(), this.disposable = vscode_1.Disposable.from(...disposables, this.backgroundScheduler, this.diagnosticRequestor);
      }
      get onDidChangeDiagnosticsEmitter() {
        return this.diagnosticRequestor.onDidChangeDiagnosticsEmitter;
      }
      get diagnostics() {
        return this.diagnosticRequestor.provider;
      }
      cleanUpDocument(document) {
        this.diagnosticRequestor.knows(PullState.document, document) && (this.diagnosticRequestor.forgetDocument(document), this.backgroundScheduler.remove(document));
      }
    };
  __name(_DiagnosticFeatureProviderImpl, "DiagnosticFeatureProviderImpl");
  var DiagnosticFeatureProviderImpl = _DiagnosticFeatureProviderImpl,
    _DiagnosticFeature = class _DiagnosticFeature extends features_1.TextDocumentLanguageFeature {
      constructor(client) {
        super(client, vscode_languageserver_protocol_1.DocumentDiagnosticRequest.type);
      }
      fillClientCapabilities(capabilities) {
        let capability = ensure(ensure(capabilities, "textDocument"), "diagnostic");
        capability.dynamicRegistration = !0, capability.relatedDocumentSupport = !1, ensure(ensure(capabilities, "workspace"), "diagnostics").refreshSupport = !0;
      }
      initialize(capabilities, documentSelector) {
        this._client.onRequest(vscode_languageserver_protocol_1.DiagnosticRefreshRequest.type, async () => {
          for (let provider of this.getAllProviders()) provider.onDidChangeDiagnosticsEmitter.fire();
        });
        let [id, options] = this.getRegistration(documentSelector, capabilities.diagnosticProvider);
        !id || !options || this.register({
          id: id,
          registerOptions: options
        });
      }
      clear() {
        this.tabs !== void 0 && (this.tabs.dispose(), this.tabs = void 0), super.clear();
      }
      registerLanguageProvider(options) {
        this.tabs === void 0 && (this.tabs = new Tabs());
        let provider = new DiagnosticFeatureProviderImpl(this._client, this.tabs, options);
        return [provider.disposable, provider];
      }
    };
  __name(_DiagnosticFeature, "DiagnosticFeature");
  var DiagnosticFeature = _DiagnosticFeature;
  exports.DiagnosticFeature = DiagnosticFeature;
});