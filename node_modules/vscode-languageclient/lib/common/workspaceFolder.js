var require_workspaceFolder = __commonJSMin(exports => {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: !0
  });
  exports.WorkspaceFoldersFeature = exports.arrayDiff = void 0;
  var UUID = yo(),
    vscode_1 = require("vscode"),
    vscode_languageserver_protocol_1 = Un();
  function access(target, key) {
    if (target != null) return target[key];
  }
  __name(access, "access");
  function arrayDiff(left, right) {
    return left.filter(element => right.indexOf(element) < 0);
  }
  __name(arrayDiff, "arrayDiff");
  exports.arrayDiff = arrayDiff;
  var _WorkspaceFoldersFeature = class _WorkspaceFoldersFeature {
    constructor(client) {
      this._client = client, this._listeners = new Map();
    }
    getState() {
      return {
        kind: "workspace",
        id: this.registrationType.method,
        registrations: this._listeners.size > 0
      };
    }
    get registrationType() {
      return vscode_languageserver_protocol_1.DidChangeWorkspaceFoldersNotification.type;
    }
    fillInitializeParams(params) {
      let folders = vscode_1.workspace.workspaceFolders;
      this.initializeWithFolders(folders), folders === void 0 ? params.workspaceFolders = null : params.workspaceFolders = folders.map(folder => this.asProtocol(folder));
    }
    initializeWithFolders(currentWorkspaceFolders) {
      this._initialFolders = currentWorkspaceFolders;
    }
    fillClientCapabilities(capabilities) {
      capabilities.workspace = capabilities.workspace || {}, capabilities.workspace.workspaceFolders = !0;
    }
    initialize(capabilities) {
      let client = this._client;
      client.onRequest(vscode_languageserver_protocol_1.WorkspaceFoldersRequest.type, token => {
        let workspaceFolders = __name(() => {
            let folders = vscode_1.workspace.workspaceFolders;
            return folders === void 0 ? null : folders.map(folder => this.asProtocol(folder));
          }, "workspaceFolders"),
          middleware = client.middleware.workspace;
        return middleware && middleware.workspaceFolders ? middleware.workspaceFolders(token, workspaceFolders) : workspaceFolders(token);
      });
      let value = access(access(access(capabilities, "workspace"), "workspaceFolders"), "changeNotifications"),
        id;
      typeof value == "string" ? id = value : value === !0 && (id = UUID.generateUuid()), id && this.register({
        id: id,
        registerOptions: void 0
      });
    }
    sendInitialEvent(currentWorkspaceFolders) {
      let promise;
      if (this._initialFolders && currentWorkspaceFolders) {
        let removed = arrayDiff(this._initialFolders, currentWorkspaceFolders),
          added = arrayDiff(currentWorkspaceFolders, this._initialFolders);
        (added.length > 0 || removed.length > 0) && (promise = this.doSendEvent(added, removed));
      } else this._initialFolders ? promise = this.doSendEvent([], this._initialFolders) : currentWorkspaceFolders && (promise = this.doSendEvent(currentWorkspaceFolders, []));
      promise !== void 0 && promise.catch(error => {
        this._client.error(`Sending notification ${vscode_languageserver_protocol_1.DidChangeWorkspaceFoldersNotification.type.method} failed`, error);
      });
    }
    doSendEvent(addedFolders, removedFolders) {
      let params = {
        event: {
          added: addedFolders.map(folder => this.asProtocol(folder)),
          removed: removedFolders.map(folder => this.asProtocol(folder))
        }
      };
      return this._client.sendNotification(vscode_languageserver_protocol_1.DidChangeWorkspaceFoldersNotification.type, params);
    }
    register(data) {
      let id = data.id,
        client = this._client,
        disposable = vscode_1.workspace.onDidChangeWorkspaceFolders(event => {
          let didChangeWorkspaceFolders = __name(event => this.doSendEvent(event.added, event.removed), "didChangeWorkspaceFolders"),
            middleware = client.middleware.workspace;
          (middleware && middleware.didChangeWorkspaceFolders ? middleware.didChangeWorkspaceFolders(event, didChangeWorkspaceFolders) : didChangeWorkspaceFolders(event)).catch(error => {
            this._client.error(`Sending notification ${vscode_languageserver_protocol_1.DidChangeWorkspaceFoldersNotification.type.method} failed`, error);
          });
        });
      this._listeners.set(id, disposable), this.sendInitialEvent(vscode_1.workspace.workspaceFolders);
    }
    unregister(id) {
      let disposable = this._listeners.get(id);
      disposable !== void 0 && (this._listeners.delete(id), disposable.dispose());
    }
    clear() {
      for (let disposable of this._listeners.values()) disposable.dispose();
      this._listeners.clear();
    }
    asProtocol(workspaceFolder) {
      return workspaceFolder === void 0 ? null : {
        uri: this._client.code2ProtocolConverter.asUri(workspaceFolder.uri),
        name: workspaceFolder.name
      };
    }
  };
  __name(_WorkspaceFoldersFeature, "WorkspaceFoldersFeature");
  var WorkspaceFoldersFeature = _WorkspaceFoldersFeature;
  exports.WorkspaceFoldersFeature = WorkspaceFoldersFeature;
});