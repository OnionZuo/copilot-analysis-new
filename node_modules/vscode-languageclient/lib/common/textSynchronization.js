var require_textSynchronization = __commonJSMin(exports => {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: !0
  });
  exports.DidSaveTextDocumentFeature = exports.WillSaveWaitUntilFeature = exports.WillSaveFeature = exports.DidChangeTextDocumentFeature = exports.DidCloseTextDocumentFeature = exports.DidOpenTextDocumentFeature = void 0;
  var vscode_1 = require("vscode"),
    vscode_languageserver_protocol_1 = Un(),
    features_1 = Oi(),
    UUID = yo(),
    _DidOpenTextDocumentFeature = class _DidOpenTextDocumentFeature extends features_1.TextDocumentEventFeature {
      constructor(client, syncedDocuments) {
        super(client, vscode_1.workspace.onDidOpenTextDocument, vscode_languageserver_protocol_1.DidOpenTextDocumentNotification.type, () => client.middleware.didOpen, textDocument => client.code2ProtocolConverter.asOpenTextDocumentParams(textDocument), data => data, features_1.TextDocumentEventFeature.textDocumentFilter), this._syncedDocuments = syncedDocuments;
      }
      get openDocuments() {
        return this._syncedDocuments.values();
      }
      fillClientCapabilities(capabilities) {
        (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "synchronization").dynamicRegistration = !0;
      }
      initialize(capabilities, documentSelector) {
        let textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;
        documentSelector && textDocumentSyncOptions && textDocumentSyncOptions.openClose && this.register({
          id: UUID.generateUuid(),
          registerOptions: {
            documentSelector: documentSelector
          }
        });
      }
      get registrationType() {
        return vscode_languageserver_protocol_1.DidOpenTextDocumentNotification.type;
      }
      register(data) {
        if (super.register(data), !data.registerOptions.documentSelector) return;
        let documentSelector = this._client.protocol2CodeConverter.asDocumentSelector(data.registerOptions.documentSelector);
        vscode_1.workspace.textDocuments.forEach(textDocument => {
          let uri = textDocument.uri.toString();
          if (!this._syncedDocuments.has(uri) && vscode_1.languages.match(documentSelector, textDocument) > 0 && !this._client.hasDedicatedTextSynchronizationFeature(textDocument)) {
            let middleware = this._client.middleware,
              didOpen = __name(textDocument => this._client.sendNotification(this._type, this._createParams(textDocument)), "didOpen");
            (middleware.didOpen ? middleware.didOpen(textDocument, didOpen) : didOpen(textDocument)).catch(error => {
              this._client.error(`Sending document notification ${this._type.method} failed`, error);
            }), this._syncedDocuments.set(uri, textDocument);
          }
        });
      }
      getTextDocument(data) {
        return data;
      }
      notificationSent(textDocument, type, params) {
        this._syncedDocuments.set(textDocument.uri.toString(), textDocument), super.notificationSent(textDocument, type, params);
      }
    };
  __name(_DidOpenTextDocumentFeature, "DidOpenTextDocumentFeature");
  var DidOpenTextDocumentFeature = _DidOpenTextDocumentFeature;
  exports.DidOpenTextDocumentFeature = DidOpenTextDocumentFeature;
  var _DidCloseTextDocumentFeature = class _DidCloseTextDocumentFeature extends features_1.TextDocumentEventFeature {
    constructor(client, syncedDocuments, pendingTextDocumentChanges) {
      super(client, vscode_1.workspace.onDidCloseTextDocument, vscode_languageserver_protocol_1.DidCloseTextDocumentNotification.type, () => client.middleware.didClose, textDocument => client.code2ProtocolConverter.asCloseTextDocumentParams(textDocument), data => data, features_1.TextDocumentEventFeature.textDocumentFilter), this._syncedDocuments = syncedDocuments, this._pendingTextDocumentChanges = pendingTextDocumentChanges;
    }
    get registrationType() {
      return vscode_languageserver_protocol_1.DidCloseTextDocumentNotification.type;
    }
    fillClientCapabilities(capabilities) {
      (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "synchronization").dynamicRegistration = !0;
    }
    initialize(capabilities, documentSelector) {
      let textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;
      documentSelector && textDocumentSyncOptions && textDocumentSyncOptions.openClose && this.register({
        id: UUID.generateUuid(),
        registerOptions: {
          documentSelector: documentSelector
        }
      });
    }
    async callback(data) {
      await super.callback(data), this._pendingTextDocumentChanges.delete(data.uri.toString());
    }
    getTextDocument(data) {
      return data;
    }
    notificationSent(textDocument, type, params) {
      this._syncedDocuments.delete(textDocument.uri.toString()), super.notificationSent(textDocument, type, params);
    }
    unregister(id) {
      let selector = this._selectors.get(id);
      super.unregister(id);
      let selectors = this._selectors.values();
      this._syncedDocuments.forEach(textDocument => {
        if (vscode_1.languages.match(selector, textDocument) > 0 && !this._selectorFilter(selectors, textDocument) && !this._client.hasDedicatedTextSynchronizationFeature(textDocument)) {
          let middleware = this._client.middleware,
            didClose = __name(textDocument => this._client.sendNotification(this._type, this._createParams(textDocument)), "didClose");
          this._syncedDocuments.delete(textDocument.uri.toString()), (middleware.didClose ? middleware.didClose(textDocument, didClose) : didClose(textDocument)).catch(error => {
            this._client.error(`Sending document notification ${this._type.method} failed`, error);
          });
        }
      });
    }
  };
  __name(_DidCloseTextDocumentFeature, "DidCloseTextDocumentFeature");
  var DidCloseTextDocumentFeature = _DidCloseTextDocumentFeature;
  exports.DidCloseTextDocumentFeature = DidCloseTextDocumentFeature;
  var _DidChangeTextDocumentFeature = class _DidChangeTextDocumentFeature extends features_1.DynamicDocumentFeature {
    constructor(client, pendingTextDocumentChanges) {
      super(client), this._changeData = new Map(), this._onNotificationSent = new vscode_1.EventEmitter(), this._onPendingChangeAdded = new vscode_1.EventEmitter(), this._pendingTextDocumentChanges = pendingTextDocumentChanges, this._syncKind = vscode_languageserver_protocol_1.TextDocumentSyncKind.None;
    }
    get onNotificationSent() {
      return this._onNotificationSent.event;
    }
    get onPendingChangeAdded() {
      return this._onPendingChangeAdded.event;
    }
    get syncKind() {
      return this._syncKind;
    }
    get registrationType() {
      return vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type;
    }
    fillClientCapabilities(capabilities) {
      (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "synchronization").dynamicRegistration = !0;
    }
    initialize(capabilities, documentSelector) {
      let textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;
      documentSelector && textDocumentSyncOptions && textDocumentSyncOptions.change !== void 0 && textDocumentSyncOptions.change !== vscode_languageserver_protocol_1.TextDocumentSyncKind.None && this.register({
        id: UUID.generateUuid(),
        registerOptions: Object.assign({}, {
          documentSelector: documentSelector
        }, {
          syncKind: textDocumentSyncOptions.change
        })
      });
    }
    register(data) {
      data.registerOptions.documentSelector && (this._listener || (this._listener = vscode_1.workspace.onDidChangeTextDocument(this.callback, this)), this._changeData.set(data.id, {
        syncKind: data.registerOptions.syncKind,
        documentSelector: this._client.protocol2CodeConverter.asDocumentSelector(data.registerOptions.documentSelector)
      }), this.updateSyncKind(data.registerOptions.syncKind));
    }
    *getDocumentSelectors() {
      for (let data of this._changeData.values()) yield data.documentSelector;
    }
    async callback(event) {
      if (event.contentChanges.length === 0) return;
      let uri = event.document.uri,
        version = event.document.version,
        promises = [];
      for (let changeData of this._changeData.values()) if (vscode_1.languages.match(changeData.documentSelector, event.document) > 0 && !this._client.hasDedicatedTextSynchronizationFeature(event.document)) {
        let middleware = this._client.middleware;
        if (changeData.syncKind === vscode_languageserver_protocol_1.TextDocumentSyncKind.Incremental) {
          let didChange = __name(async event => {
            let params = this._client.code2ProtocolConverter.asChangeTextDocumentParams(event, uri, version);
            await this._client.sendNotification(vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type, params), this.notificationSent(event.document, vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type, params);
          }, "didChange");
          promises.push(middleware.didChange ? middleware.didChange(event, event => didChange(event)) : didChange(event));
        } else if (changeData.syncKind === vscode_languageserver_protocol_1.TextDocumentSyncKind.Full) {
          let didChange = __name(async event => {
            let eventUri = event.document.uri.toString();
            this._pendingTextDocumentChanges.set(eventUri, event.document), this._onPendingChangeAdded.fire();
          }, "didChange");
          promises.push(middleware.didChange ? middleware.didChange(event, event => didChange(event)) : didChange(event));
        }
      }
      return Promise.all(promises).then(void 0, error => {
        throw this._client.error(`Sending document notification ${vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type.method} failed`, error), error;
      });
    }
    notificationSent(textDocument, type, params) {
      this._onNotificationSent.fire({
        textDocument: textDocument,
        type: type,
        params: params
      });
    }
    unregister(id) {
      if (this._changeData.delete(id), this._changeData.size === 0) this._listener && (this._listener.dispose(), this._listener = void 0), this._syncKind = vscode_languageserver_protocol_1.TextDocumentSyncKind.None;else {
        this._syncKind = vscode_languageserver_protocol_1.TextDocumentSyncKind.None;
        for (let changeData of this._changeData.values()) if (this.updateSyncKind(changeData.syncKind), this._syncKind === vscode_languageserver_protocol_1.TextDocumentSyncKind.Full) break;
      }
    }
    clear() {
      this._pendingTextDocumentChanges.clear(), this._changeData.clear(), this._syncKind = vscode_languageserver_protocol_1.TextDocumentSyncKind.None, this._listener && (this._listener.dispose(), this._listener = void 0);
    }
    getPendingDocumentChanges(excludes) {
      if (this._pendingTextDocumentChanges.size === 0) return [];
      let result;
      if (excludes.size === 0) result = Array.from(this._pendingTextDocumentChanges.values()), this._pendingTextDocumentChanges.clear();else {
        result = [];
        for (let entry of this._pendingTextDocumentChanges) excludes.has(entry[0]) || (result.push(entry[1]), this._pendingTextDocumentChanges.delete(entry[0]));
      }
      return result;
    }
    getProvider(document) {
      for (let changeData of this._changeData.values()) if (vscode_1.languages.match(changeData.documentSelector, document) > 0) return {
        send: __name(event => this.callback(event), "send")
      };
    }
    updateSyncKind(syncKind) {
      if (this._syncKind !== vscode_languageserver_protocol_1.TextDocumentSyncKind.Full) switch (syncKind) {
        case vscode_languageserver_protocol_1.TextDocumentSyncKind.Full:
          this._syncKind = syncKind;
          break;
        case vscode_languageserver_protocol_1.TextDocumentSyncKind.Incremental:
          this._syncKind === vscode_languageserver_protocol_1.TextDocumentSyncKind.None && (this._syncKind = vscode_languageserver_protocol_1.TextDocumentSyncKind.Incremental);
          break;
      }
    }
  };
  __name(_DidChangeTextDocumentFeature, "DidChangeTextDocumentFeature");
  var DidChangeTextDocumentFeature = _DidChangeTextDocumentFeature;
  exports.DidChangeTextDocumentFeature = DidChangeTextDocumentFeature;
  var _WillSaveFeature = class _WillSaveFeature extends features_1.TextDocumentEventFeature {
    constructor(client) {
      super(client, vscode_1.workspace.onWillSaveTextDocument, vscode_languageserver_protocol_1.WillSaveTextDocumentNotification.type, () => client.middleware.willSave, willSaveEvent => client.code2ProtocolConverter.asWillSaveTextDocumentParams(willSaveEvent), event => event.document, (selectors, willSaveEvent) => features_1.TextDocumentEventFeature.textDocumentFilter(selectors, willSaveEvent.document));
    }
    get registrationType() {
      return vscode_languageserver_protocol_1.WillSaveTextDocumentNotification.type;
    }
    fillClientCapabilities(capabilities) {
      let value = (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "synchronization");
      value.willSave = !0;
    }
    initialize(capabilities, documentSelector) {
      let textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;
      documentSelector && textDocumentSyncOptions && textDocumentSyncOptions.willSave && this.register({
        id: UUID.generateUuid(),
        registerOptions: {
          documentSelector: documentSelector
        }
      });
    }
    getTextDocument(data) {
      return data.document;
    }
  };
  __name(_WillSaveFeature, "WillSaveFeature");
  var WillSaveFeature = _WillSaveFeature;
  exports.WillSaveFeature = WillSaveFeature;
  var _WillSaveWaitUntilFeature = class _WillSaveWaitUntilFeature extends features_1.DynamicDocumentFeature {
    constructor(client) {
      super(client), this._selectors = new Map();
    }
    getDocumentSelectors() {
      return this._selectors.values();
    }
    get registrationType() {
      return vscode_languageserver_protocol_1.WillSaveTextDocumentWaitUntilRequest.type;
    }
    fillClientCapabilities(capabilities) {
      let value = (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "synchronization");
      value.willSaveWaitUntil = !0;
    }
    initialize(capabilities, documentSelector) {
      let textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;
      documentSelector && textDocumentSyncOptions && textDocumentSyncOptions.willSaveWaitUntil && this.register({
        id: UUID.generateUuid(),
        registerOptions: {
          documentSelector: documentSelector
        }
      });
    }
    register(data) {
      data.registerOptions.documentSelector && (this._listener || (this._listener = vscode_1.workspace.onWillSaveTextDocument(this.callback, this)), this._selectors.set(data.id, this._client.protocol2CodeConverter.asDocumentSelector(data.registerOptions.documentSelector)));
    }
    callback(event) {
      if (features_1.TextDocumentEventFeature.textDocumentFilter(this._selectors.values(), event.document) && !this._client.hasDedicatedTextSynchronizationFeature(event.document)) {
        let middleware = this._client.middleware,
          willSaveWaitUntil = __name(event => this._client.sendRequest(vscode_languageserver_protocol_1.WillSaveTextDocumentWaitUntilRequest.type, this._client.code2ProtocolConverter.asWillSaveTextDocumentParams(event)).then(async edits => {
            let vEdits = await this._client.protocol2CodeConverter.asTextEdits(edits);
            return vEdits === void 0 ? [] : vEdits;
          }), "willSaveWaitUntil");
        event.waitUntil(middleware.willSaveWaitUntil ? middleware.willSaveWaitUntil(event, willSaveWaitUntil) : willSaveWaitUntil(event));
      }
    }
    unregister(id) {
      this._selectors.delete(id), this._selectors.size === 0 && this._listener && (this._listener.dispose(), this._listener = void 0);
    }
    clear() {
      this._selectors.clear(), this._listener && (this._listener.dispose(), this._listener = void 0);
    }
  };
  __name(_WillSaveWaitUntilFeature, "WillSaveWaitUntilFeature");
  var WillSaveWaitUntilFeature = _WillSaveWaitUntilFeature;
  exports.WillSaveWaitUntilFeature = WillSaveWaitUntilFeature;
  var _DidSaveTextDocumentFeature = class _DidSaveTextDocumentFeature extends features_1.TextDocumentEventFeature {
    constructor(client) {
      super(client, vscode_1.workspace.onDidSaveTextDocument, vscode_languageserver_protocol_1.DidSaveTextDocumentNotification.type, () => client.middleware.didSave, textDocument => client.code2ProtocolConverter.asSaveTextDocumentParams(textDocument, this._includeText), data => data, features_1.TextDocumentEventFeature.textDocumentFilter), this._includeText = !1;
    }
    get registrationType() {
      return vscode_languageserver_protocol_1.DidSaveTextDocumentNotification.type;
    }
    fillClientCapabilities(capabilities) {
      (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "synchronization").didSave = !0;
    }
    initialize(capabilities, documentSelector) {
      let textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;
      if (documentSelector && textDocumentSyncOptions && textDocumentSyncOptions.save) {
        let saveOptions = typeof textDocumentSyncOptions.save == "boolean" ? {
          includeText: !1
        } : {
          includeText: !!textDocumentSyncOptions.save.includeText
        };
        this.register({
          id: UUID.generateUuid(),
          registerOptions: Object.assign({}, {
            documentSelector: documentSelector
          }, saveOptions)
        });
      }
    }
    register(data) {
      this._includeText = !!data.registerOptions.includeText, super.register(data);
    }
    getTextDocument(data) {
      return data;
    }
  };
  __name(_DidSaveTextDocumentFeature, "DidSaveTextDocumentFeature");
  var DidSaveTextDocumentFeature = _DidSaveTextDocumentFeature;
  exports.DidSaveTextDocumentFeature = DidSaveTextDocumentFeature;
});