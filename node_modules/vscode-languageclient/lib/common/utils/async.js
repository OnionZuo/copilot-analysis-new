var require_async = __commonJSMin(exports => {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: !0
  });
  exports.forEach = exports.mapAsync = exports.map = exports.clearTestMode = exports.setTestMode = exports.Semaphore = exports.Delayer = void 0;
  var vscode_languageserver_protocol_1 = Un(),
    _Delayer = class _Delayer {
      constructor(defaultDelay) {
        this.defaultDelay = defaultDelay, this.timeout = void 0, this.completionPromise = void 0, this.onSuccess = void 0, this.task = void 0;
      }
      trigger(task, delay = this.defaultDelay) {
        return this.task = task, delay >= 0 && this.cancelTimeout(), this.completionPromise || (this.completionPromise = new Promise(resolve => {
          this.onSuccess = resolve;
        }).then(() => {
          this.completionPromise = void 0, this.onSuccess = void 0;
          var result = this.task();
          return this.task = void 0, result;
        })), (delay >= 0 || this.timeout === void 0) && (this.timeout = (0, vscode_languageserver_protocol_1.RAL)().timer.setTimeout(() => {
          this.timeout = void 0, this.onSuccess(void 0);
        }, delay >= 0 ? delay : this.defaultDelay)), this.completionPromise;
      }
      forceDelivery() {
        if (!this.completionPromise) return;
        this.cancelTimeout();
        let result = this.task();
        return this.completionPromise = void 0, this.onSuccess = void 0, this.task = void 0, result;
      }
      isTriggered() {
        return this.timeout !== void 0;
      }
      cancel() {
        this.cancelTimeout(), this.completionPromise = void 0;
      }
      cancelTimeout() {
        this.timeout !== void 0 && (this.timeout.dispose(), this.timeout = void 0);
      }
    };
  __name(_Delayer, "Delayer");
  var Delayer = _Delayer;
  exports.Delayer = Delayer;
  var _Semaphore = class _Semaphore {
    constructor(capacity = 1) {
      if (capacity <= 0) throw new Error("Capacity must be greater than 0");
      this._capacity = capacity, this._active = 0, this._waiting = [];
    }
    lock(thunk) {
      return new Promise((resolve, reject) => {
        this._waiting.push({
          thunk: thunk,
          resolve: resolve,
          reject: reject
        }), this.runNext();
      });
    }
    get active() {
      return this._active;
    }
    runNext() {
      this._waiting.length === 0 || this._active === this._capacity || (0, vscode_languageserver_protocol_1.RAL)().timer.setImmediate(() => this.doRunNext());
    }
    doRunNext() {
      if (this._waiting.length === 0 || this._active === this._capacity) return;
      let next = this._waiting.shift();
      if (this._active++, this._active > this._capacity) throw new Error("To many thunks active");
      try {
        let result = next.thunk();
        result instanceof Promise ? result.then(value => {
          this._active--, next.resolve(value), this.runNext();
        }, err => {
          this._active--, next.reject(err), this.runNext();
        }) : (this._active--, next.resolve(result), this.runNext());
      } catch (err) {
        this._active--, next.reject(err), this.runNext();
      }
    }
  };
  __name(_Semaphore, "Semaphore");
  var Semaphore = _Semaphore;
  exports.Semaphore = Semaphore;
  var $test = !1;
  function setTestMode() {
    $test = !0;
  }
  __name(setTestMode, "setTestMode");
  exports.setTestMode = setTestMode;
  function clearTestMode() {
    $test = !1;
  }
  __name(clearTestMode, "clearTestMode");
  exports.clearTestMode = clearTestMode;
  var defaultYieldTimeout = 15,
    _Timer = class _Timer {
      constructor(yieldAfter = defaultYieldTimeout) {
        this.yieldAfter = $test === !0 ? Math.max(yieldAfter, 2) : Math.max(yieldAfter, defaultYieldTimeout), this.startTime = Date.now(), this.counter = 0, this.total = 0, this.counterInterval = 1;
      }
      start() {
        this.counter = 0, this.total = 0, this.counterInterval = 1, this.startTime = Date.now();
      }
      shouldYield() {
        if (++this.counter >= this.counterInterval) {
          let timeTaken = Date.now() - this.startTime,
            timeLeft = Math.max(0, this.yieldAfter - timeTaken);
          if (this.total += this.counter, this.counter = 0, timeTaken >= this.yieldAfter || timeLeft <= 1) return this.counterInterval = 1, this.total = 0, !0;
          switch (timeTaken) {
            case 0:
            case 1:
              this.counterInterval = this.total * 2;
              break;
          }
        }
        return !1;
      }
    };
  __name(_Timer, "Timer");
  var Timer = _Timer;
  async function map(items, func, token, options) {
    if (items.length === 0) return [];
    let result = new Array(items.length),
      timer = new Timer(options == null ? void 0 : options.yieldAfter);
    function convertBatch(start) {
      timer.start();
      for (let i = start; i < items.length; i++) if (result[i] = func(items[i]), timer.shouldYield()) return options != null && options.yieldCallback && options.yieldCallback(), i + 1;
      return -1;
    }
    __name(convertBatch, "convertBatch");
    let index = convertBatch(0);
    for (; index !== -1 && !(token !== void 0 && token.isCancellationRequested);) index = await new Promise(resolve => {
      (0, vscode_languageserver_protocol_1.RAL)().timer.setImmediate(() => {
        resolve(convertBatch(index));
      });
    });
    return result;
  }
  __name(map, "map");
  exports.map = map;
  async function mapAsync(items, func, token, options) {
    if (items.length === 0) return [];
    let result = new Array(items.length),
      timer = new Timer(options == null ? void 0 : options.yieldAfter);
    async function convertBatch(start) {
      timer.start();
      for (let i = start; i < items.length; i++) if (result[i] = await func(items[i], token), timer.shouldYield()) return options != null && options.yieldCallback && options.yieldCallback(), i + 1;
      return -1;
    }
    __name(convertBatch, "convertBatch");
    let index = await convertBatch(0);
    for (; index !== -1 && !(token !== void 0 && token.isCancellationRequested);) index = await new Promise(resolve => {
      (0, vscode_languageserver_protocol_1.RAL)().timer.setImmediate(() => {
        resolve(convertBatch(index));
      });
    });
    return result;
  }
  __name(mapAsync, "mapAsync");
  exports.mapAsync = mapAsync;
  async function forEach(items, func, token, options) {
    if (items.length === 0) return;
    let timer = new Timer(options == null ? void 0 : options.yieldAfter);
    function runBatch(start) {
      timer.start();
      for (let i = start; i < items.length; i++) if (func(items[i]), timer.shouldYield()) return options != null && options.yieldCallback && options.yieldCallback(), i + 1;
      return -1;
    }
    __name(runBatch, "runBatch");
    let index = runBatch(0);
    for (; index !== -1 && !(token !== void 0 && token.isCancellationRequested);) index = await new Promise(resolve => {
      (0, vscode_languageserver_protocol_1.RAL)().timer.setImmediate(() => {
        resolve(runBatch(index));
      });
    });
  }
  __name(forEach, "forEach");
  exports.forEach = forEach;
});