var require_client = __commonJSMin(exports => {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: !0
  });
  exports.ProposedFeatures = exports.BaseLanguageClient = exports.MessageTransports = exports.SuspendMode = exports.State = exports.CloseAction = exports.ErrorAction = exports.RevealOutputChannelOn = void 0;
  var vscode_1 = require("vscode"),
    vscode_languageserver_protocol_1 = Un(),
    c2p = eUe(),
    p2c = aUe(),
    Is = yp(),
    async_1 = rq(),
    UUID = yo(),
    progressPart_1 = ede(),
    features_1 = Oi(),
    diagnostic_1 = Qde(),
    notebook_1 = CUe(),
    configuration_1 = xUe(),
    textSynchronization_1 = kUe(),
    completion_1 = EUe(),
    hover_1 = BUe(),
    definition_1 = vUe(),
    signatureHelp_1 = QUe(),
    documentHighlight_1 = DUe(),
    documentSymbol_1 = gge(),
    workspaceSymbol_1 = FUe(),
    reference_1 = TUe(),
    codeAction_1 = NUe(),
    codeLens_1 = LUe(),
    formatting_1 = PUe(),
    rename_1 = zUe(),
    documentLink_1 = $Ue(),
    executeCommand_1 = jUe(),
    fileSystemWatcher_1 = UUe(),
    colorProvider_1 = OUe(),
    implementation_1 = GUe(),
    typeDefinition_1 = ZUe(),
    workspaceFolder_1 = HUe(),
    foldingRange_1 = YUe(),
    declaration_1 = KUe(),
    selectionRange_1 = JUe(),
    progress_1 = XUe(),
    callHierarchy_1 = eOe(),
    semanticTokens_1 = tOe(),
    fileOperations_1 = iOe(),
    linkedEditingRange_1 = rOe(),
    typeHierarchy_1 = oOe(),
    inlineValue_1 = cOe(),
    inlayHint_1 = AOe(),
    inlineCompletion_1 = uOe(),
    RevealOutputChannelOn;
  (function (RevealOutputChannelOn) {
    RevealOutputChannelOn[RevealOutputChannelOn.Debug = 0] = "Debug", RevealOutputChannelOn[RevealOutputChannelOn.Info = 1] = "Info", RevealOutputChannelOn[RevealOutputChannelOn.Warn = 2] = "Warn", RevealOutputChannelOn[RevealOutputChannelOn.Error = 3] = "Error", RevealOutputChannelOn[RevealOutputChannelOn.Never = 4] = "Never";
  })(RevealOutputChannelOn || (exports.RevealOutputChannelOn = RevealOutputChannelOn = {}));
  var ErrorAction;
  (function (ErrorAction) {
    ErrorAction[ErrorAction.Continue = 1] = "Continue", ErrorAction[ErrorAction.Shutdown = 2] = "Shutdown";
  })(ErrorAction || (exports.ErrorAction = ErrorAction = {}));
  var CloseAction;
  (function (CloseAction) {
    CloseAction[CloseAction.DoNotRestart = 1] = "DoNotRestart", CloseAction[CloseAction.Restart = 2] = "Restart";
  })(CloseAction || (exports.CloseAction = CloseAction = {}));
  var State;
  (function (State) {
    State[State.Stopped = 1] = "Stopped", State[State.Starting = 3] = "Starting", State[State.Running = 2] = "Running";
  })(State || (exports.State = State = {}));
  var SuspendMode;
  (function (SuspendMode) {
    SuspendMode.off = "off", SuspendMode.on = "on";
  })(SuspendMode || (exports.SuspendMode = SuspendMode = {}));
  var ResolvedClientOptions;
  (function (ResolvedClientOptions) {
    function sanitizeIsTrusted(isTrusted) {
      return isTrusted == null ? !1 : typeof isTrusted == "boolean" || typeof isTrusted == "object" && isTrusted !== null && Is.stringArray(isTrusted.enabledCommands) ? isTrusted : !1;
    }
    __name(sanitizeIsTrusted, "sanitizeIsTrusted"), ResolvedClientOptions.sanitizeIsTrusted = sanitizeIsTrusted;
  })(ResolvedClientOptions || (ResolvedClientOptions = {}));
  var _DefaultErrorHandler = class _DefaultErrorHandler {
    constructor(client, maxRestartCount) {
      this.client = client, this.maxRestartCount = maxRestartCount, this.restarts = [];
    }
    error(_error, _message, count) {
      return count && count <= 3 ? {
        action: ErrorAction.Continue
      } : {
        action: ErrorAction.Shutdown
      };
    }
    closed() {
      return this.restarts.push(Date.now()), this.restarts.length <= this.maxRestartCount ? {
        action: CloseAction.Restart
      } : this.restarts[this.restarts.length - 1] - this.restarts[0] <= 3 * 60 * 1e3 ? {
        action: CloseAction.DoNotRestart,
        message: `The ${this.client.name} server crashed ${this.maxRestartCount + 1} times in the last 3 minutes. The server will not be restarted. See the output for more information.`
      } : (this.restarts.shift(), {
        action: CloseAction.Restart
      });
    }
  };
  __name(_DefaultErrorHandler, "DefaultErrorHandler");
  var DefaultErrorHandler = _DefaultErrorHandler,
    ClientState;
  (function (ClientState) {
    ClientState.Initial = "initial", ClientState.Starting = "starting", ClientState.StartFailed = "startFailed", ClientState.Running = "running", ClientState.Stopping = "stopping", ClientState.Stopped = "stopped";
  })(ClientState || (ClientState = {}));
  var MessageTransports;
  (function (MessageTransports) {
    function is(value) {
      return value && vscode_languageserver_protocol_1.MessageReader.is(value.reader) && vscode_languageserver_protocol_1.MessageWriter.is(value.writer);
    }
    __name(is, "is"), MessageTransports.is = is;
  })(MessageTransports || (exports.MessageTransports = MessageTransports = {}));
  var _BaseLanguageClient = class _BaseLanguageClient {
    constructor(id, name, clientOptions) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j;
      this._traceFormat = vscode_languageserver_protocol_1.TraceFormat.Text, this._diagnosticQueue = new Map(), this._diagnosticQueueState = {
        state: "idle"
      }, this._features = [], this._dynamicFeatures = new Map(), this.workspaceEditLock = new async_1.Semaphore(1), this._id = id, this._name = name, clientOptions = clientOptions || {};
      let markdown = {
        isTrusted: !1,
        supportHtml: !1
      };
      clientOptions.markdown !== void 0 && (markdown.isTrusted = ResolvedClientOptions.sanitizeIsTrusted(clientOptions.markdown.isTrusted), markdown.supportHtml = clientOptions.markdown.supportHtml === !0), this._clientOptions = {
        documentSelector: (_a = clientOptions.documentSelector) != null ? _a : [],
        synchronize: (_b = clientOptions.synchronize) != null ? _b : {},
        diagnosticCollectionName: clientOptions.diagnosticCollectionName,
        outputChannelName: (_c = clientOptions.outputChannelName) != null ? _c : this._name,
        revealOutputChannelOn: (_d = clientOptions.revealOutputChannelOn) != null ? _d : RevealOutputChannelOn.Error,
        stdioEncoding: (_e = clientOptions.stdioEncoding) != null ? _e : "utf8",
        initializationOptions: clientOptions.initializationOptions,
        initializationFailedHandler: clientOptions.initializationFailedHandler,
        progressOnInitialization: !!clientOptions.progressOnInitialization,
        errorHandler: (_g = clientOptions.errorHandler) != null ? _g : this.createDefaultErrorHandler((_f = clientOptions.connectionOptions) == null ? void 0 : _f.maxRestartCount),
        middleware: (_h = clientOptions.middleware) != null ? _h : {},
        uriConverters: clientOptions.uriConverters,
        workspaceFolder: clientOptions.workspaceFolder,
        connectionOptions: clientOptions.connectionOptions,
        markdown: markdown,
        diagnosticPullOptions: (_i = clientOptions.diagnosticPullOptions) != null ? _i : {
          onChange: !0,
          onSave: !1
        },
        notebookDocumentOptions: (_j = clientOptions.notebookDocumentOptions) != null ? _j : {}
      }, this._clientOptions.synchronize = this._clientOptions.synchronize || {}, this._state = ClientState.Initial, this._ignoredRegistrations = new Set(), this._listeners = [], this._notificationHandlers = new Map(), this._pendingNotificationHandlers = new Map(), this._notificationDisposables = new Map(), this._requestHandlers = new Map(), this._pendingRequestHandlers = new Map(), this._requestDisposables = new Map(), this._progressHandlers = new Map(), this._pendingProgressHandlers = new Map(), this._progressDisposables = new Map(), this._connection = void 0, this._initializeResult = void 0, clientOptions.outputChannel ? (this._outputChannel = clientOptions.outputChannel, this._disposeOutputChannel = !1) : (this._outputChannel = void 0, this._disposeOutputChannel = !0), this._traceOutputChannel = clientOptions.traceOutputChannel, this._diagnostics = void 0, this._pendingOpenNotifications = new Set(), this._pendingChangeSemaphore = new async_1.Semaphore(1), this._pendingChangeDelayer = new async_1.Delayer(250), this._fileEvents = [], this._fileEventDelayer = new async_1.Delayer(250), this._onStop = void 0, this._telemetryEmitter = new vscode_languageserver_protocol_1.Emitter(), this._stateChangeEmitter = new vscode_languageserver_protocol_1.Emitter(), this._trace = vscode_languageserver_protocol_1.Trace.Off, this._tracer = {
        log: __name((messageOrDataObject, data) => {
          Is.string(messageOrDataObject) ? this.logTrace(messageOrDataObject, data) : this.logObjectTrace(messageOrDataObject);
        }, "log")
      }, this._c2p = c2p.createConverter(clientOptions.uriConverters ? clientOptions.uriConverters.code2Protocol : void 0), this._p2c = p2c.createConverter(clientOptions.uriConverters ? clientOptions.uriConverters.protocol2Code : void 0, this._clientOptions.markdown.isTrusted, this._clientOptions.markdown.supportHtml), this._syncedDocuments = new Map(), this.registerBuiltinFeatures();
    }
    get name() {
      return this._name;
    }
    get middleware() {
      var _a;
      return (_a = this._clientOptions.middleware) != null ? _a : Object.create(null);
    }
    get clientOptions() {
      return this._clientOptions;
    }
    get protocol2CodeConverter() {
      return this._p2c;
    }
    get code2ProtocolConverter() {
      return this._c2p;
    }
    get onTelemetry() {
      return this._telemetryEmitter.event;
    }
    get onDidChangeState() {
      return this._stateChangeEmitter.event;
    }
    get outputChannel() {
      return this._outputChannel || (this._outputChannel = vscode_1.window.createOutputChannel(this._clientOptions.outputChannelName ? this._clientOptions.outputChannelName : this._name)), this._outputChannel;
    }
    get traceOutputChannel() {
      return this._traceOutputChannel ? this._traceOutputChannel : this.outputChannel;
    }
    get diagnostics() {
      return this._diagnostics;
    }
    get state() {
      return this.getPublicState();
    }
    get $state() {
      return this._state;
    }
    set $state(value) {
      let oldState = this.getPublicState();
      this._state = value;
      let newState = this.getPublicState();
      newState !== oldState && this._stateChangeEmitter.fire({
        oldState: oldState,
        newState: newState
      });
    }
    getPublicState() {
      switch (this.$state) {
        case ClientState.Starting:
          return State.Starting;
        case ClientState.Running:
          return State.Running;
        default:
          return State.Stopped;
      }
    }
    get initializeResult() {
      return this._initializeResult;
    }
    async sendRequest(type, ...params) {
      var _a;
      if (this.$state === ClientState.StartFailed || this.$state === ClientState.Stopping || this.$state === ClientState.Stopped) return Promise.reject(new vscode_languageserver_protocol_1.ResponseError(vscode_languageserver_protocol_1.ErrorCodes.ConnectionInactive, "Client is not running"));
      let connection = await this.$start();
      this._didChangeTextDocumentFeature.syncKind === vscode_languageserver_protocol_1.TextDocumentSyncKind.Full && (await this.sendPendingFullTextDocumentChanges(connection));
      let _sendRequest = (_a = this._clientOptions.middleware) == null ? void 0 : _a.sendRequest;
      if (_sendRequest !== void 0) {
        let param, token;
        return params.length === 1 ? vscode_languageserver_protocol_1.CancellationToken.is(params[0]) ? token = params[0] : param = params[0] : params.length === 2 && (param = params[0], token = params[1]), _sendRequest(type, param, token, (type, param, token) => {
          let params = [];
          return param !== void 0 && params.push(param), token !== void 0 && params.push(token), connection.sendRequest(type, ...params);
        });
      } else return connection.sendRequest(type, ...params);
    }
    onRequest(type, handler) {
      let method = typeof type == "string" ? type : type.method;
      this._requestHandlers.set(method, handler);
      let connection = this.activeConnection(),
        disposable;
      return connection !== void 0 ? (this._requestDisposables.set(method, connection.onRequest(type, handler)), disposable = {
        dispose: __name(() => {
          let disposable = this._requestDisposables.get(method);
          disposable !== void 0 && (disposable.dispose(), this._requestDisposables.delete(method));
        }, "dispose")
      }) : (this._pendingRequestHandlers.set(method, handler), disposable = {
        dispose: __name(() => {
          this._pendingRequestHandlers.delete(method);
          let disposable = this._requestDisposables.get(method);
          disposable !== void 0 && (disposable.dispose(), this._requestDisposables.delete(method));
        }, "dispose")
      }), {
        dispose: __name(() => {
          this._requestHandlers.delete(method), disposable.dispose();
        }, "dispose")
      };
    }
    async sendNotification(type, params) {
      var _a;
      if (this.$state === ClientState.StartFailed || this.$state === ClientState.Stopping || this.$state === ClientState.Stopped) return Promise.reject(new vscode_languageserver_protocol_1.ResponseError(vscode_languageserver_protocol_1.ErrorCodes.ConnectionInactive, "Client is not running"));
      let needsPendingFullTextDocumentSync = this._didChangeTextDocumentFeature.syncKind === vscode_languageserver_protocol_1.TextDocumentSyncKind.Full,
        openNotification;
      needsPendingFullTextDocumentSync && typeof type != "string" && type.method === vscode_languageserver_protocol_1.DidOpenTextDocumentNotification.method && (openNotification = params == null ? void 0 : params.textDocument.uri, this._pendingOpenNotifications.add(openNotification));
      let connection = await this.$start();
      needsPendingFullTextDocumentSync && (await this.sendPendingFullTextDocumentChanges(connection)), openNotification !== void 0 && this._pendingOpenNotifications.delete(openNotification);
      let _sendNotification = (_a = this._clientOptions.middleware) == null ? void 0 : _a.sendNotification;
      return _sendNotification ? _sendNotification(type, connection.sendNotification.bind(connection), params) : connection.sendNotification(type, params);
    }
    onNotification(type, handler) {
      let method = typeof type == "string" ? type : type.method;
      this._notificationHandlers.set(method, handler);
      let connection = this.activeConnection(),
        disposable;
      return connection !== void 0 ? (this._notificationDisposables.set(method, connection.onNotification(type, handler)), disposable = {
        dispose: __name(() => {
          let disposable = this._notificationDisposables.get(method);
          disposable !== void 0 && (disposable.dispose(), this._notificationDisposables.delete(method));
        }, "dispose")
      }) : (this._pendingNotificationHandlers.set(method, handler), disposable = {
        dispose: __name(() => {
          this._pendingNotificationHandlers.delete(method);
          let disposable = this._notificationDisposables.get(method);
          disposable !== void 0 && (disposable.dispose(), this._notificationDisposables.delete(method));
        }, "dispose")
      }), {
        dispose: __name(() => {
          this._notificationHandlers.delete(method), disposable.dispose();
        }, "dispose")
      };
    }
    async sendProgress(type, token, value) {
      if (this.$state === ClientState.StartFailed || this.$state === ClientState.Stopping || this.$state === ClientState.Stopped) return Promise.reject(new vscode_languageserver_protocol_1.ResponseError(vscode_languageserver_protocol_1.ErrorCodes.ConnectionInactive, "Client is not running"));
      try {
        return (await this.$start()).sendProgress(type, token, value);
      } catch (error) {
        throw this.error(`Sending progress for token ${token} failed.`, error), error;
      }
    }
    onProgress(type, token, handler) {
      var _a;
      this._progressHandlers.set(token, {
        type: type,
        handler: handler
      });
      let connection = this.activeConnection(),
        disposable,
        handleWorkDoneProgress = (_a = this._clientOptions.middleware) == null ? void 0 : _a.handleWorkDoneProgress,
        realHandler = vscode_languageserver_protocol_1.WorkDoneProgress.is(type) && handleWorkDoneProgress !== void 0 ? params => {
          handleWorkDoneProgress(token, params, () => handler(params));
        } : handler;
      return connection !== void 0 ? (this._progressDisposables.set(token, connection.onProgress(type, token, realHandler)), disposable = {
        dispose: __name(() => {
          let disposable = this._progressDisposables.get(token);
          disposable !== void 0 && (disposable.dispose(), this._progressDisposables.delete(token));
        }, "dispose")
      }) : (this._pendingProgressHandlers.set(token, {
        type: type,
        handler: handler
      }), disposable = {
        dispose: __name(() => {
          this._pendingProgressHandlers.delete(token);
          let disposable = this._progressDisposables.get(token);
          disposable !== void 0 && (disposable.dispose(), this._progressDisposables.delete(token));
        }, "dispose")
      }), {
        dispose: __name(() => {
          this._progressHandlers.delete(token), disposable.dispose();
        }, "dispose")
      };
    }
    createDefaultErrorHandler(maxRestartCount) {
      if (maxRestartCount !== void 0 && maxRestartCount < 0) throw new Error(`Invalid maxRestartCount: ${maxRestartCount}`);
      return new DefaultErrorHandler(this, maxRestartCount != null ? maxRestartCount : 4);
    }
    async setTrace(value) {
      this._trace = value;
      let connection = this.activeConnection();
      connection !== void 0 && (await connection.trace(this._trace, this._tracer, {
        sendNotification: !1,
        traceFormat: this._traceFormat
      }));
    }
    data2String(data) {
      if (data instanceof vscode_languageserver_protocol_1.ResponseError) {
        let responseError = data;
        return `  Message: ${responseError.message}
  Code: ${responseError.code} ${responseError.data ? `
` + responseError.data.toString() : ""}`;
      }
      return data instanceof Error ? Is.string(data.stack) ? data.stack : data.message : Is.string(data) ? data : data.toString();
    }
    debug(message, data, showNotification = !0) {
      this.logOutputMessage(vscode_languageserver_protocol_1.MessageType.Debug, RevealOutputChannelOn.Debug, "Debug", message, data, showNotification);
    }
    info(message, data, showNotification = !0) {
      this.logOutputMessage(vscode_languageserver_protocol_1.MessageType.Info, RevealOutputChannelOn.Info, "Info", message, data, showNotification);
    }
    warn(message, data, showNotification = !0) {
      this.logOutputMessage(vscode_languageserver_protocol_1.MessageType.Warning, RevealOutputChannelOn.Warn, "Warn", message, data, showNotification);
    }
    error(message, data, showNotification = !0) {
      this.logOutputMessage(vscode_languageserver_protocol_1.MessageType.Error, RevealOutputChannelOn.Error, "Error", message, data, showNotification);
    }
    logOutputMessage(type, reveal, name, message, data, showNotification) {
      this.outputChannel.appendLine(`[${name.padEnd(5)} - ${new Date().toLocaleTimeString()}] ${message}`), data != null && this.outputChannel.appendLine(this.data2String(data)), (showNotification === "force" || showNotification && this._clientOptions.revealOutputChannelOn <= reveal) && this.showNotificationMessage(type, message);
    }
    showNotificationMessage(type, message) {
      message = message != null ? message : "A request has failed. See the output for more information.", (type === vscode_languageserver_protocol_1.MessageType.Error ? vscode_1.window.showErrorMessage : type === vscode_languageserver_protocol_1.MessageType.Warning ? vscode_1.window.showWarningMessage : vscode_1.window.showInformationMessage)(message, "Go to output").then(selection => {
        selection !== void 0 && this.outputChannel.show(!0);
      });
    }
    logTrace(message, data) {
      this.traceOutputChannel.appendLine(`[Trace - ${new Date().toLocaleTimeString()}] ${message}`), data && this.traceOutputChannel.appendLine(this.data2String(data));
    }
    logObjectTrace(data) {
      data.isLSPMessage && data.type ? this.traceOutputChannel.append(`[LSP   - ${new Date().toLocaleTimeString()}] `) : this.traceOutputChannel.append(`[Trace - ${new Date().toLocaleTimeString()}] `), data && this.traceOutputChannel.appendLine(`${JSON.stringify(data)}`);
    }
    needsStart() {
      return this.$state === ClientState.Initial || this.$state === ClientState.Stopping || this.$state === ClientState.Stopped;
    }
    needsStop() {
      return this.$state === ClientState.Starting || this.$state === ClientState.Running;
    }
    activeConnection() {
      return this.$state === ClientState.Running && this._connection !== void 0 ? this._connection : void 0;
    }
    isRunning() {
      return this.$state === ClientState.Running;
    }
    async start() {
      if (this._disposed === "disposing" || this._disposed === "disposed") throw new Error("Client got disposed and can't be restarted.");
      if (this.$state === ClientState.Stopping) throw new Error("Client is currently stopping. Can only restart a full stopped client");
      if (this._onStart !== void 0) return this._onStart;
      let [promise, resolve, reject] = this.createOnStartPromise();
      this._onStart = promise, this._diagnostics === void 0 && (this._diagnostics = this._clientOptions.diagnosticCollectionName ? vscode_1.languages.createDiagnosticCollection(this._clientOptions.diagnosticCollectionName) : vscode_1.languages.createDiagnosticCollection());
      for (let [method, handler] of this._notificationHandlers) this._pendingNotificationHandlers.has(method) || this._pendingNotificationHandlers.set(method, handler);
      for (let [method, handler] of this._requestHandlers) this._pendingRequestHandlers.has(method) || this._pendingRequestHandlers.set(method, handler);
      for (let [token, data] of this._progressHandlers) this._pendingProgressHandlers.has(token) || this._pendingProgressHandlers.set(token, data);
      this.$state = ClientState.Starting;
      try {
        let connection = await this.createConnection();
        connection.onNotification(vscode_languageserver_protocol_1.LogMessageNotification.type, message => {
          switch (message.type) {
            case vscode_languageserver_protocol_1.MessageType.Error:
              this.error(message.message, void 0, !1);
              break;
            case vscode_languageserver_protocol_1.MessageType.Warning:
              this.warn(message.message, void 0, !1);
              break;
            case vscode_languageserver_protocol_1.MessageType.Info:
              this.info(message.message, void 0, !1);
              break;
            case vscode_languageserver_protocol_1.MessageType.Debug:
              this.debug(message.message, void 0, !1);
              break;
            default:
              this.outputChannel.appendLine(message.message);
          }
        }), connection.onNotification(vscode_languageserver_protocol_1.ShowMessageNotification.type, message => {
          switch (message.type) {
            case vscode_languageserver_protocol_1.MessageType.Error:
              vscode_1.window.showErrorMessage(message.message);
              break;
            case vscode_languageserver_protocol_1.MessageType.Warning:
              vscode_1.window.showWarningMessage(message.message);
              break;
            case vscode_languageserver_protocol_1.MessageType.Info:
              vscode_1.window.showInformationMessage(message.message);
              break;
            default:
              vscode_1.window.showInformationMessage(message.message);
          }
        }), connection.onRequest(vscode_languageserver_protocol_1.ShowMessageRequest.type, params => {
          let messageFunc;
          switch (params.type) {
            case vscode_languageserver_protocol_1.MessageType.Error:
              messageFunc = vscode_1.window.showErrorMessage;
              break;
            case vscode_languageserver_protocol_1.MessageType.Warning:
              messageFunc = vscode_1.window.showWarningMessage;
              break;
            case vscode_languageserver_protocol_1.MessageType.Info:
              messageFunc = vscode_1.window.showInformationMessage;
              break;
            default:
              messageFunc = vscode_1.window.showInformationMessage;
          }
          let actions = params.actions || [];
          return messageFunc(params.message, ...actions);
        }), connection.onNotification(vscode_languageserver_protocol_1.TelemetryEventNotification.type, data => {
          this._telemetryEmitter.fire(data);
        }), connection.onRequest(vscode_languageserver_protocol_1.ShowDocumentRequest.type, async params => {
          var _a;
          let showDocument = __name(async params => {
              let uri = this.protocol2CodeConverter.asUri(params.uri);
              try {
                if (params.external === !0) return {
                  success: await vscode_1.env.openExternal(uri)
                };
                {
                  let options = {};
                  return params.selection !== void 0 && (options.selection = this.protocol2CodeConverter.asRange(params.selection)), params.takeFocus === void 0 || params.takeFocus === !1 ? options.preserveFocus = !0 : params.takeFocus === !0 && (options.preserveFocus = !1), await vscode_1.window.showTextDocument(uri, options), {
                    success: !0
                  };
                }
              } catch {
                return {
                  success: !1
                };
              }
            }, "showDocument"),
            middleware = (_a = this._clientOptions.middleware.window) == null ? void 0 : _a.showDocument;
          return middleware !== void 0 ? middleware(params, showDocument) : showDocument(params);
        }), connection.listen(), await this.initialize(connection), resolve();
      } catch (error) {
        this.$state = ClientState.StartFailed, this.error(`${this._name} client: couldn't create connection to server.`, error, "force"), reject(error);
      }
      return this._onStart;
    }
    createOnStartPromise() {
      let resolve, reject;
      return [new Promise((_resolve, _reject) => {
        resolve = _resolve, reject = _reject;
      }), resolve, reject];
    }
    async initialize(connection) {
      this.refreshTrace(connection, !1);
      let initOption = this._clientOptions.initializationOptions,
        [rootPath, workspaceFolders] = this._clientOptions.workspaceFolder !== void 0 ? [this._clientOptions.workspaceFolder.uri.fsPath, [{
          uri: this._c2p.asUri(this._clientOptions.workspaceFolder.uri),
          name: this._clientOptions.workspaceFolder.name
        }]] : [this._clientGetRootPath(), null],
        initParams = {
          processId: null,
          clientInfo: {
            name: vscode_1.env.appName,
            version: vscode_1.version
          },
          locale: this.getLocale(),
          rootPath: rootPath || null,
          rootUri: rootPath ? this._c2p.asUri(vscode_1.Uri.file(rootPath)) : null,
          capabilities: this.computeClientCapabilities(),
          initializationOptions: Is.func(initOption) ? initOption() : initOption,
          trace: vscode_languageserver_protocol_1.Trace.toString(this._trace),
          workspaceFolders: workspaceFolders
        };
      if (this.fillInitializeParams(initParams), this._clientOptions.progressOnInitialization) {
        let token = UUID.generateUuid(),
          part = new progressPart_1.ProgressPart(connection, token);
        initParams.workDoneToken = token;
        try {
          let result = await this.doInitialize(connection, initParams);
          return part.done(), result;
        } catch (error) {
          throw part.cancel(), error;
        }
      } else return this.doInitialize(connection, initParams);
    }
    async doInitialize(connection, initParams) {
      try {
        let result = await connection.initialize(initParams);
        if (result.capabilities.positionEncoding !== void 0 && result.capabilities.positionEncoding !== vscode_languageserver_protocol_1.PositionEncodingKind.UTF16) throw new Error(`Unsupported position encoding (${result.capabilities.positionEncoding}) received from server ${this.name}`);
        this._initializeResult = result, this.$state = ClientState.Running;
        let textDocumentSyncOptions;
        Is.number(result.capabilities.textDocumentSync) ? result.capabilities.textDocumentSync === vscode_languageserver_protocol_1.TextDocumentSyncKind.None ? textDocumentSyncOptions = {
          openClose: !1,
          change: vscode_languageserver_protocol_1.TextDocumentSyncKind.None,
          save: void 0
        } : textDocumentSyncOptions = {
          openClose: !0,
          change: result.capabilities.textDocumentSync,
          save: {
            includeText: !1
          }
        } : result.capabilities.textDocumentSync !== void 0 && result.capabilities.textDocumentSync !== null && (textDocumentSyncOptions = result.capabilities.textDocumentSync), this._capabilities = Object.assign({}, result.capabilities, {
          resolvedTextDocumentSync: textDocumentSyncOptions
        }), connection.onNotification(vscode_languageserver_protocol_1.PublishDiagnosticsNotification.type, params => this.handleDiagnostics(params)), connection.onRequest(vscode_languageserver_protocol_1.RegistrationRequest.type, params => this.handleRegistrationRequest(params)), connection.onRequest("client/registerFeature", params => this.handleRegistrationRequest(params)), connection.onRequest(vscode_languageserver_protocol_1.UnregistrationRequest.type, params => this.handleUnregistrationRequest(params)), connection.onRequest("client/unregisterFeature", params => this.handleUnregistrationRequest(params)), connection.onRequest(vscode_languageserver_protocol_1.ApplyWorkspaceEditRequest.type, params => this.handleApplyWorkspaceEdit(params));
        for (let [method, handler] of this._pendingNotificationHandlers) this._notificationDisposables.set(method, connection.onNotification(method, handler));
        this._pendingNotificationHandlers.clear();
        for (let [method, handler] of this._pendingRequestHandlers) this._requestDisposables.set(method, connection.onRequest(method, handler));
        this._pendingRequestHandlers.clear();
        for (let [token, data] of this._pendingProgressHandlers) this._progressDisposables.set(token, connection.onProgress(data.type, token, data.handler));
        return this._pendingProgressHandlers.clear(), await connection.sendNotification(vscode_languageserver_protocol_1.InitializedNotification.type, {}), this.hookFileEvents(connection), this.hookConfigurationChanged(connection), this.initializeFeatures(connection), result;
      } catch (error) {
        throw this._clientOptions.initializationFailedHandler ? this._clientOptions.initializationFailedHandler(error) ? this.initialize(connection) : this.stop() : error instanceof vscode_languageserver_protocol_1.ResponseError && error.data && error.data.retry ? vscode_1.window.showErrorMessage(error.message, {
          title: "Retry",
          id: "retry"
        }).then(item => {
          item && item.id === "retry" ? this.initialize(connection) : this.stop();
        }) : (error && error.message && vscode_1.window.showErrorMessage(error.message), this.error("Server initialization failed.", error), this.stop()), error;
      }
    }
    _clientGetRootPath() {
      let folders = vscode_1.workspace.workspaceFolders;
      if (!folders || folders.length === 0) return;
      let folder = folders[0];
      if (folder.uri.scheme === "file") return folder.uri.fsPath;
    }
    stop(timeout = 2e3) {
      return this.shutdown("stop", timeout);
    }
    dispose(timeout = 2e3) {
      try {
        return this._disposed = "disposing", this.stop(timeout);
      } finally {
        this._disposed = "disposed";
      }
    }
    async shutdown(mode, timeout) {
      if (this.$state === ClientState.Stopped || this.$state === ClientState.Initial) return;
      if (this.$state === ClientState.Stopping) {
        if (this._onStop !== void 0) return this._onStop;
        throw new Error("Client is stopping but no stop promise available.");
      }
      let connection = this.activeConnection();
      if (connection === void 0 || this.$state !== ClientState.Running) throw new Error(`Client is not running and can't be stopped. It's current state is: ${this.$state}`);
      this._initializeResult = void 0, this.$state = ClientState.Stopping, this.cleanUp(mode);
      let tp = new Promise(c => {
          (0, vscode_languageserver_protocol_1.RAL)().timer.setTimeout(c, timeout);
        }),
        shutdown = (async connection => (await connection.shutdown(), await connection.exit(), connection))(connection);
      return this._onStop = Promise.race([tp, shutdown]).then(connection => {
        if (connection !== void 0) connection.end(), connection.dispose();else throw this.error("Stopping server timed out", void 0, !1), new Error("Stopping the server timed out");
      }, error => {
        throw this.error("Stopping server failed", error, !1), error;
      }).finally(() => {
        this.$state = ClientState.Stopped, mode === "stop" && this.cleanUpChannel(), this._onStart = void 0, this._onStop = void 0, this._connection = void 0, this._ignoredRegistrations.clear();
      });
    }
    cleanUp(mode) {
      this._fileEvents = [], this._fileEventDelayer.cancel();
      let disposables = this._listeners.splice(0, this._listeners.length);
      for (let disposable of disposables) disposable.dispose();
      this._syncedDocuments && this._syncedDocuments.clear();
      for (let feature of Array.from(this._features.entries()).map(entry => entry[1]).reverse()) feature.clear();
      mode === "stop" && this._diagnostics !== void 0 && (this._diagnostics.dispose(), this._diagnostics = void 0), this._idleInterval !== void 0 && (this._idleInterval.dispose(), this._idleInterval = void 0);
    }
    cleanUpChannel() {
      this._outputChannel !== void 0 && this._disposeOutputChannel && (this._outputChannel.dispose(), this._outputChannel = void 0);
    }
    notifyFileEvent(event) {
      var _a;
      let client = this;
      async function didChangeWatchedFile(event) {
        return client._fileEvents.push(event), client._fileEventDelayer.trigger(async () => {
          await client.sendNotification(vscode_languageserver_protocol_1.DidChangeWatchedFilesNotification.type, {
            changes: client._fileEvents
          }), client._fileEvents = [];
        });
      }
      __name(didChangeWatchedFile, "didChangeWatchedFile");
      let workSpaceMiddleware = (_a = this.clientOptions.middleware) == null ? void 0 : _a.workspace;
      (workSpaceMiddleware != null && workSpaceMiddleware.didChangeWatchedFile ? workSpaceMiddleware.didChangeWatchedFile(event, didChangeWatchedFile) : didChangeWatchedFile(event)).catch(error => {
        client.error("Notify file events failed.", error);
      });
    }
    async sendPendingFullTextDocumentChanges(connection) {
      return this._pendingChangeSemaphore.lock(async () => {
        try {
          let changes = this._didChangeTextDocumentFeature.getPendingDocumentChanges(this._pendingOpenNotifications);
          if (changes.length === 0) return;
          for (let document of changes) {
            let params = this.code2ProtocolConverter.asChangeTextDocumentParams(document);
            await connection.sendNotification(vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type, params), this._didChangeTextDocumentFeature.notificationSent(document, vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type, params);
          }
        } catch (error) {
          throw this.error("Sending pending changes failed", error, !1), error;
        }
      });
    }
    triggerPendingChangeDelivery() {
      this._pendingChangeDelayer.trigger(async () => {
        let connection = this.activeConnection();
        if (connection === void 0) {
          this.triggerPendingChangeDelivery();
          return;
        }
        await this.sendPendingFullTextDocumentChanges(connection);
      }).catch(error => this.error("Delivering pending changes failed", error, !1));
    }
    handleDiagnostics(params) {
      if (!this._diagnostics) return;
      let key = params.uri;
      this._diagnosticQueueState.state === "busy" && this._diagnosticQueueState.document === key && this._diagnosticQueueState.tokenSource.cancel(), this._diagnosticQueue.set(params.uri, params.diagnostics), this.triggerDiagnosticQueue();
    }
    triggerDiagnosticQueue() {
      (0, vscode_languageserver_protocol_1.RAL)().timer.setImmediate(() => {
        this.workDiagnosticQueue();
      });
    }
    workDiagnosticQueue() {
      if (this._diagnosticQueueState.state === "busy") return;
      let next = this._diagnosticQueue.entries().next();
      if (next.done === !0) return;
      let [document, diagnostics] = next.value;
      this._diagnosticQueue.delete(document);
      let tokenSource = new vscode_1.CancellationTokenSource();
      this._diagnosticQueueState = {
        state: "busy",
        document: document,
        tokenSource: tokenSource
      }, this._p2c.asDiagnostics(diagnostics, tokenSource.token).then(converted => {
        if (!tokenSource.token.isCancellationRequested) {
          let uri = this._p2c.asUri(document),
            middleware = this.clientOptions.middleware;
          middleware.handleDiagnostics ? middleware.handleDiagnostics(uri, converted, (uri, diagnostics) => this.setDiagnostics(uri, diagnostics)) : this.setDiagnostics(uri, converted);
        }
      }).finally(() => {
        this._diagnosticQueueState = {
          state: "idle"
        }, this.triggerDiagnosticQueue();
      });
    }
    setDiagnostics(uri, diagnostics) {
      this._diagnostics && this._diagnostics.set(uri, diagnostics);
    }
    getLocale() {
      return vscode_1.env.language;
    }
    async $start() {
      if (this.$state === ClientState.StartFailed) throw new Error("Previous start failed. Can't restart server.");
      await this.start();
      let connection = this.activeConnection();
      if (connection === void 0) throw new Error("Starting server failed");
      return connection;
    }
    async createConnection() {
      let errorHandler = __name((error, message, count) => {
          this.handleConnectionError(error, message, count).catch(error => this.error("Handling connection error failed", error));
        }, "errorHandler"),
        closeHandler = __name(() => {
          this.handleConnectionClosed().catch(error => this.error("Handling connection close failed", error));
        }, "closeHandler"),
        transports = await this.createMessageTransports(this._clientOptions.stdioEncoding || "utf8");
      return this._connection = createConnection(transports.reader, transports.writer, errorHandler, closeHandler, this._clientOptions.connectionOptions), this._connection;
    }
    async handleConnectionClosed() {
      var _a, _b;
      if (this.$state === ClientState.Stopped) return;
      try {
        this._connection !== void 0 && this._connection.dispose();
      } catch {}
      let handlerResult = {
        action: CloseAction.DoNotRestart
      };
      if (this.$state !== ClientState.Stopping) try {
        handlerResult = await this._clientOptions.errorHandler.closed();
      } catch {}
      this._connection = void 0, handlerResult.action === CloseAction.DoNotRestart ? (this.error((_a = handlerResult.message) != null ? _a : "Connection to server got closed. Server will not be restarted.", void 0, handlerResult.handled === !0 ? !1 : "force"), this.cleanUp("stop"), this.$state === ClientState.Starting ? this.$state = ClientState.StartFailed : this.$state = ClientState.Stopped, this._onStop = Promise.resolve(), this._onStart = void 0) : handlerResult.action === CloseAction.Restart && (this.info((_b = handlerResult.message) != null ? _b : "Connection to server got closed. Server will restart.", !handlerResult.handled), this.cleanUp("restart"), this.$state = ClientState.Initial, this._onStop = Promise.resolve(), this._onStart = void 0, this.start().catch(error => this.error("Restarting server failed", error, "force")));
    }
    async handleConnectionError(error, message, count) {
      var _a, _b;
      let handlerResult = await this._clientOptions.errorHandler.error(error, message, count);
      handlerResult.action === ErrorAction.Shutdown ? (this.error((_a = handlerResult.message) != null ? _a : `Client ${this._name}: connection to server is erroring.
${error.message}
Shutting down server.`, void 0, handlerResult.handled === !0 ? !1 : "force"), this.stop().catch(error => {
        this.error("Stopping server failed", error, !1);
      })) : this.error((_b = handlerResult.message) != null ? _b : `Client ${this._name}: connection to server is erroring.
${error.message}`, void 0, handlerResult.handled === !0 ? !1 : "force");
    }
    hookConfigurationChanged(connection) {
      this._listeners.push(vscode_1.workspace.onDidChangeConfiguration(() => {
        this.refreshTrace(connection, !0);
      }));
    }
    refreshTrace(connection, sendNotification = !1) {
      let config = vscode_1.workspace.getConfiguration(this._id),
        trace = vscode_languageserver_protocol_1.Trace.Off,
        traceFormat = vscode_languageserver_protocol_1.TraceFormat.Text;
      if (config) {
        let traceConfig = config.get("trace.server", "off");
        typeof traceConfig == "string" ? trace = vscode_languageserver_protocol_1.Trace.fromString(traceConfig) : (trace = vscode_languageserver_protocol_1.Trace.fromString(config.get("trace.server.verbosity", "off")), traceFormat = vscode_languageserver_protocol_1.TraceFormat.fromString(config.get("trace.server.format", "text")));
      }
      this._trace = trace, this._traceFormat = traceFormat, connection.trace(this._trace, this._tracer, {
        sendNotification: sendNotification,
        traceFormat: this._traceFormat
      }).catch(error => {
        this.error("Updating trace failed with error", error, !1);
      });
    }
    hookFileEvents(_connection) {
      let fileEvents = this._clientOptions.synchronize.fileEvents;
      if (!fileEvents) return;
      let watchers;
      Is.array(fileEvents) ? watchers = fileEvents : watchers = [fileEvents], watchers && this._dynamicFeatures.get(vscode_languageserver_protocol_1.DidChangeWatchedFilesNotification.type.method).registerRaw(UUID.generateUuid(), watchers);
    }
    registerFeatures(features) {
      for (let feature of features) this.registerFeature(feature);
    }
    registerFeature(feature) {
      if (this._features.push(feature), features_1.DynamicFeature.is(feature)) {
        let registrationType = feature.registrationType;
        this._dynamicFeatures.set(registrationType.method, feature);
      }
    }
    getFeature(request) {
      return this._dynamicFeatures.get(request);
    }
    hasDedicatedTextSynchronizationFeature(textDocument) {
      let feature = this.getFeature(vscode_languageserver_protocol_1.NotebookDocumentSyncRegistrationType.method);
      return feature === void 0 || !(feature instanceof notebook_1.NotebookDocumentSyncFeature) ? !1 : feature.handles(textDocument);
    }
    registerBuiltinFeatures() {
      let pendingFullTextDocumentChanges = new Map();
      this.registerFeature(new configuration_1.ConfigurationFeature(this)), this.registerFeature(new textSynchronization_1.DidOpenTextDocumentFeature(this, this._syncedDocuments)), this._didChangeTextDocumentFeature = new textSynchronization_1.DidChangeTextDocumentFeature(this, pendingFullTextDocumentChanges), this._didChangeTextDocumentFeature.onPendingChangeAdded(() => {
        this.triggerPendingChangeDelivery();
      }), this.registerFeature(this._didChangeTextDocumentFeature), this.registerFeature(new textSynchronization_1.WillSaveFeature(this)), this.registerFeature(new textSynchronization_1.WillSaveWaitUntilFeature(this)), this.registerFeature(new textSynchronization_1.DidSaveTextDocumentFeature(this)), this.registerFeature(new textSynchronization_1.DidCloseTextDocumentFeature(this, this._syncedDocuments, pendingFullTextDocumentChanges)), this.registerFeature(new fileSystemWatcher_1.FileSystemWatcherFeature(this, event => this.notifyFileEvent(event))), this.registerFeature(new completion_1.CompletionItemFeature(this)), this.registerFeature(new hover_1.HoverFeature(this)), this.registerFeature(new signatureHelp_1.SignatureHelpFeature(this)), this.registerFeature(new definition_1.DefinitionFeature(this)), this.registerFeature(new reference_1.ReferencesFeature(this)), this.registerFeature(new documentHighlight_1.DocumentHighlightFeature(this)), this.registerFeature(new documentSymbol_1.DocumentSymbolFeature(this)), this.registerFeature(new workspaceSymbol_1.WorkspaceSymbolFeature(this)), this.registerFeature(new codeAction_1.CodeActionFeature(this)), this.registerFeature(new codeLens_1.CodeLensFeature(this)), this.registerFeature(new formatting_1.DocumentFormattingFeature(this)), this.registerFeature(new formatting_1.DocumentRangeFormattingFeature(this)), this.registerFeature(new formatting_1.DocumentOnTypeFormattingFeature(this)), this.registerFeature(new rename_1.RenameFeature(this)), this.registerFeature(new documentLink_1.DocumentLinkFeature(this)), this.registerFeature(new executeCommand_1.ExecuteCommandFeature(this)), this.registerFeature(new configuration_1.SyncConfigurationFeature(this)), this.registerFeature(new typeDefinition_1.TypeDefinitionFeature(this)), this.registerFeature(new implementation_1.ImplementationFeature(this)), this.registerFeature(new colorProvider_1.ColorProviderFeature(this)), this.clientOptions.workspaceFolder === void 0 && this.registerFeature(new workspaceFolder_1.WorkspaceFoldersFeature(this)), this.registerFeature(new foldingRange_1.FoldingRangeFeature(this)), this.registerFeature(new declaration_1.DeclarationFeature(this)), this.registerFeature(new selectionRange_1.SelectionRangeFeature(this)), this.registerFeature(new progress_1.ProgressFeature(this)), this.registerFeature(new callHierarchy_1.CallHierarchyFeature(this)), this.registerFeature(new semanticTokens_1.SemanticTokensFeature(this)), this.registerFeature(new linkedEditingRange_1.LinkedEditingFeature(this)), this.registerFeature(new fileOperations_1.DidCreateFilesFeature(this)), this.registerFeature(new fileOperations_1.DidRenameFilesFeature(this)), this.registerFeature(new fileOperations_1.DidDeleteFilesFeature(this)), this.registerFeature(new fileOperations_1.WillCreateFilesFeature(this)), this.registerFeature(new fileOperations_1.WillRenameFilesFeature(this)), this.registerFeature(new fileOperations_1.WillDeleteFilesFeature(this)), this.registerFeature(new typeHierarchy_1.TypeHierarchyFeature(this)), this.registerFeature(new inlineValue_1.InlineValueFeature(this)), this.registerFeature(new inlayHint_1.InlayHintsFeature(this)), this.registerFeature(new diagnostic_1.DiagnosticFeature(this)), this.registerFeature(new notebook_1.NotebookDocumentSyncFeature(this));
    }
    registerProposedFeatures() {
      this.registerFeatures(ProposedFeatures.createAll(this));
    }
    fillInitializeParams(params) {
      for (let feature of this._features) Is.func(feature.fillInitializeParams) && feature.fillInitializeParams(params);
    }
    computeClientCapabilities() {
      let result = {};
      (0, features_1.ensure)(result, "workspace").applyEdit = !0;
      let workspaceEdit = (0, features_1.ensure)((0, features_1.ensure)(result, "workspace"), "workspaceEdit");
      workspaceEdit.documentChanges = !0, workspaceEdit.resourceOperations = [vscode_languageserver_protocol_1.ResourceOperationKind.Create, vscode_languageserver_protocol_1.ResourceOperationKind.Rename, vscode_languageserver_protocol_1.ResourceOperationKind.Delete], workspaceEdit.failureHandling = vscode_languageserver_protocol_1.FailureHandlingKind.TextOnlyTransactional, workspaceEdit.normalizesLineEndings = !0, workspaceEdit.changeAnnotationSupport = {
        groupsOnLabel: !0
      };
      let diagnostics = (0, features_1.ensure)((0, features_1.ensure)(result, "textDocument"), "publishDiagnostics");
      diagnostics.relatedInformation = !0, diagnostics.versionSupport = !1, diagnostics.tagSupport = {
        valueSet: [vscode_languageserver_protocol_1.DiagnosticTag.Unnecessary, vscode_languageserver_protocol_1.DiagnosticTag.Deprecated]
      }, diagnostics.codeDescriptionSupport = !0, diagnostics.dataSupport = !0;
      let windowCapabilities = (0, features_1.ensure)(result, "window"),
        showMessage = (0, features_1.ensure)(windowCapabilities, "showMessage");
      showMessage.messageActionItem = {
        additionalPropertiesSupport: !0
      };
      let showDocument = (0, features_1.ensure)(windowCapabilities, "showDocument");
      showDocument.support = !0;
      let generalCapabilities = (0, features_1.ensure)(result, "general");
      generalCapabilities.staleRequestSupport = {
        cancel: !0,
        retryOnContentModified: Array.from(_BaseLanguageClient.RequestsToCancelOnContentModified)
      }, generalCapabilities.regularExpressions = {
        engine: "ECMAScript",
        version: "ES2020"
      }, generalCapabilities.markdown = {
        parser: "marked",
        version: "1.1.0"
      }, generalCapabilities.positionEncodings = ["utf-16"], this._clientOptions.markdown.supportHtml && (generalCapabilities.markdown.allowedTags = ["ul", "li", "p", "code", "blockquote", "ol", "h1", "h2", "h3", "h4", "h5", "h6", "hr", "em", "pre", "table", "thead", "tbody", "tr", "th", "td", "div", "del", "a", "strong", "br", "img", "span"]);
      for (let feature of this._features) feature.fillClientCapabilities(result);
      return result;
    }
    initializeFeatures(_connection) {
      let documentSelector = this._clientOptions.documentSelector;
      for (let feature of this._features) Is.func(feature.preInitialize) && feature.preInitialize(this._capabilities, documentSelector);
      for (let feature of this._features) feature.initialize(this._capabilities, documentSelector);
    }
    async handleRegistrationRequest(params) {
      var _a;
      let middleware = (_a = this.clientOptions.middleware) == null ? void 0 : _a.handleRegisterCapability;
      return middleware ? middleware(params, nextParams => this.doRegisterCapability(nextParams)) : this.doRegisterCapability(params);
    }
    async doRegisterCapability(params) {
      var _a, _b;
      if (!this.isRunning()) {
        for (let registration of params.registrations) this._ignoredRegistrations.add(registration.id);
        return;
      }
      for (let registration of params.registrations) {
        let feature = this._dynamicFeatures.get(registration.method);
        if (feature === void 0) return Promise.reject(new Error(`No feature implementation for ${registration.method} found. Registration failed.`));
        let options = (_a = registration.registerOptions) != null ? _a : {};
        options.documentSelector = (_b = options.documentSelector) != null ? _b : this._clientOptions.documentSelector;
        let data = {
          id: registration.id,
          registerOptions: options
        };
        try {
          feature.register(data);
        } catch (err) {
          return Promise.reject(err);
        }
      }
    }
    async handleUnregistrationRequest(params) {
      var _a;
      let middleware = (_a = this.clientOptions.middleware) == null ? void 0 : _a.handleUnregisterCapability;
      return middleware ? middleware(params, nextParams => this.doUnregisterCapability(nextParams)) : this.doUnregisterCapability(params);
    }
    async doUnregisterCapability(params) {
      for (let unregistration of params.unregisterations) {
        if (this._ignoredRegistrations.has(unregistration.id)) continue;
        let feature = this._dynamicFeatures.get(unregistration.method);
        if (!feature) return Promise.reject(new Error(`No feature implementation for ${unregistration.method} found. Unregistration failed.`));
        feature.unregister(unregistration.id);
      }
    }
    async handleApplyWorkspaceEdit(params) {
      let workspaceEdit = params.edit,
        converted = await this.workspaceEditLock.lock(() => this._p2c.asWorkspaceEdit(workspaceEdit)),
        openTextDocuments = new Map();
      vscode_1.workspace.textDocuments.forEach(document => openTextDocuments.set(document.uri.toString(), document));
      let versionMismatch = !1;
      if (workspaceEdit.documentChanges) {
        for (let change of workspaceEdit.documentChanges) if (vscode_languageserver_protocol_1.TextDocumentEdit.is(change) && change.textDocument.version && change.textDocument.version >= 0) {
          let changeUri = this._p2c.asUri(change.textDocument.uri).toString(),
            textDocument = openTextDocuments.get(changeUri);
          if (textDocument && textDocument.version !== change.textDocument.version) {
            versionMismatch = !0;
            break;
          }
        }
      }
      return versionMismatch ? Promise.resolve({
        applied: !1
      }) : Is.asPromise(vscode_1.workspace.applyEdit(converted).then(value => ({
        applied: value
      })));
    }
    handleFailedRequest(type, token, error, defaultValue, showNotification = !0) {
      if (error instanceof vscode_languageserver_protocol_1.ResponseError) {
        if (error.code === vscode_languageserver_protocol_1.ErrorCodes.PendingResponseRejected || error.code === vscode_languageserver_protocol_1.ErrorCodes.ConnectionInactive) return defaultValue;
        if (error.code === vscode_languageserver_protocol_1.LSPErrorCodes.RequestCancelled || error.code === vscode_languageserver_protocol_1.LSPErrorCodes.ServerCancelled) {
          if (token !== void 0 && token.isCancellationRequested) return defaultValue;
          throw error.data !== void 0 ? new features_1.LSPCancellationError(error.data) : new vscode_1.CancellationError();
        } else if (error.code === vscode_languageserver_protocol_1.LSPErrorCodes.ContentModified) {
          if (_BaseLanguageClient.RequestsToCancelOnContentModified.has(type.method) || _BaseLanguageClient.CancellableResolveCalls.has(type.method)) throw new vscode_1.CancellationError();
          return defaultValue;
        }
      }
      throw this.error(`Request ${type.method} failed.`, error, showNotification), error;
    }
  };
  __name(_BaseLanguageClient, "BaseLanguageClient");
  var BaseLanguageClient = _BaseLanguageClient;
  exports.BaseLanguageClient = BaseLanguageClient;
  BaseLanguageClient.RequestsToCancelOnContentModified = new Set([vscode_languageserver_protocol_1.SemanticTokensRequest.method, vscode_languageserver_protocol_1.SemanticTokensRangeRequest.method, vscode_languageserver_protocol_1.SemanticTokensDeltaRequest.method]);
  BaseLanguageClient.CancellableResolveCalls = new Set([vscode_languageserver_protocol_1.CompletionResolveRequest.method, vscode_languageserver_protocol_1.CodeLensResolveRequest.method, vscode_languageserver_protocol_1.CodeActionResolveRequest.method, vscode_languageserver_protocol_1.InlayHintResolveRequest.method, vscode_languageserver_protocol_1.DocumentLinkResolveRequest.method, vscode_languageserver_protocol_1.WorkspaceSymbolResolveRequest.method]);
  var _ConsoleLogger = class _ConsoleLogger {
    error(message) {
      (0, vscode_languageserver_protocol_1.RAL)().console.error(message);
    }
    warn(message) {
      (0, vscode_languageserver_protocol_1.RAL)().console.warn(message);
    }
    info(message) {
      (0, vscode_languageserver_protocol_1.RAL)().console.info(message);
    }
    log(message) {
      (0, vscode_languageserver_protocol_1.RAL)().console.log(message);
    }
  };
  __name(_ConsoleLogger, "ConsoleLogger");
  var ConsoleLogger = _ConsoleLogger;
  function createConnection(input, output, errorHandler, closeHandler, options) {
    let logger = new ConsoleLogger(),
      connection = (0, vscode_languageserver_protocol_1.createProtocolConnection)(input, output, logger, options);
    return connection.onError(data => {
      errorHandler(data[0], data[1], data[2]);
    }), connection.onClose(closeHandler), {
      listen: __name(() => connection.listen(), "listen"),
      sendRequest: connection.sendRequest,
      onRequest: connection.onRequest,
      hasPendingResponse: connection.hasPendingResponse,
      sendNotification: connection.sendNotification,
      onNotification: connection.onNotification,
      onProgress: connection.onProgress,
      sendProgress: connection.sendProgress,
      trace: __name((value, tracer, sendNotificationOrTraceOptions) => {
        let defaultTraceOptions = {
          sendNotification: !1,
          traceFormat: vscode_languageserver_protocol_1.TraceFormat.Text
        };
        return sendNotificationOrTraceOptions === void 0 ? connection.trace(value, tracer, defaultTraceOptions) : (Is.boolean(sendNotificationOrTraceOptions), connection.trace(value, tracer, sendNotificationOrTraceOptions));
      }, "trace"),
      initialize: __name(params => connection.sendRequest(vscode_languageserver_protocol_1.InitializeRequest.type, params), "initialize"),
      shutdown: __name(() => connection.sendRequest(vscode_languageserver_protocol_1.ShutdownRequest.type, void 0), "shutdown"),
      exit: __name(() => connection.sendNotification(vscode_languageserver_protocol_1.ExitNotification.type), "exit"),
      end: __name(() => connection.end(), "end"),
      dispose: __name(() => connection.dispose(), "dispose")
    };
  }
  __name(createConnection, "createConnection");
  var ProposedFeatures;
  (function (ProposedFeatures) {
    function createAll(_client) {
      return [new inlineCompletion_1.InlineCompletionItemFeature(_client)];
    }
    __name(createAll, "createAll"), ProposedFeatures.createAll = createAll;
  })(ProposedFeatures || (exports.ProposedFeatures = ProposedFeatures = {}));
});