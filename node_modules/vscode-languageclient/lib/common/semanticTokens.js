var require_semanticTokens = __commonJSMin(exports => {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: !0
  });
  exports.SemanticTokensFeature = void 0;
  var vscode = require("vscode"),
    vscode_languageserver_protocol_1 = Un(),
    features_1 = Oi(),
    Is = yp(),
    _SemanticTokensFeature = class _SemanticTokensFeature extends features_1.TextDocumentLanguageFeature {
      constructor(client) {
        super(client, vscode_languageserver_protocol_1.SemanticTokensRegistrationType.type);
      }
      fillClientCapabilities(capabilities) {
        let capability = (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "semanticTokens");
        capability.dynamicRegistration = !0, capability.tokenTypes = [vscode_languageserver_protocol_1.SemanticTokenTypes.namespace, vscode_languageserver_protocol_1.SemanticTokenTypes.type, vscode_languageserver_protocol_1.SemanticTokenTypes.class, vscode_languageserver_protocol_1.SemanticTokenTypes.enum, vscode_languageserver_protocol_1.SemanticTokenTypes.interface, vscode_languageserver_protocol_1.SemanticTokenTypes.struct, vscode_languageserver_protocol_1.SemanticTokenTypes.typeParameter, vscode_languageserver_protocol_1.SemanticTokenTypes.parameter, vscode_languageserver_protocol_1.SemanticTokenTypes.variable, vscode_languageserver_protocol_1.SemanticTokenTypes.property, vscode_languageserver_protocol_1.SemanticTokenTypes.enumMember, vscode_languageserver_protocol_1.SemanticTokenTypes.event, vscode_languageserver_protocol_1.SemanticTokenTypes.function, vscode_languageserver_protocol_1.SemanticTokenTypes.method, vscode_languageserver_protocol_1.SemanticTokenTypes.macro, vscode_languageserver_protocol_1.SemanticTokenTypes.keyword, vscode_languageserver_protocol_1.SemanticTokenTypes.modifier, vscode_languageserver_protocol_1.SemanticTokenTypes.comment, vscode_languageserver_protocol_1.SemanticTokenTypes.string, vscode_languageserver_protocol_1.SemanticTokenTypes.number, vscode_languageserver_protocol_1.SemanticTokenTypes.regexp, vscode_languageserver_protocol_1.SemanticTokenTypes.operator, vscode_languageserver_protocol_1.SemanticTokenTypes.decorator], capability.tokenModifiers = [vscode_languageserver_protocol_1.SemanticTokenModifiers.declaration, vscode_languageserver_protocol_1.SemanticTokenModifiers.definition, vscode_languageserver_protocol_1.SemanticTokenModifiers.readonly, vscode_languageserver_protocol_1.SemanticTokenModifiers.static, vscode_languageserver_protocol_1.SemanticTokenModifiers.deprecated, vscode_languageserver_protocol_1.SemanticTokenModifiers.abstract, vscode_languageserver_protocol_1.SemanticTokenModifiers.async, vscode_languageserver_protocol_1.SemanticTokenModifiers.modification, vscode_languageserver_protocol_1.SemanticTokenModifiers.documentation, vscode_languageserver_protocol_1.SemanticTokenModifiers.defaultLibrary], capability.formats = [vscode_languageserver_protocol_1.TokenFormat.Relative], capability.requests = {
          range: !0,
          full: {
            delta: !0
          }
        }, capability.multilineTokenSupport = !1, capability.overlappingTokenSupport = !1, capability.serverCancelSupport = !0, capability.augmentsSyntaxTokens = !0, (0, features_1.ensure)((0, features_1.ensure)(capabilities, "workspace"), "semanticTokens").refreshSupport = !0;
      }
      initialize(capabilities, documentSelector) {
        this._client.onRequest(vscode_languageserver_protocol_1.SemanticTokensRefreshRequest.type, async () => {
          for (let provider of this.getAllProviders()) provider.onDidChangeSemanticTokensEmitter.fire();
        });
        let [id, options] = this.getRegistration(documentSelector, capabilities.semanticTokensProvider);
        !id || !options || this.register({
          id: id,
          registerOptions: options
        });
      }
      registerLanguageProvider(options) {
        let selector = options.documentSelector,
          fullProvider = Is.boolean(options.full) ? options.full : options.full !== void 0,
          hasEditProvider = options.full !== void 0 && typeof options.full != "boolean" && options.full.delta === !0,
          eventEmitter = new vscode.EventEmitter(),
          documentProvider = fullProvider ? {
            onDidChangeSemanticTokens: eventEmitter.event,
            provideDocumentSemanticTokens: __name((document, token) => {
              let client = this._client,
                middleware = client.middleware,
                provideDocumentSemanticTokens = __name((document, token) => {
                  let params = {
                    textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document)
                  };
                  return client.sendRequest(vscode_languageserver_protocol_1.SemanticTokensRequest.type, params, token).then(result => token.isCancellationRequested ? null : client.protocol2CodeConverter.asSemanticTokens(result, token), error => client.handleFailedRequest(vscode_languageserver_protocol_1.SemanticTokensRequest.type, token, error, null));
                }, "provideDocumentSemanticTokens");
              return middleware.provideDocumentSemanticTokens ? middleware.provideDocumentSemanticTokens(document, token, provideDocumentSemanticTokens) : provideDocumentSemanticTokens(document, token);
            }, "provideDocumentSemanticTokens"),
            provideDocumentSemanticTokensEdits: hasEditProvider ? (document, previousResultId, token) => {
              let client = this._client,
                middleware = client.middleware,
                provideDocumentSemanticTokensEdits = __name((document, previousResultId, token) => {
                  let params = {
                    textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document),
                    previousResultId: previousResultId
                  };
                  return client.sendRequest(vscode_languageserver_protocol_1.SemanticTokensDeltaRequest.type, params, token).then(async result => token.isCancellationRequested ? null : vscode_languageserver_protocol_1.SemanticTokens.is(result) ? await client.protocol2CodeConverter.asSemanticTokens(result, token) : await client.protocol2CodeConverter.asSemanticTokensEdits(result, token), error => client.handleFailedRequest(vscode_languageserver_protocol_1.SemanticTokensDeltaRequest.type, token, error, null));
                }, "provideDocumentSemanticTokensEdits");
              return middleware.provideDocumentSemanticTokensEdits ? middleware.provideDocumentSemanticTokensEdits(document, previousResultId, token, provideDocumentSemanticTokensEdits) : provideDocumentSemanticTokensEdits(document, previousResultId, token);
            } : void 0
          } : void 0,
          rangeProvider = options.range === !0 ? {
            provideDocumentRangeSemanticTokens: __name((document, range, token) => {
              let client = this._client,
                middleware = client.middleware,
                provideDocumentRangeSemanticTokens = __name((document, range, token) => {
                  let params = {
                    textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document),
                    range: client.code2ProtocolConverter.asRange(range)
                  };
                  return client.sendRequest(vscode_languageserver_protocol_1.SemanticTokensRangeRequest.type, params, token).then(result => token.isCancellationRequested ? null : client.protocol2CodeConverter.asSemanticTokens(result, token), error => client.handleFailedRequest(vscode_languageserver_protocol_1.SemanticTokensRangeRequest.type, token, error, null));
                }, "provideDocumentRangeSemanticTokens");
              return middleware.provideDocumentRangeSemanticTokens ? middleware.provideDocumentRangeSemanticTokens(document, range, token, provideDocumentRangeSemanticTokens) : provideDocumentRangeSemanticTokens(document, range, token);
            }, "provideDocumentRangeSemanticTokens")
          } : void 0,
          disposables = [],
          client = this._client,
          legend = client.protocol2CodeConverter.asSemanticTokensLegend(options.legend),
          documentSelector = client.protocol2CodeConverter.asDocumentSelector(selector);
        return documentProvider !== void 0 && disposables.push(vscode.languages.registerDocumentSemanticTokensProvider(documentSelector, documentProvider, legend)), rangeProvider !== void 0 && disposables.push(vscode.languages.registerDocumentRangeSemanticTokensProvider(documentSelector, rangeProvider, legend)), [new vscode.Disposable(() => disposables.forEach(item => item.dispose())), {
          range: rangeProvider,
          full: documentProvider,
          onDidChangeSemanticTokensEmitter: eventEmitter
        }];
      }
    };
  __name(_SemanticTokensFeature, "SemanticTokensFeature");
  var SemanticTokensFeature = _SemanticTokensFeature;
  exports.SemanticTokensFeature = SemanticTokensFeature;
});