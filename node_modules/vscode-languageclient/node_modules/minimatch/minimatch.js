var require_minimatch = __commonJSMin((exports, module) => {
  var minimatch = module.exports = (p, pattern, options = {}) => (assertValidPattern(pattern), !options.nocomment && pattern.charAt(0) === "#" ? !1 : new Minimatch(pattern, options).match(p));
  module.exports = minimatch;
  var path = pUe();
  minimatch.sep = path.sep;
  var GLOBSTAR = Symbol("globstar **");
  minimatch.GLOBSTAR = GLOBSTAR;
  var expand = Rte(),
    plTypes = {
      "!": {
        open: "(?:(?!(?:",
        close: "))[^/]*?)"
      },
      "?": {
        open: "(?:",
        close: ")?"
      },
      "+": {
        open: "(?:",
        close: ")+"
      },
      "*": {
        open: "(?:",
        close: ")*"
      },
      "@": {
        open: "(?:",
        close: ")"
      }
    },
    qmark = "[^/]",
    star = qmark + "*?",
    twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?",
    twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?",
    charSet = __name(s => s.split("").reduce((set, c) => (set[c] = !0, set), {}), "charSet"),
    reSpecials = charSet("().*{}+?[]^$\\!"),
    addPatternStartSet = charSet("[.("),
    slashSplit = /\/+/;
  minimatch.filter = (pattern, options = {}) => (p, i, list) => minimatch(p, pattern, options);
  var ext = __name((a, b = {}) => {
    let t = {};
    return Object.keys(a).forEach(k => t[k] = a[k]), Object.keys(b).forEach(k => t[k] = b[k]), t;
  }, "ext");
  minimatch.defaults = def => {
    var _a;
    if (!def || typeof def != "object" || !Object.keys(def).length) return minimatch;
    let orig = minimatch,
      m = __name((p, pattern, options) => orig(p, pattern, ext(def, options)), "m");
    return m.Minimatch = (_a = class extends orig.Minimatch {
      constructor(pattern, options) {
        super(pattern, ext(def, options));
      }
    }, __name(_a, "Minimatch"), _a), m.Minimatch.defaults = options => orig.defaults(ext(def, options)).Minimatch, m.filter = (pattern, options) => orig.filter(pattern, ext(def, options)), m.defaults = options => orig.defaults(ext(def, options)), m.makeRe = (pattern, options) => orig.makeRe(pattern, ext(def, options)), m.braceExpand = (pattern, options) => orig.braceExpand(pattern, ext(def, options)), m.match = (list, pattern, options) => orig.match(list, pattern, ext(def, options)), m;
  };
  minimatch.braceExpand = (pattern, options) => braceExpand(pattern, options);
  var braceExpand = __name((pattern, options = {}) => (assertValidPattern(pattern), options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern) ? [pattern] : expand(pattern)), "braceExpand"),
    MAX_PATTERN_LENGTH = 1024 * 64,
    assertValidPattern = __name(pattern => {
      if (typeof pattern != "string") throw new TypeError("invalid pattern");
      if (pattern.length > MAX_PATTERN_LENGTH) throw new TypeError("pattern is too long");
    }, "assertValidPattern"),
    SUBPARSE = Symbol("subparse");
  minimatch.makeRe = (pattern, options) => new Minimatch(pattern, options || {}).makeRe();
  minimatch.match = (list, pattern, options = {}) => {
    let mm = new Minimatch(pattern, options);
    return list = list.filter(f => mm.match(f)), mm.options.nonull && !list.length && list.push(pattern), list;
  };
  var globUnescape = __name(s => s.replace(/\\(.)/g, "$1"), "globUnescape"),
    charUnescape = __name(s => s.replace(/\\([^-\]])/g, "$1"), "charUnescape"),
    regExpEscape = __name(s => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&"), "regExpEscape"),
    braExpEscape = __name(s => s.replace(/[[\]\\]/g, "\\$&"), "braExpEscape"),
    _Minimatch = class _Minimatch {
      constructor(pattern, options) {
        assertValidPattern(pattern), options || (options = {}), this.options = options, this.set = [], this.pattern = pattern, this.windowsPathsNoEscape = !!options.windowsPathsNoEscape || options.allowWindowsEscape === !1, this.windowsPathsNoEscape && (this.pattern = this.pattern.replace(/\\/g, "/")), this.regexp = null, this.negate = !1, this.comment = !1, this.empty = !1, this.partial = !!options.partial, this.make();
      }
      debug() {}
      make() {
        let pattern = this.pattern,
          options = this.options;
        if (!options.nocomment && pattern.charAt(0) === "#") {
          this.comment = !0;
          return;
        }
        if (!pattern) {
          this.empty = !0;
          return;
        }
        this.parseNegate();
        let set = this.globSet = this.braceExpand();
        options.debug && (this.debug = (...args) => console.error(...args)), this.debug(this.pattern, set), set = this.globParts = set.map(s => s.split(slashSplit)), this.debug(this.pattern, set), set = set.map((s, si, set) => s.map(this.parse, this)), this.debug(this.pattern, set), set = set.filter(s => s.indexOf(!1) === -1), this.debug(this.pattern, set), this.set = set;
      }
      parseNegate() {
        if (this.options.nonegate) return;
        let pattern = this.pattern,
          negate = !1,
          negateOffset = 0;
        for (let i = 0; i < pattern.length && pattern.charAt(i) === "!"; i++) negate = !negate, negateOffset++;
        negateOffset && (this.pattern = pattern.slice(negateOffset)), this.negate = negate;
      }
      matchOne(file, pattern, partial) {
        var options = this.options;
        this.debug("matchOne", {
          this: this,
          file: file,
          pattern: pattern
        }), this.debug("matchOne", file.length, pattern.length);
        for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
          this.debug("matchOne loop");
          var p = pattern[pi],
            f = file[fi];
          if (this.debug(pattern, p, f), p === !1) return !1;
          if (p === GLOBSTAR) {
            this.debug("GLOBSTAR", [pattern, p, f]);
            var fr = fi,
              pr = pi + 1;
            if (pr === pl) {
              for (this.debug("** at the end"); fi < fl; fi++) if (file[fi] === "." || file[fi] === ".." || !options.dot && file[fi].charAt(0) === ".") return !1;
              return !0;
            }
            for (; fr < fl;) {
              var swallowee = file[fr];
              if (this.debug(`
globstar while`, file, fr, pattern, pr, swallowee), this.matchOne(file.slice(fr), pattern.slice(pr), partial)) return this.debug("globstar found match!", fr, fl, swallowee), !0;
              if (swallowee === "." || swallowee === ".." || !options.dot && swallowee.charAt(0) === ".") {
                this.debug("dot detected!", file, fr, pattern, pr);
                break;
              }
              this.debug("globstar swallow a segment, and continue"), fr++;
            }
            return !!(partial && (this.debug(`
>>> no match, partial?`, file, fr, pattern, pr), fr === fl));
          }
          var hit;
          if (typeof p == "string" ? (hit = f === p, this.debug("string match", p, f, hit)) : (hit = f.match(p), this.debug("pattern match", p, f, hit)), !hit) return !1;
        }
        if (fi === fl && pi === pl) return !0;
        if (fi === fl) return partial;
        if (pi === pl) return fi === fl - 1 && file[fi] === "";
        throw new Error("wtf?");
      }
      braceExpand() {
        return braceExpand(this.pattern, this.options);
      }
      parse(pattern, isSub) {
        assertValidPattern(pattern);
        let options = this.options;
        if (pattern === "**") if (options.noglobstar) pattern = "*";else return GLOBSTAR;
        if (pattern === "") return "";
        let re = "",
          hasMagic = !1,
          escaping = !1,
          patternListStack = [],
          negativeLists = [],
          stateChar,
          inClass = !1,
          reClassStart = -1,
          classStart = -1,
          cs,
          pl,
          sp,
          dotTravAllowed = pattern.charAt(0) === ".",
          dotFileAllowed = options.dot || dotTravAllowed,
          patternStart = __name(() => dotTravAllowed ? "" : dotFileAllowed ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)", "patternStart"),
          subPatternStart = __name(p => p.charAt(0) === "." ? "" : options.dot ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)", "subPatternStart"),
          clearStateChar = __name(() => {
            if (stateChar) {
              switch (stateChar) {
                case "*":
                  re += star, hasMagic = !0;
                  break;
                case "?":
                  re += qmark, hasMagic = !0;
                  break;
                default:
                  re += "\\" + stateChar;
                  break;
              }
              this.debug("clearStateChar %j %j", stateChar, re), stateChar = !1;
            }
          }, "clearStateChar");
        for (let i = 0, c; i < pattern.length && (c = pattern.charAt(i)); i++) {
          if (this.debug("%s	%s %s %j", pattern, i, re, c), escaping) {
            if (c === "/") return !1;
            reSpecials[c] && (re += "\\"), re += c, escaping = !1;
            continue;
          }
          switch (c) {
            case "/":
              return !1;
            case "\\":
              if (inClass && pattern.charAt(i + 1) === "-") {
                re += c;
                continue;
              }
              clearStateChar(), escaping = !0;
              continue;
            case "?":
            case "*":
            case "+":
            case "@":
            case "!":
              if (this.debug("%s	%s %s %j <-- stateChar", pattern, i, re, c), inClass) {
                this.debug("  in class"), c === "!" && i === classStart + 1 && (c = "^"), re += c;
                continue;
              }
              this.debug("call clearStateChar %j", stateChar), clearStateChar(), stateChar = c, options.noext && clearStateChar();
              continue;
            case "(":
              {
                if (inClass) {
                  re += "(";
                  continue;
                }
                if (!stateChar) {
                  re += "\\(";
                  continue;
                }
                let plEntry = {
                  type: stateChar,
                  start: i - 1,
                  reStart: re.length,
                  open: plTypes[stateChar].open,
                  close: plTypes[stateChar].close
                };
                this.debug(this.pattern, "	", plEntry), patternListStack.push(plEntry), re += plEntry.open, plEntry.start === 0 && plEntry.type !== "!" && (dotTravAllowed = !0, re += subPatternStart(pattern.slice(i + 1))), this.debug("plType %j %j", stateChar, re), stateChar = !1;
                continue;
              }
            case ")":
              {
                let plEntry = patternListStack[patternListStack.length - 1];
                if (inClass || !plEntry) {
                  re += "\\)";
                  continue;
                }
                patternListStack.pop(), clearStateChar(), hasMagic = !0, pl = plEntry, re += pl.close, pl.type === "!" && negativeLists.push(Object.assign(pl, {
                  reEnd: re.length
                }));
                continue;
              }
            case "|":
              {
                let plEntry = patternListStack[patternListStack.length - 1];
                if (inClass || !plEntry) {
                  re += "\\|";
                  continue;
                }
                clearStateChar(), re += "|", plEntry.start === 0 && plEntry.type !== "!" && (dotTravAllowed = !0, re += subPatternStart(pattern.slice(i + 1)));
                continue;
              }
            case "[":
              if (clearStateChar(), inClass) {
                re += "\\" + c;
                continue;
              }
              inClass = !0, classStart = i, reClassStart = re.length, re += c;
              continue;
            case "]":
              if (i === classStart + 1 || !inClass) {
                re += "\\" + c;
                continue;
              }
              cs = pattern.substring(classStart + 1, i);
              try {
                RegExp("[" + braExpEscape(charUnescape(cs)) + "]"), re += c;
              } catch {
                re = re.substring(0, reClassStart) + "(?:$.)";
              }
              hasMagic = !0, inClass = !1;
              continue;
            default:
              clearStateChar(), reSpecials[c] && !(c === "^" && inClass) && (re += "\\"), re += c;
              break;
          }
        }
        for (inClass && (cs = pattern.slice(classStart + 1), sp = this.parse(cs, SUBPARSE), re = re.substring(0, reClassStart) + "\\[" + sp[0], hasMagic = hasMagic || sp[1]), pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
          let tail;
          tail = re.slice(pl.reStart + pl.open.length), this.debug("setting tail", re, pl), tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, (_, $1, $2) => ($2 || ($2 = "\\"), $1 + $1 + $2 + "|")), this.debug(`tail=%j
   %s`, tail, tail, pl, re);
          let t = pl.type === "*" ? star : pl.type === "?" ? qmark : "\\" + pl.type;
          hasMagic = !0, re = re.slice(0, pl.reStart) + t + "\\(" + tail;
        }
        clearStateChar(), escaping && (re += "\\\\");
        let addPatternStart = addPatternStartSet[re.charAt(0)];
        for (let n = negativeLists.length - 1; n > -1; n--) {
          let nl = negativeLists[n],
            nlBefore = re.slice(0, nl.reStart),
            nlFirst = re.slice(nl.reStart, nl.reEnd - 8),
            nlAfter = re.slice(nl.reEnd),
            nlLast = re.slice(nl.reEnd - 8, nl.reEnd) + nlAfter,
            closeParensBefore = nlBefore.split(")").length,
            openParensBefore = nlBefore.split("(").length - closeParensBefore,
            cleanAfter = nlAfter;
          for (let i = 0; i < openParensBefore; i++) cleanAfter = cleanAfter.replace(/\)[+*?]?/, "");
          nlAfter = cleanAfter;
          let dollar = nlAfter === "" && isSub !== SUBPARSE ? "(?:$|\\/)" : "";
          re = nlBefore + nlFirst + nlAfter + dollar + nlLast;
        }
        if (re !== "" && hasMagic && (re = "(?=.)" + re), addPatternStart && (re = patternStart() + re), isSub === SUBPARSE) return [re, hasMagic];
        if (options.nocase && !hasMagic && (hasMagic = pattern.toUpperCase() !== pattern.toLowerCase()), !hasMagic) return globUnescape(pattern);
        let flags = options.nocase ? "i" : "";
        try {
          return Object.assign(new RegExp("^" + re + "$", flags), {
            _glob: pattern,
            _src: re
          });
        } catch {
          return new RegExp("$.");
        }
      }
      makeRe() {
        if (this.regexp || this.regexp === !1) return this.regexp;
        let set = this.set;
        if (!set.length) return this.regexp = !1, this.regexp;
        let options = this.options,
          twoStar = options.noglobstar ? star : options.dot ? twoStarDot : twoStarNoDot,
          flags = options.nocase ? "i" : "",
          re = set.map(pattern => (pattern = pattern.map(p => typeof p == "string" ? regExpEscape(p) : p === GLOBSTAR ? GLOBSTAR : p._src).reduce((set, p) => (set[set.length - 1] === GLOBSTAR && p === GLOBSTAR || set.push(p), set), []), pattern.forEach((p, i) => {
            p !== GLOBSTAR || pattern[i - 1] === GLOBSTAR || (i === 0 ? pattern.length > 1 ? pattern[i + 1] = "(?:\\/|" + twoStar + "\\/)?" + pattern[i + 1] : pattern[i] = twoStar : i === pattern.length - 1 ? pattern[i - 1] += "(?:\\/|" + twoStar + ")?" : (pattern[i - 1] += "(?:\\/|\\/" + twoStar + "\\/)" + pattern[i + 1], pattern[i + 1] = GLOBSTAR));
          }), pattern.filter(p => p !== GLOBSTAR).join("/"))).join("|");
        re = "^(?:" + re + ")$", this.negate && (re = "^(?!" + re + ").*$");
        try {
          this.regexp = new RegExp(re, flags);
        } catch {
          this.regexp = !1;
        }
        return this.regexp;
      }
      match(f, partial = this.partial) {
        if (this.debug("match", f, this.pattern), this.comment) return !1;
        if (this.empty) return f === "";
        if (f === "/" && partial) return !0;
        let options = this.options;
        path.sep !== "/" && (f = f.split(path.sep).join("/")), f = f.split(slashSplit), this.debug(this.pattern, "split", f);
        let set = this.set;
        this.debug(this.pattern, "set", set);
        let filename;
        for (let i = f.length - 1; i >= 0 && (filename = f[i], !filename); i--);
        for (let i = 0; i < set.length; i++) {
          let pattern = set[i],
            file = f;
          if (options.matchBase && pattern.length === 1 && (file = [filename]), this.matchOne(file, pattern, partial)) return options.flipNegate ? !0 : !this.negate;
        }
        return options.flipNegate ? !1 : this.negate;
      }
      static defaults(def) {
        return minimatch.defaults(def).Minimatch;
      }
    };
  __name(_Minimatch, "Minimatch");
  var Minimatch = _Minimatch;
  minimatch.Minimatch = Minimatch;
});