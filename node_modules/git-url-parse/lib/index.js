var require_lib = __commonJSMin((exports, module) => {
  "use strict";

  var gitUp = xve();
  function gitUrlParse(url, refs) {
    if (refs = refs || [], typeof url != "string") throw new Error("The url must be a string.");
    if (!refs.every(function (item) {
      return typeof item == "string";
    })) throw new Error("The refs should contain only strings");
    var shorthandRe = /^([a-z\d-]{1,39})\/([-\.\w]{1,100})$/i;
    shorthandRe.test(url) && (url = "https://github.com/" + url);
    var urlInfo = gitUp(url),
      sourceParts = urlInfo.resource.split("."),
      splits = null;
    switch (urlInfo.toString = function (type) {
      return gitUrlParse.stringify(this, type);
    }, urlInfo.source = sourceParts.length > 2 ? sourceParts.slice(1 - sourceParts.length).join(".") : urlInfo.source = urlInfo.resource, urlInfo.git_suffix = /\.git$/.test(urlInfo.pathname), urlInfo.name = decodeURIComponent((urlInfo.pathname || urlInfo.href).replace(/(^\/)|(\/$)/g, "").replace(/\.git$/, "")), urlInfo.owner = decodeURIComponent(urlInfo.user), urlInfo.source) {
      case "git.cloudforge.com":
        urlInfo.owner = urlInfo.user, urlInfo.organization = sourceParts[0], urlInfo.source = "cloudforge.com";
        break;
      case "visualstudio.com":
        if (urlInfo.resource === "vs-ssh.visualstudio.com") {
          splits = urlInfo.name.split("/"), splits.length === 4 && (urlInfo.organization = splits[1], urlInfo.owner = splits[2], urlInfo.name = splits[3], urlInfo.full_name = splits[2] + "/" + splits[3]);
          break;
        } else {
          splits = urlInfo.name.split("/"), splits.length === 2 ? (urlInfo.owner = splits[1], urlInfo.name = splits[1], urlInfo.full_name = "_git/" + urlInfo.name) : splits.length === 3 ? (urlInfo.name = splits[2], splits[0] === "DefaultCollection" ? (urlInfo.owner = splits[2], urlInfo.organization = splits[0], urlInfo.full_name = urlInfo.organization + "/_git/" + urlInfo.name) : (urlInfo.owner = splits[0], urlInfo.full_name = urlInfo.owner + "/_git/" + urlInfo.name)) : splits.length === 4 && (urlInfo.organization = splits[0], urlInfo.owner = splits[1], urlInfo.name = splits[3], urlInfo.full_name = urlInfo.organization + "/" + urlInfo.owner + "/_git/" + urlInfo.name);
          break;
        }
      case "dev.azure.com":
      case "azure.com":
        if (urlInfo.resource === "ssh.dev.azure.com") {
          splits = urlInfo.name.split("/"), splits.length === 4 && (urlInfo.organization = splits[1], urlInfo.owner = splits[2], urlInfo.name = splits[3]);
          break;
        } else {
          splits = urlInfo.name.split("/"), splits.length === 5 ? (urlInfo.organization = splits[0], urlInfo.owner = splits[1], urlInfo.name = splits[4], urlInfo.full_name = "_git/" + urlInfo.name) : splits.length === 3 ? (urlInfo.name = splits[2], splits[0] === "DefaultCollection" ? (urlInfo.owner = splits[2], urlInfo.organization = splits[0], urlInfo.full_name = urlInfo.organization + "/_git/" + urlInfo.name) : (urlInfo.owner = splits[0], urlInfo.full_name = urlInfo.owner + "/_git/" + urlInfo.name)) : splits.length === 4 && (urlInfo.organization = splits[0], urlInfo.owner = splits[1], urlInfo.name = splits[3], urlInfo.full_name = urlInfo.organization + "/" + urlInfo.owner + "/_git/" + urlInfo.name), urlInfo.query && urlInfo.query.path && (urlInfo.filepath = urlInfo.query.path.replace(/^\/+/g, "")), urlInfo.query && urlInfo.query.version && (urlInfo.ref = urlInfo.query.version.replace(/^GB/, ""));
          break;
        }
      default:
        splits = urlInfo.name.split("/");
        var nameIndex = splits.length - 1;
        if (splits.length >= 2) {
          var dashIndex = splits.indexOf("-", 2),
            blobIndex = splits.indexOf("blob", 2),
            treeIndex = splits.indexOf("tree", 2),
            commitIndex = splits.indexOf("commit", 2),
            issuesIndex = splits.indexOf("issues", 2),
            srcIndex = splits.indexOf("src", 2),
            rawIndex = splits.indexOf("raw", 2),
            editIndex = splits.indexOf("edit", 2);
          nameIndex = dashIndex > 0 ? dashIndex - 1 : blobIndex > 0 && treeIndex > 0 ? Math.min(blobIndex - 1, treeIndex - 1) : blobIndex > 0 ? blobIndex - 1 : issuesIndex > 0 ? issuesIndex - 1 : treeIndex > 0 ? treeIndex - 1 : commitIndex > 0 ? commitIndex - 1 : srcIndex > 0 ? srcIndex - 1 : rawIndex > 0 ? rawIndex - 1 : editIndex > 0 ? editIndex - 1 : nameIndex, urlInfo.owner = splits.slice(0, nameIndex).join("/"), urlInfo.name = splits[nameIndex], commitIndex && issuesIndex < 0 && (urlInfo.commit = splits[nameIndex + 2]);
        }
        urlInfo.ref = "", urlInfo.filepathtype = "", urlInfo.filepath = "";
        var offsetNameIndex = splits.length > nameIndex && splits[nameIndex + 1] === "-" ? nameIndex + 1 : nameIndex;
        splits.length > offsetNameIndex + 2 && ["raw", "src", "blob", "tree", "edit"].indexOf(splits[offsetNameIndex + 1]) >= 0 && (urlInfo.filepathtype = splits[offsetNameIndex + 1], urlInfo.ref = splits[offsetNameIndex + 2], splits.length > offsetNameIndex + 3 && (urlInfo.filepath = splits.slice(offsetNameIndex + 3).join("/"))), urlInfo.organization = urlInfo.owner;
        break;
    }
    urlInfo.full_name || (urlInfo.full_name = urlInfo.owner, urlInfo.name && (urlInfo.full_name && (urlInfo.full_name += "/"), urlInfo.full_name += urlInfo.name)), urlInfo.owner.startsWith("scm/") && (urlInfo.source = "bitbucket-server", urlInfo.owner = urlInfo.owner.replace("scm/", ""), urlInfo.organization = urlInfo.owner, urlInfo.full_name = urlInfo.owner + "/" + urlInfo.name);
    var bitbucket = /(projects|users)\/(.*?)\/repos\/(.*?)((\/.*$)|$)/,
      matches = bitbucket.exec(urlInfo.pathname);
    return matches != null && (urlInfo.source = "bitbucket-server", matches[1] === "users" ? urlInfo.owner = "~" + matches[2] : urlInfo.owner = matches[2], urlInfo.organization = urlInfo.owner, urlInfo.name = matches[3], splits = matches[4].split("/"), splits.length > 1 && (["raw", "browse"].indexOf(splits[1]) >= 0 ? (urlInfo.filepathtype = splits[1], splits.length > 2 && (urlInfo.filepath = splits.slice(2).join("/"))) : splits[1] === "commits" && splits.length > 2 && (urlInfo.commit = splits[2])), urlInfo.full_name = urlInfo.owner + "/" + urlInfo.name, urlInfo.query.at ? urlInfo.ref = urlInfo.query.at : urlInfo.ref = ""), refs.length !== 0 && urlInfo.ref && (urlInfo.ref = findLongestMatchingSubstring(urlInfo.href, refs) || urlInfo.ref, urlInfo.filepath = urlInfo.href.split(urlInfo.ref + "/")[1]), urlInfo;
  }
  __name(gitUrlParse, "gitUrlParse");
  gitUrlParse.stringify = function (obj, type) {
    type = type || (obj.protocols && obj.protocols.length ? obj.protocols.join("+") : obj.protocol);
    var port = obj.port ? ":" + obj.port : "",
      user = obj.user || "git",
      maybeGitSuffix = obj.git_suffix ? ".git" : "";
    switch (type) {
      case "ssh":
        return port ? "ssh://" + user + "@" + obj.resource + port + "/" + obj.full_name + maybeGitSuffix : user + "@" + obj.resource + ":" + obj.full_name + maybeGitSuffix;
      case "git+ssh":
      case "ssh+git":
      case "ftp":
      case "ftps":
        return type + "://" + user + "@" + obj.resource + port + "/" + obj.full_name + maybeGitSuffix;
      case "http":
      case "https":
        var auth = obj.token ? buildToken(obj) : obj.user && (obj.protocols.includes("http") || obj.protocols.includes("https")) ? obj.user + "@" : "";
        return type + "://" + auth + obj.resource + port + "/" + buildPath(obj) + maybeGitSuffix;
      default:
        return obj.href;
    }
  };
  function buildToken(obj) {
    switch (obj.source) {
      case "bitbucket.org":
        return "x-token-auth:" + obj.token + "@";
      default:
        return obj.token + "@";
    }
  }
  __name(buildToken, "buildToken");
  function buildPath(obj) {
    switch (obj.source) {
      case "bitbucket-server":
        return "scm/" + obj.full_name;
      default:
        var encoded_full_name = obj.full_name.split("/").map(function (x) {
          return encodeURIComponent(x);
        }).join("/");
        return encoded_full_name;
    }
  }
  __name(buildPath, "buildPath");
  function findLongestMatchingSubstring(string, array) {
    var longestMatch = "";
    return array.forEach(function (item) {
      string.includes(item) && item.length > longestMatch.length && (longestMatch = item);
    }), longestMatch;
  }
  __name(findLongestMatchingSubstring, "findLongestMatchingSubstring");
  module.exports = gitUrlParse;
});