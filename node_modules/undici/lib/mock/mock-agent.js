var require_mock_agent = __commonJSMin((exports, module) => {
  "use strict";

  var {
      kClients: kClients
    } = fo(),
    Agent = aI(),
    {
      kAgent: kAgent,
      kMockAgentSet: kMockAgentSet,
      kMockAgentGet: kMockAgentGet,
      kDispatches: kDispatches,
      kIsMockActive: kIsMockActive,
      kNetConnect: kNetConnect,
      kGetNetConnect: kGetNetConnect,
      kOptions: kOptions,
      kFactory: kFactory
    } = mI(),
    MockClient = Eoe(),
    MockPool = Qoe(),
    {
      matchValue: matchValue,
      buildMockOptions: buildMockOptions
    } = _9(),
    {
      InvalidArgumentError: InvalidArgumentError,
      UndiciError: UndiciError
    } = rr(),
    Dispatcher = q4(),
    Pluralizer = NRe(),
    PendingInterceptorsFormatter = LRe(),
    _MockAgent = class _MockAgent extends Dispatcher {
      constructor(opts) {
        if (super(opts), this[kNetConnect] = !0, this[kIsMockActive] = !0, opts != null && opts.agent && typeof opts.agent.dispatch != "function") throw new InvalidArgumentError("Argument opts.agent must implement Agent");
        let agent = opts != null && opts.agent ? opts.agent : new Agent(opts);
        this[kAgent] = agent, this[kClients] = agent[kClients], this[kOptions] = buildMockOptions(opts);
      }
      get(origin) {
        let dispatcher = this[kMockAgentGet](origin);
        return dispatcher || (dispatcher = this[kFactory](origin), this[kMockAgentSet](origin, dispatcher)), dispatcher;
      }
      dispatch(opts, handler) {
        return this.get(opts.origin), this[kAgent].dispatch(opts, handler);
      }
      async close() {
        await this[kAgent].close(), this[kClients].clear();
      }
      deactivate() {
        this[kIsMockActive] = !1;
      }
      activate() {
        this[kIsMockActive] = !0;
      }
      enableNetConnect(matcher) {
        if (typeof matcher == "string" || typeof matcher == "function" || matcher instanceof RegExp) Array.isArray(this[kNetConnect]) ? this[kNetConnect].push(matcher) : this[kNetConnect] = [matcher];else if (typeof matcher > "u") this[kNetConnect] = !0;else throw new InvalidArgumentError("Unsupported matcher. Must be one of String|Function|RegExp.");
      }
      disableNetConnect() {
        this[kNetConnect] = !1;
      }
      get isMockActive() {
        return this[kIsMockActive];
      }
      [kMockAgentSet](origin, dispatcher) {
        this[kClients].set(origin, dispatcher);
      }
      [kFactory](origin) {
        let mockOptions = Object.assign({
          agent: this
        }, this[kOptions]);
        return this[kOptions] && this[kOptions].connections === 1 ? new MockClient(origin, mockOptions) : new MockPool(origin, mockOptions);
      }
      [kMockAgentGet](origin) {
        let client = this[kClients].get(origin);
        if (client) return client;
        if (typeof origin != "string") {
          let dispatcher = this[kFactory]("http://localhost:9999");
          return this[kMockAgentSet](origin, dispatcher), dispatcher;
        }
        for (let [keyMatcher, nonExplicitDispatcher] of Array.from(this[kClients])) if (nonExplicitDispatcher && typeof keyMatcher != "string" && matchValue(keyMatcher, origin)) {
          let dispatcher = this[kFactory](origin);
          return this[kMockAgentSet](origin, dispatcher), dispatcher[kDispatches] = nonExplicitDispatcher[kDispatches], dispatcher;
        }
      }
      [kGetNetConnect]() {
        return this[kNetConnect];
      }
      pendingInterceptors() {
        let mockAgentClients = this[kClients];
        return Array.from(mockAgentClients.entries()).flatMap(([origin, scope]) => scope[kDispatches].map(dispatch => ({
          ...dispatch,
          origin: origin
        }))).filter(({
          pending: pending
        }) => pending);
      }
      assertNoPendingInterceptors({
        pendingInterceptorsFormatter = new PendingInterceptorsFormatter()
      } = {}) {
        let pending = this.pendingInterceptors();
        if (pending.length === 0) return;
        let pluralizer = new Pluralizer("interceptor", "interceptors").pluralize(pending.length);
        throw new UndiciError(`
${pluralizer.count} ${pluralizer.noun} ${pluralizer.is} pending:

${pendingInterceptorsFormatter.format(pending)}
`.trim());
      }
    };
  __name(_MockAgent, "MockAgent");
  var MockAgent = _MockAgent;
  module.exports = MockAgent;
});