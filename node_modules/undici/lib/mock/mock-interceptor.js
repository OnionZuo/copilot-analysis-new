var require_mock_interceptor = __commonJSMin((exports, module) => {
  "use strict";

  var {
      getResponseData: getResponseData,
      buildKey: buildKey,
      addMockDispatch: addMockDispatch
    } = _9(),
    {
      kDispatches: kDispatches,
      kDispatchKey: kDispatchKey,
      kDefaultHeaders: kDefaultHeaders,
      kDefaultTrailers: kDefaultTrailers,
      kContentLength: kContentLength,
      kMockDispatch: kMockDispatch
    } = mI(),
    {
      InvalidArgumentError: InvalidArgumentError
    } = rr(),
    {
      buildURL: buildURL
    } = oi(),
    _MockScope = class _MockScope {
      constructor(mockDispatch) {
        this[kMockDispatch] = mockDispatch;
      }
      delay(waitInMs) {
        if (typeof waitInMs != "number" || !Number.isInteger(waitInMs) || waitInMs <= 0) throw new InvalidArgumentError("waitInMs must be a valid integer > 0");
        return this[kMockDispatch].delay = waitInMs, this;
      }
      persist() {
        return this[kMockDispatch].persist = !0, this;
      }
      times(repeatTimes) {
        if (typeof repeatTimes != "number" || !Number.isInteger(repeatTimes) || repeatTimes <= 0) throw new InvalidArgumentError("repeatTimes must be a valid integer > 0");
        return this[kMockDispatch].times = repeatTimes, this;
      }
    };
  __name(_MockScope, "MockScope");
  var MockScope = _MockScope,
    _MockInterceptor = class _MockInterceptor {
      constructor(opts, mockDispatches) {
        if (typeof opts != "object") throw new InvalidArgumentError("opts must be an object");
        if (typeof opts.path > "u") throw new InvalidArgumentError("opts.path must be defined");
        if (typeof opts.method > "u" && (opts.method = "GET"), typeof opts.path == "string") if (opts.query) opts.path = buildURL(opts.path, opts.query);else {
          let parsedURL = new URL(opts.path, "data://");
          opts.path = parsedURL.pathname + parsedURL.search;
        }
        typeof opts.method == "string" && (opts.method = opts.method.toUpperCase()), this[kDispatchKey] = buildKey(opts), this[kDispatches] = mockDispatches, this[kDefaultHeaders] = {}, this[kDefaultTrailers] = {}, this[kContentLength] = !1;
      }
      createMockScopeDispatchData({
        statusCode: statusCode,
        data: data,
        responseOptions: responseOptions
      }) {
        let responseData = getResponseData(data),
          contentLength = this[kContentLength] ? {
            "content-length": responseData.length
          } : {},
          headers = {
            ...this[kDefaultHeaders],
            ...contentLength,
            ...responseOptions.headers
          },
          trailers = {
            ...this[kDefaultTrailers],
            ...responseOptions.trailers
          };
        return {
          statusCode: statusCode,
          data: data,
          headers: headers,
          trailers: trailers
        };
      }
      validateReplyParameters(replyParameters) {
        if (typeof replyParameters.statusCode > "u") throw new InvalidArgumentError("statusCode must be defined");
        if (typeof replyParameters.responseOptions != "object" || replyParameters.responseOptions === null) throw new InvalidArgumentError("responseOptions must be an object");
      }
      reply(replyOptionsCallbackOrStatusCode) {
        if (typeof replyOptionsCallbackOrStatusCode == "function") {
          let wrappedDefaultsCallback = __name(opts => {
              let resolvedData = replyOptionsCallbackOrStatusCode(opts);
              if (typeof resolvedData != "object" || resolvedData === null) throw new InvalidArgumentError("reply options callback must return an object");
              let replyParameters = {
                data: "",
                responseOptions: {},
                ...resolvedData
              };
              return this.validateReplyParameters(replyParameters), {
                ...this.createMockScopeDispatchData(replyParameters)
              };
            }, "wrappedDefaultsCallback"),
            newMockDispatch = addMockDispatch(this[kDispatches], this[kDispatchKey], wrappedDefaultsCallback);
          return new MockScope(newMockDispatch);
        }
        let replyParameters = {
          statusCode: replyOptionsCallbackOrStatusCode,
          data: arguments[1] === void 0 ? "" : arguments[1],
          responseOptions: arguments[2] === void 0 ? {} : arguments[2]
        };
        this.validateReplyParameters(replyParameters);
        let dispatchData = this.createMockScopeDispatchData(replyParameters),
          newMockDispatch = addMockDispatch(this[kDispatches], this[kDispatchKey], dispatchData);
        return new MockScope(newMockDispatch);
      }
      replyWithError(error) {
        if (typeof error > "u") throw new InvalidArgumentError("error must be defined");
        let newMockDispatch = addMockDispatch(this[kDispatches], this[kDispatchKey], {
          error: error
        });
        return new MockScope(newMockDispatch);
      }
      defaultReplyHeaders(headers) {
        if (typeof headers > "u") throw new InvalidArgumentError("headers must be defined");
        return this[kDefaultHeaders] = headers, this;
      }
      defaultReplyTrailers(trailers) {
        if (typeof trailers > "u") throw new InvalidArgumentError("trailers must be defined");
        return this[kDefaultTrailers] = trailers, this;
      }
      replyContentLength() {
        return this[kContentLength] = !0, this;
      }
    };
  __name(_MockInterceptor, "MockInterceptor");
  var MockInterceptor = _MockInterceptor;
  module.exports.MockInterceptor = MockInterceptor;
  module.exports.MockScope = MockScope;
});