var require_mock_utils = __commonJSMin((exports, module) => {
  "use strict";

  var {
      MockNotMatchedError: MockNotMatchedError
    } = loe(),
    {
      kDispatches: kDispatches,
      kMockAgent: kMockAgent,
      kOriginalDispatch: kOriginalDispatch,
      kOrigin: kOrigin,
      kGetNetConnect: kGetNetConnect
    } = mI(),
    {
      buildURL: buildURL
    } = oi(),
    {
      STATUS_CODES: STATUS_CODES
    } = require("http"),
    {
      types: {
        isPromise: isPromise
      }
    } = require("util");
  function matchValue(match, value) {
    return typeof match == "string" ? match === value : match instanceof RegExp ? match.test(value) : typeof match == "function" ? match(value) === !0 : !1;
  }
  __name(matchValue, "matchValue");
  function lowerCaseEntries(headers) {
    return Object.fromEntries(Object.entries(headers).map(([headerName, headerValue]) => [headerName.toLocaleLowerCase(), headerValue]));
  }
  __name(lowerCaseEntries, "lowerCaseEntries");
  function getHeaderByName(headers, key) {
    if (Array.isArray(headers)) {
      for (let i = 0; i < headers.length; i += 2) if (headers[i].toLocaleLowerCase() === key.toLocaleLowerCase()) return headers[i + 1];
      return;
    } else return typeof headers.get == "function" ? headers.get(key) : lowerCaseEntries(headers)[key.toLocaleLowerCase()];
  }
  __name(getHeaderByName, "getHeaderByName");
  function buildHeadersFromArray(headers) {
    let clone = headers.slice(),
      entries = [];
    for (let index = 0; index < clone.length; index += 2) entries.push([clone[index], clone[index + 1]]);
    return Object.fromEntries(entries);
  }
  __name(buildHeadersFromArray, "buildHeadersFromArray");
  function matchHeaders(mockDispatch, headers) {
    if (typeof mockDispatch.headers == "function") return Array.isArray(headers) && (headers = buildHeadersFromArray(headers)), mockDispatch.headers(headers ? lowerCaseEntries(headers) : {});
    if (typeof mockDispatch.headers > "u") return !0;
    if (typeof headers != "object" || typeof mockDispatch.headers != "object") return !1;
    for (let [matchHeaderName, matchHeaderValue] of Object.entries(mockDispatch.headers)) {
      let headerValue = getHeaderByName(headers, matchHeaderName);
      if (!matchValue(matchHeaderValue, headerValue)) return !1;
    }
    return !0;
  }
  __name(matchHeaders, "matchHeaders");
  function safeUrl(path) {
    if (typeof path != "string") return path;
    let pathSegments = path.split("?");
    if (pathSegments.length !== 2) return path;
    let qp = new URLSearchParams(pathSegments.pop());
    return qp.sort(), [...pathSegments, qp.toString()].join("?");
  }
  __name(safeUrl, "safeUrl");
  function matchKey(mockDispatch, {
    path: path,
    method: method,
    body: body,
    headers: headers
  }) {
    let pathMatch = matchValue(mockDispatch.path, path),
      methodMatch = matchValue(mockDispatch.method, method),
      bodyMatch = typeof mockDispatch.body < "u" ? matchValue(mockDispatch.body, body) : !0,
      headersMatch = matchHeaders(mockDispatch, headers);
    return pathMatch && methodMatch && bodyMatch && headersMatch;
  }
  __name(matchKey, "matchKey");
  function getResponseData(data) {
    return Buffer.isBuffer(data) || data instanceof Uint8Array || data instanceof ArrayBuffer ? data : typeof data == "object" ? JSON.stringify(data) : data.toString();
  }
  __name(getResponseData, "getResponseData");
  function getMockDispatch(mockDispatches, key) {
    let basePath = key.query ? buildURL(key.path, key.query) : key.path,
      resolvedPath = typeof basePath == "string" ? safeUrl(basePath) : basePath,
      matchedMockDispatches = mockDispatches.filter(({
        consumed: consumed
      }) => !consumed).filter(({
        path: path
      }) => matchValue(safeUrl(path), resolvedPath));
    if (matchedMockDispatches.length === 0) throw new MockNotMatchedError(`Mock dispatch not matched for path '${resolvedPath}'`);
    if (matchedMockDispatches = matchedMockDispatches.filter(({
      method: method
    }) => matchValue(method, key.method)), matchedMockDispatches.length === 0) throw new MockNotMatchedError(`Mock dispatch not matched for method '${key.method}' on path '${resolvedPath}'`);
    if (matchedMockDispatches = matchedMockDispatches.filter(({
      body: body
    }) => typeof body < "u" ? matchValue(body, key.body) : !0), matchedMockDispatches.length === 0) throw new MockNotMatchedError(`Mock dispatch not matched for body '${key.body}' on path '${resolvedPath}'`);
    if (matchedMockDispatches = matchedMockDispatches.filter(mockDispatch => matchHeaders(mockDispatch, key.headers)), matchedMockDispatches.length === 0) {
      let headers = typeof key.headers == "object" ? JSON.stringify(key.headers) : key.headers;
      throw new MockNotMatchedError(`Mock dispatch not matched for headers '${headers}' on path '${resolvedPath}'`);
    }
    return matchedMockDispatches[0];
  }
  __name(getMockDispatch, "getMockDispatch");
  function addMockDispatch(mockDispatches, key, data) {
    let baseData = {
        timesInvoked: 0,
        times: 1,
        persist: !1,
        consumed: !1
      },
      replyData = typeof data == "function" ? {
        callback: data
      } : {
        ...data
      },
      newMockDispatch = {
        ...baseData,
        ...key,
        pending: !0,
        data: {
          error: null,
          ...replyData
        }
      };
    return mockDispatches.push(newMockDispatch), newMockDispatch;
  }
  __name(addMockDispatch, "addMockDispatch");
  function deleteMockDispatch(mockDispatches, key) {
    let index = mockDispatches.findIndex(dispatch => dispatch.consumed ? matchKey(dispatch, key) : !1);
    index !== -1 && mockDispatches.splice(index, 1);
  }
  __name(deleteMockDispatch, "deleteMockDispatch");
  function buildKey(opts) {
    let {
      path: path,
      method: method,
      body: body,
      headers: headers,
      query: query
    } = opts;
    return {
      path: path,
      method: method,
      body: body,
      headers: headers,
      query: query
    };
  }
  __name(buildKey, "buildKey");
  function generateKeyValues(data) {
    let keys = Object.keys(data),
      result = [];
    for (let i = 0; i < keys.length; ++i) {
      let key = keys[i],
        value = data[key],
        name = Buffer.from(`${key}`);
      if (Array.isArray(value)) for (let j = 0; j < value.length; ++j) result.push(name, Buffer.from(`${value[j]}`));else result.push(name, Buffer.from(`${value}`));
    }
    return result;
  }
  __name(generateKeyValues, "generateKeyValues");
  function getStatusText(statusCode) {
    return STATUS_CODES[statusCode] || "unknown";
  }
  __name(getStatusText, "getStatusText");
  async function getResponse(body) {
    let buffers = [];
    for await (let data of body) buffers.push(data);
    return Buffer.concat(buffers).toString("utf8");
  }
  __name(getResponse, "getResponse");
  function mockDispatch(opts, handler) {
    let key = buildKey(opts),
      mockDispatch = getMockDispatch(this[kDispatches], key);
    mockDispatch.timesInvoked++, mockDispatch.data.callback && (mockDispatch.data = {
      ...mockDispatch.data,
      ...mockDispatch.data.callback(opts)
    });
    let {
        data: {
          statusCode: statusCode,
          data: data,
          headers: headers,
          trailers: trailers,
          error: error
        },
        delay: delay,
        persist: persist
      } = mockDispatch,
      {
        timesInvoked: timesInvoked,
        times: times
      } = mockDispatch;
    if (mockDispatch.consumed = !persist && timesInvoked >= times, mockDispatch.pending = timesInvoked < times, error !== null) return deleteMockDispatch(this[kDispatches], key), handler.onError(error), !0;
    typeof delay == "number" && delay > 0 ? setTimeout(() => {
      handleReply(this[kDispatches]);
    }, delay) : handleReply(this[kDispatches]);
    function handleReply(mockDispatches, _data = data) {
      var _a, _b, _c, _d;
      let optsHeaders = Array.isArray(opts.headers) ? buildHeadersFromArray(opts.headers) : opts.headers,
        body = typeof _data == "function" ? _data({
          ...opts,
          headers: optsHeaders
        }) : _data;
      if (isPromise(body)) {
        body.then(newData => handleReply(mockDispatches, newData));
        return;
      }
      let responseData = getResponseData(body),
        responseHeaders = generateKeyValues(headers),
        responseTrailers = generateKeyValues(trailers);
      (_a = handler.onConnect) == null || _a.call(handler, err => handler.onError(err), null), (_b = handler.onHeaders) == null || _b.call(handler, statusCode, responseHeaders, resume, getStatusText(statusCode)), (_c = handler.onData) == null || _c.call(handler, Buffer.from(responseData)), (_d = handler.onComplete) == null || _d.call(handler, responseTrailers), deleteMockDispatch(mockDispatches, key);
    }
    __name(handleReply, "handleReply");
    function resume() {}
    return __name(resume, "resume"), !0;
  }
  __name(mockDispatch, "mockDispatch");
  function buildMockDispatch() {
    let agent = this[kMockAgent],
      origin = this[kOrigin],
      originalDispatch = this[kOriginalDispatch];
    return __name(function (opts, handler) {
      if (agent.isMockActive) try {
        mockDispatch.call(this, opts, handler);
      } catch (error) {
        if (error instanceof MockNotMatchedError) {
          let netConnect = agent[kGetNetConnect]();
          if (netConnect === !1) throw new MockNotMatchedError(`${error.message}: subsequent request to origin ${origin} was not allowed (net.connect disabled)`);
          if (checkNetConnect(netConnect, origin)) originalDispatch.call(this, opts, handler);else throw new MockNotMatchedError(`${error.message}: subsequent request to origin ${origin} was not allowed (net.connect is not enabled for this origin)`);
        } else throw error;
      } else originalDispatch.call(this, opts, handler);
    }, "dispatch");
  }
  __name(buildMockDispatch, "buildMockDispatch");
  function checkNetConnect(netConnect, origin) {
    let url = new URL(origin);
    return netConnect === !0 ? !0 : !!(Array.isArray(netConnect) && netConnect.some(matcher => matchValue(matcher, url.host)));
  }
  __name(checkNetConnect, "checkNetConnect");
  function buildMockOptions(opts) {
    if (opts) {
      let {
        agent: agent,
        ...mockOptions
      } = opts;
      return mockOptions;
    }
  }
  __name(buildMockOptions, "buildMockOptions");
  module.exports = {
    getResponseData: getResponseData,
    getMockDispatch: getMockDispatch,
    addMockDispatch: addMockDispatch,
    deleteMockDispatch: deleteMockDispatch,
    buildKey: buildKey,
    generateKeyValues: generateKeyValues,
    matchValue: matchValue,
    getResponse: getResponse,
    getStatusText: getStatusText,
    mockDispatch: mockDispatch,
    buildMockDispatch: buildMockDispatch,
    checkNetConnect: checkNetConnect,
    buildMockOptions: buildMockOptions,
    getHeaderByName: getHeaderByName,
    buildHeadersFromArray: buildHeadersFromArray
  };
});