var require_api_pipeline = __commonJSMin((exports, module) => {
  "use strict";

  var {
      Readable: Readable,
      Duplex: Duplex,
      PassThrough: PassThrough
    } = require("stream"),
    {
      InvalidArgumentError: InvalidArgumentError,
      InvalidReturnValueError: InvalidReturnValueError,
      RequestAbortedError: RequestAbortedError
    } = rr(),
    util = oi(),
    {
      AsyncResource: AsyncResource
    } = require("async_hooks"),
    {
      addSignal: addSignal,
      removeSignal: removeSignal
    } = w9(),
    assert = require("assert"),
    kResume = Symbol("resume"),
    _PipelineRequest = class _PipelineRequest extends Readable {
      constructor() {
        super({
          autoDestroy: !0
        }), this[kResume] = null;
      }
      _read() {
        let {
          [kResume]: resume
        } = this;
        resume && (this[kResume] = null, resume());
      }
      _destroy(err, callback) {
        this._read(), callback(err);
      }
    };
  __name(_PipelineRequest, "PipelineRequest");
  var PipelineRequest = _PipelineRequest,
    _PipelineResponse = class _PipelineResponse extends Readable {
      constructor(resume) {
        super({
          autoDestroy: !0
        }), this[kResume] = resume;
      }
      _read() {
        this[kResume]();
      }
      _destroy(err, callback) {
        !err && !this._readableState.endEmitted && (err = new RequestAbortedError()), callback(err);
      }
    };
  __name(_PipelineResponse, "PipelineResponse");
  var PipelineResponse = _PipelineResponse,
    _PipelineHandler = class _PipelineHandler extends AsyncResource {
      constructor(opts, handler) {
        if (!opts || typeof opts != "object") throw new InvalidArgumentError("invalid opts");
        if (typeof handler != "function") throw new InvalidArgumentError("invalid handler");
        let {
          signal: signal,
          method: method,
          opaque: opaque,
          onInfo: onInfo,
          responseHeaders: responseHeaders
        } = opts;
        if (signal && typeof signal.on != "function" && typeof signal.addEventListener != "function") throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
        if (method === "CONNECT") throw new InvalidArgumentError("invalid method");
        if (onInfo && typeof onInfo != "function") throw new InvalidArgumentError("invalid onInfo callback");
        super("UNDICI_PIPELINE"), this.opaque = opaque || null, this.responseHeaders = responseHeaders || null, this.handler = handler, this.abort = null, this.context = null, this.onInfo = onInfo || null, this.req = new PipelineRequest().on("error", util.nop), this.ret = new Duplex({
          readableObjectMode: opts.objectMode,
          autoDestroy: !0,
          read: __name(() => {
            let {
              body: body
            } = this;
            body != null && body.resume && body.resume();
          }, "read"),
          write: __name((chunk, encoding, callback) => {
            let {
              req: req
            } = this;
            req.push(chunk, encoding) || req._readableState.destroyed ? callback() : req[kResume] = callback;
          }, "write"),
          destroy: __name((err, callback) => {
            let {
              body: body,
              req: req,
              res: res,
              ret: ret,
              abort: abort
            } = this;
            !err && !ret._readableState.endEmitted && (err = new RequestAbortedError()), abort && err && abort(), util.destroy(body, err), util.destroy(req, err), util.destroy(res, err), removeSignal(this), callback(err);
          }, "destroy")
        }).on("prefinish", () => {
          let {
            req: req
          } = this;
          req.push(null);
        }), this.res = null, addSignal(this, signal);
      }
      onConnect(abort, context) {
        let {
          ret: ret,
          res: res
        } = this;
        if (this.reason) {
          abort(this.reason);
          return;
        }
        assert(!res, "pipeline cannot be retried"), assert(!ret.destroyed), this.abort = abort, this.context = context;
      }
      onHeaders(statusCode, rawHeaders, resume) {
        let {
          opaque: opaque,
          handler: handler,
          context: context
        } = this;
        if (statusCode < 200) {
          if (this.onInfo) {
            let headers = this.responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
            this.onInfo({
              statusCode: statusCode,
              headers: headers
            });
          }
          return;
        }
        this.res = new PipelineResponse(resume);
        let body;
        try {
          this.handler = null;
          let headers = this.responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
          body = this.runInAsyncScope(handler, null, {
            statusCode: statusCode,
            headers: headers,
            opaque: opaque,
            body: this.res,
            context: context
          });
        } catch (err) {
          throw this.res.on("error", util.nop), err;
        }
        if (!body || typeof body.on != "function") throw new InvalidReturnValueError("expected Readable");
        body.on("data", chunk => {
          let {
            ret: ret,
            body: body
          } = this;
          !ret.push(chunk) && body.pause && body.pause();
        }).on("error", err => {
          let {
            ret: ret
          } = this;
          util.destroy(ret, err);
        }).on("end", () => {
          let {
            ret: ret
          } = this;
          ret.push(null);
        }).on("close", () => {
          let {
            ret: ret
          } = this;
          ret._readableState.ended || util.destroy(ret, new RequestAbortedError());
        }), this.body = body;
      }
      onData(chunk) {
        let {
          res: res
        } = this;
        return res.push(chunk);
      }
      onComplete(trailers) {
        let {
          res: res
        } = this;
        res.push(null);
      }
      onError(err) {
        let {
          ret: ret
        } = this;
        this.handler = null, util.destroy(ret, err);
      }
    };
  __name(_PipelineHandler, "PipelineHandler");
  var PipelineHandler = _PipelineHandler;
  function pipeline(opts, handler) {
    try {
      let pipelineHandler = new PipelineHandler(opts, handler);
      return this.dispatch({
        ...opts,
        body: pipelineHandler.req
      }, pipelineHandler), pipelineHandler.ret;
    } catch (err) {
      return new PassThrough().destroy(err);
    }
  }
  __name(pipeline, "pipeline");
  module.exports = pipeline;
});