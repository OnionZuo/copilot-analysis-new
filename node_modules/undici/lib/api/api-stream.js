var require_api_stream = __commonJSMin((exports, module) => {
  "use strict";

  var assert = require("assert"),
    {
      finished: finished,
      PassThrough: PassThrough
    } = require("stream"),
    {
      InvalidArgumentError: InvalidArgumentError,
      InvalidReturnValueError: InvalidReturnValueError
    } = rr(),
    util = oi(),
    {
      getResolveErrorBodyCallback: getResolveErrorBodyCallback
    } = Ore(),
    {
      AsyncResource: AsyncResource
    } = require("async_hooks"),
    {
      addSignal: addSignal,
      removeSignal: removeSignal
    } = w9(),
    _StreamHandler = class _StreamHandler extends AsyncResource {
      constructor(opts, factory, callback) {
        if (!opts || typeof opts != "object") throw new InvalidArgumentError("invalid opts");
        let {
          signal: signal,
          method: method,
          opaque: opaque,
          body: body,
          onInfo: onInfo,
          responseHeaders: responseHeaders,
          throwOnError: throwOnError
        } = opts;
        try {
          if (typeof callback != "function") throw new InvalidArgumentError("invalid callback");
          if (typeof factory != "function") throw new InvalidArgumentError("invalid factory");
          if (signal && typeof signal.on != "function" && typeof signal.addEventListener != "function") throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
          if (method === "CONNECT") throw new InvalidArgumentError("invalid method");
          if (onInfo && typeof onInfo != "function") throw new InvalidArgumentError("invalid onInfo callback");
          super("UNDICI_STREAM");
        } catch (err) {
          throw util.isStream(body) && util.destroy(body.on("error", util.nop), err), err;
        }
        this.responseHeaders = responseHeaders || null, this.opaque = opaque || null, this.factory = factory, this.callback = callback, this.res = null, this.abort = null, this.context = null, this.trailers = null, this.body = body, this.onInfo = onInfo || null, this.throwOnError = throwOnError || !1, util.isStream(body) && body.on("error", err => {
          this.onError(err);
        }), addSignal(this, signal);
      }
      onConnect(abort, context) {
        if (this.reason) {
          abort(this.reason);
          return;
        }
        assert(this.callback), this.abort = abort, this.context = context;
      }
      onHeaders(statusCode, rawHeaders, resume, statusMessage) {
        var _a;
        let {
            factory: factory,
            opaque: opaque,
            context: context,
            callback: callback,
            responseHeaders: responseHeaders
          } = this,
          headers = responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
        if (statusCode < 200) {
          this.onInfo && this.onInfo({
            statusCode: statusCode,
            headers: headers
          });
          return;
        }
        this.factory = null;
        let res;
        if (this.throwOnError && statusCode >= 400) {
          let contentType = (responseHeaders === "raw" ? util.parseHeaders(rawHeaders) : headers)["content-type"];
          res = new PassThrough(), this.callback = null, this.runInAsyncScope(getResolveErrorBodyCallback, null, {
            callback: callback,
            body: res,
            contentType: contentType,
            statusCode: statusCode,
            statusMessage: statusMessage,
            headers: headers
          });
        } else {
          if (factory === null) return;
          if (res = this.runInAsyncScope(factory, null, {
            statusCode: statusCode,
            headers: headers,
            opaque: opaque,
            context: context
          }), !res || typeof res.write != "function" || typeof res.end != "function" || typeof res.on != "function") throw new InvalidReturnValueError("expected Writable");
          finished(res, {
            readable: !1
          }, err => {
            let {
              callback: callback,
              res: res,
              opaque: opaque,
              trailers: trailers,
              abort: abort
            } = this;
            this.res = null, (err || !res.readable) && util.destroy(res, err), this.callback = null, this.runInAsyncScope(callback, null, err || null, {
              opaque: opaque,
              trailers: trailers
            }), err && abort();
          });
        }
        return res.on("drain", resume), this.res = res, (res.writableNeedDrain !== void 0 ? res.writableNeedDrain : (_a = res._writableState) == null ? void 0 : _a.needDrain) !== !0;
      }
      onData(chunk) {
        let {
          res: res
        } = this;
        return res ? res.write(chunk) : !0;
      }
      onComplete(trailers) {
        let {
          res: res
        } = this;
        removeSignal(this), res && (this.trailers = util.parseHeaders(trailers), res.end());
      }
      onError(err) {
        let {
          res: res,
          callback: callback,
          opaque: opaque,
          body: body
        } = this;
        removeSignal(this), this.factory = null, res ? (this.res = null, util.destroy(res, err)) : callback && (this.callback = null, queueMicrotask(() => {
          this.runInAsyncScope(callback, null, err, {
            opaque: opaque
          });
        })), body && (this.body = null, util.destroy(body, err));
      }
    };
  __name(_StreamHandler, "StreamHandler");
  var StreamHandler = _StreamHandler;
  function stream(opts, factory, callback) {
    if (callback === void 0) return new Promise((resolve, reject) => {
      stream.call(this, opts, factory, (err, data) => err ? reject(err) : resolve(data));
    });
    try {
      this.dispatch(opts, new StreamHandler(opts, factory, callback));
    } catch (err) {
      if (typeof callback != "function") throw err;
      let opaque = opts == null ? void 0 : opts.opaque;
      queueMicrotask(() => callback(err, {
        opaque: opaque
      }));
    }
  }
  __name(stream, "stream");
  module.exports = stream;
});