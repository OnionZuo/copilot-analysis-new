var require_api_connect = __commonJSMin((exports, module) => {
  "use strict";

  var assert = require("assert"),
    {
      AsyncResource: AsyncResource
    } = require("async_hooks"),
    {
      InvalidArgumentError: InvalidArgumentError,
      SocketError: SocketError
    } = rr(),
    util = oi(),
    {
      addSignal: addSignal,
      removeSignal: removeSignal
    } = w9(),
    _ConnectHandler = class _ConnectHandler extends AsyncResource {
      constructor(opts, callback) {
        if (!opts || typeof opts != "object") throw new InvalidArgumentError("invalid opts");
        if (typeof callback != "function") throw new InvalidArgumentError("invalid callback");
        let {
          signal: signal,
          opaque: opaque,
          responseHeaders: responseHeaders
        } = opts;
        if (signal && typeof signal.on != "function" && typeof signal.addEventListener != "function") throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
        super("UNDICI_CONNECT"), this.opaque = opaque || null, this.responseHeaders = responseHeaders || null, this.callback = callback, this.abort = null, addSignal(this, signal);
      }
      onConnect(abort, context) {
        if (this.reason) {
          abort(this.reason);
          return;
        }
        assert(this.callback), this.abort = abort, this.context = context;
      }
      onHeaders() {
        throw new SocketError("bad connect", null);
      }
      onUpgrade(statusCode, rawHeaders, socket) {
        let {
          callback: callback,
          opaque: opaque,
          context: context
        } = this;
        removeSignal(this), this.callback = null;
        let headers = rawHeaders;
        headers != null && (headers = this.responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders)), this.runInAsyncScope(callback, null, null, {
          statusCode: statusCode,
          headers: headers,
          socket: socket,
          opaque: opaque,
          context: context
        });
      }
      onError(err) {
        let {
          callback: callback,
          opaque: opaque
        } = this;
        removeSignal(this), callback && (this.callback = null, queueMicrotask(() => {
          this.runInAsyncScope(callback, null, err, {
            opaque: opaque
          });
        }));
      }
    };
  __name(_ConnectHandler, "ConnectHandler");
  var ConnectHandler = _ConnectHandler;
  function connect(opts, callback) {
    if (callback === void 0) return new Promise((resolve, reject) => {
      connect.call(this, opts, (err, data) => err ? reject(err) : resolve(data));
    });
    try {
      let connectHandler = new ConnectHandler(opts, callback);
      this.dispatch({
        ...opts,
        method: "CONNECT"
      }, connectHandler);
    } catch (err) {
      if (typeof callback != "function") throw err;
      let opaque = opts == null ? void 0 : opts.opaque;
      queueMicrotask(() => callback(err, {
        opaque: opaque
      }));
    }
  }
  __name(connect, "connect");
  module.exports = connect;
});