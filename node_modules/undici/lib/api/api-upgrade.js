var require_api_upgrade = __commonJSMin((exports, module) => {
  "use strict";

  var {
      InvalidArgumentError: InvalidArgumentError,
      SocketError: SocketError
    } = rr(),
    {
      AsyncResource: AsyncResource
    } = require("async_hooks"),
    util = oi(),
    {
      addSignal: addSignal,
      removeSignal: removeSignal
    } = w9(),
    assert = require("assert"),
    _UpgradeHandler = class _UpgradeHandler extends AsyncResource {
      constructor(opts, callback) {
        if (!opts || typeof opts != "object") throw new InvalidArgumentError("invalid opts");
        if (typeof callback != "function") throw new InvalidArgumentError("invalid callback");
        let {
          signal: signal,
          opaque: opaque,
          responseHeaders: responseHeaders
        } = opts;
        if (signal && typeof signal.on != "function" && typeof signal.addEventListener != "function") throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
        super("UNDICI_UPGRADE"), this.responseHeaders = responseHeaders || null, this.opaque = opaque || null, this.callback = callback, this.abort = null, this.context = null, addSignal(this, signal);
      }
      onConnect(abort, context) {
        if (this.reason) {
          abort(this.reason);
          return;
        }
        assert(this.callback), this.abort = abort, this.context = null;
      }
      onHeaders() {
        throw new SocketError("bad upgrade", null);
      }
      onUpgrade(statusCode, rawHeaders, socket) {
        assert(statusCode === 101);
        let {
          callback: callback,
          opaque: opaque,
          context: context
        } = this;
        removeSignal(this), this.callback = null;
        let headers = this.responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
        this.runInAsyncScope(callback, null, null, {
          headers: headers,
          socket: socket,
          opaque: opaque,
          context: context
        });
      }
      onError(err) {
        let {
          callback: callback,
          opaque: opaque
        } = this;
        removeSignal(this), callback && (this.callback = null, queueMicrotask(() => {
          this.runInAsyncScope(callback, null, err, {
            opaque: opaque
          });
        }));
      }
    };
  __name(_UpgradeHandler, "UpgradeHandler");
  var UpgradeHandler = _UpgradeHandler;
  function upgrade(opts, callback) {
    if (callback === void 0) return new Promise((resolve, reject) => {
      upgrade.call(this, opts, (err, data) => err ? reject(err) : resolve(data));
    });
    try {
      let upgradeHandler = new UpgradeHandler(opts, callback);
      this.dispatch({
        ...opts,
        method: opts.method || "GET",
        upgrade: opts.protocol || "Websocket"
      }, upgradeHandler);
    } catch (err) {
      if (typeof callback != "function") throw err;
      let opaque = opts == null ? void 0 : opts.opaque;
      queueMicrotask(() => callback(err, {
        opaque: opaque
      }));
    }
  }
  __name(upgrade, "upgrade");
  module.exports = upgrade;
});