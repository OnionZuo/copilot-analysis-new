var require_readable = __commonJSMin((exports, module) => {
  "use strict";

  var assert = require("assert"),
    {
      Readable: Readable
    } = require("stream"),
    {
      RequestAbortedError: RequestAbortedError,
      NotSupportedError: NotSupportedError,
      InvalidArgumentError: InvalidArgumentError,
      AbortError: AbortError
    } = rr(),
    util = oi(),
    {
      ReadableStreamFrom: ReadableStreamFrom
    } = oi(),
    kConsume = Symbol("kConsume"),
    kReading = Symbol("kReading"),
    kBody = Symbol("kBody"),
    kAbort = Symbol("kAbort"),
    kContentType = Symbol("kContentType"),
    kContentLength = Symbol("kContentLength"),
    noop = __name(() => {}, "noop"),
    _BodyReadable = class _BodyReadable extends Readable {
      constructor({
        resume: resume,
        abort: abort,
        contentType = "",
        contentLength: contentLength,
        highWaterMark = 64 * 1024
      }) {
        super({
          autoDestroy: !0,
          read: resume,
          highWaterMark: highWaterMark
        }), this._readableState.dataEmitted = !1, this[kAbort] = abort, this[kConsume] = null, this[kBody] = null, this[kContentType] = contentType, this[kContentLength] = contentLength, this[kReading] = !1;
      }
      destroy(err) {
        return !err && !this._readableState.endEmitted && (err = new RequestAbortedError()), err && this[kAbort](), super.destroy(err);
      }
      _destroy(err, callback) {
        this[kReading] ? callback(err) : setImmediate(() => {
          callback(err);
        });
      }
      on(ev, ...args) {
        return (ev === "data" || ev === "readable") && (this[kReading] = !0), super.on(ev, ...args);
      }
      addListener(ev, ...args) {
        return this.on(ev, ...args);
      }
      off(ev, ...args) {
        let ret = super.off(ev, ...args);
        return (ev === "data" || ev === "readable") && (this[kReading] = this.listenerCount("data") > 0 || this.listenerCount("readable") > 0), ret;
      }
      removeListener(ev, ...args) {
        return this.off(ev, ...args);
      }
      push(chunk) {
        return this[kConsume] && chunk !== null ? (consumePush(this[kConsume], chunk), this[kReading] ? super.push(chunk) : !0) : super.push(chunk);
      }
      async text() {
        return consume(this, "text");
      }
      async json() {
        return consume(this, "json");
      }
      async blob() {
        return consume(this, "blob");
      }
      async bytes() {
        return consume(this, "bytes");
      }
      async arrayBuffer() {
        return consume(this, "arrayBuffer");
      }
      async formData() {
        throw new NotSupportedError();
      }
      get bodyUsed() {
        return util.isDisturbed(this);
      }
      get body() {
        return this[kBody] || (this[kBody] = ReadableStreamFrom(this), this[kConsume] && (this[kBody].getReader(), assert(this[kBody].locked))), this[kBody];
      }
      async dump(opts) {
        let limit = Number.isFinite(opts == null ? void 0 : opts.limit) ? opts.limit : 131072,
          signal = opts == null ? void 0 : opts.signal;
        if (signal != null && (typeof signal != "object" || !("aborted" in signal))) throw new InvalidArgumentError("signal must be an AbortSignal");
        return signal == null || signal.throwIfAborted(), this._readableState.closeEmitted ? null : await new Promise((resolve, reject) => {
          this[kContentLength] > limit && this.destroy(new AbortError());
          let onAbort = __name(() => {
            var _a;
            this.destroy((_a = signal.reason) != null ? _a : new AbortError());
          }, "onAbort");
          signal == null || signal.addEventListener("abort", onAbort), this.on("close", function () {
            var _a;
            signal == null || signal.removeEventListener("abort", onAbort), signal != null && signal.aborted ? reject((_a = signal.reason) != null ? _a : new AbortError()) : resolve(null);
          }).on("error", noop).on("data", function (chunk) {
            limit -= chunk.length, limit <= 0 && this.destroy();
          }).resume();
        });
      }
    };
  __name(_BodyReadable, "BodyReadable");
  var BodyReadable = _BodyReadable;
  function isLocked(self) {
    return self[kBody] && self[kBody].locked === !0 || self[kConsume];
  }
  __name(isLocked, "isLocked");
  function isUnusable(self) {
    return util.isDisturbed(self) || isLocked(self);
  }
  __name(isUnusable, "isUnusable");
  async function consume(stream, type) {
    return assert(!stream[kConsume]), new Promise((resolve, reject) => {
      var _a;
      if (isUnusable(stream)) {
        let rState = stream._readableState;
        rState.destroyed && rState.closeEmitted === !1 ? stream.on("error", err => {
          reject(err);
        }).on("close", () => {
          reject(new TypeError("unusable"));
        }) : reject((_a = rState.errored) != null ? _a : new TypeError("unusable"));
      } else queueMicrotask(() => {
        stream[kConsume] = {
          type: type,
          stream: stream,
          resolve: resolve,
          reject: reject,
          length: 0,
          body: []
        }, stream.on("error", function (err) {
          consumeFinish(this[kConsume], err);
        }).on("close", function () {
          this[kConsume].body !== null && consumeFinish(this[kConsume], new RequestAbortedError());
        }), consumeStart(stream[kConsume]);
      });
    });
  }
  __name(consume, "consume");
  function consumeStart(consume) {
    if (consume.body === null) return;
    let {
      _readableState: state
    } = consume.stream;
    if (state.bufferIndex) {
      let start = state.bufferIndex,
        end = state.buffer.length;
      for (let n = start; n < end; n++) consumePush(consume, state.buffer[n]);
    } else for (let chunk of state.buffer) consumePush(consume, chunk);
    for (state.endEmitted ? consumeEnd(this[kConsume]) : consume.stream.on("end", function () {
      consumeEnd(this[kConsume]);
    }), consume.stream.resume(); consume.stream.read() != null;);
  }
  __name(consumeStart, "consumeStart");
  function chunksDecode(chunks, length) {
    if (chunks.length === 0 || length === 0) return "";
    let buffer = chunks.length === 1 ? chunks[0] : Buffer.concat(chunks, length),
      bufferLength = buffer.length,
      start = bufferLength > 2 && buffer[0] === 239 && buffer[1] === 187 && buffer[2] === 191 ? 3 : 0;
    return buffer.utf8Slice(start, bufferLength);
  }
  __name(chunksDecode, "chunksDecode");
  function chunksConcat(chunks, length) {
    if (chunks.length === 0 || length === 0) return new Uint8Array(0);
    if (chunks.length === 1) return new Uint8Array(chunks[0]);
    let buffer = new Uint8Array(Buffer.allocUnsafeSlow(length).buffer),
      offset = 0;
    for (let i = 0; i < chunks.length; ++i) {
      let chunk = chunks[i];
      buffer.set(chunk, offset), offset += chunk.length;
    }
    return buffer;
  }
  __name(chunksConcat, "chunksConcat");
  function consumeEnd(consume) {
    let {
      type: type,
      body: body,
      resolve: resolve,
      stream: stream,
      length: length
    } = consume;
    try {
      type === "text" ? resolve(chunksDecode(body, length)) : type === "json" ? resolve(JSON.parse(chunksDecode(body, length))) : type === "arrayBuffer" ? resolve(chunksConcat(body, length).buffer) : type === "blob" ? resolve(new Blob(body, {
        type: stream[kContentType]
      })) : type === "bytes" && resolve(chunksConcat(body, length)), consumeFinish(consume);
    } catch (err) {
      stream.destroy(err);
    }
  }
  __name(consumeEnd, "consumeEnd");
  function consumePush(consume, chunk) {
    consume.length += chunk.length, consume.body.push(chunk);
  }
  __name(consumePush, "consumePush");
  function consumeFinish(consume, err) {
    consume.body !== null && (err ? consume.reject(err) : consume.resolve(), consume.type = null, consume.stream = null, consume.resolve = null, consume.reject = null, consume.length = 0, consume.body = null);
  }
  __name(consumeFinish, "consumeFinish");
  module.exports = {
    Readable: BodyReadable,
    chunksDecode: chunksDecode
  };
});