var require_api_request = __commonJSMin((exports, module) => {
  "use strict";

  var assert = require("assert"),
    {
      Readable: Readable
    } = Ure(),
    {
      InvalidArgumentError: InvalidArgumentError,
      RequestAbortedError: RequestAbortedError
    } = rr(),
    util = oi(),
    {
      getResolveErrorBodyCallback: getResolveErrorBodyCallback
    } = Ore(),
    {
      AsyncResource: AsyncResource
    } = require("async_hooks"),
    _RequestHandler = class _RequestHandler extends AsyncResource {
      constructor(opts, callback) {
        var _a;
        if (!opts || typeof opts != "object") throw new InvalidArgumentError("invalid opts");
        let {
          signal: signal,
          method: method,
          opaque: opaque,
          body: body,
          onInfo: onInfo,
          responseHeaders: responseHeaders,
          throwOnError: throwOnError,
          highWaterMark: highWaterMark
        } = opts;
        try {
          if (typeof callback != "function") throw new InvalidArgumentError("invalid callback");
          if (highWaterMark && (typeof highWaterMark != "number" || highWaterMark < 0)) throw new InvalidArgumentError("invalid highWaterMark");
          if (signal && typeof signal.on != "function" && typeof signal.addEventListener != "function") throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
          if (method === "CONNECT") throw new InvalidArgumentError("invalid method");
          if (onInfo && typeof onInfo != "function") throw new InvalidArgumentError("invalid onInfo callback");
          super("UNDICI_REQUEST");
        } catch (err) {
          throw util.isStream(body) && util.destroy(body.on("error", util.nop), err), err;
        }
        this.method = method, this.responseHeaders = responseHeaders || null, this.opaque = opaque || null, this.callback = callback, this.res = null, this.abort = null, this.body = body, this.trailers = {}, this.context = null, this.onInfo = onInfo || null, this.throwOnError = throwOnError, this.highWaterMark = highWaterMark, this.signal = signal, this.reason = null, this.removeAbortListener = null, util.isStream(body) && body.on("error", err => {
          this.onError(err);
        }), this.signal && (this.signal.aborted ? this.reason = (_a = this.signal.reason) != null ? _a : new RequestAbortedError() : this.removeAbortListener = util.addAbortListener(this.signal, () => {
          var _a, _b;
          this.reason = (_a = this.signal.reason) != null ? _a : new RequestAbortedError(), this.res ? util.destroy(this.res.on("error", util.nop), this.reason) : this.abort && this.abort(this.reason), this.removeAbortListener && ((_b = this.res) == null || _b.off("close", this.removeAbortListener), this.removeAbortListener(), this.removeAbortListener = null);
        }));
      }
      onConnect(abort, context) {
        if (this.reason) {
          abort(this.reason);
          return;
        }
        assert(this.callback), this.abort = abort, this.context = context;
      }
      onHeaders(statusCode, rawHeaders, resume, statusMessage) {
        let {
            callback: callback,
            opaque: opaque,
            abort: abort,
            context: context,
            responseHeaders: responseHeaders,
            highWaterMark: highWaterMark
          } = this,
          headers = responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
        if (statusCode < 200) {
          this.onInfo && this.onInfo({
            statusCode: statusCode,
            headers: headers
          });
          return;
        }
        let parsedHeaders = responseHeaders === "raw" ? util.parseHeaders(rawHeaders) : headers,
          contentType = parsedHeaders["content-type"],
          contentLength = parsedHeaders["content-length"],
          res = new Readable({
            resume: resume,
            abort: abort,
            contentType: contentType,
            contentLength: this.method !== "HEAD" && contentLength ? Number(contentLength) : null,
            highWaterMark: highWaterMark
          });
        this.removeAbortListener && res.on("close", this.removeAbortListener), this.callback = null, this.res = res, callback !== null && (this.throwOnError && statusCode >= 400 ? this.runInAsyncScope(getResolveErrorBodyCallback, null, {
          callback: callback,
          body: res,
          contentType: contentType,
          statusCode: statusCode,
          statusMessage: statusMessage,
          headers: headers
        }) : this.runInAsyncScope(callback, null, null, {
          statusCode: statusCode,
          headers: headers,
          trailers: this.trailers,
          opaque: opaque,
          body: res,
          context: context
        }));
      }
      onData(chunk) {
        return this.res.push(chunk);
      }
      onComplete(trailers) {
        util.parseHeaders(trailers, this.trailers), this.res.push(null);
      }
      onError(err) {
        let {
          res: res,
          callback: callback,
          body: body,
          opaque: opaque
        } = this;
        callback && (this.callback = null, queueMicrotask(() => {
          this.runInAsyncScope(callback, null, err, {
            opaque: opaque
          });
        })), res && (this.res = null, queueMicrotask(() => {
          util.destroy(res, err);
        })), body && (this.body = null, util.destroy(body, err)), this.removeAbortListener && (res == null || res.off("close", this.removeAbortListener), this.removeAbortListener(), this.removeAbortListener = null);
      }
    };
  __name(_RequestHandler, "RequestHandler");
  var RequestHandler = _RequestHandler;
  function request(opts, callback) {
    if (callback === void 0) return new Promise((resolve, reject) => {
      request.call(this, opts, (err, data) => err ? reject(err) : resolve(data));
    });
    try {
      this.dispatch(opts, new RequestHandler(opts, callback));
    } catch (err) {
      if (typeof callback != "function") throw err;
      let opaque = opts == null ? void 0 : opts.opaque;
      queueMicrotask(() => callback(err, {
        opaque: opaque
      }));
    }
  }
  __name(request, "request");
  module.exports = request;
  module.exports.RequestHandler = RequestHandler;
});