var require_tree = __commonJSMin((exports, module) => {
  "use strict";

  var {
      wellknownHeaderNames: wellknownHeaderNames,
      headerNameLowerCasedRecord: headerNameLowerCasedRecord
    } = zP(),
    _TstNode = class _TstNode {
      constructor(key, value, index) {
        __publicField(this, "value", null);
        __publicField(this, "left", null);
        __publicField(this, "middle", null);
        __publicField(this, "right", null);
        __publicField(this, "code");
        if (index === void 0 || index >= key.length) throw new TypeError("Unreachable");
        if ((this.code = key.charCodeAt(index)) > 127) throw new TypeError("key must be ascii string");
        key.length !== ++index ? this.middle = new _TstNode(key, value, index) : this.value = value;
      }
      add(key, value) {
        let length = key.length;
        if (length === 0) throw new TypeError("Unreachable");
        let index = 0,
          node = this;
        for (;;) {
          let code = key.charCodeAt(index);
          if (code > 127) throw new TypeError("key must be ascii string");
          if (node.code === code) {
            if (length === ++index) {
              node.value = value;
              break;
            } else if (node.middle !== null) node = node.middle;else {
              node.middle = new _TstNode(key, value, index);
              break;
            }
          } else if (node.code < code) {
            if (node.left !== null) node = node.left;else {
              node.left = new _TstNode(key, value, index);
              break;
            }
          } else if (node.right !== null) node = node.right;else {
            node.right = new _TstNode(key, value, index);
            break;
          }
        }
      }
      search(key) {
        let keylength = key.length,
          index = 0,
          node = this;
        for (; node !== null && index < keylength;) {
          let code = key[index];
          for (code <= 90 && code >= 65 && (code |= 32); node !== null;) {
            if (code === node.code) {
              if (keylength === ++index) return node;
              node = node.middle;
              break;
            }
            node = node.code < code ? node.left : node.right;
          }
        }
        return null;
      }
    };
  __name(_TstNode, "TstNode");
  var TstNode = _TstNode,
    _TernarySearchTree = class _TernarySearchTree {
      constructor() {
        __publicField(this, "node", null);
      }
      insert(key, value) {
        this.node === null ? this.node = new TstNode(key, value, 0) : this.node.add(key, value);
      }
      lookup(key) {
        var _a, _b, _c;
        return (_c = (_b = (_a = this.node) == null ? void 0 : _a.search(key)) == null ? void 0 : _b.value) != null ? _c : null;
      }
    };
  __name(_TernarySearchTree, "TernarySearchTree");
  var TernarySearchTree = _TernarySearchTree,
    tree = new TernarySearchTree();
  for (let i = 0; i < wellknownHeaderNames.length; ++i) {
    let key = headerNameLowerCasedRecord[wellknownHeaderNames[i]];
    tree.insert(key, key);
  }
  module.exports = {
    TernarySearchTree: TernarySearchTree,
    tree: tree
  };
});