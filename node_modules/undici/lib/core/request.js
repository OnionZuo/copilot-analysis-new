var require_request = __commonJSMin((exports, module) => {
  "use strict";

  var {
      InvalidArgumentError: InvalidArgumentError,
      NotSupportedError: NotSupportedError
    } = rr(),
    assert = require("assert"),
    {
      isValidHTTPToken: isValidHTTPToken,
      isValidHeaderValue: isValidHeaderValue,
      isStream: isStream,
      destroy: destroy,
      isBuffer: isBuffer,
      isFormDataLike: isFormDataLike,
      isIterable: isIterable,
      isBlobLike: isBlobLike,
      buildURL: buildURL,
      validateHandler: validateHandler,
      getServerName: getServerName,
      normalizedMethodRecords: normalizedMethodRecords
    } = oi(),
    {
      channels: channels
    } = Sv(),
    {
      headerNameLowerCasedRecord: headerNameLowerCasedRecord
    } = zP(),
    invalidPathRegex = /[^\u0021-\u00ff]/,
    kHandler = Symbol("handler"),
    _Request = class _Request {
      constructor(origin, {
        path: path,
        method: method,
        body: body,
        headers: headers,
        query: query,
        idempotent: idempotent,
        blocking: blocking,
        upgrade: upgrade,
        headersTimeout: headersTimeout,
        bodyTimeout: bodyTimeout,
        reset: reset,
        throwOnError: throwOnError,
        expectContinue: expectContinue,
        servername: servername
      }, handler) {
        if (typeof path != "string") throw new InvalidArgumentError("path must be a string");
        if (path[0] !== "/" && !(path.startsWith("http://") || path.startsWith("https://")) && method !== "CONNECT") throw new InvalidArgumentError("path must be an absolute URL or start with a slash");
        if (invalidPathRegex.test(path)) throw new InvalidArgumentError("invalid request path");
        if (typeof method != "string") throw new InvalidArgumentError("method must be a string");
        if (normalizedMethodRecords[method] === void 0 && !isValidHTTPToken(method)) throw new InvalidArgumentError("invalid request method");
        if (upgrade && typeof upgrade != "string") throw new InvalidArgumentError("upgrade must be a string");
        if (headersTimeout != null && (!Number.isFinite(headersTimeout) || headersTimeout < 0)) throw new InvalidArgumentError("invalid headersTimeout");
        if (bodyTimeout != null && (!Number.isFinite(bodyTimeout) || bodyTimeout < 0)) throw new InvalidArgumentError("invalid bodyTimeout");
        if (reset != null && typeof reset != "boolean") throw new InvalidArgumentError("invalid reset");
        if (expectContinue != null && typeof expectContinue != "boolean") throw new InvalidArgumentError("invalid expectContinue");
        if (this.headersTimeout = headersTimeout, this.bodyTimeout = bodyTimeout, this.throwOnError = throwOnError === !0, this.method = method, this.abort = null, body == null) this.body = null;else if (isStream(body)) {
          this.body = body;
          let rState = this.body._readableState;
          (!rState || !rState.autoDestroy) && (this.endHandler = __name(function () {
            destroy(this);
          }, "autoDestroy"), this.body.on("end", this.endHandler)), this.errorHandler = err => {
            this.abort ? this.abort(err) : this.error = err;
          }, this.body.on("error", this.errorHandler);
        } else if (isBuffer(body)) this.body = body.byteLength ? body : null;else if (ArrayBuffer.isView(body)) this.body = body.buffer.byteLength ? Buffer.from(body.buffer, body.byteOffset, body.byteLength) : null;else if (body instanceof ArrayBuffer) this.body = body.byteLength ? Buffer.from(body) : null;else if (typeof body == "string") this.body = body.length ? Buffer.from(body) : null;else if (isFormDataLike(body) || isIterable(body) || isBlobLike(body)) this.body = body;else throw new InvalidArgumentError("body must be a string, a Buffer, a Readable stream, an iterable, or an async iterable");
        if (this.completed = !1, this.aborted = !1, this.upgrade = upgrade || null, this.path = query ? buildURL(path, query) : path, this.origin = origin, this.idempotent = idempotent == null ? method === "HEAD" || method === "GET" : idempotent, this.blocking = blocking == null ? !1 : blocking, this.reset = reset == null ? null : reset, this.host = null, this.contentLength = null, this.contentType = null, this.headers = [], this.expectContinue = expectContinue != null ? expectContinue : !1, Array.isArray(headers)) {
          if (headers.length % 2 !== 0) throw new InvalidArgumentError("headers array must be even");
          for (let i = 0; i < headers.length; i += 2) processHeader(this, headers[i], headers[i + 1]);
        } else if (headers && typeof headers == "object") {
          if (headers[Symbol.iterator]) for (let header of headers) {
            if (!Array.isArray(header) || header.length !== 2) throw new InvalidArgumentError("headers must be in key-value pair format");
            processHeader(this, header[0], header[1]);
          } else {
            let keys = Object.keys(headers);
            for (let i = 0; i < keys.length; ++i) processHeader(this, keys[i], headers[keys[i]]);
          }
        } else if (headers != null) throw new InvalidArgumentError("headers must be an object or an array");
        validateHandler(handler, method, upgrade), this.servername = servername || getServerName(this.host), this[kHandler] = handler, channels.create.hasSubscribers && channels.create.publish({
          request: this
        });
      }
      onBodySent(chunk) {
        if (this[kHandler].onBodySent) try {
          return this[kHandler].onBodySent(chunk);
        } catch (err) {
          this.abort(err);
        }
      }
      onRequestSent() {
        if (channels.bodySent.hasSubscribers && channels.bodySent.publish({
          request: this
        }), this[kHandler].onRequestSent) try {
          return this[kHandler].onRequestSent();
        } catch (err) {
          this.abort(err);
        }
      }
      onConnect(abort) {
        if (assert(!this.aborted), assert(!this.completed), this.error) abort(this.error);else return this.abort = abort, this[kHandler].onConnect(abort);
      }
      onResponseStarted() {
        var _a, _b;
        return (_b = (_a = this[kHandler]).onResponseStarted) == null ? void 0 : _b.call(_a);
      }
      onHeaders(statusCode, headers, resume, statusText) {
        assert(!this.aborted), assert(!this.completed), channels.headers.hasSubscribers && channels.headers.publish({
          request: this,
          response: {
            statusCode: statusCode,
            headers: headers,
            statusText: statusText
          }
        });
        try {
          return this[kHandler].onHeaders(statusCode, headers, resume, statusText);
        } catch (err) {
          this.abort(err);
        }
      }
      onData(chunk) {
        assert(!this.aborted), assert(!this.completed);
        try {
          return this[kHandler].onData(chunk);
        } catch (err) {
          return this.abort(err), !1;
        }
      }
      onUpgrade(statusCode, headers, socket) {
        return assert(!this.aborted), assert(!this.completed), this[kHandler].onUpgrade(statusCode, headers, socket);
      }
      onComplete(trailers) {
        this.onFinally(), assert(!this.aborted), this.completed = !0, channels.trailers.hasSubscribers && channels.trailers.publish({
          request: this,
          trailers: trailers
        });
        try {
          return this[kHandler].onComplete(trailers);
        } catch (err) {
          this.onError(err);
        }
      }
      onError(error) {
        if (this.onFinally(), channels.error.hasSubscribers && channels.error.publish({
          request: this,
          error: error
        }), !this.aborted) return this.aborted = !0, this[kHandler].onError(error);
      }
      onFinally() {
        this.errorHandler && (this.body.off("error", this.errorHandler), this.errorHandler = null), this.endHandler && (this.body.off("end", this.endHandler), this.endHandler = null);
      }
      addHeader(key, value) {
        return processHeader(this, key, value), this;
      }
    };
  __name(_Request, "Request");
  var Request = _Request;
  function processHeader(request, key, val) {
    if (val && typeof val == "object" && !Array.isArray(val)) throw new InvalidArgumentError(`invalid ${key} header`);
    if (val === void 0) return;
    let headerName = headerNameLowerCasedRecord[key];
    if (headerName === void 0 && (headerName = key.toLowerCase(), headerNameLowerCasedRecord[headerName] === void 0 && !isValidHTTPToken(headerName))) throw new InvalidArgumentError("invalid header key");
    if (Array.isArray(val)) {
      let arr = [];
      for (let i = 0; i < val.length; i++) if (typeof val[i] == "string") {
        if (!isValidHeaderValue(val[i])) throw new InvalidArgumentError(`invalid ${key} header`);
        arr.push(val[i]);
      } else if (val[i] === null) arr.push("");else {
        if (typeof val[i] == "object") throw new InvalidArgumentError(`invalid ${key} header`);
        arr.push(`${val[i]}`);
      }
      val = arr;
    } else if (typeof val == "string") {
      if (!isValidHeaderValue(val)) throw new InvalidArgumentError(`invalid ${key} header`);
    } else val === null ? val = "" : val = `${val}`;
    if (request.host === null && headerName === "host") {
      if (typeof val != "string") throw new InvalidArgumentError("invalid host header");
      request.host = val;
    } else if (request.contentLength === null && headerName === "content-length") {
      if (request.contentLength = parseInt(val, 10), !Number.isFinite(request.contentLength)) throw new InvalidArgumentError("invalid content-length header");
    } else if (request.contentType === null && headerName === "content-type") request.contentType = val, request.headers.push(key, val);else {
      if (headerName === "transfer-encoding" || headerName === "keep-alive" || headerName === "upgrade") throw new InvalidArgumentError(`invalid ${headerName} header`);
      if (headerName === "connection") {
        let value = typeof val == "string" ? val.toLowerCase() : null;
        if (value !== "close" && value !== "keep-alive") throw new InvalidArgumentError("invalid connection header");
        value === "close" && (request.reset = !0);
      } else {
        if (headerName === "expect") throw new NotSupportedError("expect header not supported");
        request.headers.push(key, val);
      }
    }
  }
  __name(processHeader, "processHeader");
  module.exports = Request;
});