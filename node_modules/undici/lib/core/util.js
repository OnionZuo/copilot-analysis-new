var require_util = __commonJSMin((exports, module) => {
  "use strict";

  var assert = require("assert"),
    {
      kDestroyed: kDestroyed,
      kBodyUsed: kBodyUsed,
      kListeners: kListeners,
      kBody: kBody
    } = fo(),
    {
      IncomingMessage: IncomingMessage
    } = require("http"),
    stream = require("stream"),
    net = require("net"),
    {
      Blob: Blob
    } = require("buffer"),
    nodeUtil = require("util"),
    {
      stringify: stringify
    } = require("querystring"),
    {
      EventEmitter: EE
    } = require("events"),
    {
      InvalidArgumentError: InvalidArgumentError
    } = rr(),
    {
      headerNameLowerCasedRecord: headerNameLowerCasedRecord
    } = zP(),
    {
      tree: tree
    } = rFe(),
    [nodeMajor, nodeMinor] = process.versions.node.split(".").map(v => Number(v)),
    _BodyAsyncIterable = class _BodyAsyncIterable {
      constructor(body) {
        this[kBody] = body, this[kBodyUsed] = !1;
      }
      async *[Symbol.asyncIterator]() {
        assert(!this[kBodyUsed], "disturbed"), this[kBodyUsed] = !0, yield* this[kBody];
      }
    };
  __name(_BodyAsyncIterable, "BodyAsyncIterable");
  var BodyAsyncIterable = _BodyAsyncIterable;
  function wrapRequestBody(body) {
    return isStream(body) ? (bodyLength(body) === 0 && body.on("data", function () {
      assert(!1);
    }), typeof body.readableDidRead != "boolean" && (body[kBodyUsed] = !1, EE.prototype.on.call(body, "data", function () {
      this[kBodyUsed] = !0;
    })), body) : body && typeof body.pipeTo == "function" ? new BodyAsyncIterable(body) : body && typeof body != "string" && !ArrayBuffer.isView(body) && isIterable(body) ? new BodyAsyncIterable(body) : body;
  }
  __name(wrapRequestBody, "wrapRequestBody");
  function nop() {}
  __name(nop, "nop");
  function isStream(obj) {
    return obj && typeof obj == "object" && typeof obj.pipe == "function" && typeof obj.on == "function";
  }
  __name(isStream, "isStream");
  function isBlobLike(object) {
    if (object === null) return !1;
    if (object instanceof Blob) return !0;
    if (typeof object != "object") return !1;
    {
      let sTag = object[Symbol.toStringTag];
      return (sTag === "Blob" || sTag === "File") && ("stream" in object && typeof object.stream == "function" || "arrayBuffer" in object && typeof object.arrayBuffer == "function");
    }
  }
  __name(isBlobLike, "isBlobLike");
  function buildURL(url, queryParams) {
    if (url.includes("?") || url.includes("#")) throw new Error('Query params cannot be passed when url already contains "?" or "#".');
    let stringified = stringify(queryParams);
    return stringified && (url += "?" + stringified), url;
  }
  __name(buildURL, "buildURL");
  function isValidPort(port) {
    let value = parseInt(port, 10);
    return value === Number(port) && value >= 0 && value <= 65535;
  }
  __name(isValidPort, "isValidPort");
  function isHttpOrHttpsPrefixed(value) {
    return value != null && value[0] === "h" && value[1] === "t" && value[2] === "t" && value[3] === "p" && (value[4] === ":" || value[4] === "s" && value[5] === ":");
  }
  __name(isHttpOrHttpsPrefixed, "isHttpOrHttpsPrefixed");
  function parseURL(url) {
    if (typeof url == "string") {
      if (url = new URL(url), !isHttpOrHttpsPrefixed(url.origin || url.protocol)) throw new InvalidArgumentError("Invalid URL protocol: the URL must start with `http:` or `https:`.");
      return url;
    }
    if (!url || typeof url != "object") throw new InvalidArgumentError("Invalid URL: The URL argument must be a non-null object.");
    if (!(url instanceof URL)) {
      if (url.port != null && url.port !== "" && isValidPort(url.port) === !1) throw new InvalidArgumentError("Invalid URL: port must be a valid integer or a string representation of an integer.");
      if (url.path != null && typeof url.path != "string") throw new InvalidArgumentError("Invalid URL path: the path must be a string or null/undefined.");
      if (url.pathname != null && typeof url.pathname != "string") throw new InvalidArgumentError("Invalid URL pathname: the pathname must be a string or null/undefined.");
      if (url.hostname != null && typeof url.hostname != "string") throw new InvalidArgumentError("Invalid URL hostname: the hostname must be a string or null/undefined.");
      if (url.origin != null && typeof url.origin != "string") throw new InvalidArgumentError("Invalid URL origin: the origin must be a string or null/undefined.");
      if (!isHttpOrHttpsPrefixed(url.origin || url.protocol)) throw new InvalidArgumentError("Invalid URL protocol: the URL must start with `http:` or `https:`.");
      let port = url.port != null ? url.port : url.protocol === "https:" ? 443 : 80,
        origin = url.origin != null ? url.origin : `${url.protocol || ""}//${url.hostname || ""}:${port}`,
        path = url.path != null ? url.path : `${url.pathname || ""}${url.search || ""}`;
      return origin[origin.length - 1] === "/" && (origin = origin.slice(0, origin.length - 1)), path && path[0] !== "/" && (path = `/${path}`), new URL(`${origin}${path}`);
    }
    if (!isHttpOrHttpsPrefixed(url.origin || url.protocol)) throw new InvalidArgumentError("Invalid URL protocol: the URL must start with `http:` or `https:`.");
    return url;
  }
  __name(parseURL, "parseURL");
  function parseOrigin(url) {
    if (url = parseURL(url), url.pathname !== "/" || url.search || url.hash) throw new InvalidArgumentError("invalid url");
    return url;
  }
  __name(parseOrigin, "parseOrigin");
  function getHostname(host) {
    if (host[0] === "[") {
      let idx = host.indexOf("]");
      return assert(idx !== -1), host.substring(1, idx);
    }
    let idx = host.indexOf(":");
    return idx === -1 ? host : host.substring(0, idx);
  }
  __name(getHostname, "getHostname");
  function getServerName(host) {
    if (!host) return null;
    assert(typeof host == "string");
    let servername = getHostname(host);
    return net.isIP(servername) ? "" : servername;
  }
  __name(getServerName, "getServerName");
  function deepClone(obj) {
    return JSON.parse(JSON.stringify(obj));
  }
  __name(deepClone, "deepClone");
  function isAsyncIterable(obj) {
    return obj != null && typeof obj[Symbol.asyncIterator] == "function";
  }
  __name(isAsyncIterable, "isAsyncIterable");
  function isIterable(obj) {
    return obj != null && (typeof obj[Symbol.iterator] == "function" || typeof obj[Symbol.asyncIterator] == "function");
  }
  __name(isIterable, "isIterable");
  function bodyLength(body) {
    if (body == null) return 0;
    if (isStream(body)) {
      let state = body._readableState;
      return state && state.objectMode === !1 && state.ended === !0 && Number.isFinite(state.length) ? state.length : null;
    } else {
      if (isBlobLike(body)) return body.size != null ? body.size : null;
      if (isBuffer(body)) return body.byteLength;
    }
    return null;
  }
  __name(bodyLength, "bodyLength");
  function isDestroyed(body) {
    var _a;
    return body && !!(body.destroyed || body[kDestroyed] || (_a = stream.isDestroyed) != null && _a.call(stream, body));
  }
  __name(isDestroyed, "isDestroyed");
  function destroy(stream, err) {
    stream == null || !isStream(stream) || isDestroyed(stream) || (typeof stream.destroy == "function" ? (Object.getPrototypeOf(stream).constructor === IncomingMessage && (stream.socket = null), stream.destroy(err)) : err && queueMicrotask(() => {
      stream.emit("error", err);
    }), stream.destroyed !== !0 && (stream[kDestroyed] = !0));
  }
  __name(destroy, "destroy");
  var KEEPALIVE_TIMEOUT_EXPR = /timeout=(\d+)/;
  function parseKeepAliveTimeout(val) {
    let m = val.toString().match(KEEPALIVE_TIMEOUT_EXPR);
    return m ? parseInt(m[1], 10) * 1e3 : null;
  }
  __name(parseKeepAliveTimeout, "parseKeepAliveTimeout");
  function headerNameToString(value) {
    var _a, _b;
    return typeof value == "string" ? (_a = headerNameLowerCasedRecord[value]) != null ? _a : value.toLowerCase() : (_b = tree.lookup(value)) != null ? _b : value.toString("latin1").toLowerCase();
  }
  __name(headerNameToString, "headerNameToString");
  function bufferToLowerCasedHeaderName(value) {
    var _a;
    return (_a = tree.lookup(value)) != null ? _a : value.toString("latin1").toLowerCase();
  }
  __name(bufferToLowerCasedHeaderName, "bufferToLowerCasedHeaderName");
  function parseHeaders(headers, obj) {
    obj === void 0 && (obj = {});
    for (let i = 0; i < headers.length; i += 2) {
      let key = headerNameToString(headers[i]),
        val = obj[key];
      if (val) typeof val == "string" && (val = [val], obj[key] = val), val.push(headers[i + 1].toString("utf8"));else {
        let headersValue = headers[i + 1];
        typeof headersValue == "string" ? obj[key] = headersValue : obj[key] = Array.isArray(headersValue) ? headersValue.map(x => x.toString("utf8")) : headersValue.toString("utf8");
      }
    }
    return "content-length" in obj && "content-disposition" in obj && (obj["content-disposition"] = Buffer.from(obj["content-disposition"]).toString("latin1")), obj;
  }
  __name(parseHeaders, "parseHeaders");
  function parseRawHeaders(headers) {
    let len = headers.length,
      ret = new Array(len),
      hasContentLength = !1,
      contentDispositionIdx = -1,
      key,
      val,
      kLen = 0;
    for (let n = 0; n < headers.length; n += 2) key = headers[n], val = headers[n + 1], typeof key != "string" && (key = key.toString()), typeof val != "string" && (val = val.toString("utf8")), kLen = key.length, kLen === 14 && key[7] === "-" && (key === "content-length" || key.toLowerCase() === "content-length") ? hasContentLength = !0 : kLen === 19 && key[7] === "-" && (key === "content-disposition" || key.toLowerCase() === "content-disposition") && (contentDispositionIdx = n + 1), ret[n] = key, ret[n + 1] = val;
    return hasContentLength && contentDispositionIdx !== -1 && (ret[contentDispositionIdx] = Buffer.from(ret[contentDispositionIdx]).toString("latin1")), ret;
  }
  __name(parseRawHeaders, "parseRawHeaders");
  function isBuffer(buffer) {
    return buffer instanceof Uint8Array || Buffer.isBuffer(buffer);
  }
  __name(isBuffer, "isBuffer");
  function validateHandler(handler, method, upgrade) {
    if (!handler || typeof handler != "object") throw new InvalidArgumentError("handler must be an object");
    if (typeof handler.onConnect != "function") throw new InvalidArgumentError("invalid onConnect method");
    if (typeof handler.onError != "function") throw new InvalidArgumentError("invalid onError method");
    if (typeof handler.onBodySent != "function" && handler.onBodySent !== void 0) throw new InvalidArgumentError("invalid onBodySent method");
    if (upgrade || method === "CONNECT") {
      if (typeof handler.onUpgrade != "function") throw new InvalidArgumentError("invalid onUpgrade method");
    } else {
      if (typeof handler.onHeaders != "function") throw new InvalidArgumentError("invalid onHeaders method");
      if (typeof handler.onData != "function") throw new InvalidArgumentError("invalid onData method");
      if (typeof handler.onComplete != "function") throw new InvalidArgumentError("invalid onComplete method");
    }
  }
  __name(validateHandler, "validateHandler");
  function isDisturbed(body) {
    return !!(body && (stream.isDisturbed(body) || body[kBodyUsed]));
  }
  __name(isDisturbed, "isDisturbed");
  function isErrored(body) {
    return !!(body && stream.isErrored(body));
  }
  __name(isErrored, "isErrored");
  function isReadable(body) {
    return !!(body && stream.isReadable(body));
  }
  __name(isReadable, "isReadable");
  function getSocketInfo(socket) {
    return {
      localAddress: socket.localAddress,
      localPort: socket.localPort,
      remoteAddress: socket.remoteAddress,
      remotePort: socket.remotePort,
      remoteFamily: socket.remoteFamily,
      timeout: socket.timeout,
      bytesWritten: socket.bytesWritten,
      bytesRead: socket.bytesRead
    };
  }
  __name(getSocketInfo, "getSocketInfo");
  function ReadableStreamFrom(iterable) {
    let iterator;
    return new ReadableStream({
      async start() {
        iterator = iterable[Symbol.asyncIterator]();
      },
      async pull(controller) {
        let {
          done: done,
          value: value
        } = await iterator.next();
        if (done) queueMicrotask(() => {
          var _a;
          controller.close(), (_a = controller.byobRequest) == null || _a.respond(0);
        });else {
          let buf = Buffer.isBuffer(value) ? value : Buffer.from(value);
          buf.byteLength && controller.enqueue(new Uint8Array(buf));
        }
        return controller.desiredSize > 0;
      },
      async cancel(reason) {
        await iterator.return();
      },
      type: "bytes"
    });
  }
  __name(ReadableStreamFrom, "ReadableStreamFrom");
  function isFormDataLike(object) {
    return object && typeof object == "object" && typeof object.append == "function" && typeof object.delete == "function" && typeof object.get == "function" && typeof object.getAll == "function" && typeof object.has == "function" && typeof object.set == "function" && object[Symbol.toStringTag] === "FormData";
  }
  __name(isFormDataLike, "isFormDataLike");
  function addAbortListener(signal, listener) {
    return "addEventListener" in signal ? (signal.addEventListener("abort", listener, {
      once: !0
    }), () => signal.removeEventListener("abort", listener)) : (signal.addListener("abort", listener), () => signal.removeListener("abort", listener));
  }
  __name(addAbortListener, "addAbortListener");
  var hasToWellFormed = typeof String.prototype.toWellFormed == "function",
    hasIsWellFormed = typeof String.prototype.isWellFormed == "function";
  function toUSVString(val) {
    return hasToWellFormed ? `${val}`.toWellFormed() : nodeUtil.toUSVString(val);
  }
  __name(toUSVString, "toUSVString");
  function isUSVString(val) {
    return hasIsWellFormed ? `${val}`.isWellFormed() : toUSVString(val) === `${val}`;
  }
  __name(isUSVString, "isUSVString");
  function isTokenCharCode(c) {
    switch (c) {
      case 34:
      case 40:
      case 41:
      case 44:
      case 47:
      case 58:
      case 59:
      case 60:
      case 61:
      case 62:
      case 63:
      case 64:
      case 91:
      case 92:
      case 93:
      case 123:
      case 125:
        return !1;
      default:
        return c >= 33 && c <= 126;
    }
  }
  __name(isTokenCharCode, "isTokenCharCode");
  function isValidHTTPToken(characters) {
    if (characters.length === 0) return !1;
    for (let i = 0; i < characters.length; ++i) if (!isTokenCharCode(characters.charCodeAt(i))) return !1;
    return !0;
  }
  __name(isValidHTTPToken, "isValidHTTPToken");
  var headerCharRegex = /[^\t\x20-\x7e\x80-\xff]/;
  function isValidHeaderValue(characters) {
    return !headerCharRegex.test(characters);
  }
  __name(isValidHeaderValue, "isValidHeaderValue");
  function parseRangeHeader(range) {
    if (range == null || range === "") return {
      start: 0,
      end: null,
      size: null
    };
    let m = range ? range.match(/^bytes (\d+)-(\d+)\/(\d+)?$/) : null;
    return m ? {
      start: parseInt(m[1]),
      end: m[2] ? parseInt(m[2]) : null,
      size: m[3] ? parseInt(m[3]) : null
    } : null;
  }
  __name(parseRangeHeader, "parseRangeHeader");
  function addListener(obj, name, listener) {
    var _a;
    return ((_a = obj[kListeners]) != null ? _a : obj[kListeners] = []).push([name, listener]), obj.on(name, listener), obj;
  }
  __name(addListener, "addListener");
  function removeAllListeners(obj) {
    var _a;
    for (let [name, listener] of (_a = obj[kListeners]) != null ? _a : []) obj.removeListener(name, listener);
    obj[kListeners] = null;
  }
  __name(removeAllListeners, "removeAllListeners");
  function errorRequest(client, request, err) {
    try {
      request.onError(err), assert(request.aborted);
    } catch (err) {
      client.emit("error", err);
    }
  }
  __name(errorRequest, "errorRequest");
  var kEnumerableProperty = Object.create(null);
  kEnumerableProperty.enumerable = !0;
  var normalizedMethodRecordsBase = {
      delete: "DELETE",
      DELETE: "DELETE",
      get: "GET",
      GET: "GET",
      head: "HEAD",
      HEAD: "HEAD",
      options: "OPTIONS",
      OPTIONS: "OPTIONS",
      post: "POST",
      POST: "POST",
      put: "PUT",
      PUT: "PUT"
    },
    normalizedMethodRecords = {
      ...normalizedMethodRecordsBase,
      patch: "patch",
      PATCH: "PATCH"
    };
  Object.setPrototypeOf(normalizedMethodRecordsBase, null);
  Object.setPrototypeOf(normalizedMethodRecords, null);
  module.exports = {
    kEnumerableProperty: kEnumerableProperty,
    nop: nop,
    isDisturbed: isDisturbed,
    isErrored: isErrored,
    isReadable: isReadable,
    toUSVString: toUSVString,
    isUSVString: isUSVString,
    isBlobLike: isBlobLike,
    parseOrigin: parseOrigin,
    parseURL: parseURL,
    getServerName: getServerName,
    isStream: isStream,
    isIterable: isIterable,
    isAsyncIterable: isAsyncIterable,
    isDestroyed: isDestroyed,
    headerNameToString: headerNameToString,
    bufferToLowerCasedHeaderName: bufferToLowerCasedHeaderName,
    addListener: addListener,
    removeAllListeners: removeAllListeners,
    errorRequest: errorRequest,
    parseRawHeaders: parseRawHeaders,
    parseHeaders: parseHeaders,
    parseKeepAliveTimeout: parseKeepAliveTimeout,
    destroy: destroy,
    bodyLength: bodyLength,
    deepClone: deepClone,
    ReadableStreamFrom: ReadableStreamFrom,
    isBuffer: isBuffer,
    validateHandler: validateHandler,
    getSocketInfo: getSocketInfo,
    isFormDataLike: isFormDataLike,
    buildURL: buildURL,
    addAbortListener: addAbortListener,
    isValidHTTPToken: isValidHTTPToken,
    isValidHeaderValue: isValidHeaderValue,
    isTokenCharCode: isTokenCharCode,
    parseRangeHeader: parseRangeHeader,
    normalizedMethodRecordsBase: normalizedMethodRecordsBase,
    normalizedMethodRecords: normalizedMethodRecords,
    isValidPort: isValidPort,
    isHttpOrHttpsPrefixed: isHttpOrHttpsPrefixed,
    nodeMajor: nodeMajor,
    nodeMinor: nodeMinor,
    safeHTTPMethods: ["GET", "HEAD", "OPTIONS", "TRACE"],
    wrapRequestBody: wrapRequestBody
  };
});