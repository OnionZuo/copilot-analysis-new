var require_connect = __commonJSMin((exports, module) => {
  "use strict";

  var net = require("net"),
    assert = require("assert"),
    util = oi(),
    {
      InvalidArgumentError: InvalidArgumentError,
      ConnectTimeoutError: ConnectTimeoutError
    } = rr(),
    timers = Aie();
  function noop() {}
  __name(noop, "noop");
  var tls, SessionCache, _a, _b;
  global.FinalizationRegistry && !(process.env.NODE_V8_COVERAGE || process.env.UNDICI_NO_FG) ? SessionCache = (_a = class {
    constructor(maxCachedSessions) {
      this._maxCachedSessions = maxCachedSessions, this._sessionCache = new Map(), this._sessionRegistry = new global.FinalizationRegistry(key => {
        if (this._sessionCache.size < this._maxCachedSessions) return;
        let ref = this._sessionCache.get(key);
        ref !== void 0 && ref.deref() === void 0 && this._sessionCache.delete(key);
      });
    }
    get(sessionKey) {
      let ref = this._sessionCache.get(sessionKey);
      return ref ? ref.deref() : null;
    }
    set(sessionKey, session) {
      this._maxCachedSessions !== 0 && (this._sessionCache.set(sessionKey, new WeakRef(session)), this._sessionRegistry.register(session, sessionKey));
    }
  }, __name(_a, "WeakSessionCache"), _a) : SessionCache = (_b = class {
    constructor(maxCachedSessions) {
      this._maxCachedSessions = maxCachedSessions, this._sessionCache = new Map();
    }
    get(sessionKey) {
      return this._sessionCache.get(sessionKey);
    }
    set(sessionKey, session) {
      if (this._maxCachedSessions !== 0) {
        if (this._sessionCache.size >= this._maxCachedSessions) {
          let {
            value: oldestKey
          } = this._sessionCache.keys().next();
          this._sessionCache.delete(oldestKey);
        }
        this._sessionCache.set(sessionKey, session);
      }
    }
  }, __name(_b, "SimpleSessionCache"), _b);
  function buildConnector({
    allowH2: allowH2,
    maxCachedSessions: maxCachedSessions,
    socketPath: socketPath,
    timeout: timeout,
    session: customSession,
    ...opts
  }) {
    if (maxCachedSessions != null && (!Number.isInteger(maxCachedSessions) || maxCachedSessions < 0)) throw new InvalidArgumentError("maxCachedSessions must be a positive integer or zero");
    let options = {
        path: socketPath,
        ...opts
      },
      sessionCache = new SessionCache(maxCachedSessions == null ? 100 : maxCachedSessions);
    return timeout = timeout == null ? 1e4 : timeout, allowH2 = allowH2 != null ? allowH2 : !1, __name(function ({
      hostname: hostname,
      host: host,
      protocol: protocol,
      port: port,
      servername: servername,
      localAddress: localAddress,
      httpSocket: httpSocket
    }, callback) {
      let socket;
      if (protocol === "https:") {
        tls || (tls = require("tls")), servername = servername || options.servername || util.getServerName(host) || null;
        let sessionKey = servername || hostname;
        assert(sessionKey);
        let session = customSession || sessionCache.get(sessionKey) || null;
        port = port || 443, socket = tls.connect({
          highWaterMark: 16384,
          ...options,
          servername: servername,
          session: session,
          localAddress: localAddress,
          ALPNProtocols: allowH2 ? ["http/1.1", "h2"] : ["http/1.1"],
          socket: httpSocket,
          port: port,
          host: hostname
        }), socket.on("session", function (session) {
          sessionCache.set(sessionKey, session);
        });
      } else assert(!httpSocket, "httpSocket can only be sent on TLS update"), port = port || 80, socket = net.connect({
        highWaterMark: 64 * 1024,
        ...options,
        localAddress: localAddress,
        port: port,
        host: hostname
      });
      if (options.keepAlive == null || options.keepAlive) {
        let keepAliveInitialDelay = options.keepAliveInitialDelay === void 0 ? 6e4 : options.keepAliveInitialDelay;
        socket.setKeepAlive(!0, keepAliveInitialDelay);
      }
      let clearConnectTimeout = setupConnectTimeout(new WeakRef(socket), {
        timeout: timeout,
        hostname: hostname,
        port: port
      });
      return socket.setNoDelay(!0).once(protocol === "https:" ? "secureConnect" : "connect", function () {
        if (queueMicrotask(clearConnectTimeout), callback) {
          let cb = callback;
          callback = null, cb(null, this);
        }
      }).on("error", function (err) {
        if (queueMicrotask(clearConnectTimeout), callback) {
          let cb = callback;
          callback = null, cb(err);
        }
      }), socket;
    }, "connect");
  }
  __name(buildConnector, "buildConnector");
  var setupConnectTimeout = process.platform === "win32" ? (socketWeakRef, opts) => {
    if (!opts.timeout) return noop;
    let s1 = null,
      s2 = null,
      fastTimer = timers.setFastTimeout(() => {
        s1 = setImmediate(() => {
          s2 = setImmediate(() => onConnectTimeout(socketWeakRef.deref(), opts));
        });
      }, opts.timeout);
    return () => {
      timers.clearFastTimeout(fastTimer), clearImmediate(s1), clearImmediate(s2);
    };
  } : (socketWeakRef, opts) => {
    if (!opts.timeout) return noop;
    let s1 = null,
      fastTimer = timers.setFastTimeout(() => {
        s1 = setImmediate(() => {
          onConnectTimeout(socketWeakRef.deref(), opts);
        });
      }, opts.timeout);
    return () => {
      timers.clearFastTimeout(fastTimer), clearImmediate(s1);
    };
  };
  function onConnectTimeout(socket, opts) {
    if (socket == null) return;
    let message = "Connect Timeout Error";
    Array.isArray(socket.autoSelectFamilyAttemptedAddresses) ? message += ` (attempted addresses: ${socket.autoSelectFamilyAttemptedAddresses.join(", ")},` : message += ` (attempted address: ${opts.hostname}:${opts.port},`, message += ` timeout: ${opts.timeout}ms)`, util.destroy(socket, new ConnectTimeoutError(message));
  }
  __name(onConnectTimeout, "onConnectTimeout");
  module.exports = buildConnector;
});