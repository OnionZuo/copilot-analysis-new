var require_retry_handler = __commonJSMin((exports, module) => {
  "use strict";

  var assert = require("assert"),
    {
      kRetryHandlerDefaultRetry: kRetryHandlerDefaultRetry
    } = fo(),
    {
      RequestRetryError: RequestRetryError
    } = rr(),
    {
      isDisturbed: isDisturbed,
      parseHeaders: parseHeaders,
      parseRangeHeader: parseRangeHeader,
      wrapRequestBody: wrapRequestBody
    } = oi();
  function calculateRetryAfterHeader(retryAfter) {
    let current = Date.now();
    return new Date(retryAfter).getTime() - current;
  }
  __name(calculateRetryAfterHeader, "calculateRetryAfterHeader");
  var _RetryHandler = class _RetryHandler {
    constructor(opts, handlers) {
      let {
          retryOptions: retryOptions,
          ...dispatchOpts
        } = opts,
        {
          retry: retryFn,
          maxRetries: maxRetries,
          maxTimeout: maxTimeout,
          minTimeout: minTimeout,
          timeoutFactor: timeoutFactor,
          methods: methods,
          errorCodes: errorCodes,
          retryAfter: retryAfter,
          statusCodes: statusCodes
        } = retryOptions != null ? retryOptions : {};
      this.dispatch = handlers.dispatch, this.handler = handlers.handler, this.opts = {
        ...dispatchOpts,
        body: wrapRequestBody(opts.body)
      }, this.abort = null, this.aborted = !1, this.retryOpts = {
        retry: retryFn != null ? retryFn : _RetryHandler[kRetryHandlerDefaultRetry],
        retryAfter: retryAfter != null ? retryAfter : !0,
        maxTimeout: maxTimeout != null ? maxTimeout : 30 * 1e3,
        minTimeout: minTimeout != null ? minTimeout : 500,
        timeoutFactor: timeoutFactor != null ? timeoutFactor : 2,
        maxRetries: maxRetries != null ? maxRetries : 5,
        methods: methods != null ? methods : ["GET", "HEAD", "OPTIONS", "PUT", "DELETE", "TRACE"],
        statusCodes: statusCodes != null ? statusCodes : [500, 502, 503, 504, 429],
        errorCodes: errorCodes != null ? errorCodes : ["ECONNRESET", "ECONNREFUSED", "ENOTFOUND", "ENETDOWN", "ENETUNREACH", "EHOSTDOWN", "EHOSTUNREACH", "EPIPE", "UND_ERR_SOCKET"]
      }, this.retryCount = 0, this.retryCountCheckpoint = 0, this.start = 0, this.end = null, this.etag = null, this.resume = null, this.handler.onConnect(reason => {
        this.aborted = !0, this.abort ? this.abort(reason) : this.reason = reason;
      });
    }
    onRequestSent() {
      this.handler.onRequestSent && this.handler.onRequestSent();
    }
    onUpgrade(statusCode, headers, socket) {
      this.handler.onUpgrade && this.handler.onUpgrade(statusCode, headers, socket);
    }
    onConnect(abort) {
      this.aborted ? abort(this.reason) : this.abort = abort;
    }
    onBodySent(chunk) {
      if (this.handler.onBodySent) return this.handler.onBodySent(chunk);
    }
    static [kRetryHandlerDefaultRetry](err, {
      state: state,
      opts: opts
    }, cb) {
      let {
          statusCode: statusCode,
          code: code,
          headers: headers
        } = err,
        {
          method: method,
          retryOptions: retryOptions
        } = opts,
        {
          maxRetries: maxRetries,
          minTimeout: minTimeout,
          maxTimeout: maxTimeout,
          timeoutFactor: timeoutFactor,
          statusCodes: statusCodes,
          errorCodes: errorCodes,
          methods: methods
        } = retryOptions,
        {
          counter: counter
        } = state;
      if (code && code !== "UND_ERR_REQ_RETRY" && !errorCodes.includes(code)) {
        cb(err);
        return;
      }
      if (Array.isArray(methods) && !methods.includes(method)) {
        cb(err);
        return;
      }
      if (statusCode != null && Array.isArray(statusCodes) && !statusCodes.includes(statusCode)) {
        cb(err);
        return;
      }
      if (counter > maxRetries) {
        cb(err);
        return;
      }
      let retryAfterHeader = headers == null ? void 0 : headers["retry-after"];
      retryAfterHeader && (retryAfterHeader = Number(retryAfterHeader), retryAfterHeader = Number.isNaN(retryAfterHeader) ? calculateRetryAfterHeader(retryAfterHeader) : retryAfterHeader * 1e3);
      let retryTimeout = retryAfterHeader > 0 ? Math.min(retryAfterHeader, maxTimeout) : Math.min(minTimeout * timeoutFactor ** (counter - 1), maxTimeout);
      setTimeout(() => cb(null), retryTimeout);
    }
    onHeaders(statusCode, rawHeaders, resume, statusMessage) {
      let headers = parseHeaders(rawHeaders);
      if (this.retryCount += 1, statusCode >= 300) return this.retryOpts.statusCodes.includes(statusCode) === !1 ? this.handler.onHeaders(statusCode, rawHeaders, resume, statusMessage) : (this.abort(new RequestRetryError("Request failed", statusCode, {
        headers: headers,
        data: {
          count: this.retryCount
        }
      })), !1);
      if (this.resume != null) {
        if (this.resume = null, statusCode !== 206 && (this.start > 0 || statusCode !== 200)) return this.abort(new RequestRetryError("server does not support the range header and the payload was partially consumed", statusCode, {
          headers: headers,
          data: {
            count: this.retryCount
          }
        })), !1;
        let contentRange = parseRangeHeader(headers["content-range"]);
        if (!contentRange) return this.abort(new RequestRetryError("Content-Range mismatch", statusCode, {
          headers: headers,
          data: {
            count: this.retryCount
          }
        })), !1;
        if (this.etag != null && this.etag !== headers.etag) return this.abort(new RequestRetryError("ETag mismatch", statusCode, {
          headers: headers,
          data: {
            count: this.retryCount
          }
        })), !1;
        let {
          start: start,
          size: size,
          end = size - 1
        } = contentRange;
        return assert(this.start === start, "content-range mismatch"), assert(this.end == null || this.end === end, "content-range mismatch"), this.resume = resume, !0;
      }
      if (this.end == null) {
        if (statusCode === 206) {
          let range = parseRangeHeader(headers["content-range"]);
          if (range == null) return this.handler.onHeaders(statusCode, rawHeaders, resume, statusMessage);
          let {
            start: start,
            size: size,
            end = size - 1
          } = range;
          assert(start != null && Number.isFinite(start), "content-range mismatch"), assert(end != null && Number.isFinite(end), "invalid content-length"), this.start = start, this.end = end;
        }
        if (this.end == null) {
          let contentLength = headers["content-length"];
          this.end = contentLength != null ? Number(contentLength) - 1 : null;
        }
        return assert(Number.isFinite(this.start)), assert(this.end == null || Number.isFinite(this.end), "invalid content-length"), this.resume = resume, this.etag = headers.etag != null ? headers.etag : null, this.etag != null && this.etag.startsWith("W/") && (this.etag = null), this.handler.onHeaders(statusCode, rawHeaders, resume, statusMessage);
      }
      let err = new RequestRetryError("Request failed", statusCode, {
        headers: headers,
        data: {
          count: this.retryCount
        }
      });
      return this.abort(err), !1;
    }
    onData(chunk) {
      return this.start += chunk.length, this.handler.onData(chunk);
    }
    onComplete(rawTrailers) {
      return this.retryCount = 0, this.handler.onComplete(rawTrailers);
    }
    onError(err) {
      if (this.aborted || isDisturbed(this.opts.body)) return this.handler.onError(err);
      this.retryCount - this.retryCountCheckpoint > 0 ? this.retryCount = this.retryCountCheckpoint + (this.retryCount - this.retryCountCheckpoint) : this.retryCount += 1, this.retryOpts.retry(err, {
        state: {
          counter: this.retryCount
        },
        opts: {
          retryOptions: this.retryOpts,
          ...this.opts
        }
      }, onRetry.bind(this));
      function onRetry(err) {
        var _a;
        if (err != null || this.aborted || isDisturbed(this.opts.body)) return this.handler.onError(err);
        if (this.start !== 0) {
          let headers = {
            range: `bytes=${this.start}-${(_a = this.end) != null ? _a : ""}`
          };
          this.etag != null && (headers["if-match"] = this.etag), this.opts = {
            ...this.opts,
            headers: {
              ...this.opts.headers,
              ...headers
            }
          };
        }
        try {
          this.retryCountCheckpoint = this.retryCount, this.dispatch(this.opts, this);
        } catch (err) {
          this.handler.onError(err);
        }
      }
      __name(onRetry, "onRetry");
    }
  };
  __name(_RetryHandler, "RetryHandler");
  var RetryHandler = _RetryHandler;
  module.exports = RetryHandler;
});