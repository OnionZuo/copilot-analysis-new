var require_redirect_handler = __commonJSMin((exports, module) => {
  "use strict";

  var util = oi(),
    {
      kBodyUsed: kBodyUsed
    } = fo(),
    assert = require("assert"),
    {
      InvalidArgumentError: InvalidArgumentError
    } = rr(),
    EE = require("events"),
    redirectableStatusCodes = [300, 301, 302, 303, 307, 308],
    kBody = Symbol("body"),
    _BodyAsyncIterable = class _BodyAsyncIterable {
      constructor(body) {
        this[kBody] = body, this[kBodyUsed] = !1;
      }
      async *[Symbol.asyncIterator]() {
        assert(!this[kBodyUsed], "disturbed"), this[kBodyUsed] = !0, yield* this[kBody];
      }
    };
  __name(_BodyAsyncIterable, "BodyAsyncIterable");
  var BodyAsyncIterable = _BodyAsyncIterable,
    _RedirectHandler = class _RedirectHandler {
      constructor(dispatch, maxRedirections, opts, handler) {
        if (maxRedirections != null && (!Number.isInteger(maxRedirections) || maxRedirections < 0)) throw new InvalidArgumentError("maxRedirections must be a positive number");
        util.validateHandler(handler, opts.method, opts.upgrade), this.dispatch = dispatch, this.location = null, this.abort = null, this.opts = {
          ...opts,
          maxRedirections: 0
        }, this.maxRedirections = maxRedirections, this.handler = handler, this.history = [], this.redirectionLimitReached = !1, util.isStream(this.opts.body) ? (util.bodyLength(this.opts.body) === 0 && this.opts.body.on("data", function () {
          assert(!1);
        }), typeof this.opts.body.readableDidRead != "boolean" && (this.opts.body[kBodyUsed] = !1, EE.prototype.on.call(this.opts.body, "data", function () {
          this[kBodyUsed] = !0;
        }))) : this.opts.body && typeof this.opts.body.pipeTo == "function" ? this.opts.body = new BodyAsyncIterable(this.opts.body) : this.opts.body && typeof this.opts.body != "string" && !ArrayBuffer.isView(this.opts.body) && util.isIterable(this.opts.body) && (this.opts.body = new BodyAsyncIterable(this.opts.body));
      }
      onConnect(abort) {
        this.abort = abort, this.handler.onConnect(abort, {
          history: this.history
        });
      }
      onUpgrade(statusCode, headers, socket) {
        this.handler.onUpgrade(statusCode, headers, socket);
      }
      onError(error) {
        this.handler.onError(error);
      }
      onHeaders(statusCode, headers, resume, statusText) {
        if (this.location = this.history.length >= this.maxRedirections || util.isDisturbed(this.opts.body) ? null : parseLocation(statusCode, headers), this.opts.throwOnMaxRedirect && this.history.length >= this.maxRedirections) {
          this.request && this.request.abort(new Error("max redirects")), this.redirectionLimitReached = !0, this.abort(new Error("max redirects"));
          return;
        }
        if (this.opts.origin && this.history.push(new URL(this.opts.path, this.opts.origin)), !this.location) return this.handler.onHeaders(statusCode, headers, resume, statusText);
        let {
            origin: origin,
            pathname: pathname,
            search: search
          } = util.parseURL(new URL(this.location, this.opts.origin && new URL(this.opts.path, this.opts.origin))),
          path = search ? `${pathname}${search}` : pathname;
        this.opts.headers = cleanRequestHeaders(this.opts.headers, statusCode === 303, this.opts.origin !== origin), this.opts.path = path, this.opts.origin = origin, this.opts.maxRedirections = 0, this.opts.query = null, statusCode === 303 && this.opts.method !== "HEAD" && (this.opts.method = "GET", this.opts.body = null);
      }
      onData(chunk) {
        if (!this.location) return this.handler.onData(chunk);
      }
      onComplete(trailers) {
        this.location ? (this.location = null, this.abort = null, this.dispatch(this.opts, this)) : this.handler.onComplete(trailers);
      }
      onBodySent(chunk) {
        this.handler.onBodySent && this.handler.onBodySent(chunk);
      }
    };
  __name(_RedirectHandler, "RedirectHandler");
  var RedirectHandler = _RedirectHandler;
  function parseLocation(statusCode, headers) {
    if (redirectableStatusCodes.indexOf(statusCode) === -1) return null;
    for (let i = 0; i < headers.length; i += 2) if (headers[i].length === 8 && util.headerNameToString(headers[i]) === "location") return headers[i + 1];
  }
  __name(parseLocation, "parseLocation");
  function shouldRemoveHeader(header, removeContent, unknownOrigin) {
    if (header.length === 4) return util.headerNameToString(header) === "host";
    if (removeContent && util.headerNameToString(header).startsWith("content-")) return !0;
    if (unknownOrigin && (header.length === 13 || header.length === 6 || header.length === 19)) {
      let name = util.headerNameToString(header);
      return name === "authorization" || name === "cookie" || name === "proxy-authorization";
    }
    return !1;
  }
  __name(shouldRemoveHeader, "shouldRemoveHeader");
  function cleanRequestHeaders(headers, removeContent, unknownOrigin) {
    let ret = [];
    if (Array.isArray(headers)) for (let i = 0; i < headers.length; i += 2) shouldRemoveHeader(headers[i], removeContent, unknownOrigin) || ret.push(headers[i], headers[i + 1]);else if (headers && typeof headers == "object") for (let key of Object.keys(headers)) shouldRemoveHeader(key, removeContent, unknownOrigin) || ret.push(key, headers[key]);else assert(headers == null, "headers must be an object or an array");
    return ret;
  }
  __name(cleanRequestHeaders, "cleanRequestHeaders");
  module.exports = RedirectHandler;
});