var require_cachestorage = __commonJSMin((exports, module) => {
  "use strict";

  var {
      kConstruct: kConstruct
    } = f7(),
    {
      Cache: Cache
    } = E6e(),
    {
      webidl: webidl
    } = Gc(),
    {
      kEnumerableProperty: kEnumerableProperty
    } = oi(),
    _caches,
    _CacheStorage = class _CacheStorage {
      constructor() {
        __privateAdd(this, _caches, new Map());
        arguments[0] !== kConstruct && webidl.illegalConstructor(), webidl.util.markAsUncloneable(this);
      }
      async match(request, options = {}) {
        if (webidl.brandCheck(this, _CacheStorage), webidl.argumentLengthCheck(arguments, 1, "CacheStorage.match"), request = webidl.converters.RequestInfo(request), options = webidl.converters.MultiCacheQueryOptions(options), options.cacheName != null) {
          if (__privateGet(this, _caches).has(options.cacheName)) {
            let cacheList = __privateGet(this, _caches).get(options.cacheName);
            return await new Cache(kConstruct, cacheList).match(request, options);
          }
        } else for (let cacheList of __privateGet(this, _caches).values()) {
          let response = await new Cache(kConstruct, cacheList).match(request, options);
          if (response !== void 0) return response;
        }
      }
      async has(cacheName) {
        webidl.brandCheck(this, _CacheStorage);
        let prefix = "CacheStorage.has";
        return webidl.argumentLengthCheck(arguments, 1, prefix), cacheName = webidl.converters.DOMString(cacheName, prefix, "cacheName"), __privateGet(this, _caches).has(cacheName);
      }
      async open(cacheName) {
        webidl.brandCheck(this, _CacheStorage);
        let prefix = "CacheStorage.open";
        if (webidl.argumentLengthCheck(arguments, 1, prefix), cacheName = webidl.converters.DOMString(cacheName, prefix, "cacheName"), __privateGet(this, _caches).has(cacheName)) {
          let cache = __privateGet(this, _caches).get(cacheName);
          return new Cache(kConstruct, cache);
        }
        let cache = [];
        return __privateGet(this, _caches).set(cacheName, cache), new Cache(kConstruct, cache);
      }
      async delete(cacheName) {
        webidl.brandCheck(this, _CacheStorage);
        let prefix = "CacheStorage.delete";
        return webidl.argumentLengthCheck(arguments, 1, prefix), cacheName = webidl.converters.DOMString(cacheName, prefix, "cacheName"), __privateGet(this, _caches).delete(cacheName);
      }
      async keys() {
        return webidl.brandCheck(this, _CacheStorage), [...__privateGet(this, _caches).keys()];
      }
    };
  _caches = new WeakMap(), __name(_CacheStorage, "CacheStorage");
  var CacheStorage = _CacheStorage;
  Object.defineProperties(CacheStorage.prototype, {
    [Symbol.toStringTag]: {
      value: "CacheStorage",
      configurable: !0
    },
    match: kEnumerableProperty,
    has: kEnumerableProperty,
    open: kEnumerableProperty,
    delete: kEnumerableProperty,
    keys: kEnumerableProperty
  });
  module.exports = {
    CacheStorage: CacheStorage
  };
});