var require_cache = __commonJSMin((exports, module) => {
  "use strict";

  var {
      kConstruct: kConstruct
    } = f7(),
    {
      urlEquals: urlEquals,
      getFieldValues: getFieldValues
    } = C6e(),
    {
      kEnumerableProperty: kEnumerableProperty,
      isDisturbed: isDisturbed
    } = oi(),
    {
      webidl: webidl
    } = Gc(),
    {
      Response: Response,
      cloneResponse: cloneResponse,
      fromInnerResponse: fromInnerResponse
    } = B9(),
    {
      Request: Request,
      fromInnerRequest: fromInnerRequest
    } = vI(),
    {
      kState: kState
    } = iw(),
    {
      fetching: fetching
    } = I9(),
    {
      urlIsHttpHttpsScheme: urlIsHttpHttpsScheme,
      createDeferredPromise: createDeferredPromise,
      readAllBytes: readAllBytes
    } = Lu(),
    assert = require("assert"),
    _relevantRequestResponseList,
    _Cache_instances,
    batchCacheOperations_fn,
    queryCache_fn,
    requestMatchesCachedItem_fn,
    internalMatchAll_fn,
    _Cache = class _Cache {
      constructor() {
        __privateAdd(this, _Cache_instances);
        __privateAdd(this, _relevantRequestResponseList);
        arguments[0] !== kConstruct && webidl.illegalConstructor(), webidl.util.markAsUncloneable(this), __privateSet(this, _relevantRequestResponseList, arguments[1]);
      }
      async match(request, options = {}) {
        webidl.brandCheck(this, _Cache);
        let prefix = "Cache.match";
        webidl.argumentLengthCheck(arguments, 1, prefix), request = webidl.converters.RequestInfo(request, prefix, "request"), options = webidl.converters.CacheQueryOptions(options, prefix, "options");
        let p = __privateMethod(this, _Cache_instances, internalMatchAll_fn).call(this, request, options, 1);
        if (p.length !== 0) return p[0];
      }
      async matchAll(request = void 0, options = {}) {
        webidl.brandCheck(this, _Cache);
        let prefix = "Cache.matchAll";
        return request !== void 0 && (request = webidl.converters.RequestInfo(request, prefix, "request")), options = webidl.converters.CacheQueryOptions(options, prefix, "options"), __privateMethod(this, _Cache_instances, internalMatchAll_fn).call(this, request, options);
      }
      async add(request) {
        webidl.brandCheck(this, _Cache);
        let prefix = "Cache.add";
        webidl.argumentLengthCheck(arguments, 1, prefix), request = webidl.converters.RequestInfo(request, prefix, "request");
        let requests = [request];
        return await this.addAll(requests);
      }
      async addAll(requests) {
        webidl.brandCheck(this, _Cache);
        let prefix = "Cache.addAll";
        webidl.argumentLengthCheck(arguments, 1, prefix);
        let responsePromises = [],
          requestList = [];
        for (let request of requests) {
          if (request === void 0) throw webidl.errors.conversionFailed({
            prefix: prefix,
            argument: "Argument 1",
            types: ["undefined is not allowed"]
          });
          if (request = webidl.converters.RequestInfo(request), typeof request == "string") continue;
          let r = request[kState];
          if (!urlIsHttpHttpsScheme(r.url) || r.method !== "GET") throw webidl.errors.exception({
            header: prefix,
            message: "Expected http/s scheme when method is not GET."
          });
        }
        let fetchControllers = [];
        for (let request of requests) {
          let r = new Request(request)[kState];
          if (!urlIsHttpHttpsScheme(r.url)) throw webidl.errors.exception({
            header: prefix,
            message: "Expected http/s scheme."
          });
          r.initiator = "fetch", r.destination = "subresource", requestList.push(r);
          let responsePromise = createDeferredPromise();
          fetchControllers.push(fetching({
            request: r,
            processResponse(response) {
              if (response.type === "error" || response.status === 206 || response.status < 200 || response.status > 299) responsePromise.reject(webidl.errors.exception({
                header: "Cache.addAll",
                message: "Received an invalid status code or the request failed."
              }));else if (response.headersList.contains("vary")) {
                let fieldValues = getFieldValues(response.headersList.get("vary"));
                for (let fieldValue of fieldValues) if (fieldValue === "*") {
                  responsePromise.reject(webidl.errors.exception({
                    header: "Cache.addAll",
                    message: "invalid vary field value"
                  }));
                  for (let controller of fetchControllers) controller.abort();
                  return;
                }
              }
            },
            processResponseEndOfBody(response) {
              if (response.aborted) {
                responsePromise.reject(new DOMException("aborted", "AbortError"));
                return;
              }
              responsePromise.resolve(response);
            }
          })), responsePromises.push(responsePromise.promise);
        }
        let responses = await Promise.all(responsePromises),
          operations = [],
          index = 0;
        for (let response of responses) {
          let operation = {
            type: "put",
            request: requestList[index],
            response: response
          };
          operations.push(operation), index++;
        }
        let cacheJobPromise = createDeferredPromise(),
          errorData = null;
        try {
          __privateMethod(this, _Cache_instances, batchCacheOperations_fn).call(this, operations);
        } catch (e) {
          errorData = e;
        }
        return queueMicrotask(() => {
          errorData === null ? cacheJobPromise.resolve(void 0) : cacheJobPromise.reject(errorData);
        }), cacheJobPromise.promise;
      }
      async put(request, response) {
        webidl.brandCheck(this, _Cache);
        let prefix = "Cache.put";
        webidl.argumentLengthCheck(arguments, 2, prefix), request = webidl.converters.RequestInfo(request, prefix, "request"), response = webidl.converters.Response(response, prefix, "response");
        let innerRequest = null;
        if (request instanceof Request ? innerRequest = request[kState] : innerRequest = new Request(request)[kState], !urlIsHttpHttpsScheme(innerRequest.url) || innerRequest.method !== "GET") throw webidl.errors.exception({
          header: prefix,
          message: "Expected an http/s scheme when method is not GET"
        });
        let innerResponse = response[kState];
        if (innerResponse.status === 206) throw webidl.errors.exception({
          header: prefix,
          message: "Got 206 status"
        });
        if (innerResponse.headersList.contains("vary")) {
          let fieldValues = getFieldValues(innerResponse.headersList.get("vary"));
          for (let fieldValue of fieldValues) if (fieldValue === "*") throw webidl.errors.exception({
            header: prefix,
            message: "Got * vary field value"
          });
        }
        if (innerResponse.body && (isDisturbed(innerResponse.body.stream) || innerResponse.body.stream.locked)) throw webidl.errors.exception({
          header: prefix,
          message: "Response body is locked or disturbed"
        });
        let clonedResponse = cloneResponse(innerResponse),
          bodyReadPromise = createDeferredPromise();
        if (innerResponse.body != null) {
          let reader = innerResponse.body.stream.getReader();
          readAllBytes(reader).then(bodyReadPromise.resolve, bodyReadPromise.reject);
        } else bodyReadPromise.resolve(void 0);
        let operations = [],
          operation = {
            type: "put",
            request: innerRequest,
            response: clonedResponse
          };
        operations.push(operation);
        let bytes = await bodyReadPromise.promise;
        clonedResponse.body != null && (clonedResponse.body.source = bytes);
        let cacheJobPromise = createDeferredPromise(),
          errorData = null;
        try {
          __privateMethod(this, _Cache_instances, batchCacheOperations_fn).call(this, operations);
        } catch (e) {
          errorData = e;
        }
        return queueMicrotask(() => {
          errorData === null ? cacheJobPromise.resolve() : cacheJobPromise.reject(errorData);
        }), cacheJobPromise.promise;
      }
      async delete(request, options = {}) {
        webidl.brandCheck(this, _Cache);
        let prefix = "Cache.delete";
        webidl.argumentLengthCheck(arguments, 1, prefix), request = webidl.converters.RequestInfo(request, prefix, "request"), options = webidl.converters.CacheQueryOptions(options, prefix, "options");
        let r = null;
        if (request instanceof Request) {
          if (r = request[kState], r.method !== "GET" && !options.ignoreMethod) return !1;
        } else assert(typeof request == "string"), r = new Request(request)[kState];
        let operations = [],
          operation = {
            type: "delete",
            request: r,
            options: options
          };
        operations.push(operation);
        let cacheJobPromise = createDeferredPromise(),
          errorData = null,
          requestResponses;
        try {
          requestResponses = __privateMethod(this, _Cache_instances, batchCacheOperations_fn).call(this, operations);
        } catch (e) {
          errorData = e;
        }
        return queueMicrotask(() => {
          errorData === null ? cacheJobPromise.resolve(!!(requestResponses != null && requestResponses.length)) : cacheJobPromise.reject(errorData);
        }), cacheJobPromise.promise;
      }
      async keys(request = void 0, options = {}) {
        webidl.brandCheck(this, _Cache);
        let prefix = "Cache.keys";
        request !== void 0 && (request = webidl.converters.RequestInfo(request, prefix, "request")), options = webidl.converters.CacheQueryOptions(options, prefix, "options");
        let r = null;
        if (request !== void 0) if (request instanceof Request) {
          if (r = request[kState], r.method !== "GET" && !options.ignoreMethod) return [];
        } else typeof request == "string" && (r = new Request(request)[kState]);
        let promise = createDeferredPromise(),
          requests = [];
        if (request === void 0) for (let requestResponse of __privateGet(this, _relevantRequestResponseList)) requests.push(requestResponse[0]);else {
          let requestResponses = __privateMethod(this, _Cache_instances, queryCache_fn).call(this, r, options);
          for (let requestResponse of requestResponses) requests.push(requestResponse[0]);
        }
        return queueMicrotask(() => {
          let requestList = [];
          for (let request of requests) {
            let requestObject = fromInnerRequest(request, new AbortController().signal, "immutable");
            requestList.push(requestObject);
          }
          promise.resolve(Object.freeze(requestList));
        }), promise.promise;
      }
    };
  _relevantRequestResponseList = new WeakMap(), _Cache_instances = new WeakSet(), batchCacheOperations_fn = __name(function (operations) {
    let cache = __privateGet(this, _relevantRequestResponseList),
      backupCache = [...cache],
      addedItems = [],
      resultList = [];
    try {
      for (let operation of operations) {
        if (operation.type !== "delete" && operation.type !== "put") throw webidl.errors.exception({
          header: "Cache.#batchCacheOperations",
          message: 'operation type does not match "delete" or "put"'
        });
        if (operation.type === "delete" && operation.response != null) throw webidl.errors.exception({
          header: "Cache.#batchCacheOperations",
          message: "delete operation should not have an associated response"
        });
        if (__privateMethod(this, _Cache_instances, queryCache_fn).call(this, operation.request, operation.options, addedItems).length) throw new DOMException("???", "InvalidStateError");
        let requestResponses;
        if (operation.type === "delete") {
          if (requestResponses = __privateMethod(this, _Cache_instances, queryCache_fn).call(this, operation.request, operation.options), requestResponses.length === 0) return [];
          for (let requestResponse of requestResponses) {
            let idx = cache.indexOf(requestResponse);
            assert(idx !== -1), cache.splice(idx, 1);
          }
        } else if (operation.type === "put") {
          if (operation.response == null) throw webidl.errors.exception({
            header: "Cache.#batchCacheOperations",
            message: "put operation should have an associated response"
          });
          let r = operation.request;
          if (!urlIsHttpHttpsScheme(r.url)) throw webidl.errors.exception({
            header: "Cache.#batchCacheOperations",
            message: "expected http or https scheme"
          });
          if (r.method !== "GET") throw webidl.errors.exception({
            header: "Cache.#batchCacheOperations",
            message: "not get method"
          });
          if (operation.options != null) throw webidl.errors.exception({
            header: "Cache.#batchCacheOperations",
            message: "options must not be defined"
          });
          requestResponses = __privateMethod(this, _Cache_instances, queryCache_fn).call(this, operation.request);
          for (let requestResponse of requestResponses) {
            let idx = cache.indexOf(requestResponse);
            assert(idx !== -1), cache.splice(idx, 1);
          }
          cache.push([operation.request, operation.response]), addedItems.push([operation.request, operation.response]);
        }
        resultList.push([operation.request, operation.response]);
      }
      return resultList;
    } catch (e) {
      throw __privateGet(this, _relevantRequestResponseList).length = 0, __privateSet(this, _relevantRequestResponseList, backupCache), e;
    }
  }, "#batchCacheOperations"), queryCache_fn = __name(function (requestQuery, options, targetStorage) {
    let resultList = [],
      storage = targetStorage != null ? targetStorage : __privateGet(this, _relevantRequestResponseList);
    for (let requestResponse of storage) {
      let [cachedRequest, cachedResponse] = requestResponse;
      __privateMethod(this, _Cache_instances, requestMatchesCachedItem_fn).call(this, requestQuery, cachedRequest, cachedResponse, options) && resultList.push(requestResponse);
    }
    return resultList;
  }, "#queryCache"), requestMatchesCachedItem_fn = __name(function (requestQuery, request, response = null, options) {
    let queryURL = new URL(requestQuery.url),
      cachedURL = new URL(request.url);
    if (options != null && options.ignoreSearch && (cachedURL.search = "", queryURL.search = ""), !urlEquals(queryURL, cachedURL, !0)) return !1;
    if (response == null || options != null && options.ignoreVary || !response.headersList.contains("vary")) return !0;
    let fieldValues = getFieldValues(response.headersList.get("vary"));
    for (let fieldValue of fieldValues) {
      if (fieldValue === "*") return !1;
      let requestValue = request.headersList.get(fieldValue),
        queryValue = requestQuery.headersList.get(fieldValue);
      if (requestValue !== queryValue) return !1;
    }
    return !0;
  }, "#requestMatchesCachedItem"), internalMatchAll_fn = __name(function (request, options, maxResponses = 1 / 0) {
    let r = null;
    if (request !== void 0) if (request instanceof Request) {
      if (r = request[kState], r.method !== "GET" && !options.ignoreMethod) return [];
    } else typeof request == "string" && (r = new Request(request)[kState]);
    let responses = [];
    if (request === void 0) for (let requestResponse of __privateGet(this, _relevantRequestResponseList)) responses.push(requestResponse[1]);else {
      let requestResponses = __privateMethod(this, _Cache_instances, queryCache_fn).call(this, r, options);
      for (let requestResponse of requestResponses) responses.push(requestResponse[1]);
    }
    let responseList = [];
    for (let response of responses) {
      let responseObject = fromInnerResponse(response, "immutable");
      if (responseList.push(responseObject.clone()), responseList.length >= maxResponses) break;
    }
    return Object.freeze(responseList);
  }, "#internalMatchAll"), __name(_Cache, "Cache");
  var Cache = _Cache;
  Object.defineProperties(Cache.prototype, {
    [Symbol.toStringTag]: {
      value: "Cache",
      configurable: !0
    },
    match: kEnumerableProperty,
    matchAll: kEnumerableProperty,
    add: kEnumerableProperty,
    addAll: kEnumerableProperty,
    put: kEnumerableProperty,
    delete: kEnumerableProperty,
    keys: kEnumerableProperty
  });
  var cacheQueryOptionConverters = [{
    key: "ignoreSearch",
    converter: webidl.converters.boolean,
    defaultValue: __name(() => !1, "defaultValue")
  }, {
    key: "ignoreMethod",
    converter: webidl.converters.boolean,
    defaultValue: __name(() => !1, "defaultValue")
  }, {
    key: "ignoreVary",
    converter: webidl.converters.boolean,
    defaultValue: __name(() => !1, "defaultValue")
  }];
  webidl.converters.CacheQueryOptions = webidl.dictionaryConverter(cacheQueryOptionConverters);
  webidl.converters.MultiCacheQueryOptions = webidl.dictionaryConverter([...cacheQueryOptionConverters, {
    key: "cacheName",
    converter: webidl.converters.DOMString
  }]);
  webidl.converters.Response = webidl.interfaceConverter(Response);
  webidl.converters["sequence<RequestInfo>"] = webidl.sequenceConverter(webidl.converters.RequestInfo);
  module.exports = {
    Cache: Cache
  };
});