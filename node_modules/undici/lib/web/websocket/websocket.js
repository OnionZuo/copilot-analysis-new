var require_websocket = __commonJSMin((exports, module) => {
  "use strict";

  var {
      webidl: webidl
    } = Gc(),
    {
      URLSerializer: URLSerializer
    } = zA(),
    {
      environmentSettingsObject: environmentSettingsObject
    } = Lu(),
    {
      staticPropertyDescriptors: staticPropertyDescriptors,
      states: states,
      sentCloseFrameState: sentCloseFrameState,
      sendHints: sendHints
    } = Px(),
    {
      kWebSocketURL: kWebSocketURL,
      kReadyState: kReadyState,
      kController: kController,
      kBinaryType: kBinaryType,
      kResponse: kResponse,
      kSentClose: kSentClose,
      kByteParser: kByteParser
    } = F9(),
    {
      isConnecting: isConnecting,
      isEstablished: isEstablished,
      isClosing: isClosing,
      isValidSubprotocol: isValidSubprotocol,
      fireEvent: fireEvent
    } = R9(),
    {
      establishWebSocketConnection: establishWebSocketConnection,
      closeWebSocketConnection: closeWebSocketConnection
    } = Cse(),
    {
      ByteParser: ByteParser
    } = yPe(),
    {
      kEnumerableProperty: kEnumerableProperty,
      isBlobLike: isBlobLike
    } = oi(),
    {
      getGlobalDispatcher: getGlobalDispatcher
    } = GM(),
    {
      types: types
    } = require("util"),
    {
      ErrorEvent: ErrorEvent,
      CloseEvent: CloseEvent
    } = LI(),
    {
      SendQueue: SendQueue
    } = EPe(),
    _events,
    _bufferedAmount,
    _protocol,
    _extensions,
    _sendQueue,
    _WebSocket_instances,
    onConnectionEstablished_fn,
    _WebSocket = class _WebSocket extends EventTarget {
      constructor(url, protocols = []) {
        super();
        __privateAdd(this, _WebSocket_instances);
        __privateAdd(this, _events, {
          open: null,
          error: null,
          close: null,
          message: null
        });
        __privateAdd(this, _bufferedAmount, 0);
        __privateAdd(this, _protocol, "");
        __privateAdd(this, _extensions, "");
        __privateAdd(this, _sendQueue);
        webidl.util.markAsUncloneable(this);
        let prefix = "WebSocket constructor";
        webidl.argumentLengthCheck(arguments, 1, prefix);
        let options = webidl.converters["DOMString or sequence<DOMString> or WebSocketInit"](protocols, prefix, "options");
        url = webidl.converters.USVString(url, prefix, "url"), protocols = options.protocols;
        let baseURL = environmentSettingsObject.settingsObject.baseUrl,
          urlRecord;
        try {
          urlRecord = new URL(url, baseURL);
        } catch (e) {
          throw new DOMException(e, "SyntaxError");
        }
        if (urlRecord.protocol === "http:" ? urlRecord.protocol = "ws:" : urlRecord.protocol === "https:" && (urlRecord.protocol = "wss:"), urlRecord.protocol !== "ws:" && urlRecord.protocol !== "wss:") throw new DOMException(`Expected a ws: or wss: protocol, got ${urlRecord.protocol}`, "SyntaxError");
        if (urlRecord.hash || urlRecord.href.endsWith("#")) throw new DOMException("Got fragment", "SyntaxError");
        if (typeof protocols == "string" && (protocols = [protocols]), protocols.length !== new Set(protocols.map(p => p.toLowerCase())).size) throw new DOMException("Invalid Sec-WebSocket-Protocol value", "SyntaxError");
        if (protocols.length > 0 && !protocols.every(p => isValidSubprotocol(p))) throw new DOMException("Invalid Sec-WebSocket-Protocol value", "SyntaxError");
        this[kWebSocketURL] = new URL(urlRecord.href);
        let client = environmentSettingsObject.settingsObject;
        this[kController] = establishWebSocketConnection(urlRecord, protocols, client, this, (response, extensions) => __privateMethod(this, _WebSocket_instances, onConnectionEstablished_fn).call(this, response, extensions), options), this[kReadyState] = _WebSocket.CONNECTING, this[kSentClose] = sentCloseFrameState.NOT_SENT, this[kBinaryType] = "blob";
      }
      close(code = void 0, reason = void 0) {
        webidl.brandCheck(this, _WebSocket);
        let prefix = "WebSocket.close";
        if (code !== void 0 && (code = webidl.converters["unsigned short"](code, prefix, "code", {
          clamp: !0
        })), reason !== void 0 && (reason = webidl.converters.USVString(reason, prefix, "reason")), code !== void 0 && code !== 1e3 && (code < 3e3 || code > 4999)) throw new DOMException("invalid code", "InvalidAccessError");
        let reasonByteLength = 0;
        if (reason !== void 0 && (reasonByteLength = Buffer.byteLength(reason), reasonByteLength > 123)) throw new DOMException(`Reason must be less than 123 bytes; received ${reasonByteLength}`, "SyntaxError");
        closeWebSocketConnection(this, code, reason, reasonByteLength);
      }
      send(data) {
        webidl.brandCheck(this, _WebSocket);
        let prefix = "WebSocket.send";
        if (webidl.argumentLengthCheck(arguments, 1, prefix), data = webidl.converters.WebSocketSendData(data, prefix, "data"), isConnecting(this)) throw new DOMException("Sent before connected.", "InvalidStateError");
        if (!(!isEstablished(this) || isClosing(this))) if (typeof data == "string") {
          let length = Buffer.byteLength(data);
          __privateSet(this, _bufferedAmount, __privateGet(this, _bufferedAmount) + length), __privateGet(this, _sendQueue).add(data, () => {
            __privateSet(this, _bufferedAmount, __privateGet(this, _bufferedAmount) - length);
          }, sendHints.string);
        } else types.isArrayBuffer(data) ? (__privateSet(this, _bufferedAmount, __privateGet(this, _bufferedAmount) + data.byteLength), __privateGet(this, _sendQueue).add(data, () => {
          __privateSet(this, _bufferedAmount, __privateGet(this, _bufferedAmount) - data.byteLength);
        }, sendHints.arrayBuffer)) : ArrayBuffer.isView(data) ? (__privateSet(this, _bufferedAmount, __privateGet(this, _bufferedAmount) + data.byteLength), __privateGet(this, _sendQueue).add(data, () => {
          __privateSet(this, _bufferedAmount, __privateGet(this, _bufferedAmount) - data.byteLength);
        }, sendHints.typedArray)) : isBlobLike(data) && (__privateSet(this, _bufferedAmount, __privateGet(this, _bufferedAmount) + data.size), __privateGet(this, _sendQueue).add(data, () => {
          __privateSet(this, _bufferedAmount, __privateGet(this, _bufferedAmount) - data.size);
        }, sendHints.blob));
      }
      get readyState() {
        return webidl.brandCheck(this, _WebSocket), this[kReadyState];
      }
      get bufferedAmount() {
        return webidl.brandCheck(this, _WebSocket), __privateGet(this, _bufferedAmount);
      }
      get url() {
        return webidl.brandCheck(this, _WebSocket), URLSerializer(this[kWebSocketURL]);
      }
      get extensions() {
        return webidl.brandCheck(this, _WebSocket), __privateGet(this, _extensions);
      }
      get protocol() {
        return webidl.brandCheck(this, _WebSocket), __privateGet(this, _protocol);
      }
      get onopen() {
        return webidl.brandCheck(this, _WebSocket), __privateGet(this, _events).open;
      }
      set onopen(fn) {
        webidl.brandCheck(this, _WebSocket), __privateGet(this, _events).open && this.removeEventListener("open", __privateGet(this, _events).open), typeof fn == "function" ? (__privateGet(this, _events).open = fn, this.addEventListener("open", fn)) : __privateGet(this, _events).open = null;
      }
      get onerror() {
        return webidl.brandCheck(this, _WebSocket), __privateGet(this, _events).error;
      }
      set onerror(fn) {
        webidl.brandCheck(this, _WebSocket), __privateGet(this, _events).error && this.removeEventListener("error", __privateGet(this, _events).error), typeof fn == "function" ? (__privateGet(this, _events).error = fn, this.addEventListener("error", fn)) : __privateGet(this, _events).error = null;
      }
      get onclose() {
        return webidl.brandCheck(this, _WebSocket), __privateGet(this, _events).close;
      }
      set onclose(fn) {
        webidl.brandCheck(this, _WebSocket), __privateGet(this, _events).close && this.removeEventListener("close", __privateGet(this, _events).close), typeof fn == "function" ? (__privateGet(this, _events).close = fn, this.addEventListener("close", fn)) : __privateGet(this, _events).close = null;
      }
      get onmessage() {
        return webidl.brandCheck(this, _WebSocket), __privateGet(this, _events).message;
      }
      set onmessage(fn) {
        webidl.brandCheck(this, _WebSocket), __privateGet(this, _events).message && this.removeEventListener("message", __privateGet(this, _events).message), typeof fn == "function" ? (__privateGet(this, _events).message = fn, this.addEventListener("message", fn)) : __privateGet(this, _events).message = null;
      }
      get binaryType() {
        return webidl.brandCheck(this, _WebSocket), this[kBinaryType];
      }
      set binaryType(type) {
        webidl.brandCheck(this, _WebSocket), type !== "blob" && type !== "arraybuffer" ? this[kBinaryType] = "blob" : this[kBinaryType] = type;
      }
    };
  _events = new WeakMap(), _bufferedAmount = new WeakMap(), _protocol = new WeakMap(), _extensions = new WeakMap(), _sendQueue = new WeakMap(), _WebSocket_instances = new WeakSet(), onConnectionEstablished_fn = __name(function (response, parsedExtensions) {
    this[kResponse] = response;
    let parser = new ByteParser(this, parsedExtensions);
    parser.on("drain", onParserDrain), parser.on("error", onParserError.bind(this)), response.socket.ws = this, this[kByteParser] = parser, __privateSet(this, _sendQueue, new SendQueue(response.socket)), this[kReadyState] = states.OPEN;
    let extensions = response.headersList.get("sec-websocket-extensions");
    extensions !== null && __privateSet(this, _extensions, extensions);
    let protocol = response.headersList.get("sec-websocket-protocol");
    protocol !== null && __privateSet(this, _protocol, protocol), fireEvent("open", this);
  }, "#onConnectionEstablished"), __name(_WebSocket, "WebSocket");
  var WebSocket = _WebSocket;
  WebSocket.CONNECTING = WebSocket.prototype.CONNECTING = states.CONNECTING;
  WebSocket.OPEN = WebSocket.prototype.OPEN = states.OPEN;
  WebSocket.CLOSING = WebSocket.prototype.CLOSING = states.CLOSING;
  WebSocket.CLOSED = WebSocket.prototype.CLOSED = states.CLOSED;
  Object.defineProperties(WebSocket.prototype, {
    CONNECTING: staticPropertyDescriptors,
    OPEN: staticPropertyDescriptors,
    CLOSING: staticPropertyDescriptors,
    CLOSED: staticPropertyDescriptors,
    url: kEnumerableProperty,
    readyState: kEnumerableProperty,
    bufferedAmount: kEnumerableProperty,
    onopen: kEnumerableProperty,
    onerror: kEnumerableProperty,
    onclose: kEnumerableProperty,
    close: kEnumerableProperty,
    onmessage: kEnumerableProperty,
    binaryType: kEnumerableProperty,
    send: kEnumerableProperty,
    extensions: kEnumerableProperty,
    protocol: kEnumerableProperty,
    [Symbol.toStringTag]: {
      value: "WebSocket",
      writable: !1,
      enumerable: !1,
      configurable: !0
    }
  });
  Object.defineProperties(WebSocket, {
    CONNECTING: staticPropertyDescriptors,
    OPEN: staticPropertyDescriptors,
    CLOSING: staticPropertyDescriptors,
    CLOSED: staticPropertyDescriptors
  });
  webidl.converters["sequence<DOMString>"] = webidl.sequenceConverter(webidl.converters.DOMString);
  webidl.converters["DOMString or sequence<DOMString>"] = function (V, prefix, argument) {
    return webidl.util.Type(V) === "Object" && Symbol.iterator in V ? webidl.converters["sequence<DOMString>"](V) : webidl.converters.DOMString(V, prefix, argument);
  };
  webidl.converters.WebSocketInit = webidl.dictionaryConverter([{
    key: "protocols",
    converter: webidl.converters["DOMString or sequence<DOMString>"],
    defaultValue: __name(() => new Array(0), "defaultValue")
  }, {
    key: "dispatcher",
    converter: webidl.converters.any,
    defaultValue: __name(() => getGlobalDispatcher(), "defaultValue")
  }, {
    key: "headers",
    converter: webidl.nullableConverter(webidl.converters.HeadersInit)
  }]);
  webidl.converters["DOMString or sequence<DOMString> or WebSocketInit"] = function (V) {
    return webidl.util.Type(V) === "Object" && !(Symbol.iterator in V) ? webidl.converters.WebSocketInit(V) : {
      protocols: webidl.converters["DOMString or sequence<DOMString>"](V)
    };
  };
  webidl.converters.WebSocketSendData = function (V) {
    if (webidl.util.Type(V) === "Object") {
      if (isBlobLike(V)) return webidl.converters.Blob(V, {
        strict: !1
      });
      if (ArrayBuffer.isView(V) || types.isArrayBuffer(V)) return webidl.converters.BufferSource(V);
    }
    return webidl.converters.USVString(V);
  };
  function onParserDrain() {
    this.ws[kResponse].socket.resume();
  }
  __name(onParserDrain, "onParserDrain");
  function onParserError(err) {
    let message, code;
    err instanceof CloseEvent ? (message = err.reason, code = err.code) : message = err.message, fireEvent("error", this, () => new ErrorEvent("error", {
      error: err,
      message: message
    })), closeWebSocketConnection(this, code);
  }
  __name(onParserError, "onParserError");
  module.exports = {
    WebSocket: WebSocket
  };
});