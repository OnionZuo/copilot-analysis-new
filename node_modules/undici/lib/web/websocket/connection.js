var require_connection = __commonJSMin((exports, module) => {
  "use strict";

  var {
      uid: uid,
      states: states,
      sentCloseFrameState: sentCloseFrameState,
      emptyBuffer: emptyBuffer,
      opcodes: opcodes
    } = Px(),
    {
      kReadyState: kReadyState,
      kSentClose: kSentClose,
      kByteParser: kByteParser,
      kReceivedClose: kReceivedClose,
      kResponse: kResponse
    } = F9(),
    {
      fireEvent: fireEvent,
      failWebsocketConnection: failWebsocketConnection,
      isClosing: isClosing,
      isClosed: isClosed,
      isEstablished: isEstablished,
      parseExtensions: parseExtensions
    } = R9(),
    {
      channels: channels
    } = Sv(),
    {
      CloseEvent: CloseEvent
    } = LI(),
    {
      makeRequest: makeRequest
    } = vI(),
    {
      fetching: fetching
    } = I9(),
    {
      Headers: Headers,
      getHeadersList: getHeadersList
    } = Dx(),
    {
      getDecodeSplit: getDecodeSplit
    } = Lu(),
    {
      WebsocketFrameSend: WebsocketFrameSend
    } = I7(),
    crypto;
  try {
    crypto = require("crypto");
  } catch {}
  function establishWebSocketConnection(url, protocols, client, ws, onEstablish, options) {
    let requestURL = url;
    requestURL.protocol = url.protocol === "ws:" ? "http:" : "https:";
    let request = makeRequest({
      urlList: [requestURL],
      client: client,
      serviceWorkers: "none",
      referrer: "no-referrer",
      mode: "websocket",
      credentials: "include",
      cache: "no-store",
      redirect: "error"
    });
    if (options.headers) {
      let headersList = getHeadersList(new Headers(options.headers));
      request.headersList = headersList;
    }
    let keyValue = crypto.randomBytes(16).toString("base64");
    request.headersList.append("sec-websocket-key", keyValue), request.headersList.append("sec-websocket-version", "13");
    for (let protocol of protocols) request.headersList.append("sec-websocket-protocol", protocol);
    return request.headersList.append("sec-websocket-extensions", "permessage-deflate; client_max_window_bits"), fetching({
      request: request,
      useParallelQueue: !0,
      dispatcher: options.dispatcher,
      processResponse(response) {
        var _a, _b;
        if (response.type === "error" || response.status !== 101) {
          failWebsocketConnection(ws, "Received network error or non-101 status code.");
          return;
        }
        if (protocols.length !== 0 && !response.headersList.get("Sec-WebSocket-Protocol")) {
          failWebsocketConnection(ws, "Server did not respond with sent protocols.");
          return;
        }
        if (((_a = response.headersList.get("Upgrade")) == null ? void 0 : _a.toLowerCase()) !== "websocket") {
          failWebsocketConnection(ws, 'Server did not set Upgrade header to "websocket".');
          return;
        }
        if (((_b = response.headersList.get("Connection")) == null ? void 0 : _b.toLowerCase()) !== "upgrade") {
          failWebsocketConnection(ws, 'Server did not set Connection header to "upgrade".');
          return;
        }
        let secWSAccept = response.headersList.get("Sec-WebSocket-Accept"),
          digest = crypto.createHash("sha1").update(keyValue + uid).digest("base64");
        if (secWSAccept !== digest) {
          failWebsocketConnection(ws, "Incorrect hash received in Sec-WebSocket-Accept header.");
          return;
        }
        let secExtension = response.headersList.get("Sec-WebSocket-Extensions"),
          extensions;
        if (secExtension !== null && (extensions = parseExtensions(secExtension), !extensions.has("permessage-deflate"))) {
          failWebsocketConnection(ws, "Sec-WebSocket-Extensions header does not match.");
          return;
        }
        let secProtocol = response.headersList.get("Sec-WebSocket-Protocol");
        if (secProtocol !== null && !getDecodeSplit("sec-websocket-protocol", request.headersList).includes(secProtocol)) {
          failWebsocketConnection(ws, "Protocol was not set in the opening handshake.");
          return;
        }
        response.socket.on("data", onSocketData), response.socket.on("close", onSocketClose), response.socket.on("error", onSocketError), channels.open.hasSubscribers && channels.open.publish({
          address: response.socket.address(),
          protocol: secProtocol,
          extensions: secExtension
        }), onEstablish(response, extensions);
      }
    });
  }
  __name(establishWebSocketConnection, "establishWebSocketConnection");
  function closeWebSocketConnection(ws, code, reason, reasonByteLength) {
    if (!(isClosing(ws) || isClosed(ws))) if (!isEstablished(ws)) failWebsocketConnection(ws, "Connection was closed before it was established."), ws[kReadyState] = states.CLOSING;else if (ws[kSentClose] === sentCloseFrameState.NOT_SENT) {
      ws[kSentClose] = sentCloseFrameState.PROCESSING;
      let frame = new WebsocketFrameSend();
      code !== void 0 && reason === void 0 ? (frame.frameData = Buffer.allocUnsafe(2), frame.frameData.writeUInt16BE(code, 0)) : code !== void 0 && reason !== void 0 ? (frame.frameData = Buffer.allocUnsafe(2 + reasonByteLength), frame.frameData.writeUInt16BE(code, 0), frame.frameData.write(reason, 2, "utf-8")) : frame.frameData = emptyBuffer, ws[kResponse].socket.write(frame.createFrame(opcodes.CLOSE)), ws[kSentClose] = sentCloseFrameState.SENT, ws[kReadyState] = states.CLOSING;
    } else ws[kReadyState] = states.CLOSING;
  }
  __name(closeWebSocketConnection, "closeWebSocketConnection");
  function onSocketData(chunk) {
    this.ws[kByteParser].write(chunk) || this.pause();
  }
  __name(onSocketData, "onSocketData");
  function onSocketClose() {
    var _a;
    let {
        ws: ws
      } = this,
      {
        [kResponse]: response
      } = ws;
    response.socket.off("data", onSocketData), response.socket.off("close", onSocketClose), response.socket.off("error", onSocketError);
    let wasClean = ws[kSentClose] === sentCloseFrameState.SENT && ws[kReceivedClose],
      code = 1005,
      reason = "",
      result = ws[kByteParser].closingInfo;
    result && !result.error ? (code = (_a = result.code) != null ? _a : 1005, reason = result.reason) : ws[kReceivedClose] || (code = 1006), ws[kReadyState] = states.CLOSED, fireEvent("close", ws, (type, init) => new CloseEvent(type, init), {
      wasClean: wasClean,
      code: code,
      reason: reason
    }), channels.close.hasSubscribers && channels.close.publish({
      websocket: ws,
      code: code,
      reason: reason
    });
  }
  __name(onSocketClose, "onSocketClose");
  function onSocketError(error) {
    let {
      ws: ws
    } = this;
    ws[kReadyState] = states.CLOSING, channels.socketError.hasSubscribers && channels.socketError.publish(error), this.destroy();
  }
  __name(onSocketError, "onSocketError");
  module.exports = {
    establishWebSocketConnection: establishWebSocketConnection,
    closeWebSocketConnection: closeWebSocketConnection
  };
});