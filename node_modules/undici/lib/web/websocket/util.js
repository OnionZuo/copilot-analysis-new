var require_util = __commonJSMin((exports, module) => {
  "use strict";

  var {
      kReadyState: kReadyState,
      kController: kController,
      kResponse: kResponse,
      kBinaryType: kBinaryType,
      kWebSocketURL: kWebSocketURL
    } = F9(),
    {
      states: states,
      opcodes: opcodes
    } = Px(),
    {
      ErrorEvent: ErrorEvent,
      createFastMessageEvent: createFastMessageEvent
    } = LI(),
    {
      isUtf8: isUtf8
    } = require("buffer"),
    {
      collectASequenceOfCodePointsFast: collectASequenceOfCodePointsFast,
      removeHTTPWhitespace: removeHTTPWhitespace
    } = zA();
  function isConnecting(ws) {
    return ws[kReadyState] === states.CONNECTING;
  }
  __name(isConnecting, "isConnecting");
  function isEstablished(ws) {
    return ws[kReadyState] === states.OPEN;
  }
  __name(isEstablished, "isEstablished");
  function isClosing(ws) {
    return ws[kReadyState] === states.CLOSING;
  }
  __name(isClosing, "isClosing");
  function isClosed(ws) {
    return ws[kReadyState] === states.CLOSED;
  }
  __name(isClosed, "isClosed");
  function fireEvent(e, target, eventFactory = (type, init) => new Event(type, init), eventInitDict = {}) {
    let event = eventFactory(e, eventInitDict);
    target.dispatchEvent(event);
  }
  __name(fireEvent, "fireEvent");
  function websocketMessageReceived(ws, type, data) {
    if (ws[kReadyState] !== states.OPEN) return;
    let dataForEvent;
    if (type === opcodes.TEXT) try {
      dataForEvent = utf8Decode(data);
    } catch {
      failWebsocketConnection(ws, "Received invalid UTF-8 in text frame.");
      return;
    } else type === opcodes.BINARY && (ws[kBinaryType] === "blob" ? dataForEvent = new Blob([data]) : dataForEvent = toArrayBuffer(data));
    fireEvent("message", ws, createFastMessageEvent, {
      origin: ws[kWebSocketURL].origin,
      data: dataForEvent
    });
  }
  __name(websocketMessageReceived, "websocketMessageReceived");
  function toArrayBuffer(buffer) {
    return buffer.byteLength === buffer.buffer.byteLength ? buffer.buffer : buffer.buffer.slice(buffer.byteOffset, buffer.byteOffset + buffer.byteLength);
  }
  __name(toArrayBuffer, "toArrayBuffer");
  function isValidSubprotocol(protocol) {
    if (protocol.length === 0) return !1;
    for (let i = 0; i < protocol.length; ++i) {
      let code = protocol.charCodeAt(i);
      if (code < 33 || code > 126 || code === 34 || code === 40 || code === 41 || code === 44 || code === 47 || code === 58 || code === 59 || code === 60 || code === 61 || code === 62 || code === 63 || code === 64 || code === 91 || code === 92 || code === 93 || code === 123 || code === 125) return !1;
    }
    return !0;
  }
  __name(isValidSubprotocol, "isValidSubprotocol");
  function isValidStatusCode(code) {
    return code >= 1e3 && code < 1015 ? code !== 1004 && code !== 1005 && code !== 1006 : code >= 3e3 && code <= 4999;
  }
  __name(isValidStatusCode, "isValidStatusCode");
  function failWebsocketConnection(ws, reason) {
    let {
      [kController]: controller,
      [kResponse]: response
    } = ws;
    controller.abort(), response != null && response.socket && !response.socket.destroyed && response.socket.destroy(), reason && fireEvent("error", ws, (type, init) => new ErrorEvent(type, init), {
      error: new Error(reason),
      message: reason
    });
  }
  __name(failWebsocketConnection, "failWebsocketConnection");
  function isControlFrame(opcode) {
    return opcode === opcodes.CLOSE || opcode === opcodes.PING || opcode === opcodes.PONG;
  }
  __name(isControlFrame, "isControlFrame");
  function isContinuationFrame(opcode) {
    return opcode === opcodes.CONTINUATION;
  }
  __name(isContinuationFrame, "isContinuationFrame");
  function isTextBinaryFrame(opcode) {
    return opcode === opcodes.TEXT || opcode === opcodes.BINARY;
  }
  __name(isTextBinaryFrame, "isTextBinaryFrame");
  function isValidOpcode(opcode) {
    return isTextBinaryFrame(opcode) || isContinuationFrame(opcode) || isControlFrame(opcode);
  }
  __name(isValidOpcode, "isValidOpcode");
  function parseExtensions(extensions) {
    let position = {
        position: 0
      },
      extensionList = new Map();
    for (; position.position < extensions.length;) {
      let pair = collectASequenceOfCodePointsFast(";", extensions, position),
        [name, value = ""] = pair.split("=");
      extensionList.set(removeHTTPWhitespace(name, !0, !1), removeHTTPWhitespace(value, !1, !0)), position.position++;
    }
    return extensionList;
  }
  __name(parseExtensions, "parseExtensions");
  function isValidClientWindowBits(value) {
    for (let i = 0; i < value.length; i++) {
      let byte = value.charCodeAt(i);
      if (byte < 48 || byte > 57) return !1;
    }
    return !0;
  }
  __name(isValidClientWindowBits, "isValidClientWindowBits");
  var hasIntl = typeof process.versions.icu == "string",
    fatalDecoder = hasIntl ? new TextDecoder("utf-8", {
      fatal: !0
    }) : void 0,
    utf8Decode = hasIntl ? fatalDecoder.decode.bind(fatalDecoder) : function (buffer) {
      if (isUtf8(buffer)) return buffer.toString("utf-8");
      throw new TypeError("Invalid utf-8 received.");
    };
  module.exports = {
    isConnecting: isConnecting,
    isEstablished: isEstablished,
    isClosing: isClosing,
    isClosed: isClosed,
    fireEvent: fireEvent,
    isValidSubprotocol: isValidSubprotocol,
    isValidStatusCode: isValidStatusCode,
    failWebsocketConnection: failWebsocketConnection,
    websocketMessageReceived: websocketMessageReceived,
    utf8Decode: utf8Decode,
    isControlFrame: isControlFrame,
    isContinuationFrame: isContinuationFrame,
    isTextBinaryFrame: isTextBinaryFrame,
    isValidOpcode: isValidOpcode,
    parseExtensions: parseExtensions,
    isValidClientWindowBits: isValidClientWindowBits
  };
});