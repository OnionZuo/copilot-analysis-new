var require_receiver = __commonJSMin((exports, module) => {
  "use strict";

  var {
      Writable: Writable
    } = require("stream"),
    assert = require("assert"),
    {
      parserStates: parserStates,
      opcodes: opcodes,
      states: states,
      emptyBuffer: emptyBuffer,
      sentCloseFrameState: sentCloseFrameState
    } = Px(),
    {
      kReadyState: kReadyState,
      kSentClose: kSentClose,
      kResponse: kResponse,
      kReceivedClose: kReceivedClose
    } = F9(),
    {
      channels: channels
    } = Sv(),
    {
      isValidStatusCode: isValidStatusCode,
      isValidOpcode: isValidOpcode,
      failWebsocketConnection: failWebsocketConnection,
      websocketMessageReceived: websocketMessageReceived,
      utf8Decode: utf8Decode,
      isControlFrame: isControlFrame,
      isTextBinaryFrame: isTextBinaryFrame,
      isContinuationFrame: isContinuationFrame
    } = R9(),
    {
      WebsocketFrameSend: WebsocketFrameSend
    } = I7(),
    {
      closeWebSocketConnection: closeWebSocketConnection
    } = Cse(),
    {
      PerMessageDeflate: PerMessageDeflate
    } = cPe(),
    _buffers,
    _byteOffset,
    _loop,
    _state,
    _info,
    _fragments,
    _extensions,
    _ByteParser = class _ByteParser extends Writable {
      constructor(ws, extensions) {
        super();
        __privateAdd(this, _buffers, []);
        __privateAdd(this, _byteOffset, 0);
        __privateAdd(this, _loop, !1);
        __privateAdd(this, _state, parserStates.INFO);
        __privateAdd(this, _info, {});
        __privateAdd(this, _fragments, []);
        __privateAdd(this, _extensions);
        this.ws = ws, __privateSet(this, _extensions, extensions == null ? new Map() : extensions), __privateGet(this, _extensions).has("permessage-deflate") && __privateGet(this, _extensions).set("permessage-deflate", new PerMessageDeflate(extensions));
      }
      _write(chunk, _, callback) {
        __privateGet(this, _buffers).push(chunk), __privateSet(this, _byteOffset, __privateGet(this, _byteOffset) + chunk.length), __privateSet(this, _loop, !0), this.run(callback);
      }
      run(callback) {
        for (; __privateGet(this, _loop);) if (__privateGet(this, _state) === parserStates.INFO) {
          if (__privateGet(this, _byteOffset) < 2) return callback();
          let buffer = this.consume(2),
            fin = (buffer[0] & 128) !== 0,
            opcode = buffer[0] & 15,
            masked = (buffer[1] & 128) === 128,
            fragmented = !fin && opcode !== opcodes.CONTINUATION,
            payloadLength = buffer[1] & 127,
            rsv1 = buffer[0] & 64,
            rsv2 = buffer[0] & 32,
            rsv3 = buffer[0] & 16;
          if (!isValidOpcode(opcode)) return failWebsocketConnection(this.ws, "Invalid opcode received"), callback();
          if (masked) return failWebsocketConnection(this.ws, "Frame cannot be masked"), callback();
          if (rsv1 !== 0 && !__privateGet(this, _extensions).has("permessage-deflate")) {
            failWebsocketConnection(this.ws, "Expected RSV1 to be clear.");
            return;
          }
          if (rsv2 !== 0 || rsv3 !== 0) {
            failWebsocketConnection(this.ws, "RSV1, RSV2, RSV3 must be clear");
            return;
          }
          if (fragmented && !isTextBinaryFrame(opcode)) {
            failWebsocketConnection(this.ws, "Invalid frame type was fragmented.");
            return;
          }
          if (isTextBinaryFrame(opcode) && __privateGet(this, _fragments).length > 0) {
            failWebsocketConnection(this.ws, "Expected continuation frame");
            return;
          }
          if (__privateGet(this, _info).fragmented && fragmented) {
            failWebsocketConnection(this.ws, "Fragmented frame exceeded 125 bytes.");
            return;
          }
          if ((payloadLength > 125 || fragmented) && isControlFrame(opcode)) {
            failWebsocketConnection(this.ws, "Control frame either too large or fragmented");
            return;
          }
          if (isContinuationFrame(opcode) && __privateGet(this, _fragments).length === 0 && !__privateGet(this, _info).compressed) {
            failWebsocketConnection(this.ws, "Unexpected continuation frame");
            return;
          }
          payloadLength <= 125 ? (__privateGet(this, _info).payloadLength = payloadLength, __privateSet(this, _state, parserStates.READ_DATA)) : payloadLength === 126 ? __privateSet(this, _state, parserStates.PAYLOADLENGTH_16) : payloadLength === 127 && __privateSet(this, _state, parserStates.PAYLOADLENGTH_64), isTextBinaryFrame(opcode) && (__privateGet(this, _info).binaryType = opcode, __privateGet(this, _info).compressed = rsv1 !== 0), __privateGet(this, _info).opcode = opcode, __privateGet(this, _info).masked = masked, __privateGet(this, _info).fin = fin, __privateGet(this, _info).fragmented = fragmented;
        } else if (__privateGet(this, _state) === parserStates.PAYLOADLENGTH_16) {
          if (__privateGet(this, _byteOffset) < 2) return callback();
          let buffer = this.consume(2);
          __privateGet(this, _info).payloadLength = buffer.readUInt16BE(0), __privateSet(this, _state, parserStates.READ_DATA);
        } else if (__privateGet(this, _state) === parserStates.PAYLOADLENGTH_64) {
          if (__privateGet(this, _byteOffset) < 8) return callback();
          let buffer = this.consume(8),
            upper = buffer.readUInt32BE(0);
          if (upper > 2 ** 31 - 1) {
            failWebsocketConnection(this.ws, "Received payload length > 2^31 bytes.");
            return;
          }
          let lower = buffer.readUInt32BE(4);
          __privateGet(this, _info).payloadLength = (upper << 8) + lower, __privateSet(this, _state, parserStates.READ_DATA);
        } else if (__privateGet(this, _state) === parserStates.READ_DATA) {
          if (__privateGet(this, _byteOffset) < __privateGet(this, _info).payloadLength) return callback();
          let body = this.consume(__privateGet(this, _info).payloadLength);
          if (isControlFrame(__privateGet(this, _info).opcode)) __privateSet(this, _loop, this.parseControlFrame(body)), __privateSet(this, _state, parserStates.INFO);else if (__privateGet(this, _info).compressed) {
            __privateGet(this, _extensions).get("permessage-deflate").decompress(body, __privateGet(this, _info).fin, (error, data) => {
              if (error) {
                closeWebSocketConnection(this.ws, 1007, error.message, error.message.length);
                return;
              }
              if (__privateGet(this, _fragments).push(data), !__privateGet(this, _info).fin) {
                __privateSet(this, _state, parserStates.INFO), __privateSet(this, _loop, !0), this.run(callback);
                return;
              }
              websocketMessageReceived(this.ws, __privateGet(this, _info).binaryType, Buffer.concat(__privateGet(this, _fragments))), __privateSet(this, _loop, !0), __privateSet(this, _state, parserStates.INFO), __privateGet(this, _fragments).length = 0, this.run(callback);
            }), __privateSet(this, _loop, !1);
            break;
          } else {
            if (__privateGet(this, _fragments).push(body), !__privateGet(this, _info).fragmented && __privateGet(this, _info).fin) {
              let fullMessage = Buffer.concat(__privateGet(this, _fragments));
              websocketMessageReceived(this.ws, __privateGet(this, _info).binaryType, fullMessage), __privateGet(this, _fragments).length = 0;
            }
            __privateSet(this, _state, parserStates.INFO);
          }
        }
      }
      consume(n) {
        if (n > __privateGet(this, _byteOffset)) throw new Error("Called consume() before buffers satiated.");
        if (n === 0) return emptyBuffer;
        if (__privateGet(this, _buffers)[0].length === n) return __privateSet(this, _byteOffset, __privateGet(this, _byteOffset) - __privateGet(this, _buffers)[0].length), __privateGet(this, _buffers).shift();
        let buffer = Buffer.allocUnsafe(n),
          offset = 0;
        for (; offset !== n;) {
          let next = __privateGet(this, _buffers)[0],
            {
              length: length
            } = next;
          if (length + offset === n) {
            buffer.set(__privateGet(this, _buffers).shift(), offset);
            break;
          } else if (length + offset > n) {
            buffer.set(next.subarray(0, n - offset), offset), __privateGet(this, _buffers)[0] = next.subarray(n - offset);
            break;
          } else buffer.set(__privateGet(this, _buffers).shift(), offset), offset += next.length;
        }
        return __privateSet(this, _byteOffset, __privateGet(this, _byteOffset) - n), buffer;
      }
      parseCloseBody(data) {
        assert(data.length !== 1);
        let code;
        if (data.length >= 2 && (code = data.readUInt16BE(0)), code !== void 0 && !isValidStatusCode(code)) return {
          code: 1002,
          reason: "Invalid status code",
          error: !0
        };
        let reason = data.subarray(2);
        reason[0] === 239 && reason[1] === 187 && reason[2] === 191 && (reason = reason.subarray(3));
        try {
          reason = utf8Decode(reason);
        } catch {
          return {
            code: 1007,
            reason: "Invalid UTF-8",
            error: !0
          };
        }
        return {
          code: code,
          reason: reason,
          error: !1
        };
      }
      parseControlFrame(body) {
        let {
          opcode: opcode,
          payloadLength: payloadLength
        } = __privateGet(this, _info);
        if (opcode === opcodes.CLOSE) {
          if (payloadLength === 1) return failWebsocketConnection(this.ws, "Received close frame with a 1-byte body."), !1;
          if (__privateGet(this, _info).closeInfo = this.parseCloseBody(body), __privateGet(this, _info).closeInfo.error) {
            let {
              code: code,
              reason: reason
            } = __privateGet(this, _info).closeInfo;
            return closeWebSocketConnection(this.ws, code, reason, reason.length), failWebsocketConnection(this.ws, reason), !1;
          }
          if (this.ws[kSentClose] !== sentCloseFrameState.SENT) {
            let body = emptyBuffer;
            __privateGet(this, _info).closeInfo.code && (body = Buffer.allocUnsafe(2), body.writeUInt16BE(__privateGet(this, _info).closeInfo.code, 0));
            let closeFrame = new WebsocketFrameSend(body);
            this.ws[kResponse].socket.write(closeFrame.createFrame(opcodes.CLOSE), err => {
              err || (this.ws[kSentClose] = sentCloseFrameState.SENT);
            });
          }
          return this.ws[kReadyState] = states.CLOSING, this.ws[kReceivedClose] = !0, !1;
        } else if (opcode === opcodes.PING) {
          if (!this.ws[kReceivedClose]) {
            let frame = new WebsocketFrameSend(body);
            this.ws[kResponse].socket.write(frame.createFrame(opcodes.PONG)), channels.ping.hasSubscribers && channels.ping.publish({
              payload: body
            });
          }
        } else opcode === opcodes.PONG && channels.pong.hasSubscribers && channels.pong.publish({
          payload: body
        });
        return !0;
      }
      get closingInfo() {
        return __privateGet(this, _info).closeInfo;
      }
    };
  _buffers = new WeakMap(), _byteOffset = new WeakMap(), _loop = new WeakMap(), _state = new WeakMap(), _info = new WeakMap(), _fragments = new WeakMap(), _extensions = new WeakMap(), __name(_ByteParser, "ByteParser");
  var ByteParser = _ByteParser;
  module.exports = {
    ByteParser: ByteParser
  };
});