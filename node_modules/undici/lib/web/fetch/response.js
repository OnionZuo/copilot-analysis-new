var require_response = __commonJSMin((exports, module) => {
  "use strict";

  var {
      Headers: Headers,
      HeadersList: HeadersList,
      fill: fill,
      getHeadersGuard: getHeadersGuard,
      setHeadersGuard: setHeadersGuard,
      setHeadersList: setHeadersList
    } = Dx(),
    {
      extractBody: extractBody,
      cloneBody: cloneBody,
      mixinBody: mixinBody,
      hasFinalizationRegistry: hasFinalizationRegistry,
      streamRegistry: streamRegistry,
      bodyUnusable: bodyUnusable
    } = Wv(),
    util = oi(),
    nodeUtil = require("util"),
    {
      kEnumerableProperty: kEnumerableProperty
    } = util,
    {
      isValidReasonPhrase: isValidReasonPhrase,
      isCancelled: isCancelled,
      isAborted: isAborted,
      isBlobLike: isBlobLike,
      serializeJavascriptValueToJSONString: serializeJavascriptValueToJSONString,
      isErrorLike: isErrorLike,
      isomorphicEncode: isomorphicEncode,
      environmentSettingsObject: relevantRealm
    } = Lu(),
    {
      redirectStatusSet: redirectStatusSet,
      nullBodyStatus: nullBodyStatus
    } = O4(),
    {
      kState: kState,
      kHeaders: kHeaders
    } = iw(),
    {
      webidl: webidl
    } = Gc(),
    {
      FormData: FormData
    } = K4(),
    {
      URLSerializer: URLSerializer
    } = zA(),
    {
      kConstruct: kConstruct
    } = fo(),
    assert = require("assert"),
    {
      types: types
    } = require("util"),
    textEncoder = new TextEncoder("utf-8"),
    _Response = class _Response {
      static error() {
        return fromInnerResponse(makeNetworkError(), "immutable");
      }
      static json(data, init = {}) {
        webidl.argumentLengthCheck(arguments, 1, "Response.json"), init !== null && (init = webidl.converters.ResponseInit(init));
        let bytes = textEncoder.encode(serializeJavascriptValueToJSONString(data)),
          body = extractBody(bytes),
          responseObject = fromInnerResponse(makeResponse({}), "response");
        return initializeResponse(responseObject, init, {
          body: body[0],
          type: "application/json"
        }), responseObject;
      }
      static redirect(url, status = 302) {
        webidl.argumentLengthCheck(arguments, 1, "Response.redirect"), url = webidl.converters.USVString(url), status = webidl.converters["unsigned short"](status);
        let parsedURL;
        try {
          parsedURL = new URL(url, relevantRealm.settingsObject.baseUrl);
        } catch (err) {
          throw new TypeError(`Failed to parse URL from ${url}`, {
            cause: err
          });
        }
        if (!redirectStatusSet.has(status)) throw new RangeError(`Invalid status code ${status}`);
        let responseObject = fromInnerResponse(makeResponse({}), "immutable");
        responseObject[kState].status = status;
        let value = isomorphicEncode(URLSerializer(parsedURL));
        return responseObject[kState].headersList.append("location", value, !0), responseObject;
      }
      constructor(body = null, init = {}) {
        if (webidl.util.markAsUncloneable(this), body === kConstruct) return;
        body !== null && (body = webidl.converters.BodyInit(body)), init = webidl.converters.ResponseInit(init), this[kState] = makeResponse({}), this[kHeaders] = new Headers(kConstruct), setHeadersGuard(this[kHeaders], "response"), setHeadersList(this[kHeaders], this[kState].headersList);
        let bodyWithType = null;
        if (body != null) {
          let [extractedBody, type] = extractBody(body);
          bodyWithType = {
            body: extractedBody,
            type: type
          };
        }
        initializeResponse(this, init, bodyWithType);
      }
      get type() {
        return webidl.brandCheck(this, _Response), this[kState].type;
      }
      get url() {
        var _a;
        webidl.brandCheck(this, _Response);
        let urlList = this[kState].urlList,
          url = (_a = urlList[urlList.length - 1]) != null ? _a : null;
        return url === null ? "" : URLSerializer(url, !0);
      }
      get redirected() {
        return webidl.brandCheck(this, _Response), this[kState].urlList.length > 1;
      }
      get status() {
        return webidl.brandCheck(this, _Response), this[kState].status;
      }
      get ok() {
        return webidl.brandCheck(this, _Response), this[kState].status >= 200 && this[kState].status <= 299;
      }
      get statusText() {
        return webidl.brandCheck(this, _Response), this[kState].statusText;
      }
      get headers() {
        return webidl.brandCheck(this, _Response), this[kHeaders];
      }
      get body() {
        return webidl.brandCheck(this, _Response), this[kState].body ? this[kState].body.stream : null;
      }
      get bodyUsed() {
        return webidl.brandCheck(this, _Response), !!this[kState].body && util.isDisturbed(this[kState].body.stream);
      }
      clone() {
        if (webidl.brandCheck(this, _Response), bodyUnusable(this)) throw webidl.errors.exception({
          header: "Response.clone",
          message: "Body has already been consumed."
        });
        let clonedResponse = cloneResponse(this[kState]);
        return fromInnerResponse(clonedResponse, getHeadersGuard(this[kHeaders]));
      }
      [nodeUtil.inspect.custom](depth, options) {
        var _a;
        options.depth === null && (options.depth = 2), (_a = options.colors) != null || (options.colors = !0);
        let properties = {
          status: this.status,
          statusText: this.statusText,
          headers: this.headers,
          body: this.body,
          bodyUsed: this.bodyUsed,
          ok: this.ok,
          redirected: this.redirected,
          type: this.type,
          url: this.url
        };
        return `Response ${nodeUtil.formatWithOptions(options, properties)}`;
      }
    };
  __name(_Response, "Response");
  var Response = _Response;
  mixinBody(Response);
  Object.defineProperties(Response.prototype, {
    type: kEnumerableProperty,
    url: kEnumerableProperty,
    status: kEnumerableProperty,
    ok: kEnumerableProperty,
    redirected: kEnumerableProperty,
    statusText: kEnumerableProperty,
    headers: kEnumerableProperty,
    clone: kEnumerableProperty,
    body: kEnumerableProperty,
    bodyUsed: kEnumerableProperty,
    [Symbol.toStringTag]: {
      value: "Response",
      configurable: !0
    }
  });
  Object.defineProperties(Response, {
    json: kEnumerableProperty,
    redirect: kEnumerableProperty,
    error: kEnumerableProperty
  });
  function cloneResponse(response) {
    if (response.internalResponse) return filterResponse(cloneResponse(response.internalResponse), response.type);
    let newResponse = makeResponse({
      ...response,
      body: null
    });
    return response.body != null && (newResponse.body = cloneBody(newResponse, response.body)), newResponse;
  }
  __name(cloneResponse, "cloneResponse");
  function makeResponse(init) {
    return {
      aborted: !1,
      rangeRequested: !1,
      timingAllowPassed: !1,
      requestIncludesCredentials: !1,
      type: "default",
      status: 200,
      timingInfo: null,
      cacheState: "",
      statusText: "",
      ...init,
      headersList: init != null && init.headersList ? new HeadersList(init == null ? void 0 : init.headersList) : new HeadersList(),
      urlList: init != null && init.urlList ? [...init.urlList] : []
    };
  }
  __name(makeResponse, "makeResponse");
  function makeNetworkError(reason) {
    let isError = isErrorLike(reason);
    return makeResponse({
      type: "error",
      status: 0,
      error: isError ? reason : new Error(reason && String(reason)),
      aborted: reason && reason.name === "AbortError"
    });
  }
  __name(makeNetworkError, "makeNetworkError");
  function isNetworkError(response) {
    return response.type === "error" && response.status === 0;
  }
  __name(isNetworkError, "isNetworkError");
  function makeFilteredResponse(response, state) {
    return state = {
      internalResponse: response,
      ...state
    }, new Proxy(response, {
      get(target, p) {
        return p in state ? state[p] : target[p];
      },
      set(target, p, value) {
        return assert(!(p in state)), target[p] = value, !0;
      }
    });
  }
  __name(makeFilteredResponse, "makeFilteredResponse");
  function filterResponse(response, type) {
    if (type === "basic") return makeFilteredResponse(response, {
      type: "basic",
      headersList: response.headersList
    });
    if (type === "cors") return makeFilteredResponse(response, {
      type: "cors",
      headersList: response.headersList
    });
    if (type === "opaque") return makeFilteredResponse(response, {
      type: "opaque",
      urlList: Object.freeze([]),
      status: 0,
      statusText: "",
      body: null
    });
    if (type === "opaqueredirect") return makeFilteredResponse(response, {
      type: "opaqueredirect",
      status: 0,
      statusText: "",
      headersList: [],
      body: null
    });
    assert(!1);
  }
  __name(filterResponse, "filterResponse");
  function makeAppropriateNetworkError(fetchParams, err = null) {
    return assert(isCancelled(fetchParams)), isAborted(fetchParams) ? makeNetworkError(Object.assign(new DOMException("The operation was aborted.", "AbortError"), {
      cause: err
    })) : makeNetworkError(Object.assign(new DOMException("Request was cancelled."), {
      cause: err
    }));
  }
  __name(makeAppropriateNetworkError, "makeAppropriateNetworkError");
  function initializeResponse(response, init, body) {
    if (init.status !== null && (init.status < 200 || init.status > 599)) throw new RangeError('init["status"] must be in the range of 200 to 599, inclusive.');
    if ("statusText" in init && init.statusText != null && !isValidReasonPhrase(String(init.statusText))) throw new TypeError("Invalid statusText");
    if ("status" in init && init.status != null && (response[kState].status = init.status), "statusText" in init && init.statusText != null && (response[kState].statusText = init.statusText), "headers" in init && init.headers != null && fill(response[kHeaders], init.headers), body) {
      if (nullBodyStatus.includes(response.status)) throw webidl.errors.exception({
        header: "Response constructor",
        message: `Invalid response status code ${response.status}`
      });
      response[kState].body = body.body, body.type != null && !response[kState].headersList.contains("content-type", !0) && response[kState].headersList.append("content-type", body.type, !0);
    }
  }
  __name(initializeResponse, "initializeResponse");
  function fromInnerResponse(innerResponse, guard) {
    var _a;
    let response = new Response(kConstruct);
    return response[kState] = innerResponse, response[kHeaders] = new Headers(kConstruct), setHeadersList(response[kHeaders], innerResponse.headersList), setHeadersGuard(response[kHeaders], guard), hasFinalizationRegistry && (_a = innerResponse.body) != null && _a.stream && streamRegistry.register(response, new WeakRef(innerResponse.body.stream)), response;
  }
  __name(fromInnerResponse, "fromInnerResponse");
  webidl.converters.ReadableStream = webidl.interfaceConverter(ReadableStream);
  webidl.converters.FormData = webidl.interfaceConverter(FormData);
  webidl.converters.URLSearchParams = webidl.interfaceConverter(URLSearchParams);
  webidl.converters.XMLHttpRequestBodyInit = function (V, prefix, name) {
    return typeof V == "string" ? webidl.converters.USVString(V, prefix, name) : isBlobLike(V) ? webidl.converters.Blob(V, prefix, name, {
      strict: !1
    }) : ArrayBuffer.isView(V) || types.isArrayBuffer(V) ? webidl.converters.BufferSource(V, prefix, name) : util.isFormDataLike(V) ? webidl.converters.FormData(V, prefix, name, {
      strict: !1
    }) : V instanceof URLSearchParams ? webidl.converters.URLSearchParams(V, prefix, name) : webidl.converters.DOMString(V, prefix, name);
  };
  webidl.converters.BodyInit = function (V, prefix, argument) {
    return V instanceof ReadableStream ? webidl.converters.ReadableStream(V, prefix, argument) : V != null && V[Symbol.asyncIterator] ? V : webidl.converters.XMLHttpRequestBodyInit(V, prefix, argument);
  };
  webidl.converters.ResponseInit = webidl.dictionaryConverter([{
    key: "status",
    converter: webidl.converters["unsigned short"],
    defaultValue: __name(() => 200, "defaultValue")
  }, {
    key: "statusText",
    converter: webidl.converters.ByteString,
    defaultValue: __name(() => "", "defaultValue")
  }, {
    key: "headers",
    converter: webidl.converters.HeadersInit
  }]);
  module.exports = {
    isNetworkError: isNetworkError,
    makeNetworkError: makeNetworkError,
    makeResponse: makeResponse,
    makeAppropriateNetworkError: makeAppropriateNetworkError,
    filterResponse: filterResponse,
    Response: Response,
    cloneResponse: cloneResponse,
    fromInnerResponse: fromInnerResponse
  };
});