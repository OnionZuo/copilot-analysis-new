var require_headers = __commonJSMin((exports, module) => {
  "use strict";

  var {
      kConstruct: kConstruct
    } = fo(),
    {
      kEnumerableProperty: kEnumerableProperty
    } = oi(),
    {
      iteratorMixin: iteratorMixin,
      isValidHeaderName: isValidHeaderName,
      isValidHeaderValue: isValidHeaderValue
    } = Lu(),
    {
      webidl: webidl
    } = Gc(),
    assert = require("assert"),
    util = require("util"),
    kHeadersMap = Symbol("headers map"),
    kHeadersSortedMap = Symbol("headers map sorted");
  function isHTTPWhiteSpaceCharCode(code) {
    return code === 10 || code === 13 || code === 9 || code === 32;
  }
  __name(isHTTPWhiteSpaceCharCode, "isHTTPWhiteSpaceCharCode");
  function headerValueNormalize(potentialValue) {
    let i = 0,
      j = potentialValue.length;
    for (; j > i && isHTTPWhiteSpaceCharCode(potentialValue.charCodeAt(j - 1));) --j;
    for (; j > i && isHTTPWhiteSpaceCharCode(potentialValue.charCodeAt(i));) ++i;
    return i === 0 && j === potentialValue.length ? potentialValue : potentialValue.substring(i, j);
  }
  __name(headerValueNormalize, "headerValueNormalize");
  function fill(headers, object) {
    if (Array.isArray(object)) for (let i = 0; i < object.length; ++i) {
      let header = object[i];
      if (header.length !== 2) throw webidl.errors.exception({
        header: "Headers constructor",
        message: `expected name/value pair to be length 2, found ${header.length}.`
      });
      appendHeader(headers, header[0], header[1]);
    } else if (typeof object == "object" && object !== null) {
      let keys = Object.keys(object);
      for (let i = 0; i < keys.length; ++i) appendHeader(headers, keys[i], object[keys[i]]);
    } else throw webidl.errors.conversionFailed({
      prefix: "Headers constructor",
      argument: "Argument 1",
      types: ["sequence<sequence<ByteString>>", "record<ByteString, ByteString>"]
    });
  }
  __name(fill, "fill");
  function appendHeader(headers, name, value) {
    if (value = headerValueNormalize(value), isValidHeaderName(name)) {
      if (!isValidHeaderValue(value)) throw webidl.errors.invalidArgument({
        prefix: "Headers.append",
        value: value,
        type: "header value"
      });
    } else throw webidl.errors.invalidArgument({
      prefix: "Headers.append",
      value: name,
      type: "header name"
    });
    if (getHeadersGuard(headers) === "immutable") throw new TypeError("immutable");
    return getHeadersList(headers).append(name, value, !1);
  }
  __name(appendHeader, "appendHeader");
  function compareHeaderName(a, b) {
    return a[0] < b[0] ? -1 : 1;
  }
  __name(compareHeaderName, "compareHeaderName");
  var _HeadersList = class _HeadersList {
    constructor(init) {
      __publicField(this, "cookies", null);
      init instanceof _HeadersList ? (this[kHeadersMap] = new Map(init[kHeadersMap]), this[kHeadersSortedMap] = init[kHeadersSortedMap], this.cookies = init.cookies === null ? null : [...init.cookies]) : (this[kHeadersMap] = new Map(init), this[kHeadersSortedMap] = null);
    }
    contains(name, isLowerCase) {
      return this[kHeadersMap].has(isLowerCase ? name : name.toLowerCase());
    }
    clear() {
      this[kHeadersMap].clear(), this[kHeadersSortedMap] = null, this.cookies = null;
    }
    append(name, value, isLowerCase) {
      var _a;
      this[kHeadersSortedMap] = null;
      let lowercaseName = isLowerCase ? name : name.toLowerCase(),
        exists = this[kHeadersMap].get(lowercaseName);
      if (exists) {
        let delimiter = lowercaseName === "cookie" ? "; " : ", ";
        this[kHeadersMap].set(lowercaseName, {
          name: exists.name,
          value: `${exists.value}${delimiter}${value}`
        });
      } else this[kHeadersMap].set(lowercaseName, {
        name: name,
        value: value
      });
      lowercaseName === "set-cookie" && ((_a = this.cookies) != null ? _a : this.cookies = []).push(value);
    }
    set(name, value, isLowerCase) {
      this[kHeadersSortedMap] = null;
      let lowercaseName = isLowerCase ? name : name.toLowerCase();
      lowercaseName === "set-cookie" && (this.cookies = [value]), this[kHeadersMap].set(lowercaseName, {
        name: name,
        value: value
      });
    }
    delete(name, isLowerCase) {
      this[kHeadersSortedMap] = null, isLowerCase || (name = name.toLowerCase()), name === "set-cookie" && (this.cookies = null), this[kHeadersMap].delete(name);
    }
    get(name, isLowerCase) {
      var _a, _b;
      return (_b = (_a = this[kHeadersMap].get(isLowerCase ? name : name.toLowerCase())) == null ? void 0 : _a.value) != null ? _b : null;
    }
    *[Symbol.iterator]() {
      for (let {
        0: name,
        1: {
          value: value
        }
      } of this[kHeadersMap]) yield [name, value];
    }
    get entries() {
      let headers = {};
      if (this[kHeadersMap].size !== 0) for (let {
        name: name,
        value: value
      } of this[kHeadersMap].values()) headers[name] = value;
      return headers;
    }
    rawValues() {
      return this[kHeadersMap].values();
    }
    get entriesList() {
      let headers = [];
      if (this[kHeadersMap].size !== 0) for (let {
        0: lowerName,
        1: {
          name: name,
          value: value
        }
      } of this[kHeadersMap]) if (lowerName === "set-cookie") for (let cookie of this.cookies) headers.push([name, cookie]);else headers.push([name, value]);
      return headers;
    }
    toSortedArray() {
      let size = this[kHeadersMap].size,
        array = new Array(size);
      if (size <= 32) {
        if (size === 0) return array;
        let iterator = this[kHeadersMap][Symbol.iterator](),
          firstValue = iterator.next().value;
        array[0] = [firstValue[0], firstValue[1].value], assert(firstValue[1].value !== null);
        for (let i = 1, j = 0, right = 0, left = 0, pivot = 0, x, value; i < size; ++i) {
          for (value = iterator.next().value, x = array[i] = [value[0], value[1].value], assert(x[1] !== null), left = 0, right = i; left < right;) pivot = left + (right - left >> 1), array[pivot][0] <= x[0] ? left = pivot + 1 : right = pivot;
          if (i !== pivot) {
            for (j = i; j > left;) array[j] = array[--j];
            array[left] = x;
          }
        }
        if (!iterator.next().done) throw new TypeError("Unreachable");
        return array;
      } else {
        let i = 0;
        for (let {
          0: name,
          1: {
            value: value
          }
        } of this[kHeadersMap]) array[i++] = [name, value], assert(value !== null);
        return array.sort(compareHeaderName);
      }
    }
  };
  __name(_HeadersList, "HeadersList");
  var HeadersList = _HeadersList,
    _guard,
    _headersList,
    _Headers = class _Headers {
      constructor(init = void 0) {
        __privateAdd(this, _guard);
        __privateAdd(this, _headersList);
        webidl.util.markAsUncloneable(this), init !== kConstruct && (__privateSet(this, _headersList, new HeadersList()), __privateSet(this, _guard, "none"), init !== void 0 && (init = webidl.converters.HeadersInit(init, "Headers contructor", "init"), fill(this, init)));
      }
      append(name, value) {
        webidl.brandCheck(this, _Headers), webidl.argumentLengthCheck(arguments, 2, "Headers.append");
        let prefix = "Headers.append";
        return name = webidl.converters.ByteString(name, prefix, "name"), value = webidl.converters.ByteString(value, prefix, "value"), appendHeader(this, name, value);
      }
      delete(name) {
        if (webidl.brandCheck(this, _Headers), webidl.argumentLengthCheck(arguments, 1, "Headers.delete"), name = webidl.converters.ByteString(name, "Headers.delete", "name"), !isValidHeaderName(name)) throw webidl.errors.invalidArgument({
          prefix: "Headers.delete",
          value: name,
          type: "header name"
        });
        if (__privateGet(this, _guard) === "immutable") throw new TypeError("immutable");
        __privateGet(this, _headersList).contains(name, !1) && __privateGet(this, _headersList).delete(name, !1);
      }
      get(name) {
        webidl.brandCheck(this, _Headers), webidl.argumentLengthCheck(arguments, 1, "Headers.get");
        let prefix = "Headers.get";
        if (name = webidl.converters.ByteString(name, prefix, "name"), !isValidHeaderName(name)) throw webidl.errors.invalidArgument({
          prefix: prefix,
          value: name,
          type: "header name"
        });
        return __privateGet(this, _headersList).get(name, !1);
      }
      has(name) {
        webidl.brandCheck(this, _Headers), webidl.argumentLengthCheck(arguments, 1, "Headers.has");
        let prefix = "Headers.has";
        if (name = webidl.converters.ByteString(name, prefix, "name"), !isValidHeaderName(name)) throw webidl.errors.invalidArgument({
          prefix: prefix,
          value: name,
          type: "header name"
        });
        return __privateGet(this, _headersList).contains(name, !1);
      }
      set(name, value) {
        webidl.brandCheck(this, _Headers), webidl.argumentLengthCheck(arguments, 2, "Headers.set");
        let prefix = "Headers.set";
        if (name = webidl.converters.ByteString(name, prefix, "name"), value = webidl.converters.ByteString(value, prefix, "value"), value = headerValueNormalize(value), isValidHeaderName(name)) {
          if (!isValidHeaderValue(value)) throw webidl.errors.invalidArgument({
            prefix: prefix,
            value: value,
            type: "header value"
          });
        } else throw webidl.errors.invalidArgument({
          prefix: prefix,
          value: name,
          type: "header name"
        });
        if (__privateGet(this, _guard) === "immutable") throw new TypeError("immutable");
        __privateGet(this, _headersList).set(name, value, !1);
      }
      getSetCookie() {
        webidl.brandCheck(this, _Headers);
        let list = __privateGet(this, _headersList).cookies;
        return list ? [...list] : [];
      }
      get [kHeadersSortedMap]() {
        if (__privateGet(this, _headersList)[kHeadersSortedMap]) return __privateGet(this, _headersList)[kHeadersSortedMap];
        let headers = [],
          names = __privateGet(this, _headersList).toSortedArray(),
          cookies = __privateGet(this, _headersList).cookies;
        if (cookies === null || cookies.length === 1) return __privateGet(this, _headersList)[kHeadersSortedMap] = names;
        for (let i = 0; i < names.length; ++i) {
          let {
            0: name,
            1: value
          } = names[i];
          if (name === "set-cookie") for (let j = 0; j < cookies.length; ++j) headers.push([name, cookies[j]]);else headers.push([name, value]);
        }
        return __privateGet(this, _headersList)[kHeadersSortedMap] = headers;
      }
      [util.inspect.custom](depth, options) {
        var _a;
        return (_a = options.depth) != null || (options.depth = depth), `Headers ${util.formatWithOptions(options, __privateGet(this, _headersList).entries)}`;
      }
      static getHeadersGuard(o) {
        return __privateGet(o, _guard);
      }
      static setHeadersGuard(o, guard) {
        __privateSet(o, _guard, guard);
      }
      static getHeadersList(o) {
        return __privateGet(o, _headersList);
      }
      static setHeadersList(o, list) {
        __privateSet(o, _headersList, list);
      }
    };
  _guard = new WeakMap(), _headersList = new WeakMap(), __name(_Headers, "Headers");
  var Headers = _Headers,
    {
      getHeadersGuard: getHeadersGuard,
      setHeadersGuard: setHeadersGuard,
      getHeadersList: getHeadersList,
      setHeadersList: setHeadersList
    } = Headers;
  Reflect.deleteProperty(Headers, "getHeadersGuard");
  Reflect.deleteProperty(Headers, "setHeadersGuard");
  Reflect.deleteProperty(Headers, "getHeadersList");
  Reflect.deleteProperty(Headers, "setHeadersList");
  iteratorMixin("Headers", Headers, kHeadersSortedMap, 0, 1);
  Object.defineProperties(Headers.prototype, {
    append: kEnumerableProperty,
    delete: kEnumerableProperty,
    get: kEnumerableProperty,
    has: kEnumerableProperty,
    set: kEnumerableProperty,
    getSetCookie: kEnumerableProperty,
    [Symbol.toStringTag]: {
      value: "Headers",
      configurable: !0
    },
    [util.inspect.custom]: {
      enumerable: !1
    }
  });
  webidl.converters.HeadersInit = function (V, prefix, argument) {
    if (webidl.util.Type(V) === "Object") {
      let iterator = Reflect.get(V, Symbol.iterator);
      if (!util.types.isProxy(V) && iterator === Headers.prototype.entries) try {
        return getHeadersList(V).entriesList;
      } catch {}
      return typeof iterator == "function" ? webidl.converters["sequence<sequence<ByteString>>"](V, prefix, argument, iterator.bind(V)) : webidl.converters["record<ByteString, ByteString>"](V, prefix, argument);
    }
    throw webidl.errors.conversionFailed({
      prefix: "Headers constructor",
      argument: "Argument 1",
      types: ["sequence<sequence<ByteString>>", "record<ByteString, ByteString>"]
    });
  };
  module.exports = {
    fill: fill,
    compareHeaderName: compareHeaderName,
    Headers: Headers,
    HeadersList: HeadersList,
    getHeadersGuard: getHeadersGuard,
    setHeadersGuard: setHeadersGuard,
    setHeadersList: setHeadersList,
    getHeadersList: getHeadersList
  };
});