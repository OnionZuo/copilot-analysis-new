var require_request = __commonJSMin((exports, module) => {
  "use strict";

  var {
      extractBody: extractBody,
      mixinBody: mixinBody,
      cloneBody: cloneBody,
      bodyUnusable: bodyUnusable
    } = Wv(),
    {
      Headers: Headers,
      fill: fillHeaders,
      HeadersList: HeadersList,
      setHeadersGuard: setHeadersGuard,
      getHeadersGuard: getHeadersGuard,
      setHeadersList: setHeadersList,
      getHeadersList: getHeadersList
    } = Dx(),
    {
      FinalizationRegistry: FinalizationRegistry
    } = kLe()(),
    util = oi(),
    nodeUtil = require("util"),
    {
      isValidHTTPToken: isValidHTTPToken,
      sameOrigin: sameOrigin,
      environmentSettingsObject: environmentSettingsObject
    } = Lu(),
    {
      forbiddenMethodsSet: forbiddenMethodsSet,
      corsSafeListedMethodsSet: corsSafeListedMethodsSet,
      referrerPolicy: referrerPolicy,
      requestRedirect: requestRedirect,
      requestMode: requestMode,
      requestCredentials: requestCredentials,
      requestCache: requestCache,
      requestDuplex: requestDuplex
    } = O4(),
    {
      kEnumerableProperty: kEnumerableProperty,
      normalizedMethodRecordsBase: normalizedMethodRecordsBase,
      normalizedMethodRecords: normalizedMethodRecords
    } = util,
    {
      kHeaders: kHeaders,
      kSignal: kSignal,
      kState: kState,
      kDispatcher: kDispatcher
    } = iw(),
    {
      webidl: webidl
    } = Gc(),
    {
      URLSerializer: URLSerializer
    } = zA(),
    {
      kConstruct: kConstruct
    } = fo(),
    assert = require("assert"),
    {
      getMaxListeners: getMaxListeners,
      setMaxListeners: setMaxListeners,
      getEventListeners: getEventListeners,
      defaultMaxListeners: defaultMaxListeners
    } = require("events"),
    kAbortController = Symbol("abortController"),
    requestFinalizer = new FinalizationRegistry(({
      signal: signal,
      abort: abort
    }) => {
      signal.removeEventListener("abort", abort);
    }),
    dependentControllerMap = new WeakMap();
  function buildAbort(acRef) {
    return abort;
    function abort() {
      let ac = acRef.deref();
      if (ac !== void 0) {
        requestFinalizer.unregister(abort), this.removeEventListener("abort", abort), ac.abort(this.reason);
        let controllerList = dependentControllerMap.get(ac.signal);
        if (controllerList !== void 0) {
          if (controllerList.size !== 0) {
            for (let ref of controllerList) {
              let ctrl = ref.deref();
              ctrl !== void 0 && ctrl.abort(this.reason);
            }
            controllerList.clear();
          }
          dependentControllerMap.delete(ac.signal);
        }
      }
    }
  }
  __name(buildAbort, "buildAbort");
  var patchMethodWarning = !1,
    _Request = class _Request {
      constructor(input, init = {}) {
        var _a, _b, _c;
        if (webidl.util.markAsUncloneable(this), input === kConstruct) return;
        let prefix = "Request constructor";
        webidl.argumentLengthCheck(arguments, 1, prefix), input = webidl.converters.RequestInfo(input, prefix, "input"), init = webidl.converters.RequestInit(init, prefix, "init");
        let request = null,
          fallbackMode = null,
          baseUrl = environmentSettingsObject.settingsObject.baseUrl,
          signal = null;
        if (typeof input == "string") {
          this[kDispatcher] = init.dispatcher;
          let parsedURL;
          try {
            parsedURL = new URL(input, baseUrl);
          } catch (err) {
            throw new TypeError("Failed to parse URL from " + input, {
              cause: err
            });
          }
          if (parsedURL.username || parsedURL.password) throw new TypeError("Request cannot be constructed from a URL that includes credentials: " + input);
          request = makeRequest({
            urlList: [parsedURL]
          }), fallbackMode = "cors";
        } else this[kDispatcher] = init.dispatcher || input[kDispatcher], assert(input instanceof _Request), request = input[kState], signal = input[kSignal];
        let origin = environmentSettingsObject.settingsObject.origin,
          window = "client";
        if (((_b = (_a = request.window) == null ? void 0 : _a.constructor) == null ? void 0 : _b.name) === "EnvironmentSettingsObject" && sameOrigin(request.window, origin) && (window = request.window), init.window != null) throw new TypeError(`'window' option '${window}' must be null`);
        "window" in init && (window = "no-window"), request = makeRequest({
          method: request.method,
          headersList: request.headersList,
          unsafeRequest: request.unsafeRequest,
          client: environmentSettingsObject.settingsObject,
          window: window,
          priority: request.priority,
          origin: request.origin,
          referrer: request.referrer,
          referrerPolicy: request.referrerPolicy,
          mode: request.mode,
          credentials: request.credentials,
          cache: request.cache,
          redirect: request.redirect,
          integrity: request.integrity,
          keepalive: request.keepalive,
          reloadNavigation: request.reloadNavigation,
          historyNavigation: request.historyNavigation,
          urlList: [...request.urlList]
        });
        let initHasKey = Object.keys(init).length !== 0;
        if (initHasKey && (request.mode === "navigate" && (request.mode = "same-origin"), request.reloadNavigation = !1, request.historyNavigation = !1, request.origin = "client", request.referrer = "client", request.referrerPolicy = "", request.url = request.urlList[request.urlList.length - 1], request.urlList = [request.url]), init.referrer !== void 0) {
          let referrer = init.referrer;
          if (referrer === "") request.referrer = "no-referrer";else {
            let parsedReferrer;
            try {
              parsedReferrer = new URL(referrer, baseUrl);
            } catch (err) {
              throw new TypeError(`Referrer "${referrer}" is not a valid URL.`, {
                cause: err
              });
            }
            parsedReferrer.protocol === "about:" && parsedReferrer.hostname === "client" || origin && !sameOrigin(parsedReferrer, environmentSettingsObject.settingsObject.baseUrl) ? request.referrer = "client" : request.referrer = parsedReferrer;
          }
        }
        init.referrerPolicy !== void 0 && (request.referrerPolicy = init.referrerPolicy);
        let mode;
        if (init.mode !== void 0 ? mode = init.mode : mode = fallbackMode, mode === "navigate") throw webidl.errors.exception({
          header: "Request constructor",
          message: "invalid request mode navigate."
        });
        if (mode != null && (request.mode = mode), init.credentials !== void 0 && (request.credentials = init.credentials), init.cache !== void 0 && (request.cache = init.cache), request.cache === "only-if-cached" && request.mode !== "same-origin") throw new TypeError("'only-if-cached' can be set only with 'same-origin' mode");
        if (init.redirect !== void 0 && (request.redirect = init.redirect), init.integrity != null && (request.integrity = String(init.integrity)), init.keepalive !== void 0 && (request.keepalive = !!init.keepalive), init.method !== void 0) {
          let method = init.method,
            mayBeNormalized = normalizedMethodRecords[method];
          if (mayBeNormalized !== void 0) request.method = mayBeNormalized;else {
            if (!isValidHTTPToken(method)) throw new TypeError(`'${method}' is not a valid HTTP method.`);
            let upperCase = method.toUpperCase();
            if (forbiddenMethodsSet.has(upperCase)) throw new TypeError(`'${method}' HTTP method is unsupported.`);
            method = (_c = normalizedMethodRecordsBase[upperCase]) != null ? _c : method, request.method = method;
          }
          !patchMethodWarning && request.method === "patch" && (process.emitWarning("Using `patch` is highly likely to result in a `405 Method Not Allowed`. `PATCH` is much more likely to succeed.", {
            code: "UNDICI-FETCH-patch"
          }), patchMethodWarning = !0);
        }
        init.signal !== void 0 && (signal = init.signal), this[kState] = request;
        let ac = new AbortController();
        if (this[kSignal] = ac.signal, signal != null) {
          if (!signal || typeof signal.aborted != "boolean" || typeof signal.addEventListener != "function") throw new TypeError("Failed to construct 'Request': member signal is not of type AbortSignal.");
          if (signal.aborted) ac.abort(signal.reason);else {
            this[kAbortController] = ac;
            let acRef = new WeakRef(ac),
              abort = buildAbort(acRef);
            try {
              (typeof getMaxListeners == "function" && getMaxListeners(signal) === defaultMaxListeners || getEventListeners(signal, "abort").length >= defaultMaxListeners) && setMaxListeners(1500, signal);
            } catch {}
            util.addAbortListener(signal, abort), requestFinalizer.register(ac, {
              signal: signal,
              abort: abort
            }, abort);
          }
        }
        if (this[kHeaders] = new Headers(kConstruct), setHeadersList(this[kHeaders], request.headersList), setHeadersGuard(this[kHeaders], "request"), mode === "no-cors") {
          if (!corsSafeListedMethodsSet.has(request.method)) throw new TypeError(`'${request.method} is unsupported in no-cors mode.`);
          setHeadersGuard(this[kHeaders], "request-no-cors");
        }
        if (initHasKey) {
          let headersList = getHeadersList(this[kHeaders]),
            headers = init.headers !== void 0 ? init.headers : new HeadersList(headersList);
          if (headersList.clear(), headers instanceof HeadersList) {
            for (let {
              name: name,
              value: value
            } of headers.rawValues()) headersList.append(name, value, !1);
            headersList.cookies = headers.cookies;
          } else fillHeaders(this[kHeaders], headers);
        }
        let inputBody = input instanceof _Request ? input[kState].body : null;
        if ((init.body != null || inputBody != null) && (request.method === "GET" || request.method === "HEAD")) throw new TypeError("Request with GET/HEAD method cannot have body.");
        let initBody = null;
        if (init.body != null) {
          let [extractedBody, contentType] = extractBody(init.body, request.keepalive);
          initBody = extractedBody, contentType && !getHeadersList(this[kHeaders]).contains("content-type", !0) && this[kHeaders].append("content-type", contentType);
        }
        let inputOrInitBody = initBody != null ? initBody : inputBody;
        if (inputOrInitBody != null && inputOrInitBody.source == null) {
          if (initBody != null && init.duplex == null) throw new TypeError("RequestInit: duplex option is required when sending a body.");
          if (request.mode !== "same-origin" && request.mode !== "cors") throw new TypeError('If request is made from ReadableStream, mode should be "same-origin" or "cors"');
          request.useCORSPreflightFlag = !0;
        }
        let finalBody = inputOrInitBody;
        if (initBody == null && inputBody != null) {
          if (bodyUnusable(input)) throw new TypeError("Cannot construct a Request with a Request object that has already been used.");
          let identityTransform = new TransformStream();
          inputBody.stream.pipeThrough(identityTransform), finalBody = {
            source: inputBody.source,
            length: inputBody.length,
            stream: identityTransform.readable
          };
        }
        this[kState].body = finalBody;
      }
      get method() {
        return webidl.brandCheck(this, _Request), this[kState].method;
      }
      get url() {
        return webidl.brandCheck(this, _Request), URLSerializer(this[kState].url);
      }
      get headers() {
        return webidl.brandCheck(this, _Request), this[kHeaders];
      }
      get destination() {
        return webidl.brandCheck(this, _Request), this[kState].destination;
      }
      get referrer() {
        return webidl.brandCheck(this, _Request), this[kState].referrer === "no-referrer" ? "" : this[kState].referrer === "client" ? "about:client" : this[kState].referrer.toString();
      }
      get referrerPolicy() {
        return webidl.brandCheck(this, _Request), this[kState].referrerPolicy;
      }
      get mode() {
        return webidl.brandCheck(this, _Request), this[kState].mode;
      }
      get credentials() {
        return this[kState].credentials;
      }
      get cache() {
        return webidl.brandCheck(this, _Request), this[kState].cache;
      }
      get redirect() {
        return webidl.brandCheck(this, _Request), this[kState].redirect;
      }
      get integrity() {
        return webidl.brandCheck(this, _Request), this[kState].integrity;
      }
      get keepalive() {
        return webidl.brandCheck(this, _Request), this[kState].keepalive;
      }
      get isReloadNavigation() {
        return webidl.brandCheck(this, _Request), this[kState].reloadNavigation;
      }
      get isHistoryNavigation() {
        return webidl.brandCheck(this, _Request), this[kState].historyNavigation;
      }
      get signal() {
        return webidl.brandCheck(this, _Request), this[kSignal];
      }
      get body() {
        return webidl.brandCheck(this, _Request), this[kState].body ? this[kState].body.stream : null;
      }
      get bodyUsed() {
        return webidl.brandCheck(this, _Request), !!this[kState].body && util.isDisturbed(this[kState].body.stream);
      }
      get duplex() {
        return webidl.brandCheck(this, _Request), "half";
      }
      clone() {
        if (webidl.brandCheck(this, _Request), bodyUnusable(this)) throw new TypeError("unusable");
        let clonedRequest = cloneRequest(this[kState]),
          ac = new AbortController();
        if (this.signal.aborted) ac.abort(this.signal.reason);else {
          let list = dependentControllerMap.get(this.signal);
          list === void 0 && (list = new Set(), dependentControllerMap.set(this.signal, list));
          let acRef = new WeakRef(ac);
          list.add(acRef), util.addAbortListener(ac.signal, buildAbort(acRef));
        }
        return fromInnerRequest(clonedRequest, ac.signal, getHeadersGuard(this[kHeaders]));
      }
      [nodeUtil.inspect.custom](depth, options) {
        var _a;
        options.depth === null && (options.depth = 2), (_a = options.colors) != null || (options.colors = !0);
        let properties = {
          method: this.method,
          url: this.url,
          headers: this.headers,
          destination: this.destination,
          referrer: this.referrer,
          referrerPolicy: this.referrerPolicy,
          mode: this.mode,
          credentials: this.credentials,
          cache: this.cache,
          redirect: this.redirect,
          integrity: this.integrity,
          keepalive: this.keepalive,
          isReloadNavigation: this.isReloadNavigation,
          isHistoryNavigation: this.isHistoryNavigation,
          signal: this.signal
        };
        return `Request ${nodeUtil.formatWithOptions(options, properties)}`;
      }
    };
  __name(_Request, "Request");
  var Request = _Request;
  mixinBody(Request);
  function makeRequest(init) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _A, _B, _C, _D, _E, _F, _G, _H, _I;
    return {
      method: (_a = init.method) != null ? _a : "GET",
      localURLsOnly: (_b = init.localURLsOnly) != null ? _b : !1,
      unsafeRequest: (_c = init.unsafeRequest) != null ? _c : !1,
      body: (_d = init.body) != null ? _d : null,
      client: (_e = init.client) != null ? _e : null,
      reservedClient: (_f = init.reservedClient) != null ? _f : null,
      replacesClientId: (_g = init.replacesClientId) != null ? _g : "",
      window: (_h = init.window) != null ? _h : "client",
      keepalive: (_i = init.keepalive) != null ? _i : !1,
      serviceWorkers: (_j = init.serviceWorkers) != null ? _j : "all",
      initiator: (_k = init.initiator) != null ? _k : "",
      destination: (_l = init.destination) != null ? _l : "",
      priority: (_m = init.priority) != null ? _m : null,
      origin: (_n = init.origin) != null ? _n : "client",
      policyContainer: (_o = init.policyContainer) != null ? _o : "client",
      referrer: (_p = init.referrer) != null ? _p : "client",
      referrerPolicy: (_q = init.referrerPolicy) != null ? _q : "",
      mode: (_r = init.mode) != null ? _r : "no-cors",
      useCORSPreflightFlag: (_s = init.useCORSPreflightFlag) != null ? _s : !1,
      credentials: (_t = init.credentials) != null ? _t : "same-origin",
      useCredentials: (_u = init.useCredentials) != null ? _u : !1,
      cache: (_v = init.cache) != null ? _v : "default",
      redirect: (_w = init.redirect) != null ? _w : "follow",
      integrity: (_x = init.integrity) != null ? _x : "",
      cryptoGraphicsNonceMetadata: (_y = init.cryptoGraphicsNonceMetadata) != null ? _y : "",
      parserMetadata: (_z = init.parserMetadata) != null ? _z : "",
      reloadNavigation: (_A = init.reloadNavigation) != null ? _A : !1,
      historyNavigation: (_B = init.historyNavigation) != null ? _B : !1,
      userActivation: (_C = init.userActivation) != null ? _C : !1,
      taintedOrigin: (_D = init.taintedOrigin) != null ? _D : !1,
      redirectCount: (_E = init.redirectCount) != null ? _E : 0,
      responseTainting: (_F = init.responseTainting) != null ? _F : "basic",
      preventNoCacheCacheControlHeaderModification: (_G = init.preventNoCacheCacheControlHeaderModification) != null ? _G : !1,
      done: (_H = init.done) != null ? _H : !1,
      timingAllowFailed: (_I = init.timingAllowFailed) != null ? _I : !1,
      urlList: init.urlList,
      url: init.urlList[0],
      headersList: init.headersList ? new HeadersList(init.headersList) : new HeadersList()
    };
  }
  __name(makeRequest, "makeRequest");
  function cloneRequest(request) {
    let newRequest = makeRequest({
      ...request,
      body: null
    });
    return request.body != null && (newRequest.body = cloneBody(newRequest, request.body)), newRequest;
  }
  __name(cloneRequest, "cloneRequest");
  function fromInnerRequest(innerRequest, signal, guard) {
    let request = new Request(kConstruct);
    return request[kState] = innerRequest, request[kSignal] = signal, request[kHeaders] = new Headers(kConstruct), setHeadersList(request[kHeaders], innerRequest.headersList), setHeadersGuard(request[kHeaders], guard), request;
  }
  __name(fromInnerRequest, "fromInnerRequest");
  Object.defineProperties(Request.prototype, {
    method: kEnumerableProperty,
    url: kEnumerableProperty,
    headers: kEnumerableProperty,
    redirect: kEnumerableProperty,
    clone: kEnumerableProperty,
    signal: kEnumerableProperty,
    duplex: kEnumerableProperty,
    destination: kEnumerableProperty,
    body: kEnumerableProperty,
    bodyUsed: kEnumerableProperty,
    isHistoryNavigation: kEnumerableProperty,
    isReloadNavigation: kEnumerableProperty,
    keepalive: kEnumerableProperty,
    integrity: kEnumerableProperty,
    cache: kEnumerableProperty,
    credentials: kEnumerableProperty,
    attribute: kEnumerableProperty,
    referrerPolicy: kEnumerableProperty,
    referrer: kEnumerableProperty,
    mode: kEnumerableProperty,
    [Symbol.toStringTag]: {
      value: "Request",
      configurable: !0
    }
  });
  webidl.converters.Request = webidl.interfaceConverter(Request);
  webidl.converters.RequestInfo = function (V, prefix, argument) {
    return typeof V == "string" ? webidl.converters.USVString(V, prefix, argument) : V instanceof Request ? webidl.converters.Request(V, prefix, argument) : webidl.converters.USVString(V, prefix, argument);
  };
  webidl.converters.AbortSignal = webidl.interfaceConverter(AbortSignal);
  webidl.converters.RequestInit = webidl.dictionaryConverter([{
    key: "method",
    converter: webidl.converters.ByteString
  }, {
    key: "headers",
    converter: webidl.converters.HeadersInit
  }, {
    key: "body",
    converter: webidl.nullableConverter(webidl.converters.BodyInit)
  }, {
    key: "referrer",
    converter: webidl.converters.USVString
  }, {
    key: "referrerPolicy",
    converter: webidl.converters.DOMString,
    allowedValues: referrerPolicy
  }, {
    key: "mode",
    converter: webidl.converters.DOMString,
    allowedValues: requestMode
  }, {
    key: "credentials",
    converter: webidl.converters.DOMString,
    allowedValues: requestCredentials
  }, {
    key: "cache",
    converter: webidl.converters.DOMString,
    allowedValues: requestCache
  }, {
    key: "redirect",
    converter: webidl.converters.DOMString,
    allowedValues: requestRedirect
  }, {
    key: "integrity",
    converter: webidl.converters.DOMString
  }, {
    key: "keepalive",
    converter: webidl.converters.boolean
  }, {
    key: "signal",
    converter: webidl.nullableConverter(signal => webidl.converters.AbortSignal(signal, "RequestInit", "signal", {
      strict: !1
    }))
  }, {
    key: "window",
    converter: webidl.converters.any
  }, {
    key: "duplex",
    converter: webidl.converters.DOMString,
    allowedValues: requestDuplex
  }, {
    key: "dispatcher",
    converter: webidl.converters.any
  }]);
  module.exports = {
    Request: Request,
    makeRequest: makeRequest,
    fromInnerRequest: fromInnerRequest,
    cloneRequest: cloneRequest
  };
});