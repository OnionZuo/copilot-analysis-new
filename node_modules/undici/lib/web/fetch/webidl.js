var require_webidl = __commonJSMin((exports, module) => {
  "use strict";

  var {
      types: types,
      inspect: inspect
    } = require("util"),
    {
      markAsUncloneable: markAsUncloneable
    } = require("worker_threads"),
    {
      toUSVString: toUSVString
    } = oi(),
    webidl = {};
  webidl.converters = {};
  webidl.util = {};
  webidl.errors = {};
  webidl.errors.exception = function (message) {
    return new TypeError(`${message.header}: ${message.message}`);
  };
  webidl.errors.conversionFailed = function (context) {
    let plural = context.types.length === 1 ? "" : " one of",
      message = `${context.argument} could not be converted to${plural}: ${context.types.join(", ")}.`;
    return webidl.errors.exception({
      header: context.prefix,
      message: message
    });
  };
  webidl.errors.invalidArgument = function (context) {
    return webidl.errors.exception({
      header: context.prefix,
      message: `"${context.value}" is an invalid ${context.type}.`
    });
  };
  webidl.brandCheck = function (V, I, opts) {
    if ((opts == null ? void 0 : opts.strict) !== !1) {
      if (!(V instanceof I)) {
        let err = new TypeError("Illegal invocation");
        throw err.code = "ERR_INVALID_THIS", err;
      }
    } else if ((V == null ? void 0 : V[Symbol.toStringTag]) !== I.prototype[Symbol.toStringTag]) {
      let err = new TypeError("Illegal invocation");
      throw err.code = "ERR_INVALID_THIS", err;
    }
  };
  webidl.argumentLengthCheck = function ({
    length: length
  }, min, ctx) {
    if (length < min) throw webidl.errors.exception({
      message: `${min} argument${min !== 1 ? "s" : ""} required, but${length ? " only" : ""} ${length} found.`,
      header: ctx
    });
  };
  webidl.illegalConstructor = function () {
    throw webidl.errors.exception({
      header: "TypeError",
      message: "Illegal constructor"
    });
  };
  webidl.util.Type = function (V) {
    switch (typeof V) {
      case "undefined":
        return "Undefined";
      case "boolean":
        return "Boolean";
      case "string":
        return "String";
      case "symbol":
        return "Symbol";
      case "number":
        return "Number";
      case "bigint":
        return "BigInt";
      case "function":
      case "object":
        return V === null ? "Null" : "Object";
    }
  };
  webidl.util.markAsUncloneable = markAsUncloneable || (() => {});
  webidl.util.ConvertToInt = function (V, bitLength, signedness, opts) {
    let upperBound, lowerBound;
    bitLength === 64 ? (upperBound = Math.pow(2, 53) - 1, signedness === "unsigned" ? lowerBound = 0 : lowerBound = Math.pow(-2, 53) + 1) : signedness === "unsigned" ? (lowerBound = 0, upperBound = Math.pow(2, bitLength) - 1) : (lowerBound = Math.pow(-2, bitLength) - 1, upperBound = Math.pow(2, bitLength - 1) - 1);
    let x = Number(V);
    if (x === 0 && (x = 0), (opts == null ? void 0 : opts.enforceRange) === !0) {
      if (Number.isNaN(x) || x === Number.POSITIVE_INFINITY || x === Number.NEGATIVE_INFINITY) throw webidl.errors.exception({
        header: "Integer conversion",
        message: `Could not convert ${webidl.util.Stringify(V)} to an integer.`
      });
      if (x = webidl.util.IntegerPart(x), x < lowerBound || x > upperBound) throw webidl.errors.exception({
        header: "Integer conversion",
        message: `Value must be between ${lowerBound}-${upperBound}, got ${x}.`
      });
      return x;
    }
    return !Number.isNaN(x) && (opts == null ? void 0 : opts.clamp) === !0 ? (x = Math.min(Math.max(x, lowerBound), upperBound), Math.floor(x) % 2 === 0 ? x = Math.floor(x) : x = Math.ceil(x), x) : Number.isNaN(x) || x === 0 && Object.is(0, x) || x === Number.POSITIVE_INFINITY || x === Number.NEGATIVE_INFINITY ? 0 : (x = webidl.util.IntegerPart(x), x = x % Math.pow(2, bitLength), signedness === "signed" && x >= Math.pow(2, bitLength) - 1 ? x - Math.pow(2, bitLength) : x);
  };
  webidl.util.IntegerPart = function (n) {
    let r = Math.floor(Math.abs(n));
    return n < 0 ? -1 * r : r;
  };
  webidl.util.Stringify = function (V) {
    switch (webidl.util.Type(V)) {
      case "Symbol":
        return `Symbol(${V.description})`;
      case "Object":
        return inspect(V);
      case "String":
        return `"${V}"`;
      default:
        return `${V}`;
    }
  };
  webidl.sequenceConverter = function (converter) {
    return (V, prefix, argument, Iterable) => {
      var _a;
      if (webidl.util.Type(V) !== "Object") throw webidl.errors.exception({
        header: prefix,
        message: `${argument} (${webidl.util.Stringify(V)}) is not iterable.`
      });
      let method = typeof Iterable == "function" ? Iterable() : (_a = V == null ? void 0 : V[Symbol.iterator]) == null ? void 0 : _a.call(V),
        seq = [],
        index = 0;
      if (method === void 0 || typeof method.next != "function") throw webidl.errors.exception({
        header: prefix,
        message: `${argument} is not iterable.`
      });
      for (;;) {
        let {
          done: done,
          value: value
        } = method.next();
        if (done) break;
        seq.push(converter(value, prefix, `${argument}[${index++}]`));
      }
      return seq;
    };
  };
  webidl.recordConverter = function (keyConverter, valueConverter) {
    return (O, prefix, argument) => {
      if (webidl.util.Type(O) !== "Object") throw webidl.errors.exception({
        header: prefix,
        message: `${argument} ("${webidl.util.Type(O)}") is not an Object.`
      });
      let result = {};
      if (!types.isProxy(O)) {
        let keys = [...Object.getOwnPropertyNames(O), ...Object.getOwnPropertySymbols(O)];
        for (let key of keys) {
          let typedKey = keyConverter(key, prefix, argument),
            typedValue = valueConverter(O[key], prefix, argument);
          result[typedKey] = typedValue;
        }
        return result;
      }
      let keys = Reflect.ownKeys(O);
      for (let key of keys) {
        let desc = Reflect.getOwnPropertyDescriptor(O, key);
        if (desc != null && desc.enumerable) {
          let typedKey = keyConverter(key, prefix, argument),
            typedValue = valueConverter(O[key], prefix, argument);
          result[typedKey] = typedValue;
        }
      }
      return result;
    };
  };
  webidl.interfaceConverter = function (i) {
    return (V, prefix, argument, opts) => {
      if ((opts == null ? void 0 : opts.strict) !== !1 && !(V instanceof i)) throw webidl.errors.exception({
        header: prefix,
        message: `Expected ${argument} ("${webidl.util.Stringify(V)}") to be an instance of ${i.name}.`
      });
      return V;
    };
  };
  webidl.dictionaryConverter = function (converters) {
    return (dictionary, prefix, argument) => {
      let type = webidl.util.Type(dictionary),
        dict = {};
      if (type === "Null" || type === "Undefined") return dict;
      if (type !== "Object") throw webidl.errors.exception({
        header: prefix,
        message: `Expected ${dictionary} to be one of: Null, Undefined, Object.`
      });
      for (let options of converters) {
        let {
          key: key,
          defaultValue: defaultValue,
          required: required,
          converter: converter
        } = options;
        if (required === !0 && !Object.hasOwn(dictionary, key)) throw webidl.errors.exception({
          header: prefix,
          message: `Missing required key "${key}".`
        });
        let value = dictionary[key],
          hasDefault = Object.hasOwn(options, "defaultValue");
        if (hasDefault && value !== null && (value != null || (value = defaultValue())), required || hasDefault || value !== void 0) {
          if (value = converter(value, prefix, `${argument}.${key}`), options.allowedValues && !options.allowedValues.includes(value)) throw webidl.errors.exception({
            header: prefix,
            message: `${value} is not an accepted type. Expected one of ${options.allowedValues.join(", ")}.`
          });
          dict[key] = value;
        }
      }
      return dict;
    };
  };
  webidl.nullableConverter = function (converter) {
    return (V, prefix, argument) => V === null ? V : converter(V, prefix, argument);
  };
  webidl.converters.DOMString = function (V, prefix, argument, opts) {
    if (V === null && opts != null && opts.legacyNullToEmptyString) return "";
    if (typeof V == "symbol") throw webidl.errors.exception({
      header: prefix,
      message: `${argument} is a symbol, which cannot be converted to a DOMString.`
    });
    return String(V);
  };
  webidl.converters.ByteString = function (V, prefix, argument) {
    let x = webidl.converters.DOMString(V, prefix, argument);
    for (let index = 0; index < x.length; index++) if (x.charCodeAt(index) > 255) throw new TypeError(`Cannot convert argument to a ByteString because the character at index ${index} has a value of ${x.charCodeAt(index)} which is greater than 255.`);
    return x;
  };
  webidl.converters.USVString = toUSVString;
  webidl.converters.boolean = function (V) {
    return !!V;
  };
  webidl.converters.any = function (V) {
    return V;
  };
  webidl.converters["long long"] = function (V, prefix, argument) {
    return webidl.util.ConvertToInt(V, 64, "signed", void 0, prefix, argument);
  };
  webidl.converters["unsigned long long"] = function (V, prefix, argument) {
    return webidl.util.ConvertToInt(V, 64, "unsigned", void 0, prefix, argument);
  };
  webidl.converters["unsigned long"] = function (V, prefix, argument) {
    return webidl.util.ConvertToInt(V, 32, "unsigned", void 0, prefix, argument);
  };
  webidl.converters["unsigned short"] = function (V, prefix, argument, opts) {
    return webidl.util.ConvertToInt(V, 16, "unsigned", opts, prefix, argument);
  };
  webidl.converters.ArrayBuffer = function (V, prefix, argument, opts) {
    if (webidl.util.Type(V) !== "Object" || !types.isAnyArrayBuffer(V)) throw webidl.errors.conversionFailed({
      prefix: prefix,
      argument: `${argument} ("${webidl.util.Stringify(V)}")`,
      types: ["ArrayBuffer"]
    });
    if ((opts == null ? void 0 : opts.allowShared) === !1 && types.isSharedArrayBuffer(V)) throw webidl.errors.exception({
      header: "ArrayBuffer",
      message: "SharedArrayBuffer is not allowed."
    });
    if (V.resizable || V.growable) throw webidl.errors.exception({
      header: "ArrayBuffer",
      message: "Received a resizable ArrayBuffer."
    });
    return V;
  };
  webidl.converters.TypedArray = function (V, T, prefix, name, opts) {
    if (webidl.util.Type(V) !== "Object" || !types.isTypedArray(V) || V.constructor.name !== T.name) throw webidl.errors.conversionFailed({
      prefix: prefix,
      argument: `${name} ("${webidl.util.Stringify(V)}")`,
      types: [T.name]
    });
    if ((opts == null ? void 0 : opts.allowShared) === !1 && types.isSharedArrayBuffer(V.buffer)) throw webidl.errors.exception({
      header: "ArrayBuffer",
      message: "SharedArrayBuffer is not allowed."
    });
    if (V.buffer.resizable || V.buffer.growable) throw webidl.errors.exception({
      header: "ArrayBuffer",
      message: "Received a resizable ArrayBuffer."
    });
    return V;
  };
  webidl.converters.DataView = function (V, prefix, name, opts) {
    if (webidl.util.Type(V) !== "Object" || !types.isDataView(V)) throw webidl.errors.exception({
      header: prefix,
      message: `${name} is not a DataView.`
    });
    if ((opts == null ? void 0 : opts.allowShared) === !1 && types.isSharedArrayBuffer(V.buffer)) throw webidl.errors.exception({
      header: "ArrayBuffer",
      message: "SharedArrayBuffer is not allowed."
    });
    if (V.buffer.resizable || V.buffer.growable) throw webidl.errors.exception({
      header: "ArrayBuffer",
      message: "Received a resizable ArrayBuffer."
    });
    return V;
  };
  webidl.converters.BufferSource = function (V, prefix, name, opts) {
    if (types.isAnyArrayBuffer(V)) return webidl.converters.ArrayBuffer(V, prefix, name, {
      ...opts,
      allowShared: !1
    });
    if (types.isTypedArray(V)) return webidl.converters.TypedArray(V, V.constructor, prefix, name, {
      ...opts,
      allowShared: !1
    });
    if (types.isDataView(V)) return webidl.converters.DataView(V, prefix, name, {
      ...opts,
      allowShared: !1
    });
    throw webidl.errors.conversionFailed({
      prefix: prefix,
      argument: `${name} ("${webidl.util.Stringify(V)}")`,
      types: ["BufferSource"]
    });
  };
  webidl.converters["sequence<ByteString>"] = webidl.sequenceConverter(webidl.converters.ByteString);
  webidl.converters["sequence<sequence<ByteString>>"] = webidl.sequenceConverter(webidl.converters["sequence<ByteString>"]);
  webidl.converters["record<ByteString, ByteString>"] = webidl.recordConverter(webidl.converters.ByteString, webidl.converters.ByteString);
  module.exports = {
    webidl: webidl
  };
});