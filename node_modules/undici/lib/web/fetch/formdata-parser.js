var require_formdata_parser = __commonJSMin((exports, module) => {
  "use strict";

  var {
      isUSVString: isUSVString,
      bufferToLowerCasedHeaderName: bufferToLowerCasedHeaderName
    } = oi(),
    {
      utf8DecodeBytes: utf8DecodeBytes
    } = Lu(),
    {
      HTTP_TOKEN_CODEPOINTS: HTTP_TOKEN_CODEPOINTS,
      isomorphicDecode: isomorphicDecode
    } = zA(),
    {
      isFileLike: isFileLike
    } = vie(),
    {
      makeEntry: makeEntry
    } = K4(),
    assert = require("assert"),
    {
      File: NodeFile
    } = require("buffer"),
    _a,
    File = (_a = globalThis.File) != null ? _a : NodeFile,
    formDataNameBuffer = Buffer.from('form-data; name="'),
    filenameBuffer = Buffer.from("; filename"),
    dd = Buffer.from("--"),
    ddcrlf = Buffer.from(`--\r
`);
  function isAsciiString(chars) {
    for (let i = 0; i < chars.length; ++i) if ((chars.charCodeAt(i) & -128) !== 0) return !1;
    return !0;
  }
  __name(isAsciiString, "isAsciiString");
  function validateBoundary(boundary) {
    let length = boundary.length;
    if (length < 27 || length > 70) return !1;
    for (let i = 0; i < length; ++i) {
      let cp = boundary.charCodeAt(i);
      if (!(cp >= 48 && cp <= 57 || cp >= 65 && cp <= 90 || cp >= 97 && cp <= 122 || cp === 39 || cp === 45 || cp === 95)) return !1;
    }
    return !0;
  }
  __name(validateBoundary, "validateBoundary");
  function multipartFormDataParser(input, mimeType) {
    assert(mimeType !== "failure" && mimeType.essence === "multipart/form-data");
    let boundaryString = mimeType.parameters.get("boundary");
    if (boundaryString === void 0) return "failure";
    let boundary = Buffer.from(`--${boundaryString}`, "utf8"),
      entryList = [],
      position = {
        position: 0
      };
    for (; input[position.position] === 13 && input[position.position + 1] === 10;) position.position += 2;
    let trailing = input.length;
    for (; input[trailing - 1] === 10 && input[trailing - 2] === 13;) trailing -= 2;
    for (trailing !== input.length && (input = input.subarray(0, trailing));;) {
      if (input.subarray(position.position, position.position + boundary.length).equals(boundary)) position.position += boundary.length;else return "failure";
      if (position.position === input.length - 2 && bufferStartsWith(input, dd, position) || position.position === input.length - 4 && bufferStartsWith(input, ddcrlf, position)) return entryList;
      if (input[position.position] !== 13 || input[position.position + 1] !== 10) return "failure";
      position.position += 2;
      let result = parseMultipartFormDataHeaders(input, position);
      if (result === "failure") return "failure";
      let {
        name: name,
        filename: filename,
        contentType: contentType,
        encoding: encoding
      } = result;
      position.position += 2;
      let body;
      {
        let boundaryIndex = input.indexOf(boundary.subarray(2), position.position);
        if (boundaryIndex === -1) return "failure";
        body = input.subarray(position.position, boundaryIndex - 4), position.position += body.length, encoding === "base64" && (body = Buffer.from(body.toString(), "base64"));
      }
      if (input[position.position] !== 13 || input[position.position + 1] !== 10) return "failure";
      position.position += 2;
      let value;
      filename !== null ? (contentType != null || (contentType = "text/plain"), isAsciiString(contentType) || (contentType = ""), value = new File([body], filename, {
        type: contentType
      })) : value = utf8DecodeBytes(Buffer.from(body)), assert(isUSVString(name)), assert(typeof value == "string" && isUSVString(value) || isFileLike(value)), entryList.push(makeEntry(name, value, filename));
    }
  }
  __name(multipartFormDataParser, "multipartFormDataParser");
  function parseMultipartFormDataHeaders(input, position) {
    let name = null,
      filename = null,
      contentType = null,
      encoding = null;
    for (;;) {
      if (input[position.position] === 13 && input[position.position + 1] === 10) return name === null ? "failure" : {
        name: name,
        filename: filename,
        contentType: contentType,
        encoding: encoding
      };
      let headerName = collectASequenceOfBytes(char => char !== 10 && char !== 13 && char !== 58, input, position);
      if (headerName = removeChars(headerName, !0, !0, char => char === 9 || char === 32), !HTTP_TOKEN_CODEPOINTS.test(headerName.toString()) || input[position.position] !== 58) return "failure";
      switch (position.position++, collectASequenceOfBytes(char => char === 32 || char === 9, input, position), bufferToLowerCasedHeaderName(headerName)) {
        case "content-disposition":
          {
            if (name = filename = null, !bufferStartsWith(input, formDataNameBuffer, position) || (position.position += 17, name = parseMultipartFormDataName(input, position), name === null)) return "failure";
            if (bufferStartsWith(input, filenameBuffer, position)) {
              let check = position.position + filenameBuffer.length;
              if (input[check] === 42 && (position.position += 1, check += 1), input[check] !== 61 || input[check + 1] !== 34 || (position.position += 12, filename = parseMultipartFormDataName(input, position), filename === null)) return "failure";
            }
            break;
          }
        case "content-type":
          {
            let headerValue = collectASequenceOfBytes(char => char !== 10 && char !== 13, input, position);
            headerValue = removeChars(headerValue, !1, !0, char => char === 9 || char === 32), contentType = isomorphicDecode(headerValue);
            break;
          }
        case "content-transfer-encoding":
          {
            let headerValue = collectASequenceOfBytes(char => char !== 10 && char !== 13, input, position);
            headerValue = removeChars(headerValue, !1, !0, char => char === 9 || char === 32), encoding = isomorphicDecode(headerValue);
            break;
          }
        default:
          collectASequenceOfBytes(char => char !== 10 && char !== 13, input, position);
      }
      if (input[position.position] !== 13 && input[position.position + 1] !== 10) return "failure";
      position.position += 2;
    }
  }
  __name(parseMultipartFormDataHeaders, "parseMultipartFormDataHeaders");
  function parseMultipartFormDataName(input, position) {
    assert(input[position.position - 1] === 34);
    let name = collectASequenceOfBytes(char => char !== 10 && char !== 13 && char !== 34, input, position);
    return input[position.position] !== 34 ? null : (position.position++, name = new TextDecoder().decode(name).replace(/%0A/ig, `
`).replace(/%0D/ig, "\r").replace(/%22/g, '"'), name);
  }
  __name(parseMultipartFormDataName, "parseMultipartFormDataName");
  function collectASequenceOfBytes(condition, input, position) {
    let start = position.position;
    for (; start < input.length && condition(input[start]);) ++start;
    return input.subarray(position.position, position.position = start);
  }
  __name(collectASequenceOfBytes, "collectASequenceOfBytes");
  function removeChars(buf, leading, trailing, predicate) {
    let lead = 0,
      trail = buf.length - 1;
    if (leading) for (; lead < buf.length && predicate(buf[lead]);) lead++;
    if (trailing) for (; trail > 0 && predicate(buf[trail]);) trail--;
    return lead === 0 && trail === buf.length - 1 ? buf : buf.subarray(lead, trail + 1);
  }
  __name(removeChars, "removeChars");
  function bufferStartsWith(buffer, start, position) {
    if (buffer.length < start.length) return !1;
    for (let i = 0; i < start.length; i++) if (start[i] !== buffer[position.position + i]) return !1;
    return !0;
  }
  __name(bufferStartsWith, "bufferStartsWith");
  module.exports = {
    multipartFormDataParser: multipartFormDataParser,
    validateBoundary: validateBoundary
  };
});