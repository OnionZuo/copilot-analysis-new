var require_data_url = __commonJSMin((exports, module) => {
  "use strict";

  var assert = require("assert"),
    encoder = new TextEncoder(),
    HTTP_TOKEN_CODEPOINTS = /^[!#$%&'*+\-.^_|~A-Za-z0-9]+$/,
    HTTP_WHITESPACE_REGEX = /[\u000A\u000D\u0009\u0020]/,
    ASCII_WHITESPACE_REPLACE_REGEX = /[\u0009\u000A\u000C\u000D\u0020]/g,
    HTTP_QUOTED_STRING_TOKENS = /^[\u0009\u0020-\u007E\u0080-\u00FF]+$/;
  function dataURLProcessor(dataURL) {
    assert(dataURL.protocol === "data:");
    let input = URLSerializer(dataURL, !0);
    input = input.slice(5);
    let position = {
        position: 0
      },
      mimeType = collectASequenceOfCodePointsFast(",", input, position),
      mimeTypeLength = mimeType.length;
    if (mimeType = removeASCIIWhitespace(mimeType, !0, !0), position.position >= input.length) return "failure";
    position.position++;
    let encodedBody = input.slice(mimeTypeLength + 1),
      body = stringPercentDecode(encodedBody);
    if (/;(\u0020){0,}base64$/i.test(mimeType)) {
      let stringBody = isomorphicDecode(body);
      if (body = forgivingBase64(stringBody), body === "failure") return "failure";
      mimeType = mimeType.slice(0, -6), mimeType = mimeType.replace(/(\u0020)+$/, ""), mimeType = mimeType.slice(0, -1);
    }
    mimeType.startsWith(";") && (mimeType = "text/plain" + mimeType);
    let mimeTypeRecord = parseMIMEType(mimeType);
    return mimeTypeRecord === "failure" && (mimeTypeRecord = parseMIMEType("text/plain;charset=US-ASCII")), {
      mimeType: mimeTypeRecord,
      body: body
    };
  }
  __name(dataURLProcessor, "dataURLProcessor");
  function URLSerializer(url, excludeFragment = !1) {
    if (!excludeFragment) return url.href;
    let href = url.href,
      hashLength = url.hash.length,
      serialized = hashLength === 0 ? href : href.substring(0, href.length - hashLength);
    return !hashLength && href.endsWith("#") ? serialized.slice(0, -1) : serialized;
  }
  __name(URLSerializer, "URLSerializer");
  function collectASequenceOfCodePoints(condition, input, position) {
    let result = "";
    for (; position.position < input.length && condition(input[position.position]);) result += input[position.position], position.position++;
    return result;
  }
  __name(collectASequenceOfCodePoints, "collectASequenceOfCodePoints");
  function collectASequenceOfCodePointsFast(char, input, position) {
    let idx = input.indexOf(char, position.position),
      start = position.position;
    return idx === -1 ? (position.position = input.length, input.slice(start)) : (position.position = idx, input.slice(start, position.position));
  }
  __name(collectASequenceOfCodePointsFast, "collectASequenceOfCodePointsFast");
  function stringPercentDecode(input) {
    let bytes = encoder.encode(input);
    return percentDecode(bytes);
  }
  __name(stringPercentDecode, "stringPercentDecode");
  function isHexCharByte(byte) {
    return byte >= 48 && byte <= 57 || byte >= 65 && byte <= 70 || byte >= 97 && byte <= 102;
  }
  __name(isHexCharByte, "isHexCharByte");
  function hexByteToNumber(byte) {
    return byte >= 48 && byte <= 57 ? byte - 48 : (byte & 223) - 55;
  }
  __name(hexByteToNumber, "hexByteToNumber");
  function percentDecode(input) {
    let length = input.length,
      output = new Uint8Array(length),
      j = 0;
    for (let i = 0; i < length; ++i) {
      let byte = input[i];
      byte !== 37 ? output[j++] = byte : byte === 37 && !(isHexCharByte(input[i + 1]) && isHexCharByte(input[i + 2])) ? output[j++] = 37 : (output[j++] = hexByteToNumber(input[i + 1]) << 4 | hexByteToNumber(input[i + 2]), i += 2);
    }
    return length === j ? output : output.subarray(0, j);
  }
  __name(percentDecode, "percentDecode");
  function parseMIMEType(input) {
    input = removeHTTPWhitespace(input, !0, !0);
    let position = {
        position: 0
      },
      type = collectASequenceOfCodePointsFast("/", input, position);
    if (type.length === 0 || !HTTP_TOKEN_CODEPOINTS.test(type) || position.position > input.length) return "failure";
    position.position++;
    let subtype = collectASequenceOfCodePointsFast(";", input, position);
    if (subtype = removeHTTPWhitespace(subtype, !1, !0), subtype.length === 0 || !HTTP_TOKEN_CODEPOINTS.test(subtype)) return "failure";
    let typeLowercase = type.toLowerCase(),
      subtypeLowercase = subtype.toLowerCase(),
      mimeType = {
        type: typeLowercase,
        subtype: subtypeLowercase,
        parameters: new Map(),
        essence: `${typeLowercase}/${subtypeLowercase}`
      };
    for (; position.position < input.length;) {
      position.position++, collectASequenceOfCodePoints(char => HTTP_WHITESPACE_REGEX.test(char), input, position);
      let parameterName = collectASequenceOfCodePoints(char => char !== ";" && char !== "=", input, position);
      if (parameterName = parameterName.toLowerCase(), position.position < input.length) {
        if (input[position.position] === ";") continue;
        position.position++;
      }
      if (position.position > input.length) break;
      let parameterValue = null;
      if (input[position.position] === '"') parameterValue = collectAnHTTPQuotedString(input, position, !0), collectASequenceOfCodePointsFast(";", input, position);else if (parameterValue = collectASequenceOfCodePointsFast(";", input, position), parameterValue = removeHTTPWhitespace(parameterValue, !1, !0), parameterValue.length === 0) continue;
      parameterName.length !== 0 && HTTP_TOKEN_CODEPOINTS.test(parameterName) && (parameterValue.length === 0 || HTTP_QUOTED_STRING_TOKENS.test(parameterValue)) && !mimeType.parameters.has(parameterName) && mimeType.parameters.set(parameterName, parameterValue);
    }
    return mimeType;
  }
  __name(parseMIMEType, "parseMIMEType");
  function forgivingBase64(data) {
    data = data.replace(ASCII_WHITESPACE_REPLACE_REGEX, "");
    let dataLength = data.length;
    if (dataLength % 4 === 0 && data.charCodeAt(dataLength - 1) === 61 && (--dataLength, data.charCodeAt(dataLength - 1) === 61 && --dataLength), dataLength % 4 === 1 || /[^+/0-9A-Za-z]/.test(data.length === dataLength ? data : data.substring(0, dataLength))) return "failure";
    let buffer = Buffer.from(data, "base64");
    return new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);
  }
  __name(forgivingBase64, "forgivingBase64");
  function collectAnHTTPQuotedString(input, position, extractValue) {
    let positionStart = position.position,
      value = "";
    for (assert(input[position.position] === '"'), position.position++; value += collectASequenceOfCodePoints(char => char !== '"' && char !== "\\", input, position), !(position.position >= input.length);) {
      let quoteOrBackslash = input[position.position];
      if (position.position++, quoteOrBackslash === "\\") {
        if (position.position >= input.length) {
          value += "\\";
          break;
        }
        value += input[position.position], position.position++;
      } else {
        assert(quoteOrBackslash === '"');
        break;
      }
    }
    return extractValue ? value : input.slice(positionStart, position.position);
  }
  __name(collectAnHTTPQuotedString, "collectAnHTTPQuotedString");
  function serializeAMimeType(mimeType) {
    assert(mimeType !== "failure");
    let {
        parameters: parameters,
        essence: essence
      } = mimeType,
      serialization = essence;
    for (let [name, value] of parameters.entries()) serialization += ";", serialization += name, serialization += "=", HTTP_TOKEN_CODEPOINTS.test(value) || (value = value.replace(/(\\|")/g, "\\$1"), value = '"' + value, value += '"'), serialization += value;
    return serialization;
  }
  __name(serializeAMimeType, "serializeAMimeType");
  function isHTTPWhiteSpace(char) {
    return char === 13 || char === 10 || char === 9 || char === 32;
  }
  __name(isHTTPWhiteSpace, "isHTTPWhiteSpace");
  function removeHTTPWhitespace(str, leading = !0, trailing = !0) {
    return removeChars(str, leading, trailing, isHTTPWhiteSpace);
  }
  __name(removeHTTPWhitespace, "removeHTTPWhitespace");
  function isASCIIWhitespace(char) {
    return char === 13 || char === 10 || char === 9 || char === 12 || char === 32;
  }
  __name(isASCIIWhitespace, "isASCIIWhitespace");
  function removeASCIIWhitespace(str, leading = !0, trailing = !0) {
    return removeChars(str, leading, trailing, isASCIIWhitespace);
  }
  __name(removeASCIIWhitespace, "removeASCIIWhitespace");
  function removeChars(str, leading, trailing, predicate) {
    let lead = 0,
      trail = str.length - 1;
    if (leading) for (; lead < str.length && predicate(str.charCodeAt(lead));) lead++;
    if (trailing) for (; trail > 0 && predicate(str.charCodeAt(trail));) trail--;
    return lead === 0 && trail === str.length - 1 ? str : str.slice(lead, trail + 1);
  }
  __name(removeChars, "removeChars");
  function isomorphicDecode(input) {
    let length = input.length;
    if (65535 > length) return String.fromCharCode.apply(null, input);
    let result = "",
      i = 0,
      addition = 65535;
    for (; i < length;) i + addition > length && (addition = length - i), result += String.fromCharCode.apply(null, input.subarray(i, i += addition));
    return result;
  }
  __name(isomorphicDecode, "isomorphicDecode");
  function minimizeSupportedMimeType(mimeType) {
    switch (mimeType.essence) {
      case "application/ecmascript":
      case "application/javascript":
      case "application/x-ecmascript":
      case "application/x-javascript":
      case "text/ecmascript":
      case "text/javascript":
      case "text/javascript1.0":
      case "text/javascript1.1":
      case "text/javascript1.2":
      case "text/javascript1.3":
      case "text/javascript1.4":
      case "text/javascript1.5":
      case "text/jscript":
      case "text/livescript":
      case "text/x-ecmascript":
      case "text/x-javascript":
        return "text/javascript";
      case "application/json":
      case "text/json":
        return "application/json";
      case "image/svg+xml":
        return "image/svg+xml";
      case "text/xml":
      case "application/xml":
        return "application/xml";
    }
    return mimeType.subtype.endsWith("+json") ? "application/json" : mimeType.subtype.endsWith("+xml") ? "application/xml" : "";
  }
  __name(minimizeSupportedMimeType, "minimizeSupportedMimeType");
  module.exports = {
    dataURLProcessor: dataURLProcessor,
    URLSerializer: URLSerializer,
    collectASequenceOfCodePoints: collectASequenceOfCodePoints,
    collectASequenceOfCodePointsFast: collectASequenceOfCodePointsFast,
    stringPercentDecode: stringPercentDecode,
    parseMIMEType: parseMIMEType,
    collectAnHTTPQuotedString: collectAnHTTPQuotedString,
    serializeAMimeType: serializeAMimeType,
    removeChars: removeChars,
    removeHTTPWhitespace: removeHTTPWhitespace,
    minimizeSupportedMimeType: minimizeSupportedMimeType,
    HTTP_TOKEN_CODEPOINTS: HTTP_TOKEN_CODEPOINTS,
    isomorphicDecode: isomorphicDecode
  };
});