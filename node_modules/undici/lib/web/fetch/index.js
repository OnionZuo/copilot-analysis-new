var require_fetch = __commonJSMin((exports, module) => {
  "use strict";

  var {
      makeNetworkError: makeNetworkError,
      makeAppropriateNetworkError: makeAppropriateNetworkError,
      filterResponse: filterResponse,
      makeResponse: makeResponse,
      fromInnerResponse: fromInnerResponse
    } = B9(),
    {
      HeadersList: HeadersList
    } = Dx(),
    {
      Request: Request,
      cloneRequest: cloneRequest
    } = vI(),
    zlib = require("zlib"),
    {
      bytesMatch: bytesMatch,
      makePolicyContainer: makePolicyContainer,
      clonePolicyContainer: clonePolicyContainer,
      requestBadPort: requestBadPort,
      TAOCheck: TAOCheck,
      appendRequestOriginHeader: appendRequestOriginHeader,
      responseLocationURL: responseLocationURL,
      requestCurrentURL: requestCurrentURL,
      setRequestReferrerPolicyOnRedirect: setRequestReferrerPolicyOnRedirect,
      tryUpgradeRequestToAPotentiallyTrustworthyURL: tryUpgradeRequestToAPotentiallyTrustworthyURL,
      createOpaqueTimingInfo: createOpaqueTimingInfo,
      appendFetchMetadata: appendFetchMetadata,
      corsCheck: corsCheck,
      crossOriginResourcePolicyCheck: crossOriginResourcePolicyCheck,
      determineRequestsReferrer: determineRequestsReferrer,
      coarsenedSharedCurrentTime: coarsenedSharedCurrentTime,
      createDeferredPromise: createDeferredPromise,
      isBlobLike: isBlobLike,
      sameOrigin: sameOrigin,
      isCancelled: isCancelled,
      isAborted: isAborted,
      isErrorLike: isErrorLike,
      fullyReadBody: fullyReadBody,
      readableStreamClose: readableStreamClose,
      isomorphicEncode: isomorphicEncode,
      urlIsLocal: urlIsLocal,
      urlIsHttpHttpsScheme: urlIsHttpHttpsScheme,
      urlHasHttpsScheme: urlHasHttpsScheme,
      clampAndCoarsenConnectionTimingInfo: clampAndCoarsenConnectionTimingInfo,
      simpleRangeHeaderValue: simpleRangeHeaderValue,
      buildContentRange: buildContentRange,
      createInflate: createInflate,
      extractMimeType: extractMimeType
    } = Lu(),
    {
      kState: kState,
      kDispatcher: kDispatcher
    } = iw(),
    assert = require("assert"),
    {
      safelyExtractBody: safelyExtractBody,
      extractBody: extractBody
    } = Wv(),
    {
      redirectStatusSet: redirectStatusSet,
      nullBodyStatus: nullBodyStatus,
      safeMethodsSet: safeMethodsSet,
      requestBodyHeader: requestBodyHeader,
      subresourceSet: subresourceSet
    } = O4(),
    EE = require("events"),
    {
      Readable: Readable,
      pipeline: pipeline,
      finished: finished
    } = require("stream"),
    {
      addAbortListener: addAbortListener,
      isErrored: isErrored,
      isReadable: isReadable,
      bufferToLowerCasedHeaderName: bufferToLowerCasedHeaderName
    } = oi(),
    {
      dataURLProcessor: dataURLProcessor,
      serializeAMimeType: serializeAMimeType,
      minimizeSupportedMimeType: minimizeSupportedMimeType
    } = zA(),
    {
      getGlobalDispatcher: getGlobalDispatcher
    } = GM(),
    {
      webidl: webidl
    } = Gc(),
    {
      STATUS_CODES: STATUS_CODES
    } = require("http"),
    GET_OR_HEAD = ["GET", "HEAD"],
    defaultUserAgent = typeof __UNDICI_IS_NODE__ < "u" || typeof esbuildDetection < "u" ? "node" : "undici",
    resolveObjectURL,
    _Fetch = class _Fetch extends EE {
      constructor(dispatcher) {
        super(), this.dispatcher = dispatcher, this.connection = null, this.dump = !1, this.state = "ongoing";
      }
      terminate(reason) {
        var _a;
        this.state === "ongoing" && (this.state = "terminated", (_a = this.connection) == null || _a.destroy(reason), this.emit("terminated", reason));
      }
      abort(error) {
        var _a;
        this.state === "ongoing" && (this.state = "aborted", error || (error = new DOMException("The operation was aborted.", "AbortError")), this.serializedAbortReason = error, (_a = this.connection) == null || _a.destroy(error), this.emit("terminated", error));
      }
    };
  __name(_Fetch, "Fetch");
  var Fetch = _Fetch;
  function handleFetchDone(response) {
    finalizeAndReportTiming(response, "fetch");
  }
  __name(handleFetchDone, "handleFetchDone");
  function fetch(input, init = void 0) {
    var _a;
    webidl.argumentLengthCheck(arguments, 1, "globalThis.fetch");
    let p = createDeferredPromise(),
      requestObject;
    try {
      requestObject = new Request(input, init);
    } catch (e) {
      return p.reject(e), p.promise;
    }
    let request = requestObject[kState];
    if (requestObject.signal.aborted) return abortFetch(p, request, null, requestObject.signal.reason), p.promise;
    let globalObject = request.client.globalObject;
    ((_a = globalObject == null ? void 0 : globalObject.constructor) == null ? void 0 : _a.name) === "ServiceWorkerGlobalScope" && (request.serviceWorkers = "none");
    let responseObject = null,
      locallyAborted = !1,
      controller = null;
    return addAbortListener(requestObject.signal, () => {
      locallyAborted = !0, assert(controller != null), controller.abort(requestObject.signal.reason);
      let realResponse = responseObject == null ? void 0 : responseObject.deref();
      abortFetch(p, request, realResponse, requestObject.signal.reason);
    }), controller = fetching({
      request: request,
      processResponseEndOfBody: handleFetchDone,
      processResponse: __name(response => {
        if (!locallyAborted) {
          if (response.aborted) {
            abortFetch(p, request, responseObject, controller.serializedAbortReason);
            return;
          }
          if (response.type === "error") {
            p.reject(new TypeError("fetch failed", {
              cause: response.error
            }));
            return;
          }
          responseObject = new WeakRef(fromInnerResponse(response, "immutable")), p.resolve(responseObject.deref()), p = null;
        }
      }, "processResponse"),
      dispatcher: requestObject[kDispatcher]
    }), p.promise;
  }
  __name(fetch, "fetch");
  function finalizeAndReportTiming(response, initiatorType = "other") {
    var _a;
    if (response.type === "error" && response.aborted || !((_a = response.urlList) != null && _a.length)) return;
    let originalURL = response.urlList[0],
      timingInfo = response.timingInfo,
      cacheState = response.cacheState;
    urlIsHttpHttpsScheme(originalURL) && timingInfo !== null && (response.timingAllowPassed || (timingInfo = createOpaqueTimingInfo({
      startTime: timingInfo.startTime
    }), cacheState = ""), timingInfo.endTime = coarsenedSharedCurrentTime(), response.timingInfo = timingInfo, markResourceTiming(timingInfo, originalURL.href, initiatorType, globalThis, cacheState));
  }
  __name(finalizeAndReportTiming, "finalizeAndReportTiming");
  var markResourceTiming = performance.markResourceTiming;
  function abortFetch(p, request, responseObject, error) {
    var _a, _b;
    if (p && p.reject(error), request.body != null && isReadable((_a = request.body) == null ? void 0 : _a.stream) && request.body.stream.cancel(error).catch(err => {
      if (err.code !== "ERR_INVALID_STATE") throw err;
    }), responseObject == null) return;
    let response = responseObject[kState];
    response.body != null && isReadable((_b = response.body) == null ? void 0 : _b.stream) && response.body.stream.cancel(error).catch(err => {
      if (err.code !== "ERR_INVALID_STATE") throw err;
    });
  }
  __name(abortFetch, "abortFetch");
  function fetching({
    request: request,
    processRequestBodyChunkLength: processRequestBodyChunkLength,
    processRequestEndOfBody: processRequestEndOfBody,
    processResponse: processResponse,
    processResponseEndOfBody: processResponseEndOfBody,
    processResponseConsumeBody: processResponseConsumeBody,
    useParallelQueue = !1,
    dispatcher = getGlobalDispatcher()
  }) {
    var _a, _b, _c;
    assert(dispatcher);
    let taskDestination = null,
      crossOriginIsolatedCapability = !1;
    request.client != null && (taskDestination = request.client.globalObject, crossOriginIsolatedCapability = request.client.crossOriginIsolatedCapability);
    let currentTime = coarsenedSharedCurrentTime(crossOriginIsolatedCapability),
      timingInfo = createOpaqueTimingInfo({
        startTime: currentTime
      }),
      fetchParams = {
        controller: new Fetch(dispatcher),
        request: request,
        timingInfo: timingInfo,
        processRequestBodyChunkLength: processRequestBodyChunkLength,
        processRequestEndOfBody: processRequestEndOfBody,
        processResponse: processResponse,
        processResponseConsumeBody: processResponseConsumeBody,
        processResponseEndOfBody: processResponseEndOfBody,
        taskDestination: taskDestination,
        crossOriginIsolatedCapability: crossOriginIsolatedCapability
      };
    return assert(!request.body || request.body.stream), request.window === "client" && (request.window = ((_c = (_b = (_a = request.client) == null ? void 0 : _a.globalObject) == null ? void 0 : _b.constructor) == null ? void 0 : _c.name) === "Window" ? request.client : "no-window"), request.origin === "client" && (request.origin = request.client.origin), request.policyContainer === "client" && (request.client != null ? request.policyContainer = clonePolicyContainer(request.client.policyContainer) : request.policyContainer = makePolicyContainer()), request.headersList.contains("accept", !0) || request.headersList.append("accept", "*/*", !0), request.headersList.contains("accept-language", !0) || request.headersList.append("accept-language", "*", !0), request.priority, subresourceSet.has(request.destination), mainFetch(fetchParams).catch(err => {
      fetchParams.controller.terminate(err);
    }), fetchParams.controller;
  }
  __name(fetching, "fetching");
  async function mainFetch(fetchParams, recursive = !1) {
    let request = fetchParams.request,
      response = null;
    if (request.localURLsOnly && !urlIsLocal(requestCurrentURL(request)) && (response = makeNetworkError("local URLs only")), tryUpgradeRequestToAPotentiallyTrustworthyURL(request), requestBadPort(request) === "blocked" && (response = makeNetworkError("bad port")), request.referrerPolicy === "" && (request.referrerPolicy = request.policyContainer.referrerPolicy), request.referrer !== "no-referrer" && (request.referrer = determineRequestsReferrer(request)), response === null && (response = await (async () => {
      let currentURL = requestCurrentURL(request);
      return sameOrigin(currentURL, request.url) && request.responseTainting === "basic" || currentURL.protocol === "data:" || request.mode === "navigate" || request.mode === "websocket" ? (request.responseTainting = "basic", await schemeFetch(fetchParams)) : request.mode === "same-origin" ? makeNetworkError('request mode cannot be "same-origin"') : request.mode === "no-cors" ? request.redirect !== "follow" ? makeNetworkError('redirect mode cannot be "follow" for "no-cors" request') : (request.responseTainting = "opaque", await schemeFetch(fetchParams)) : urlIsHttpHttpsScheme(requestCurrentURL(request)) ? (request.responseTainting = "cors", await httpFetch(fetchParams)) : makeNetworkError("URL scheme must be a HTTP(S) scheme");
    })()), recursive) return response;
    response.status !== 0 && !response.internalResponse && (request.responseTainting, request.responseTainting === "basic" ? response = filterResponse(response, "basic") : request.responseTainting === "cors" ? response = filterResponse(response, "cors") : request.responseTainting === "opaque" ? response = filterResponse(response, "opaque") : assert(!1));
    let internalResponse = response.status === 0 ? response : response.internalResponse;
    if (internalResponse.urlList.length === 0 && internalResponse.urlList.push(...request.urlList), request.timingAllowFailed || (response.timingAllowPassed = !0), response.type === "opaque" && internalResponse.status === 206 && internalResponse.rangeRequested && !request.headers.contains("range", !0) && (response = internalResponse = makeNetworkError()), response.status !== 0 && (request.method === "HEAD" || request.method === "CONNECT" || nullBodyStatus.includes(internalResponse.status)) && (internalResponse.body = null, fetchParams.controller.dump = !0), request.integrity) {
      let processBodyError = __name(reason => fetchFinale(fetchParams, makeNetworkError(reason)), "processBodyError");
      if (request.responseTainting === "opaque" || response.body == null) {
        processBodyError(response.error);
        return;
      }
      let processBody = __name(bytes => {
        if (!bytesMatch(bytes, request.integrity)) {
          processBodyError("integrity mismatch");
          return;
        }
        response.body = safelyExtractBody(bytes)[0], fetchFinale(fetchParams, response);
      }, "processBody");
      await fullyReadBody(response.body, processBody, processBodyError);
    } else fetchFinale(fetchParams, response);
  }
  __name(mainFetch, "mainFetch");
  function schemeFetch(fetchParams) {
    if (isCancelled(fetchParams) && fetchParams.request.redirectCount === 0) return Promise.resolve(makeAppropriateNetworkError(fetchParams));
    let {
        request: request
      } = fetchParams,
      {
        protocol: scheme
      } = requestCurrentURL(request);
    switch (scheme) {
      case "about:":
        return Promise.resolve(makeNetworkError("about scheme is not supported"));
      case "blob:":
        {
          resolveObjectURL || (resolveObjectURL = require("buffer").resolveObjectURL);
          let blobURLEntry = requestCurrentURL(request);
          if (blobURLEntry.search.length !== 0) return Promise.resolve(makeNetworkError("NetworkError when attempting to fetch resource."));
          let blob = resolveObjectURL(blobURLEntry.toString());
          if (request.method !== "GET" || !isBlobLike(blob)) return Promise.resolve(makeNetworkError("invalid method"));
          let response = makeResponse(),
            fullLength = blob.size,
            serializedFullLength = isomorphicEncode(`${fullLength}`),
            type = blob.type;
          if (request.headersList.contains("range", !0)) {
            response.rangeRequested = !0;
            let rangeHeader = request.headersList.get("range", !0),
              rangeValue = simpleRangeHeaderValue(rangeHeader, !0);
            if (rangeValue === "failure") return Promise.resolve(makeNetworkError("failed to fetch the data URL"));
            let {
              rangeStartValue: rangeStart,
              rangeEndValue: rangeEnd
            } = rangeValue;
            if (rangeStart === null) rangeStart = fullLength - rangeEnd, rangeEnd = rangeStart + rangeEnd - 1;else {
              if (rangeStart >= fullLength) return Promise.resolve(makeNetworkError("Range start is greater than the blob's size."));
              (rangeEnd === null || rangeEnd >= fullLength) && (rangeEnd = fullLength - 1);
            }
            let slicedBlob = blob.slice(rangeStart, rangeEnd, type),
              slicedBodyWithType = extractBody(slicedBlob);
            response.body = slicedBodyWithType[0];
            let serializedSlicedLength = isomorphicEncode(`${slicedBlob.size}`),
              contentRange = buildContentRange(rangeStart, rangeEnd, fullLength);
            response.status = 206, response.statusText = "Partial Content", response.headersList.set("content-length", serializedSlicedLength, !0), response.headersList.set("content-type", type, !0), response.headersList.set("content-range", contentRange, !0);
          } else {
            let bodyWithType = extractBody(blob);
            response.statusText = "OK", response.body = bodyWithType[0], response.headersList.set("content-length", serializedFullLength, !0), response.headersList.set("content-type", type, !0);
          }
          return Promise.resolve(response);
        }
      case "data:":
        {
          let currentURL = requestCurrentURL(request),
            dataURLStruct = dataURLProcessor(currentURL);
          if (dataURLStruct === "failure") return Promise.resolve(makeNetworkError("failed to fetch the data URL"));
          let mimeType = serializeAMimeType(dataURLStruct.mimeType);
          return Promise.resolve(makeResponse({
            statusText: "OK",
            headersList: [["content-type", {
              name: "Content-Type",
              value: mimeType
            }]],
            body: safelyExtractBody(dataURLStruct.body)[0]
          }));
        }
      case "file:":
        return Promise.resolve(makeNetworkError("not implemented... yet..."));
      case "http:":
      case "https:":
        return httpFetch(fetchParams).catch(err => makeNetworkError(err));
      default:
        return Promise.resolve(makeNetworkError("unknown scheme"));
    }
  }
  __name(schemeFetch, "schemeFetch");
  function finalizeResponse(fetchParams, response) {
    fetchParams.request.done = !0, fetchParams.processResponseDone != null && queueMicrotask(() => fetchParams.processResponseDone(response));
  }
  __name(finalizeResponse, "finalizeResponse");
  function fetchFinale(fetchParams, response) {
    var _a;
    let timingInfo = fetchParams.timingInfo,
      processResponseEndOfBody = __name(() => {
        let unsafeEndTime = Date.now();
        fetchParams.request.destination === "document" && (fetchParams.controller.fullTimingInfo = timingInfo), fetchParams.controller.reportTimingSteps = () => {
          if (fetchParams.request.url.protocol !== "https:") return;
          timingInfo.endTime = unsafeEndTime;
          let cacheState = response.cacheState,
            bodyInfo = response.bodyInfo;
          response.timingAllowPassed || (timingInfo = createOpaqueTimingInfo(timingInfo), cacheState = "");
          let responseStatus = 0;
          if (fetchParams.request.mode !== "navigator" || !response.hasCrossOriginRedirects) {
            responseStatus = response.status;
            let mimeType = extractMimeType(response.headersList);
            mimeType !== "failure" && (bodyInfo.contentType = minimizeSupportedMimeType(mimeType));
          }
          fetchParams.request.initiatorType != null && markResourceTiming(timingInfo, fetchParams.request.url.href, fetchParams.request.initiatorType, globalThis, cacheState, bodyInfo, responseStatus);
        };
        let processResponseEndOfBodyTask = __name(() => {
          fetchParams.request.done = !0, fetchParams.processResponseEndOfBody != null && queueMicrotask(() => fetchParams.processResponseEndOfBody(response)), fetchParams.request.initiatorType != null && fetchParams.controller.reportTimingSteps();
        }, "processResponseEndOfBodyTask");
        queueMicrotask(() => processResponseEndOfBodyTask());
      }, "processResponseEndOfBody");
    fetchParams.processResponse != null && queueMicrotask(() => {
      fetchParams.processResponse(response), fetchParams.processResponse = null;
    });
    let internalResponse = response.type === "error" ? response : (_a = response.internalResponse) != null ? _a : response;
    internalResponse.body == null ? processResponseEndOfBody() : finished(internalResponse.body.stream, () => {
      processResponseEndOfBody();
    });
  }
  __name(fetchFinale, "fetchFinale");
  async function httpFetch(fetchParams) {
    let request = fetchParams.request,
      response = null,
      actualResponse = null,
      timingInfo = fetchParams.timingInfo;
    if (request.serviceWorkers, response === null) {
      if (request.redirect === "follow" && (request.serviceWorkers = "none"), actualResponse = response = await httpNetworkOrCacheFetch(fetchParams), request.responseTainting === "cors" && corsCheck(request, response) === "failure") return makeNetworkError("cors failure");
      TAOCheck(request, response) === "failure" && (request.timingAllowFailed = !0);
    }
    return (request.responseTainting === "opaque" || response.type === "opaque") && crossOriginResourcePolicyCheck(request.origin, request.client, request.destination, actualResponse) === "blocked" ? makeNetworkError("blocked") : (redirectStatusSet.has(actualResponse.status) && (request.redirect !== "manual" && fetchParams.controller.connection.destroy(void 0, !1), request.redirect === "error" ? response = makeNetworkError("unexpected redirect") : request.redirect === "manual" ? response = actualResponse : request.redirect === "follow" ? response = await httpRedirectFetch(fetchParams, response) : assert(!1)), response.timingInfo = timingInfo, response);
  }
  __name(httpFetch, "httpFetch");
  function httpRedirectFetch(fetchParams, response) {
    let request = fetchParams.request,
      actualResponse = response.internalResponse ? response.internalResponse : response,
      locationURL;
    try {
      if (locationURL = responseLocationURL(actualResponse, requestCurrentURL(request).hash), locationURL == null) return response;
    } catch (err) {
      return Promise.resolve(makeNetworkError(err));
    }
    if (!urlIsHttpHttpsScheme(locationURL)) return Promise.resolve(makeNetworkError("URL scheme must be a HTTP(S) scheme"));
    if (request.redirectCount === 20) return Promise.resolve(makeNetworkError("redirect count exceeded"));
    if (request.redirectCount += 1, request.mode === "cors" && (locationURL.username || locationURL.password) && !sameOrigin(request, locationURL)) return Promise.resolve(makeNetworkError('cross origin not allowed for request mode "cors"'));
    if (request.responseTainting === "cors" && (locationURL.username || locationURL.password)) return Promise.resolve(makeNetworkError('URL cannot contain credentials for request mode "cors"'));
    if (actualResponse.status !== 303 && request.body != null && request.body.source == null) return Promise.resolve(makeNetworkError());
    if ([301, 302].includes(actualResponse.status) && request.method === "POST" || actualResponse.status === 303 && !GET_OR_HEAD.includes(request.method)) {
      request.method = "GET", request.body = null;
      for (let headerName of requestBodyHeader) request.headersList.delete(headerName);
    }
    sameOrigin(requestCurrentURL(request), locationURL) || (request.headersList.delete("authorization", !0), request.headersList.delete("proxy-authorization", !0), request.headersList.delete("cookie", !0), request.headersList.delete("host", !0)), request.body != null && (assert(request.body.source != null), request.body = safelyExtractBody(request.body.source)[0]);
    let timingInfo = fetchParams.timingInfo;
    return timingInfo.redirectEndTime = timingInfo.postRedirectStartTime = coarsenedSharedCurrentTime(fetchParams.crossOriginIsolatedCapability), timingInfo.redirectStartTime === 0 && (timingInfo.redirectStartTime = timingInfo.startTime), request.urlList.push(locationURL), setRequestReferrerPolicyOnRedirect(request, actualResponse), mainFetch(fetchParams, !0);
  }
  __name(httpRedirectFetch, "httpRedirectFetch");
  async function httpNetworkOrCacheFetch(fetchParams, isAuthenticationFetch = !1, isNewConnectionFetch = !1) {
    let request = fetchParams.request,
      httpFetchParams = null,
      httpRequest = null,
      response = null,
      httpCache = null,
      revalidatingFlag = !1;
    request.window === "no-window" && request.redirect === "error" ? (httpFetchParams = fetchParams, httpRequest = request) : (httpRequest = cloneRequest(request), httpFetchParams = {
      ...fetchParams
    }, httpFetchParams.request = httpRequest);
    let includeCredentials = request.credentials === "include" || request.credentials === "same-origin" && request.responseTainting === "basic",
      contentLength = httpRequest.body ? httpRequest.body.length : null,
      contentLengthHeaderValue = null;
    if (httpRequest.body == null && ["POST", "PUT"].includes(httpRequest.method) && (contentLengthHeaderValue = "0"), contentLength != null && (contentLengthHeaderValue = isomorphicEncode(`${contentLength}`)), contentLengthHeaderValue != null && httpRequest.headersList.append("content-length", contentLengthHeaderValue, !0), contentLength != null && httpRequest.keepalive, httpRequest.referrer instanceof URL && httpRequest.headersList.append("referer", isomorphicEncode(httpRequest.referrer.href), !0), appendRequestOriginHeader(httpRequest), appendFetchMetadata(httpRequest), httpRequest.headersList.contains("user-agent", !0) || httpRequest.headersList.append("user-agent", defaultUserAgent), httpRequest.cache === "default" && (httpRequest.headersList.contains("if-modified-since", !0) || httpRequest.headersList.contains("if-none-match", !0) || httpRequest.headersList.contains("if-unmodified-since", !0) || httpRequest.headersList.contains("if-match", !0) || httpRequest.headersList.contains("if-range", !0)) && (httpRequest.cache = "no-store"), httpRequest.cache === "no-cache" && !httpRequest.preventNoCacheCacheControlHeaderModification && !httpRequest.headersList.contains("cache-control", !0) && httpRequest.headersList.append("cache-control", "max-age=0", !0), (httpRequest.cache === "no-store" || httpRequest.cache === "reload") && (httpRequest.headersList.contains("pragma", !0) || httpRequest.headersList.append("pragma", "no-cache", !0), httpRequest.headersList.contains("cache-control", !0) || httpRequest.headersList.append("cache-control", "no-cache", !0)), httpRequest.headersList.contains("range", !0) && httpRequest.headersList.append("accept-encoding", "identity", !0), httpRequest.headersList.contains("accept-encoding", !0) || (urlHasHttpsScheme(requestCurrentURL(httpRequest)) ? httpRequest.headersList.append("accept-encoding", "br, gzip, deflate", !0) : httpRequest.headersList.append("accept-encoding", "gzip, deflate", !0)), httpRequest.headersList.delete("host", !0), httpCache == null && (httpRequest.cache = "no-store"), httpRequest.cache !== "no-store" && httpRequest.cache, response == null) {
      if (httpRequest.cache === "only-if-cached") return makeNetworkError("only if cached");
      let forwardResponse = await httpNetworkFetch(httpFetchParams, includeCredentials, isNewConnectionFetch);
      !safeMethodsSet.has(httpRequest.method) && forwardResponse.status >= 200 && forwardResponse.status <= 399, revalidatingFlag && forwardResponse.status, response == null && (response = forwardResponse);
    }
    if (response.urlList = [...httpRequest.urlList], httpRequest.headersList.contains("range", !0) && (response.rangeRequested = !0), response.requestIncludesCredentials = includeCredentials, response.status === 407) return request.window === "no-window" ? makeNetworkError() : isCancelled(fetchParams) ? makeAppropriateNetworkError(fetchParams) : makeNetworkError("proxy authentication required");
    if (response.status === 421 && !isNewConnectionFetch && (request.body == null || request.body.source != null)) {
      if (isCancelled(fetchParams)) return makeAppropriateNetworkError(fetchParams);
      fetchParams.controller.connection.destroy(), response = await httpNetworkOrCacheFetch(fetchParams, isAuthenticationFetch, !0);
    }
    return response;
  }
  __name(httpNetworkOrCacheFetch, "httpNetworkOrCacheFetch");
  async function httpNetworkFetch(fetchParams, includeCredentials = !1, forceNewConnection = !1) {
    assert(!fetchParams.controller.connection || fetchParams.controller.connection.destroyed), fetchParams.controller.connection = {
      abort: null,
      destroyed: !1,
      destroy(err, abort = !0) {
        var _a;
        this.destroyed || (this.destroyed = !0, abort && ((_a = this.abort) == null || _a.call(this, err != null ? err : new DOMException("The operation was aborted.", "AbortError"))));
      }
    };
    let request = fetchParams.request,
      response = null,
      timingInfo = fetchParams.timingInfo;
    null == null && (request.cache = "no-store");
    let newConnection = forceNewConnection ? "yes" : "no";
    request.mode;
    let requestBody = null;
    if (request.body == null && fetchParams.processRequestEndOfBody) queueMicrotask(() => fetchParams.processRequestEndOfBody());else if (request.body != null) {
      let processBodyChunk = __name(async function* (bytes) {
          var _a;
          isCancelled(fetchParams) || (yield bytes, (_a = fetchParams.processRequestBodyChunkLength) == null || _a.call(fetchParams, bytes.byteLength));
        }, "processBodyChunk"),
        processEndOfBody = __name(() => {
          isCancelled(fetchParams) || fetchParams.processRequestEndOfBody && fetchParams.processRequestEndOfBody();
        }, "processEndOfBody"),
        processBodyError = __name(e => {
          isCancelled(fetchParams) || (e.name === "AbortError" ? fetchParams.controller.abort() : fetchParams.controller.terminate(e));
        }, "processBodyError");
      requestBody = async function* () {
        try {
          for await (let bytes of request.body.stream) yield* processBodyChunk(bytes);
          processEndOfBody();
        } catch (err) {
          processBodyError(err);
        }
      }();
    }
    try {
      let {
        body: body,
        status: status,
        statusText: statusText,
        headersList: headersList,
        socket: socket
      } = await dispatch({
        body: requestBody
      });
      if (socket) response = makeResponse({
        status: status,
        statusText: statusText,
        headersList: headersList,
        socket: socket
      });else {
        let iterator = body[Symbol.asyncIterator]();
        fetchParams.controller.next = () => iterator.next(), response = makeResponse({
          status: status,
          statusText: statusText,
          headersList: headersList
        });
      }
    } catch (err) {
      return err.name === "AbortError" ? (fetchParams.controller.connection.destroy(), makeAppropriateNetworkError(fetchParams, err)) : makeNetworkError(err);
    }
    let pullAlgorithm = __name(async () => {
        await fetchParams.controller.resume();
      }, "pullAlgorithm"),
      cancelAlgorithm = __name(reason => {
        isCancelled(fetchParams) || fetchParams.controller.abort(reason);
      }, "cancelAlgorithm"),
      stream = new ReadableStream({
        async start(controller) {
          fetchParams.controller.controller = controller;
        },
        async pull(controller) {
          await pullAlgorithm(controller);
        },
        async cancel(reason) {
          await cancelAlgorithm(reason);
        },
        type: "bytes"
      });
    response.body = {
      stream: stream,
      source: null,
      length: null
    }, fetchParams.controller.onAborted = onAborted, fetchParams.controller.on("terminated", onAborted), fetchParams.controller.resume = async () => {
      var _a;
      for (;;) {
        let bytes, isFailure;
        try {
          let {
            done: done,
            value: value
          } = await fetchParams.controller.next();
          if (isAborted(fetchParams)) break;
          bytes = done ? void 0 : value;
        } catch (err) {
          fetchParams.controller.ended && !timingInfo.encodedBodySize ? bytes = void 0 : (bytes = err, isFailure = !0);
        }
        if (bytes === void 0) {
          readableStreamClose(fetchParams.controller.controller), finalizeResponse(fetchParams, response);
          return;
        }
        if (timingInfo.decodedBodySize += (_a = bytes == null ? void 0 : bytes.byteLength) != null ? _a : 0, isFailure) {
          fetchParams.controller.terminate(bytes);
          return;
        }
        let buffer = new Uint8Array(bytes);
        if (buffer.byteLength && fetchParams.controller.controller.enqueue(buffer), isErrored(stream)) {
          fetchParams.controller.terminate();
          return;
        }
        if (fetchParams.controller.controller.desiredSize <= 0) return;
      }
    };
    function onAborted(reason) {
      isAborted(fetchParams) ? (response.aborted = !0, isReadable(stream) && fetchParams.controller.controller.error(fetchParams.controller.serializedAbortReason)) : isReadable(stream) && fetchParams.controller.controller.error(new TypeError("terminated", {
        cause: isErrorLike(reason) ? reason : void 0
      })), fetchParams.controller.connection.destroy();
    }
    return __name(onAborted, "onAborted"), response;
    function dispatch({
      body: body
    }) {
      let url = requestCurrentURL(request),
        agent = fetchParams.controller.dispatcher;
      return new Promise((resolve, reject) => agent.dispatch({
        path: url.pathname + url.search,
        origin: url.origin,
        method: request.method,
        body: agent.isMockActive ? request.body && (request.body.source || request.body.stream) : body,
        headers: request.headersList.entries,
        maxRedirections: 0,
        upgrade: request.mode === "websocket" ? "websocket" : void 0
      }, {
        body: null,
        abort: null,
        onConnect(abort) {
          let {
            connection: connection
          } = fetchParams.controller;
          timingInfo.finalConnectionTimingInfo = clampAndCoarsenConnectionTimingInfo(void 0, timingInfo.postRedirectStartTime, fetchParams.crossOriginIsolatedCapability), connection.destroyed ? abort(new DOMException("The operation was aborted.", "AbortError")) : (fetchParams.controller.on("terminated", abort), this.abort = connection.abort = abort), timingInfo.finalNetworkRequestStartTime = coarsenedSharedCurrentTime(fetchParams.crossOriginIsolatedCapability);
        },
        onResponseStarted() {
          timingInfo.finalNetworkResponseStartTime = coarsenedSharedCurrentTime(fetchParams.crossOriginIsolatedCapability);
        },
        onHeaders(status, rawHeaders, resume, statusText) {
          if (status < 200) return;
          let codings = [],
            location = "",
            headersList = new HeadersList();
          for (let i = 0; i < rawHeaders.length; i += 2) headersList.append(bufferToLowerCasedHeaderName(rawHeaders[i]), rawHeaders[i + 1].toString("latin1"), !0);
          let contentEncoding = headersList.get("content-encoding", !0);
          contentEncoding && (codings = contentEncoding.toLowerCase().split(",").map(x => x.trim())), location = headersList.get("location", !0), this.body = new Readable({
            read: resume
          });
          let decoders = [],
            willFollow = location && request.redirect === "follow" && redirectStatusSet.has(status);
          if (codings.length !== 0 && request.method !== "HEAD" && request.method !== "CONNECT" && !nullBodyStatus.includes(status) && !willFollow) for (let i = codings.length - 1; i >= 0; --i) {
            let coding = codings[i];
            if (coding === "x-gzip" || coding === "gzip") decoders.push(zlib.createGunzip({
              flush: zlib.constants.Z_SYNC_FLUSH,
              finishFlush: zlib.constants.Z_SYNC_FLUSH
            }));else if (coding === "deflate") decoders.push(createInflate({
              flush: zlib.constants.Z_SYNC_FLUSH,
              finishFlush: zlib.constants.Z_SYNC_FLUSH
            }));else if (coding === "br") decoders.push(zlib.createBrotliDecompress({
              flush: zlib.constants.BROTLI_OPERATION_FLUSH,
              finishFlush: zlib.constants.BROTLI_OPERATION_FLUSH
            }));else {
              decoders.length = 0;
              break;
            }
          }
          let onError = this.onError.bind(this);
          return resolve({
            status: status,
            statusText: statusText,
            headersList: headersList,
            body: decoders.length ? pipeline(this.body, ...decoders, err => {
              err && this.onError(err);
            }).on("error", onError) : this.body.on("error", onError)
          }), !0;
        },
        onData(chunk) {
          if (fetchParams.controller.dump) return;
          let bytes = chunk;
          return timingInfo.encodedBodySize += bytes.byteLength, this.body.push(bytes);
        },
        onComplete() {
          this.abort && fetchParams.controller.off("terminated", this.abort), fetchParams.controller.onAborted && fetchParams.controller.off("terminated", fetchParams.controller.onAborted), fetchParams.controller.ended = !0, this.body.push(null);
        },
        onError(error) {
          var _a;
          this.abort && fetchParams.controller.off("terminated", this.abort), (_a = this.body) == null || _a.destroy(error), fetchParams.controller.terminate(error), reject(error);
        },
        onUpgrade(status, rawHeaders, socket) {
          if (status !== 101) return;
          let headersList = new HeadersList();
          for (let i = 0; i < rawHeaders.length; i += 2) headersList.append(bufferToLowerCasedHeaderName(rawHeaders[i]), rawHeaders[i + 1].toString("latin1"), !0);
          return resolve({
            status: status,
            statusText: STATUS_CODES[status],
            headersList: headersList,
            socket: socket
          }), !0;
        }
      }));
    }
    __name(dispatch, "dispatch");
  }
  __name(httpNetworkFetch, "httpNetworkFetch");
  module.exports = {
    fetch: fetch,
    Fetch: Fetch,
    fetching: fetching,
    finalizeAndReportTiming: finalizeAndReportTiming
  };
});