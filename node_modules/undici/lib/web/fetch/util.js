var require_util = __commonJSMin((exports, module) => {
  "use strict";

  var {
      Transform: Transform
    } = require("stream"),
    zlib = require("zlib"),
    {
      redirectStatusSet: redirectStatusSet,
      referrerPolicySet: referrerPolicyTokens,
      badPortsSet: badPortsSet
    } = O4(),
    {
      getGlobalOrigin: getGlobalOrigin
    } = gie(),
    {
      collectASequenceOfCodePoints: collectASequenceOfCodePoints,
      collectAnHTTPQuotedString: collectAnHTTPQuotedString,
      removeChars: removeChars,
      parseMIMEType: parseMIMEType
    } = zA(),
    {
      performance: performance
    } = require("perf_hooks"),
    {
      isBlobLike: isBlobLike,
      ReadableStreamFrom: ReadableStreamFrom,
      isValidHTTPToken: isValidHTTPToken,
      normalizedMethodRecordsBase: normalizedMethodRecordsBase
    } = oi(),
    assert = require("assert"),
    {
      isUint8Array: isUint8Array
    } = require("util/types"),
    {
      webidl: webidl
    } = Gc(),
    supportedHashes = [],
    crypto;
  try {
    crypto = require("crypto");
    let possibleRelevantHashes = ["sha256", "sha384", "sha512"];
    supportedHashes = crypto.getHashes().filter(hash => possibleRelevantHashes.includes(hash));
  } catch {}
  function responseURL(response) {
    let urlList = response.urlList,
      length = urlList.length;
    return length === 0 ? null : urlList[length - 1].toString();
  }
  __name(responseURL, "responseURL");
  function responseLocationURL(response, requestFragment) {
    if (!redirectStatusSet.has(response.status)) return null;
    let location = response.headersList.get("location", !0);
    return location !== null && isValidHeaderValue(location) && (isValidEncodedURL(location) || (location = normalizeBinaryStringToUtf8(location)), location = new URL(location, responseURL(response))), location && !location.hash && (location.hash = requestFragment), location;
  }
  __name(responseLocationURL, "responseLocationURL");
  function isValidEncodedURL(url) {
    for (let i = 0; i < url.length; ++i) {
      let code = url.charCodeAt(i);
      if (code > 126 || code < 32) return !1;
    }
    return !0;
  }
  __name(isValidEncodedURL, "isValidEncodedURL");
  function normalizeBinaryStringToUtf8(value) {
    return Buffer.from(value, "binary").toString("utf8");
  }
  __name(normalizeBinaryStringToUtf8, "normalizeBinaryStringToUtf8");
  function requestCurrentURL(request) {
    return request.urlList[request.urlList.length - 1];
  }
  __name(requestCurrentURL, "requestCurrentURL");
  function requestBadPort(request) {
    let url = requestCurrentURL(request);
    return urlIsHttpHttpsScheme(url) && badPortsSet.has(url.port) ? "blocked" : "allowed";
  }
  __name(requestBadPort, "requestBadPort");
  function isErrorLike(object) {
    var _a, _b;
    return object instanceof Error || ((_a = object == null ? void 0 : object.constructor) == null ? void 0 : _a.name) === "Error" || ((_b = object == null ? void 0 : object.constructor) == null ? void 0 : _b.name) === "DOMException";
  }
  __name(isErrorLike, "isErrorLike");
  function isValidReasonPhrase(statusText) {
    for (let i = 0; i < statusText.length; ++i) {
      let c = statusText.charCodeAt(i);
      if (!(c === 9 || c >= 32 && c <= 126 || c >= 128 && c <= 255)) return !1;
    }
    return !0;
  }
  __name(isValidReasonPhrase, "isValidReasonPhrase");
  var isValidHeaderName = isValidHTTPToken;
  function isValidHeaderValue(potentialValue) {
    return (potentialValue[0] === "	" || potentialValue[0] === " " || potentialValue[potentialValue.length - 1] === "	" || potentialValue[potentialValue.length - 1] === " " || potentialValue.includes(`
`) || potentialValue.includes("\r") || potentialValue.includes("\0")) === !1;
  }
  __name(isValidHeaderValue, "isValidHeaderValue");
  function setRequestReferrerPolicyOnRedirect(request, actualResponse) {
    var _a;
    let {
        headersList: headersList
      } = actualResponse,
      policyHeader = ((_a = headersList.get("referrer-policy", !0)) != null ? _a : "").split(","),
      policy = "";
    if (policyHeader.length > 0) for (let i = policyHeader.length; i !== 0; i--) {
      let token = policyHeader[i - 1].trim();
      if (referrerPolicyTokens.has(token)) {
        policy = token;
        break;
      }
    }
    policy !== "" && (request.referrerPolicy = policy);
  }
  __name(setRequestReferrerPolicyOnRedirect, "setRequestReferrerPolicyOnRedirect");
  function crossOriginResourcePolicyCheck() {
    return "allowed";
  }
  __name(crossOriginResourcePolicyCheck, "crossOriginResourcePolicyCheck");
  function corsCheck() {
    return "success";
  }
  __name(corsCheck, "corsCheck");
  function TAOCheck() {
    return "success";
  }
  __name(TAOCheck, "TAOCheck");
  function appendFetchMetadata(httpRequest) {
    let header = null;
    header = httpRequest.mode, httpRequest.headersList.set("sec-fetch-mode", header, !0);
  }
  __name(appendFetchMetadata, "appendFetchMetadata");
  function appendRequestOriginHeader(request) {
    let serializedOrigin = request.origin;
    if (!(serializedOrigin === "client" || serializedOrigin === void 0)) {
      if (request.responseTainting === "cors" || request.mode === "websocket") request.headersList.append("origin", serializedOrigin, !0);else if (request.method !== "GET" && request.method !== "HEAD") {
        switch (request.referrerPolicy) {
          case "no-referrer":
            serializedOrigin = null;
            break;
          case "no-referrer-when-downgrade":
          case "strict-origin":
          case "strict-origin-when-cross-origin":
            request.origin && urlHasHttpsScheme(request.origin) && !urlHasHttpsScheme(requestCurrentURL(request)) && (serializedOrigin = null);
            break;
          case "same-origin":
            sameOrigin(request, requestCurrentURL(request)) || (serializedOrigin = null);
            break;
          default:
        }
        request.headersList.append("origin", serializedOrigin, !0);
      }
    }
  }
  __name(appendRequestOriginHeader, "appendRequestOriginHeader");
  function coarsenTime(timestamp, crossOriginIsolatedCapability) {
    return timestamp;
  }
  __name(coarsenTime, "coarsenTime");
  function clampAndCoarsenConnectionTimingInfo(connectionTimingInfo, defaultStartTime, crossOriginIsolatedCapability) {
    return !(connectionTimingInfo != null && connectionTimingInfo.startTime) || connectionTimingInfo.startTime < defaultStartTime ? {
      domainLookupStartTime: defaultStartTime,
      domainLookupEndTime: defaultStartTime,
      connectionStartTime: defaultStartTime,
      connectionEndTime: defaultStartTime,
      secureConnectionStartTime: defaultStartTime,
      ALPNNegotiatedProtocol: connectionTimingInfo == null ? void 0 : connectionTimingInfo.ALPNNegotiatedProtocol
    } : {
      domainLookupStartTime: coarsenTime(connectionTimingInfo.domainLookupStartTime, crossOriginIsolatedCapability),
      domainLookupEndTime: coarsenTime(connectionTimingInfo.domainLookupEndTime, crossOriginIsolatedCapability),
      connectionStartTime: coarsenTime(connectionTimingInfo.connectionStartTime, crossOriginIsolatedCapability),
      connectionEndTime: coarsenTime(connectionTimingInfo.connectionEndTime, crossOriginIsolatedCapability),
      secureConnectionStartTime: coarsenTime(connectionTimingInfo.secureConnectionStartTime, crossOriginIsolatedCapability),
      ALPNNegotiatedProtocol: connectionTimingInfo.ALPNNegotiatedProtocol
    };
  }
  __name(clampAndCoarsenConnectionTimingInfo, "clampAndCoarsenConnectionTimingInfo");
  function coarsenedSharedCurrentTime(crossOriginIsolatedCapability) {
    return coarsenTime(performance.now(), crossOriginIsolatedCapability);
  }
  __name(coarsenedSharedCurrentTime, "coarsenedSharedCurrentTime");
  function createOpaqueTimingInfo(timingInfo) {
    var _a, _b;
    return {
      startTime: (_a = timingInfo.startTime) != null ? _a : 0,
      redirectStartTime: 0,
      redirectEndTime: 0,
      postRedirectStartTime: (_b = timingInfo.startTime) != null ? _b : 0,
      finalServiceWorkerStartTime: 0,
      finalNetworkResponseStartTime: 0,
      finalNetworkRequestStartTime: 0,
      endTime: 0,
      encodedBodySize: 0,
      decodedBodySize: 0,
      finalConnectionTimingInfo: null
    };
  }
  __name(createOpaqueTimingInfo, "createOpaqueTimingInfo");
  function makePolicyContainer() {
    return {
      referrerPolicy: "strict-origin-when-cross-origin"
    };
  }
  __name(makePolicyContainer, "makePolicyContainer");
  function clonePolicyContainer(policyContainer) {
    return {
      referrerPolicy: policyContainer.referrerPolicy
    };
  }
  __name(clonePolicyContainer, "clonePolicyContainer");
  function determineRequestsReferrer(request) {
    let policy = request.referrerPolicy;
    assert(policy);
    let referrerSource = null;
    if (request.referrer === "client") {
      let globalOrigin = getGlobalOrigin();
      if (!globalOrigin || globalOrigin.origin === "null") return "no-referrer";
      referrerSource = new URL(globalOrigin);
    } else request.referrer instanceof URL && (referrerSource = request.referrer);
    let referrerURL = stripURLForReferrer(referrerSource),
      referrerOrigin = stripURLForReferrer(referrerSource, !0);
    referrerURL.toString().length > 4096 && (referrerURL = referrerOrigin);
    let areSameOrigin = sameOrigin(request, referrerURL),
      isNonPotentiallyTrustWorthy = isURLPotentiallyTrustworthy(referrerURL) && !isURLPotentiallyTrustworthy(request.url);
    switch (policy) {
      case "origin":
        return referrerOrigin != null ? referrerOrigin : stripURLForReferrer(referrerSource, !0);
      case "unsafe-url":
        return referrerURL;
      case "same-origin":
        return areSameOrigin ? referrerOrigin : "no-referrer";
      case "origin-when-cross-origin":
        return areSameOrigin ? referrerURL : referrerOrigin;
      case "strict-origin-when-cross-origin":
        {
          let currentURL = requestCurrentURL(request);
          return sameOrigin(referrerURL, currentURL) ? referrerURL : isURLPotentiallyTrustworthy(referrerURL) && !isURLPotentiallyTrustworthy(currentURL) ? "no-referrer" : referrerOrigin;
        }
      case "strict-origin":
      case "no-referrer-when-downgrade":
      default:
        return isNonPotentiallyTrustWorthy ? "no-referrer" : referrerOrigin;
    }
  }
  __name(determineRequestsReferrer, "determineRequestsReferrer");
  function stripURLForReferrer(url, originOnly) {
    return assert(url instanceof URL), url = new URL(url), url.protocol === "file:" || url.protocol === "about:" || url.protocol === "blank:" ? "no-referrer" : (url.username = "", url.password = "", url.hash = "", originOnly && (url.pathname = "", url.search = ""), url);
  }
  __name(stripURLForReferrer, "stripURLForReferrer");
  function isURLPotentiallyTrustworthy(url) {
    if (!(url instanceof URL)) return !1;
    if (url.href === "about:blank" || url.href === "about:srcdoc" || url.protocol === "data:" || url.protocol === "file:") return !0;
    return isOriginPotentiallyTrustworthy(url.origin);
    function isOriginPotentiallyTrustworthy(origin) {
      if (origin == null || origin === "null") return !1;
      let originAsURL = new URL(origin);
      return !!(originAsURL.protocol === "https:" || originAsURL.protocol === "wss:" || /^127(?:\.[0-9]+){0,2}\.[0-9]+$|^\[(?:0*:)*?:?0*1\]$/.test(originAsURL.hostname) || originAsURL.hostname === "localhost" || originAsURL.hostname.includes("localhost.") || originAsURL.hostname.endsWith(".localhost"));
    }
  }
  __name(isURLPotentiallyTrustworthy, "isURLPotentiallyTrustworthy");
  function bytesMatch(bytes, metadataList) {
    if (crypto === void 0) return !0;
    let parsedMetadata = parseMetadata(metadataList);
    if (parsedMetadata === "no metadata" || parsedMetadata.length === 0) return !0;
    let strongest = getStrongestMetadata(parsedMetadata),
      metadata = filterMetadataListByAlgorithm(parsedMetadata, strongest);
    for (let item of metadata) {
      let algorithm = item.algo,
        expectedValue = item.hash,
        actualValue = crypto.createHash(algorithm).update(bytes).digest("base64");
      if (actualValue[actualValue.length - 1] === "=" && (actualValue[actualValue.length - 2] === "=" ? actualValue = actualValue.slice(0, -2) : actualValue = actualValue.slice(0, -1)), compareBase64Mixed(actualValue, expectedValue)) return !0;
    }
    return !1;
  }
  __name(bytesMatch, "bytesMatch");
  var parseHashWithOptions = /(?<algo>sha256|sha384|sha512)-((?<hash>[A-Za-z0-9+/]+|[A-Za-z0-9_-]+)={0,2}(?:\s|$)( +[!-~]*)?)?/i;
  function parseMetadata(metadata) {
    let result = [],
      empty = !0;
    for (let token of metadata.split(" ")) {
      empty = !1;
      let parsedToken = parseHashWithOptions.exec(token);
      if (parsedToken === null || parsedToken.groups === void 0 || parsedToken.groups.algo === void 0) continue;
      let algorithm = parsedToken.groups.algo.toLowerCase();
      supportedHashes.includes(algorithm) && result.push(parsedToken.groups);
    }
    return empty === !0 ? "no metadata" : result;
  }
  __name(parseMetadata, "parseMetadata");
  function getStrongestMetadata(metadataList) {
    let algorithm = metadataList[0].algo;
    if (algorithm[3] === "5") return algorithm;
    for (let i = 1; i < metadataList.length; ++i) {
      let metadata = metadataList[i];
      if (metadata.algo[3] === "5") {
        algorithm = "sha512";
        break;
      } else {
        if (algorithm[3] === "3") continue;
        metadata.algo[3] === "3" && (algorithm = "sha384");
      }
    }
    return algorithm;
  }
  __name(getStrongestMetadata, "getStrongestMetadata");
  function filterMetadataListByAlgorithm(metadataList, algorithm) {
    if (metadataList.length === 1) return metadataList;
    let pos = 0;
    for (let i = 0; i < metadataList.length; ++i) metadataList[i].algo === algorithm && (metadataList[pos++] = metadataList[i]);
    return metadataList.length = pos, metadataList;
  }
  __name(filterMetadataListByAlgorithm, "filterMetadataListByAlgorithm");
  function compareBase64Mixed(actualValue, expectedValue) {
    if (actualValue.length !== expectedValue.length) return !1;
    for (let i = 0; i < actualValue.length; ++i) if (actualValue[i] !== expectedValue[i]) {
      if (actualValue[i] === "+" && expectedValue[i] === "-" || actualValue[i] === "/" && expectedValue[i] === "_") continue;
      return !1;
    }
    return !0;
  }
  __name(compareBase64Mixed, "compareBase64Mixed");
  function tryUpgradeRequestToAPotentiallyTrustworthyURL(request) {}
  __name(tryUpgradeRequestToAPotentiallyTrustworthyURL, "tryUpgradeRequestToAPotentiallyTrustworthyURL");
  function sameOrigin(A, B) {
    return A.origin === B.origin && A.origin === "null" || A.protocol === B.protocol && A.hostname === B.hostname && A.port === B.port;
  }
  __name(sameOrigin, "sameOrigin");
  function createDeferredPromise() {
    let res, rej;
    return {
      promise: new Promise((resolve, reject) => {
        res = resolve, rej = reject;
      }),
      resolve: res,
      reject: rej
    };
  }
  __name(createDeferredPromise, "createDeferredPromise");
  function isAborted(fetchParams) {
    return fetchParams.controller.state === "aborted";
  }
  __name(isAborted, "isAborted");
  function isCancelled(fetchParams) {
    return fetchParams.controller.state === "aborted" || fetchParams.controller.state === "terminated";
  }
  __name(isCancelled, "isCancelled");
  function normalizeMethod(method) {
    var _a;
    return (_a = normalizedMethodRecordsBase[method.toLowerCase()]) != null ? _a : method;
  }
  __name(normalizeMethod, "normalizeMethod");
  function serializeJavascriptValueToJSONString(value) {
    let result = JSON.stringify(value);
    if (result === void 0) throw new TypeError("Value is not JSON serializable");
    return assert(typeof result == "string"), result;
  }
  __name(serializeJavascriptValueToJSONString, "serializeJavascriptValueToJSONString");
  var esIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]()));
  function createIterator(name, kInternalIterator, keyIndex = 0, valueIndex = 1) {
    var _target, _kind, _index;
    let _FastIterableIterator = class _FastIterableIterator {
      constructor(target, kind) {
        __privateAdd(this, _target);
        __privateAdd(this, _kind);
        __privateAdd(this, _index);
        __privateSet(this, _target, target), __privateSet(this, _kind, kind), __privateSet(this, _index, 0);
      }
      next() {
        if (typeof this != "object" || this === null || !__privateIn(_target, this)) throw new TypeError(`'next' called on an object that does not implement interface ${name} Iterator.`);
        let index = __privateGet(this, _index),
          values = __privateGet(this, _target)[kInternalIterator],
          len = values.length;
        if (index >= len) return {
          value: void 0,
          done: !0
        };
        let {
          [keyIndex]: key,
          [valueIndex]: value
        } = values[index];
        __privateSet(this, _index, index + 1);
        let result;
        switch (__privateGet(this, _kind)) {
          case "key":
            result = key;
            break;
          case "value":
            result = value;
            break;
          case "key+value":
            result = [key, value];
            break;
        }
        return {
          value: result,
          done: !1
        };
      }
    };
    _target = new WeakMap(), _kind = new WeakMap(), _index = new WeakMap(), __name(_FastIterableIterator, "FastIterableIterator");
    let FastIterableIterator = _FastIterableIterator;
    return delete FastIterableIterator.prototype.constructor, Object.setPrototypeOf(FastIterableIterator.prototype, esIteratorPrototype), Object.defineProperties(FastIterableIterator.prototype, {
      [Symbol.toStringTag]: {
        writable: !1,
        enumerable: !1,
        configurable: !0,
        value: `${name} Iterator`
      },
      next: {
        writable: !0,
        enumerable: !0,
        configurable: !0
      }
    }), function (target, kind) {
      return new FastIterableIterator(target, kind);
    };
  }
  __name(createIterator, "createIterator");
  function iteratorMixin(name, object, kInternalIterator, keyIndex = 0, valueIndex = 1) {
    let makeIterator = createIterator(name, kInternalIterator, keyIndex, valueIndex),
      properties = {
        keys: {
          writable: !0,
          enumerable: !0,
          configurable: !0,
          value: __name(function () {
            return webidl.brandCheck(this, object), makeIterator(this, "key");
          }, "keys")
        },
        values: {
          writable: !0,
          enumerable: !0,
          configurable: !0,
          value: __name(function () {
            return webidl.brandCheck(this, object), makeIterator(this, "value");
          }, "values")
        },
        entries: {
          writable: !0,
          enumerable: !0,
          configurable: !0,
          value: __name(function () {
            return webidl.brandCheck(this, object), makeIterator(this, "key+value");
          }, "entries")
        },
        forEach: {
          writable: !0,
          enumerable: !0,
          configurable: !0,
          value: __name(function (callbackfn, thisArg = globalThis) {
            if (webidl.brandCheck(this, object), webidl.argumentLengthCheck(arguments, 1, `${name}.forEach`), typeof callbackfn != "function") throw new TypeError(`Failed to execute 'forEach' on '${name}': parameter 1 is not of type 'Function'.`);
            for (let {
              0: key,
              1: value
            } of makeIterator(this, "key+value")) callbackfn.call(thisArg, value, key, this);
          }, "forEach")
        }
      };
    return Object.defineProperties(object.prototype, {
      ...properties,
      [Symbol.iterator]: {
        writable: !0,
        enumerable: !1,
        configurable: !0,
        value: properties.entries.value
      }
    });
  }
  __name(iteratorMixin, "iteratorMixin");
  async function fullyReadBody(body, processBody, processBodyError) {
    let successSteps = processBody,
      errorSteps = processBodyError,
      reader;
    try {
      reader = body.stream.getReader();
    } catch (e) {
      errorSteps(e);
      return;
    }
    try {
      successSteps(await readAllBytes(reader));
    } catch (e) {
      errorSteps(e);
    }
  }
  __name(fullyReadBody, "fullyReadBody");
  function isReadableStreamLike(stream) {
    return stream instanceof ReadableStream || stream[Symbol.toStringTag] === "ReadableStream" && typeof stream.tee == "function";
  }
  __name(isReadableStreamLike, "isReadableStreamLike");
  function readableStreamClose(controller) {
    var _a;
    try {
      controller.close(), (_a = controller.byobRequest) == null || _a.respond(0);
    } catch (err) {
      if (!err.message.includes("Controller is already closed") && !err.message.includes("ReadableStream is already closed")) throw err;
    }
  }
  __name(readableStreamClose, "readableStreamClose");
  var invalidIsomorphicEncodeValueRegex = /[^\x00-\xFF]/;
  function isomorphicEncode(input) {
    return assert(!invalidIsomorphicEncodeValueRegex.test(input)), input;
  }
  __name(isomorphicEncode, "isomorphicEncode");
  async function readAllBytes(reader) {
    let bytes = [],
      byteLength = 0;
    for (;;) {
      let {
        done: done,
        value: chunk
      } = await reader.read();
      if (done) return Buffer.concat(bytes, byteLength);
      if (!isUint8Array(chunk)) throw new TypeError("Received non-Uint8Array chunk");
      bytes.push(chunk), byteLength += chunk.length;
    }
  }
  __name(readAllBytes, "readAllBytes");
  function urlIsLocal(url) {
    assert("protocol" in url);
    let protocol = url.protocol;
    return protocol === "about:" || protocol === "blob:" || protocol === "data:";
  }
  __name(urlIsLocal, "urlIsLocal");
  function urlHasHttpsScheme(url) {
    return typeof url == "string" && url[5] === ":" && url[0] === "h" && url[1] === "t" && url[2] === "t" && url[3] === "p" && url[4] === "s" || url.protocol === "https:";
  }
  __name(urlHasHttpsScheme, "urlHasHttpsScheme");
  function urlIsHttpHttpsScheme(url) {
    assert("protocol" in url);
    let protocol = url.protocol;
    return protocol === "http:" || protocol === "https:";
  }
  __name(urlIsHttpHttpsScheme, "urlIsHttpHttpsScheme");
  function simpleRangeHeaderValue(value, allowWhitespace) {
    let data = value;
    if (!data.startsWith("bytes")) return "failure";
    let position = {
      position: 5
    };
    if (allowWhitespace && collectASequenceOfCodePoints(char => char === "	" || char === " ", data, position), data.charCodeAt(position.position) !== 61) return "failure";
    position.position++, allowWhitespace && collectASequenceOfCodePoints(char => char === "	" || char === " ", data, position);
    let rangeStart = collectASequenceOfCodePoints(char => {
        let code = char.charCodeAt(0);
        return code >= 48 && code <= 57;
      }, data, position),
      rangeStartValue = rangeStart.length ? Number(rangeStart) : null;
    if (allowWhitespace && collectASequenceOfCodePoints(char => char === "	" || char === " ", data, position), data.charCodeAt(position.position) !== 45) return "failure";
    position.position++, allowWhitespace && collectASequenceOfCodePoints(char => char === "	" || char === " ", data, position);
    let rangeEnd = collectASequenceOfCodePoints(char => {
        let code = char.charCodeAt(0);
        return code >= 48 && code <= 57;
      }, data, position),
      rangeEndValue = rangeEnd.length ? Number(rangeEnd) : null;
    return position.position < data.length || rangeEndValue === null && rangeStartValue === null || rangeStartValue > rangeEndValue ? "failure" : {
      rangeStartValue: rangeStartValue,
      rangeEndValue: rangeEndValue
    };
  }
  __name(simpleRangeHeaderValue, "simpleRangeHeaderValue");
  function buildContentRange(rangeStart, rangeEnd, fullLength) {
    let contentRange = "bytes ";
    return contentRange += isomorphicEncode(`${rangeStart}`), contentRange += "-", contentRange += isomorphicEncode(`${rangeEnd}`), contentRange += "/", contentRange += isomorphicEncode(`${fullLength}`), contentRange;
  }
  __name(buildContentRange, "buildContentRange");
  var _zlibOptions,
    _InflateStream = class _InflateStream extends Transform {
      constructor(zlibOptions) {
        super();
        __privateAdd(this, _zlibOptions);
        __privateSet(this, _zlibOptions, zlibOptions);
      }
      _transform(chunk, encoding, callback) {
        if (!this._inflateStream) {
          if (chunk.length === 0) {
            callback();
            return;
          }
          this._inflateStream = (chunk[0] & 15) === 8 ? zlib.createInflate(__privateGet(this, _zlibOptions)) : zlib.createInflateRaw(__privateGet(this, _zlibOptions)), this._inflateStream.on("data", this.push.bind(this)), this._inflateStream.on("end", () => this.push(null)), this._inflateStream.on("error", err => this.destroy(err));
        }
        this._inflateStream.write(chunk, encoding, callback);
      }
      _final(callback) {
        this._inflateStream && (this._inflateStream.end(), this._inflateStream = null), callback();
      }
    };
  _zlibOptions = new WeakMap(), __name(_InflateStream, "InflateStream");
  var InflateStream = _InflateStream;
  function createInflate(zlibOptions) {
    return new InflateStream(zlibOptions);
  }
  __name(createInflate, "createInflate");
  function extractMimeType(headers) {
    let charset = null,
      essence = null,
      mimeType = null,
      values = getDecodeSplit("content-type", headers);
    if (values === null) return "failure";
    for (let value of values) {
      let temporaryMimeType = parseMIMEType(value);
      temporaryMimeType === "failure" || temporaryMimeType.essence === "*/*" || (mimeType = temporaryMimeType, mimeType.essence !== essence ? (charset = null, mimeType.parameters.has("charset") && (charset = mimeType.parameters.get("charset")), essence = mimeType.essence) : !mimeType.parameters.has("charset") && charset !== null && mimeType.parameters.set("charset", charset));
    }
    return mimeType == null ? "failure" : mimeType;
  }
  __name(extractMimeType, "extractMimeType");
  function gettingDecodingSplitting(value) {
    let input = value,
      position = {
        position: 0
      },
      values = [],
      temporaryValue = "";
    for (; position.position < input.length;) {
      if (temporaryValue += collectASequenceOfCodePoints(char => char !== '"' && char !== ",", input, position), position.position < input.length) if (input.charCodeAt(position.position) === 34) {
        if (temporaryValue += collectAnHTTPQuotedString(input, position), position.position < input.length) continue;
      } else assert(input.charCodeAt(position.position) === 44), position.position++;
      temporaryValue = removeChars(temporaryValue, !0, !0, char => char === 9 || char === 32), values.push(temporaryValue), temporaryValue = "";
    }
    return values;
  }
  __name(gettingDecodingSplitting, "gettingDecodingSplitting");
  function getDecodeSplit(name, list) {
    let value = list.get(name, !0);
    return value === null ? null : gettingDecodingSplitting(value);
  }
  __name(getDecodeSplit, "getDecodeSplit");
  var textDecoder = new TextDecoder();
  function utf8DecodeBytes(buffer) {
    return buffer.length === 0 ? "" : (buffer[0] === 239 && buffer[1] === 187 && buffer[2] === 191 && (buffer = buffer.subarray(3)), textDecoder.decode(buffer));
  }
  __name(utf8DecodeBytes, "utf8DecodeBytes");
  var _EnvironmentSettingsObjectBase = class _EnvironmentSettingsObjectBase {
    constructor() {
      __publicField(this, "policyContainer", makePolicyContainer());
    }
    get baseUrl() {
      return getGlobalOrigin();
    }
    get origin() {
      var _a;
      return (_a = this.baseUrl) == null ? void 0 : _a.origin;
    }
  };
  __name(_EnvironmentSettingsObjectBase, "EnvironmentSettingsObjectBase");
  var EnvironmentSettingsObjectBase = _EnvironmentSettingsObjectBase,
    _EnvironmentSettingsObject = class _EnvironmentSettingsObject {
      constructor() {
        __publicField(this, "settingsObject", new EnvironmentSettingsObjectBase());
      }
    };
  __name(_EnvironmentSettingsObject, "EnvironmentSettingsObject");
  var EnvironmentSettingsObject = _EnvironmentSettingsObject,
    environmentSettingsObject = new EnvironmentSettingsObject();
  module.exports = {
    isAborted: isAborted,
    isCancelled: isCancelled,
    isValidEncodedURL: isValidEncodedURL,
    createDeferredPromise: createDeferredPromise,
    ReadableStreamFrom: ReadableStreamFrom,
    tryUpgradeRequestToAPotentiallyTrustworthyURL: tryUpgradeRequestToAPotentiallyTrustworthyURL,
    clampAndCoarsenConnectionTimingInfo: clampAndCoarsenConnectionTimingInfo,
    coarsenedSharedCurrentTime: coarsenedSharedCurrentTime,
    determineRequestsReferrer: determineRequestsReferrer,
    makePolicyContainer: makePolicyContainer,
    clonePolicyContainer: clonePolicyContainer,
    appendFetchMetadata: appendFetchMetadata,
    appendRequestOriginHeader: appendRequestOriginHeader,
    TAOCheck: TAOCheck,
    corsCheck: corsCheck,
    crossOriginResourcePolicyCheck: crossOriginResourcePolicyCheck,
    createOpaqueTimingInfo: createOpaqueTimingInfo,
    setRequestReferrerPolicyOnRedirect: setRequestReferrerPolicyOnRedirect,
    isValidHTTPToken: isValidHTTPToken,
    requestBadPort: requestBadPort,
    requestCurrentURL: requestCurrentURL,
    responseURL: responseURL,
    responseLocationURL: responseLocationURL,
    isBlobLike: isBlobLike,
    isURLPotentiallyTrustworthy: isURLPotentiallyTrustworthy,
    isValidReasonPhrase: isValidReasonPhrase,
    sameOrigin: sameOrigin,
    normalizeMethod: normalizeMethod,
    serializeJavascriptValueToJSONString: serializeJavascriptValueToJSONString,
    iteratorMixin: iteratorMixin,
    createIterator: createIterator,
    isValidHeaderName: isValidHeaderName,
    isValidHeaderValue: isValidHeaderValue,
    isErrorLike: isErrorLike,
    fullyReadBody: fullyReadBody,
    bytesMatch: bytesMatch,
    isReadableStreamLike: isReadableStreamLike,
    readableStreamClose: readableStreamClose,
    isomorphicEncode: isomorphicEncode,
    urlIsLocal: urlIsLocal,
    urlHasHttpsScheme: urlHasHttpsScheme,
    urlIsHttpHttpsScheme: urlIsHttpHttpsScheme,
    readAllBytes: readAllBytes,
    simpleRangeHeaderValue: simpleRangeHeaderValue,
    buildContentRange: buildContentRange,
    parseMetadata: parseMetadata,
    createInflate: createInflate,
    extractMimeType: extractMimeType,
    getDecodeSplit: getDecodeSplit,
    utf8DecodeBytes: utf8DecodeBytes,
    environmentSettingsObject: environmentSettingsObject
  };
});