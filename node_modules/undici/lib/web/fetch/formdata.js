var require_formdata = __commonJSMin((exports, module) => {
  "use strict";

  var {
      isBlobLike: isBlobLike,
      iteratorMixin: iteratorMixin
    } = Lu(),
    {
      kState: kState
    } = iw(),
    {
      kEnumerableProperty: kEnumerableProperty
    } = oi(),
    {
      FileLike: FileLike,
      isFileLike: isFileLike
    } = vie(),
    {
      webidl: webidl
    } = Gc(),
    {
      File: NativeFile
    } = require("buffer"),
    nodeUtil = require("util"),
    _a,
    File = (_a = globalThis.File) != null ? _a : NativeFile,
    _FormData = class _FormData {
      constructor(form) {
        if (webidl.util.markAsUncloneable(this), form !== void 0) throw webidl.errors.conversionFailed({
          prefix: "FormData constructor",
          argument: "Argument 1",
          types: ["undefined"]
        });
        this[kState] = [];
      }
      append(name, value, filename = void 0) {
        webidl.brandCheck(this, _FormData);
        let prefix = "FormData.append";
        if (webidl.argumentLengthCheck(arguments, 2, prefix), arguments.length === 3 && !isBlobLike(value)) throw new TypeError("Failed to execute 'append' on 'FormData': parameter 2 is not of type 'Blob'");
        name = webidl.converters.USVString(name, prefix, "name"), value = isBlobLike(value) ? webidl.converters.Blob(value, prefix, "value", {
          strict: !1
        }) : webidl.converters.USVString(value, prefix, "value"), filename = arguments.length === 3 ? webidl.converters.USVString(filename, prefix, "filename") : void 0;
        let entry = makeEntry(name, value, filename);
        this[kState].push(entry);
      }
      delete(name) {
        webidl.brandCheck(this, _FormData);
        let prefix = "FormData.delete";
        webidl.argumentLengthCheck(arguments, 1, prefix), name = webidl.converters.USVString(name, prefix, "name"), this[kState] = this[kState].filter(entry => entry.name !== name);
      }
      get(name) {
        webidl.brandCheck(this, _FormData);
        let prefix = "FormData.get";
        webidl.argumentLengthCheck(arguments, 1, prefix), name = webidl.converters.USVString(name, prefix, "name");
        let idx = this[kState].findIndex(entry => entry.name === name);
        return idx === -1 ? null : this[kState][idx].value;
      }
      getAll(name) {
        webidl.brandCheck(this, _FormData);
        let prefix = "FormData.getAll";
        return webidl.argumentLengthCheck(arguments, 1, prefix), name = webidl.converters.USVString(name, prefix, "name"), this[kState].filter(entry => entry.name === name).map(entry => entry.value);
      }
      has(name) {
        webidl.brandCheck(this, _FormData);
        let prefix = "FormData.has";
        return webidl.argumentLengthCheck(arguments, 1, prefix), name = webidl.converters.USVString(name, prefix, "name"), this[kState].findIndex(entry => entry.name === name) !== -1;
      }
      set(name, value, filename = void 0) {
        webidl.brandCheck(this, _FormData);
        let prefix = "FormData.set";
        if (webidl.argumentLengthCheck(arguments, 2, prefix), arguments.length === 3 && !isBlobLike(value)) throw new TypeError("Failed to execute 'set' on 'FormData': parameter 2 is not of type 'Blob'");
        name = webidl.converters.USVString(name, prefix, "name"), value = isBlobLike(value) ? webidl.converters.Blob(value, prefix, "name", {
          strict: !1
        }) : webidl.converters.USVString(value, prefix, "name"), filename = arguments.length === 3 ? webidl.converters.USVString(filename, prefix, "name") : void 0;
        let entry = makeEntry(name, value, filename),
          idx = this[kState].findIndex(entry => entry.name === name);
        idx !== -1 ? this[kState] = [...this[kState].slice(0, idx), entry, ...this[kState].slice(idx + 1).filter(entry => entry.name !== name)] : this[kState].push(entry);
      }
      [nodeUtil.inspect.custom](depth, options) {
        var _a, _b;
        let state = this[kState].reduce((a, b) => (a[b.name] ? Array.isArray(a[b.name]) ? a[b.name].push(b.value) : a[b.name] = [a[b.name], b.value] : a[b.name] = b.value, a), {
          __proto__: null
        });
        (_a = options.depth) != null || (options.depth = depth), (_b = options.colors) != null || (options.colors = !0);
        let output = nodeUtil.formatWithOptions(options, state);
        return `FormData ${output.slice(output.indexOf("]") + 2)}`;
      }
    };
  __name(_FormData, "FormData");
  var FormData = _FormData;
  iteratorMixin("FormData", FormData, kState, "name", "value");
  Object.defineProperties(FormData.prototype, {
    append: kEnumerableProperty,
    delete: kEnumerableProperty,
    get: kEnumerableProperty,
    getAll: kEnumerableProperty,
    has: kEnumerableProperty,
    set: kEnumerableProperty,
    [Symbol.toStringTag]: {
      value: "FormData",
      configurable: !0
    }
  });
  function makeEntry(name, value, filename) {
    if (typeof value != "string") {
      if (isFileLike(value) || (value = value instanceof Blob ? new File([value], "blob", {
        type: value.type
      }) : new FileLike(value, "blob", {
        type: value.type
      })), filename !== void 0) {
        let options = {
          type: value.type,
          lastModified: value.lastModified
        };
        value = value instanceof NativeFile ? new File([value], filename, options) : new FileLike(value, filename, options);
      }
    }
    return {
      name: name,
      value: value
    };
  }
  __name(makeEntry, "makeEntry");
  module.exports = {
    FormData: FormData,
    makeEntry: makeEntry
  };
});