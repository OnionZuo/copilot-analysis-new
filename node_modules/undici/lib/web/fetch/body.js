var require_body = __commonJSMin((exports, module) => {
  "use strict";

  var util = oi(),
    {
      ReadableStreamFrom: ReadableStreamFrom,
      isBlobLike: isBlobLike,
      isReadableStreamLike: isReadableStreamLike,
      readableStreamClose: readableStreamClose,
      createDeferredPromise: createDeferredPromise,
      fullyReadBody: fullyReadBody,
      extractMimeType: extractMimeType,
      utf8DecodeBytes: utf8DecodeBytes
    } = Lu(),
    {
      FormData: FormData
    } = K4(),
    {
      kState: kState
    } = iw(),
    {
      webidl: webidl
    } = Gc(),
    {
      Blob: Blob
    } = require("buffer"),
    assert = require("assert"),
    {
      isErrored: isErrored,
      isDisturbed: isDisturbed
    } = require("stream"),
    {
      isArrayBuffer: isArrayBuffer
    } = require("util/types"),
    {
      serializeAMimeType: serializeAMimeType
    } = zA(),
    {
      multipartFormDataParser: multipartFormDataParser
    } = P5e(),
    random;
  try {
    let crypto = require("crypto");
    random = __name(max => crypto.randomInt(0, max), "random");
  } catch {
    random = __name(max => Math.floor(Math.random(max)), "random");
  }
  var textEncoder = new TextEncoder();
  function noop() {}
  __name(noop, "noop");
  var hasFinalizationRegistry = globalThis.FinalizationRegistry && process.version.indexOf("v18") !== 0,
    streamRegistry;
  hasFinalizationRegistry && (streamRegistry = new FinalizationRegistry(weakRef => {
    let stream = weakRef.deref();
    stream && !stream.locked && !isDisturbed(stream) && !isErrored(stream) && stream.cancel("Response object has been garbage collected").catch(noop);
  }));
  function extractBody(object, keepalive = !1) {
    let stream = null;
    object instanceof ReadableStream ? stream = object : isBlobLike(object) ? stream = object.stream() : stream = new ReadableStream({
      async pull(controller) {
        let buffer = typeof source == "string" ? textEncoder.encode(source) : source;
        buffer.byteLength && controller.enqueue(buffer), queueMicrotask(() => readableStreamClose(controller));
      },
      start() {},
      type: "bytes"
    }), assert(isReadableStreamLike(stream));
    let action = null,
      source = null,
      length = null,
      type = null;
    if (typeof object == "string") source = object, type = "text/plain;charset=UTF-8";else if (object instanceof URLSearchParams) source = object.toString(), type = "application/x-www-form-urlencoded;charset=UTF-8";else if (isArrayBuffer(object)) source = new Uint8Array(object.slice());else if (ArrayBuffer.isView(object)) source = new Uint8Array(object.buffer.slice(object.byteOffset, object.byteOffset + object.byteLength));else if (util.isFormDataLike(object)) {
      let boundary = `----formdata-undici-0${`${random(1e11)}`.padStart(11, "0")}`,
        prefix = `--${boundary}\r
Content-Disposition: form-data`;
      let escape = __name(str => str.replace(/\n/g, "%0A").replace(/\r/g, "%0D").replace(/"/g, "%22"), "escape"),
        normalizeLinefeeds = __name(value => value.replace(/\r?\n|\r/g, `\r
`), "normalizeLinefeeds"),
        blobParts = [],
        rn = new Uint8Array([13, 10]);
      length = 0;
      let hasUnknownSizeValue = !1;
      for (let [name, value] of object) if (typeof value == "string") {
        let chunk = textEncoder.encode(prefix + `; name="${escape(normalizeLinefeeds(name))}"\r
\r
${normalizeLinefeeds(value)}\r
`);
        blobParts.push(chunk), length += chunk.byteLength;
      } else {
        let chunk = textEncoder.encode(`${prefix}; name="${escape(normalizeLinefeeds(name))}"` + (value.name ? `; filename="${escape(value.name)}"` : "") + `\r
Content-Type: ${value.type || "application/octet-stream"}\r
\r
`);
        blobParts.push(chunk, value, rn), typeof value.size == "number" ? length += chunk.byteLength + value.size + rn.byteLength : hasUnknownSizeValue = !0;
      }
      let chunk = textEncoder.encode(`--${boundary}--`);
      blobParts.push(chunk), length += chunk.byteLength, hasUnknownSizeValue && (length = null), source = object, action = __name(async function* () {
        for (let part of blobParts) part.stream ? yield* part.stream() : yield part;
      }, "action"), type = `multipart/form-data; boundary=${boundary}`;
    } else if (isBlobLike(object)) source = object, length = object.size, object.type && (type = object.type);else if (typeof object[Symbol.asyncIterator] == "function") {
      if (keepalive) throw new TypeError("keepalive");
      if (util.isDisturbed(object) || object.locked) throw new TypeError("Response body object should not be disturbed or locked");
      stream = object instanceof ReadableStream ? object : ReadableStreamFrom(object);
    }
    if ((typeof source == "string" || util.isBuffer(source)) && (length = Buffer.byteLength(source)), action != null) {
      let iterator;
      stream = new ReadableStream({
        async start() {
          iterator = action(object)[Symbol.asyncIterator]();
        },
        async pull(controller) {
          let {
            value: value,
            done: done
          } = await iterator.next();
          if (done) queueMicrotask(() => {
            var _a;
            controller.close(), (_a = controller.byobRequest) == null || _a.respond(0);
          });else if (!isErrored(stream)) {
            let buffer = new Uint8Array(value);
            buffer.byteLength && controller.enqueue(buffer);
          }
          return controller.desiredSize > 0;
        },
        async cancel(reason) {
          await iterator.return();
        },
        type: "bytes"
      });
    }
    return [{
      stream: stream,
      source: source,
      length: length
    }, type];
  }
  __name(extractBody, "extractBody");
  function safelyExtractBody(object, keepalive = !1) {
    return object instanceof ReadableStream && (assert(!util.isDisturbed(object), "The body has already been consumed."), assert(!object.locked, "The stream is locked.")), extractBody(object, keepalive);
  }
  __name(safelyExtractBody, "safelyExtractBody");
  function cloneBody(instance, body) {
    let [out1, out2] = body.stream.tee();
    return hasFinalizationRegistry && streamRegistry.register(instance, new WeakRef(out1)), body.stream = out1, {
      stream: out2,
      length: body.length,
      source: body.source
    };
  }
  __name(cloneBody, "cloneBody");
  function throwIfAborted(state) {
    if (state.aborted) throw new DOMException("The operation was aborted.", "AbortError");
  }
  __name(throwIfAborted, "throwIfAborted");
  function bodyMixinMethods(instance) {
    return {
      blob() {
        return consumeBody(this, bytes => {
          let mimeType = bodyMimeType(this);
          return mimeType === null ? mimeType = "" : mimeType && (mimeType = serializeAMimeType(mimeType)), new Blob([bytes], {
            type: mimeType
          });
        }, instance);
      },
      arrayBuffer() {
        return consumeBody(this, bytes => new Uint8Array(bytes).buffer, instance);
      },
      text() {
        return consumeBody(this, utf8DecodeBytes, instance);
      },
      json() {
        return consumeBody(this, parseJSONFromBytes, instance);
      },
      formData() {
        return consumeBody(this, value => {
          let mimeType = bodyMimeType(this);
          if (mimeType !== null) switch (mimeType.essence) {
            case "multipart/form-data":
              {
                let parsed = multipartFormDataParser(value, mimeType);
                if (parsed === "failure") throw new TypeError("Failed to parse body as FormData.");
                let fd = new FormData();
                return fd[kState] = parsed, fd;
              }
            case "application/x-www-form-urlencoded":
              {
                let entries = new URLSearchParams(value.toString()),
                  fd = new FormData();
                for (let [name, value] of entries) fd.append(name, value);
                return fd;
              }
          }
          throw new TypeError('Content-Type was not one of "multipart/form-data" or "application/x-www-form-urlencoded".');
        }, instance);
      },
      bytes() {
        return consumeBody(this, bytes => new Uint8Array(bytes), instance);
      }
    };
  }
  __name(bodyMixinMethods, "bodyMixinMethods");
  function mixinBody(prototype) {
    Object.assign(prototype.prototype, bodyMixinMethods(prototype));
  }
  __name(mixinBody, "mixinBody");
  async function consumeBody(object, convertBytesToJSValue, instance) {
    if (webidl.brandCheck(object, instance), bodyUnusable(object)) throw new TypeError("Body is unusable: Body has already been read");
    throwIfAborted(object[kState]);
    let promise = createDeferredPromise(),
      errorSteps = __name(error => promise.reject(error), "errorSteps"),
      successSteps = __name(data => {
        try {
          promise.resolve(convertBytesToJSValue(data));
        } catch (e) {
          errorSteps(e);
        }
      }, "successSteps");
    return object[kState].body == null ? (successSteps(Buffer.allocUnsafe(0)), promise.promise) : (await fullyReadBody(object[kState].body, successSteps, errorSteps), promise.promise);
  }
  __name(consumeBody, "consumeBody");
  function bodyUnusable(object) {
    let body = object[kState].body;
    return body != null && (body.stream.locked || util.isDisturbed(body.stream));
  }
  __name(bodyUnusable, "bodyUnusable");
  function parseJSONFromBytes(bytes) {
    return JSON.parse(utf8DecodeBytes(bytes));
  }
  __name(parseJSONFromBytes, "parseJSONFromBytes");
  function bodyMimeType(requestOrResponse) {
    let headers = requestOrResponse[kState].headersList,
      mimeType = extractMimeType(headers);
    return mimeType === "failure" ? null : mimeType;
  }
  __name(bodyMimeType, "bodyMimeType");
  module.exports = {
    extractBody: extractBody,
    safelyExtractBody: safelyExtractBody,
    cloneBody: cloneBody,
    mixinBody: mixinBody,
    streamRegistry: streamRegistry,
    hasFinalizationRegistry: hasFinalizationRegistry,
    bodyUnusable: bodyUnusable
  };
});