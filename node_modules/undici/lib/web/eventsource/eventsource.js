var require_eventsource = __commonJSMin((exports, module) => {
  "use strict";

  var {
      pipeline: pipeline
    } = require("stream"),
    {
      fetching: fetching
    } = I9(),
    {
      makeRequest: makeRequest
    } = vI(),
    {
      webidl: webidl
    } = Gc(),
    {
      EventSourceStream: EventSourceStream
    } = $Pe(),
    {
      parseMIMEType: parseMIMEType
    } = zA(),
    {
      createFastMessageEvent: createFastMessageEvent
    } = LI(),
    {
      isNetworkError: isNetworkError
    } = B9(),
    {
      delay: delay
    } = Dse(),
    {
      kEnumerableProperty: kEnumerableProperty
    } = oi(),
    {
      environmentSettingsObject: environmentSettingsObject
    } = Lu(),
    experimentalWarned = !1,
    defaultReconnectionTime = 3e3,
    CONNECTING = 0,
    OPEN = 1,
    CLOSED = 2,
    ANONYMOUS = "anonymous",
    USE_CREDENTIALS = "use-credentials",
    _events,
    _url,
    _withCredentials,
    _readyState,
    _request,
    _controller,
    _dispatcher,
    _state,
    _EventSource_instances,
    connect_fn,
    reconnect_fn,
    _EventSource = class _EventSource extends EventTarget {
      constructor(url, eventSourceInitDict = {}) {
        super();
        __privateAdd(this, _EventSource_instances);
        __privateAdd(this, _events, {
          open: null,
          error: null,
          message: null
        });
        __privateAdd(this, _url, null);
        __privateAdd(this, _withCredentials, !1);
        __privateAdd(this, _readyState, CONNECTING);
        __privateAdd(this, _request, null);
        __privateAdd(this, _controller, null);
        __privateAdd(this, _dispatcher);
        __privateAdd(this, _state);
        webidl.util.markAsUncloneable(this);
        let prefix = "EventSource constructor";
        webidl.argumentLengthCheck(arguments, 1, prefix), experimentalWarned || (experimentalWarned = !0, process.emitWarning("EventSource is experimental, expect them to change at any time.", {
          code: "UNDICI-ES"
        })), url = webidl.converters.USVString(url, prefix, "url"), eventSourceInitDict = webidl.converters.EventSourceInitDict(eventSourceInitDict, prefix, "eventSourceInitDict"), __privateSet(this, _dispatcher, eventSourceInitDict.dispatcher), __privateSet(this, _state, {
          lastEventId: "",
          reconnectionTime: defaultReconnectionTime
        });
        let settings = environmentSettingsObject,
          urlRecord;
        try {
          urlRecord = new URL(url, settings.settingsObject.baseUrl), __privateGet(this, _state).origin = urlRecord.origin;
        } catch (e) {
          throw new DOMException(e, "SyntaxError");
        }
        __privateSet(this, _url, urlRecord.href);
        let corsAttributeState = ANONYMOUS;
        eventSourceInitDict.withCredentials && (corsAttributeState = USE_CREDENTIALS, __privateSet(this, _withCredentials, !0));
        let initRequest = {
          redirect: "follow",
          keepalive: !0,
          mode: "cors",
          credentials: corsAttributeState === "anonymous" ? "same-origin" : "omit",
          referrer: "no-referrer"
        };
        initRequest.client = environmentSettingsObject.settingsObject, initRequest.headersList = [["accept", {
          name: "accept",
          value: "text/event-stream"
        }]], initRequest.cache = "no-store", initRequest.initiator = "other", initRequest.urlList = [new URL(__privateGet(this, _url))], __privateSet(this, _request, makeRequest(initRequest)), __privateMethod(this, _EventSource_instances, connect_fn).call(this);
      }
      get readyState() {
        return __privateGet(this, _readyState);
      }
      get url() {
        return __privateGet(this, _url);
      }
      get withCredentials() {
        return __privateGet(this, _withCredentials);
      }
      close() {
        webidl.brandCheck(this, _EventSource), __privateGet(this, _readyState) !== CLOSED && (__privateSet(this, _readyState, CLOSED), __privateGet(this, _controller).abort(), __privateSet(this, _request, null));
      }
      get onopen() {
        return __privateGet(this, _events).open;
      }
      set onopen(fn) {
        __privateGet(this, _events).open && this.removeEventListener("open", __privateGet(this, _events).open), typeof fn == "function" ? (__privateGet(this, _events).open = fn, this.addEventListener("open", fn)) : __privateGet(this, _events).open = null;
      }
      get onmessage() {
        return __privateGet(this, _events).message;
      }
      set onmessage(fn) {
        __privateGet(this, _events).message && this.removeEventListener("message", __privateGet(this, _events).message), typeof fn == "function" ? (__privateGet(this, _events).message = fn, this.addEventListener("message", fn)) : __privateGet(this, _events).message = null;
      }
      get onerror() {
        return __privateGet(this, _events).error;
      }
      set onerror(fn) {
        __privateGet(this, _events).error && this.removeEventListener("error", __privateGet(this, _events).error), typeof fn == "function" ? (__privateGet(this, _events).error = fn, this.addEventListener("error", fn)) : __privateGet(this, _events).error = null;
      }
    };
  _events = new WeakMap(), _url = new WeakMap(), _withCredentials = new WeakMap(), _readyState = new WeakMap(), _request = new WeakMap(), _controller = new WeakMap(), _dispatcher = new WeakMap(), _state = new WeakMap(), _EventSource_instances = new WeakSet(), connect_fn = __name(function () {
    if (__privateGet(this, _readyState) === CLOSED) return;
    __privateSet(this, _readyState, CONNECTING);
    let fetchParams = {
        request: __privateGet(this, _request),
        dispatcher: __privateGet(this, _dispatcher)
      },
      processEventSourceEndOfBody = __name(response => {
        isNetworkError(response) && (this.dispatchEvent(new Event("error")), this.close()), __privateMethod(this, _EventSource_instances, reconnect_fn).call(this);
      }, "processEventSourceEndOfBody");
    fetchParams.processResponseEndOfBody = processEventSourceEndOfBody, fetchParams.processResponse = response => {
      if (isNetworkError(response)) if (response.aborted) {
        this.close(), this.dispatchEvent(new Event("error"));
        return;
      } else {
        __privateMethod(this, _EventSource_instances, reconnect_fn).call(this);
        return;
      }
      let contentType = response.headersList.get("content-type", !0),
        mimeType = contentType !== null ? parseMIMEType(contentType) : "failure",
        contentTypeValid = mimeType !== "failure" && mimeType.essence === "text/event-stream";
      if (response.status !== 200 || contentTypeValid === !1) {
        this.close(), this.dispatchEvent(new Event("error"));
        return;
      }
      __privateSet(this, _readyState, OPEN), this.dispatchEvent(new Event("open")), __privateGet(this, _state).origin = response.urlList[response.urlList.length - 1].origin;
      let eventSourceStream = new EventSourceStream({
        eventSourceSettings: __privateGet(this, _state),
        push: __name(event => {
          this.dispatchEvent(createFastMessageEvent(event.type, event.options));
        }, "push")
      });
      pipeline(response.body.stream, eventSourceStream, error => {
        (error == null ? void 0 : error.aborted) === !1 && (this.close(), this.dispatchEvent(new Event("error")));
      });
    }, __privateSet(this, _controller, fetching(fetchParams));
  }, "#connect"), reconnect_fn = __name(async function () {
    __privateGet(this, _readyState) !== CLOSED && (__privateSet(this, _readyState, CONNECTING), this.dispatchEvent(new Event("error")), await delay(__privateGet(this, _state).reconnectionTime), __privateGet(this, _readyState) === CONNECTING && (__privateGet(this, _state).lastEventId.length && __privateGet(this, _request).headersList.set("last-event-id", __privateGet(this, _state).lastEventId, !0), __privateMethod(this, _EventSource_instances, connect_fn).call(this)));
  }, "#reconnect"), __name(_EventSource, "EventSource");
  var EventSource = _EventSource,
    constantsPropertyDescriptors = {
      CONNECTING: {
        __proto__: null,
        configurable: !1,
        enumerable: !0,
        value: CONNECTING,
        writable: !1
      },
      OPEN: {
        __proto__: null,
        configurable: !1,
        enumerable: !0,
        value: OPEN,
        writable: !1
      },
      CLOSED: {
        __proto__: null,
        configurable: !1,
        enumerable: !0,
        value: CLOSED,
        writable: !1
      }
    };
  Object.defineProperties(EventSource, constantsPropertyDescriptors);
  Object.defineProperties(EventSource.prototype, constantsPropertyDescriptors);
  Object.defineProperties(EventSource.prototype, {
    close: kEnumerableProperty,
    onerror: kEnumerableProperty,
    onmessage: kEnumerableProperty,
    onopen: kEnumerableProperty,
    readyState: kEnumerableProperty,
    url: kEnumerableProperty,
    withCredentials: kEnumerableProperty
  });
  webidl.converters.EventSourceInitDict = webidl.dictionaryConverter([{
    key: "withCredentials",
    converter: webidl.converters.boolean,
    defaultValue: __name(() => !1, "defaultValue")
  }, {
    key: "dispatcher",
    converter: webidl.converters.any
  }]);
  module.exports = {
    EventSource: EventSource,
    defaultReconnectionTime: defaultReconnectionTime
  };
});