var require_eventsource_stream = __commonJSMin((exports, module) => {
  "use strict";

  var {
      Transform: Transform
    } = require("stream"),
    {
      isASCIINumber: isASCIINumber,
      isValidLastEventId: isValidLastEventId
    } = Dse(),
    BOM = [239, 187, 191],
    LF = 10,
    CR = 13,
    COLON = 58,
    SPACE = 32,
    _EventSourceStream = class _EventSourceStream extends Transform {
      constructor(options = {}) {
        options.readableObjectMode = !0;
        super(options);
        __publicField(this, "state", null);
        __publicField(this, "checkBOM", !0);
        __publicField(this, "crlfCheck", !1);
        __publicField(this, "eventEndCheck", !1);
        __publicField(this, "buffer", null);
        __publicField(this, "pos", 0);
        __publicField(this, "event", {
          data: void 0,
          event: void 0,
          id: void 0,
          retry: void 0
        });
        this.state = options.eventSourceSettings || {}, options.push && (this.push = options.push);
      }
      _transform(chunk, _encoding, callback) {
        if (chunk.length === 0) {
          callback();
          return;
        }
        if (this.buffer ? this.buffer = Buffer.concat([this.buffer, chunk]) : this.buffer = chunk, this.checkBOM) switch (this.buffer.length) {
          case 1:
            if (this.buffer[0] === BOM[0]) {
              callback();
              return;
            }
            this.checkBOM = !1, callback();
            return;
          case 2:
            if (this.buffer[0] === BOM[0] && this.buffer[1] === BOM[1]) {
              callback();
              return;
            }
            this.checkBOM = !1;
            break;
          case 3:
            if (this.buffer[0] === BOM[0] && this.buffer[1] === BOM[1] && this.buffer[2] === BOM[2]) {
              this.buffer = Buffer.alloc(0), this.checkBOM = !1, callback();
              return;
            }
            this.checkBOM = !1;
            break;
          default:
            this.buffer[0] === BOM[0] && this.buffer[1] === BOM[1] && this.buffer[2] === BOM[2] && (this.buffer = this.buffer.subarray(3)), this.checkBOM = !1;
            break;
        }
        for (; this.pos < this.buffer.length;) {
          if (this.eventEndCheck) {
            if (this.crlfCheck) {
              if (this.buffer[this.pos] === LF) {
                this.buffer = this.buffer.subarray(this.pos + 1), this.pos = 0, this.crlfCheck = !1;
                continue;
              }
              this.crlfCheck = !1;
            }
            if (this.buffer[this.pos] === LF || this.buffer[this.pos] === CR) {
              this.buffer[this.pos] === CR && (this.crlfCheck = !0), this.buffer = this.buffer.subarray(this.pos + 1), this.pos = 0, (this.event.data !== void 0 || this.event.event || this.event.id || this.event.retry) && this.processEvent(this.event), this.clearEvent();
              continue;
            }
            this.eventEndCheck = !1;
            continue;
          }
          if (this.buffer[this.pos] === LF || this.buffer[this.pos] === CR) {
            this.buffer[this.pos] === CR && (this.crlfCheck = !0), this.parseLine(this.buffer.subarray(0, this.pos), this.event), this.buffer = this.buffer.subarray(this.pos + 1), this.pos = 0, this.eventEndCheck = !0;
            continue;
          }
          this.pos++;
        }
        callback();
      }
      parseLine(line, event) {
        if (line.length === 0) return;
        let colonPosition = line.indexOf(COLON);
        if (colonPosition === 0) return;
        let field = "",
          value = "";
        if (colonPosition !== -1) {
          field = line.subarray(0, colonPosition).toString("utf8");
          let valueStart = colonPosition + 1;
          line[valueStart] === SPACE && ++valueStart, value = line.subarray(valueStart).toString("utf8");
        } else field = line.toString("utf8"), value = "";
        switch (field) {
          case "data":
            event[field] === void 0 ? event[field] = value : event[field] += `
${value}`;
            break;
          case "retry":
            isASCIINumber(value) && (event[field] = value);
            break;
          case "id":
            isValidLastEventId(value) && (event[field] = value);
            break;
          case "event":
            value.length > 0 && (event[field] = value);
            break;
        }
      }
      processEvent(event) {
        event.retry && isASCIINumber(event.retry) && (this.state.reconnectionTime = parseInt(event.retry, 10)), event.id && isValidLastEventId(event.id) && (this.state.lastEventId = event.id), event.data !== void 0 && this.push({
          type: event.event || "message",
          options: {
            data: event.data,
            lastEventId: this.state.lastEventId,
            origin: this.state.origin
          }
        });
      }
      clearEvent() {
        this.event = {
          data: void 0,
          event: void 0,
          id: void 0,
          retry: void 0
        };
      }
    };
  __name(_EventSourceStream, "EventSourceStream");
  var EventSourceStream = _EventSourceStream;
  module.exports = {
    EventSourceStream: EventSourceStream
  };
});