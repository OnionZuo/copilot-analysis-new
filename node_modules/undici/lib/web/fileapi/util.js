var require_util = __commonJSMin((exports, module) => {
  "use strict";

  var {
      kState: kState,
      kError: kError,
      kResult: kResult,
      kAborted: kAborted,
      kLastProgressEventFired: kLastProgressEventFired
    } = sse(),
    {
      ProgressEvent: ProgressEvent
    } = a6e(),
    {
      getEncoding: getEncoding
    } = r6e(),
    {
      serializeAMimeType: serializeAMimeType,
      parseMIMEType: parseMIMEType
    } = zA(),
    {
      types: types
    } = require("util"),
    {
      StringDecoder: StringDecoder
    } = require("string_decoder"),
    {
      btoa: btoa
    } = require("buffer"),
    staticPropertyDescriptors = {
      enumerable: !0,
      writable: !1,
      configurable: !1
    };
  function readOperation(fr, blob, type, encodingName) {
    if (fr[kState] === "loading") throw new DOMException("Invalid state", "InvalidStateError");
    fr[kState] = "loading", fr[kResult] = null, fr[kError] = null;
    let reader = blob.stream().getReader(),
      bytes = [],
      chunkPromise = reader.read(),
      isFirstChunk = !0;
    (async () => {
      for (; !fr[kAborted];) try {
        let {
          done: done,
          value: value
        } = await chunkPromise;
        if (isFirstChunk && !fr[kAborted] && queueMicrotask(() => {
          fireAProgressEvent("loadstart", fr);
        }), isFirstChunk = !1, !done && types.isUint8Array(value)) bytes.push(value), (fr[kLastProgressEventFired] === void 0 || Date.now() - fr[kLastProgressEventFired] >= 50) && !fr[kAborted] && (fr[kLastProgressEventFired] = Date.now(), queueMicrotask(() => {
          fireAProgressEvent("progress", fr);
        })), chunkPromise = reader.read();else if (done) {
          queueMicrotask(() => {
            fr[kState] = "done";
            try {
              let result = packageData(bytes, type, blob.type, encodingName);
              if (fr[kAborted]) return;
              fr[kResult] = result, fireAProgressEvent("load", fr);
            } catch (error) {
              fr[kError] = error, fireAProgressEvent("error", fr);
            }
            fr[kState] !== "loading" && fireAProgressEvent("loadend", fr);
          });
          break;
        }
      } catch (error) {
        if (fr[kAborted]) return;
        queueMicrotask(() => {
          fr[kState] = "done", fr[kError] = error, fireAProgressEvent("error", fr), fr[kState] !== "loading" && fireAProgressEvent("loadend", fr);
        });
        break;
      }
    })();
  }
  __name(readOperation, "readOperation");
  function fireAProgressEvent(e, reader) {
    let event = new ProgressEvent(e, {
      bubbles: !1,
      cancelable: !1
    });
    reader.dispatchEvent(event);
  }
  __name(fireAProgressEvent, "fireAProgressEvent");
  function packageData(bytes, type, mimeType, encodingName) {
    switch (type) {
      case "DataURL":
        {
          let dataURL = "data:",
            parsed = parseMIMEType(mimeType || "application/octet-stream");
          parsed !== "failure" && (dataURL += serializeAMimeType(parsed)), dataURL += ";base64,";
          let decoder = new StringDecoder("latin1");
          for (let chunk of bytes) dataURL += btoa(decoder.write(chunk));
          return dataURL += btoa(decoder.end()), dataURL;
        }
      case "Text":
        {
          let encoding = "failure";
          if (encodingName && (encoding = getEncoding(encodingName)), encoding === "failure" && mimeType) {
            let type = parseMIMEType(mimeType);
            type !== "failure" && (encoding = getEncoding(type.parameters.get("charset")));
          }
          return encoding === "failure" && (encoding = "UTF-8"), decode(bytes, encoding);
        }
      case "ArrayBuffer":
        return combineByteSequences(bytes).buffer;
      case "BinaryString":
        {
          let binaryString = "",
            decoder = new StringDecoder("latin1");
          for (let chunk of bytes) binaryString += decoder.write(chunk);
          return binaryString += decoder.end(), binaryString;
        }
    }
  }
  __name(packageData, "packageData");
  function decode(ioQueue, encoding) {
    let bytes = combineByteSequences(ioQueue),
      BOMEncoding = BOMSniffing(bytes),
      slice = 0;
    BOMEncoding !== null && (encoding = BOMEncoding, slice = BOMEncoding === "UTF-8" ? 3 : 2);
    let sliced = bytes.slice(slice);
    return new TextDecoder(encoding).decode(sliced);
  }
  __name(decode, "decode");
  function BOMSniffing(ioQueue) {
    let [a, b, c] = ioQueue;
    return a === 239 && b === 187 && c === 191 ? "UTF-8" : a === 254 && b === 255 ? "UTF-16BE" : a === 255 && b === 254 ? "UTF-16LE" : null;
  }
  __name(BOMSniffing, "BOMSniffing");
  function combineByteSequences(sequences) {
    let size = sequences.reduce((a, b) => a + b.byteLength, 0),
      offset = 0;
    return sequences.reduce((a, b) => (a.set(b, offset), offset += b.byteLength, a), new Uint8Array(size));
  }
  __name(combineByteSequences, "combineByteSequences");
  module.exports = {
    staticPropertyDescriptors: staticPropertyDescriptors,
    readOperation: readOperation,
    fireAProgressEvent: fireAProgressEvent
  };
});