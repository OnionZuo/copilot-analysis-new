var require_client_h2 = __commonJSMin((exports, module) => {
  "use strict";

  var assert = require("assert"),
    {
      pipeline: pipeline
    } = require("stream"),
    util = oi(),
    {
      RequestContentLengthMismatchError: RequestContentLengthMismatchError,
      RequestAbortedError: RequestAbortedError,
      SocketError: SocketError,
      InformationalError: InformationalError
    } = rr(),
    {
      kUrl: kUrl,
      kReset: kReset,
      kClient: kClient,
      kRunning: kRunning,
      kPending: kPending,
      kQueue: kQueue,
      kPendingIdx: kPendingIdx,
      kRunningIdx: kRunningIdx,
      kError: kError,
      kSocket: kSocket,
      kStrictContentLength: kStrictContentLength,
      kOnError: kOnError,
      kMaxConcurrentStreams: kMaxConcurrentStreams,
      kHTTP2Session: kHTTP2Session,
      kResume: kResume,
      kSize: kSize,
      kHTTPContext: kHTTPContext
    } = fo(),
    kOpenStreams = Symbol("open streams"),
    extractBody,
    h2ExperimentalWarned = !1,
    http2;
  try {
    http2 = require("http2");
  } catch {
    http2 = {
      constants: {}
    };
  }
  var {
    constants: {
      HTTP2_HEADER_AUTHORITY: HTTP2_HEADER_AUTHORITY,
      HTTP2_HEADER_METHOD: HTTP2_HEADER_METHOD,
      HTTP2_HEADER_PATH: HTTP2_HEADER_PATH,
      HTTP2_HEADER_SCHEME: HTTP2_HEADER_SCHEME,
      HTTP2_HEADER_CONTENT_LENGTH: HTTP2_HEADER_CONTENT_LENGTH,
      HTTP2_HEADER_EXPECT: HTTP2_HEADER_EXPECT,
      HTTP2_HEADER_STATUS: HTTP2_HEADER_STATUS
    }
  } = http2;
  function parseH2Headers(headers) {
    let result = [];
    for (let [name, value] of Object.entries(headers)) if (Array.isArray(value)) for (let subvalue of value) result.push(Buffer.from(name), Buffer.from(subvalue));else result.push(Buffer.from(name), Buffer.from(value));
    return result;
  }
  __name(parseH2Headers, "parseH2Headers");
  async function connectH2(client, socket) {
    client[kSocket] = socket, h2ExperimentalWarned || (h2ExperimentalWarned = !0, process.emitWarning("H2 support is experimental, expect them to change at any time.", {
      code: "UNDICI-H2"
    }));
    let session = http2.connect(client[kUrl], {
      createConnection: __name(() => socket, "createConnection"),
      peerMaxConcurrentStreams: client[kMaxConcurrentStreams]
    });
    session[kOpenStreams] = 0, session[kClient] = client, session[kSocket] = socket, util.addListener(session, "error", onHttp2SessionError), util.addListener(session, "frameError", onHttp2FrameError), util.addListener(session, "end", onHttp2SessionEnd), util.addListener(session, "goaway", onHTTP2GoAway), util.addListener(session, "close", function () {
      let {
          [kClient]: client
        } = this,
        {
          [kSocket]: socket
        } = client,
        err = this[kSocket][kError] || this[kError] || new SocketError("closed", util.getSocketInfo(socket));
      if (client[kHTTP2Session] = null, client.destroyed) {
        assert(client[kPending] === 0);
        let requests = client[kQueue].splice(client[kRunningIdx]);
        for (let i = 0; i < requests.length; i++) {
          let request = requests[i];
          util.errorRequest(client, request, err);
        }
      }
    }), session.unref(), client[kHTTP2Session] = session, socket[kHTTP2Session] = session, util.addListener(socket, "error", function (err) {
      assert(err.code !== "ERR_TLS_CERT_ALTNAME_INVALID"), this[kError] = err, this[kClient][kOnError](err);
    }), util.addListener(socket, "end", function () {
      util.destroy(this, new SocketError("other side closed", util.getSocketInfo(this)));
    }), util.addListener(socket, "close", function () {
      let err = this[kError] || new SocketError("closed", util.getSocketInfo(this));
      client[kSocket] = null, this[kHTTP2Session] != null && this[kHTTP2Session].destroy(err), client[kPendingIdx] = client[kRunningIdx], assert(client[kRunning] === 0), client.emit("disconnect", client[kUrl], [client], err), client[kResume]();
    });
    let closed = !1;
    return socket.on("close", () => {
      closed = !0;
    }), {
      version: "h2",
      defaultPipelining: 1 / 0,
      write(...args) {
        return writeH2(client, ...args);
      },
      resume() {
        resumeH2(client);
      },
      destroy(err, callback) {
        closed ? queueMicrotask(callback) : socket.destroy(err).on("close", callback);
      },
      get destroyed() {
        return socket.destroyed;
      },
      busy() {
        return !1;
      }
    };
  }
  __name(connectH2, "connectH2");
  function resumeH2(client) {
    let socket = client[kSocket];
    (socket == null ? void 0 : socket.destroyed) === !1 && (client[kSize] === 0 && client[kMaxConcurrentStreams] === 0 ? (socket.unref(), client[kHTTP2Session].unref()) : (socket.ref(), client[kHTTP2Session].ref()));
  }
  __name(resumeH2, "resumeH2");
  function onHttp2SessionError(err) {
    assert(err.code !== "ERR_TLS_CERT_ALTNAME_INVALID"), this[kSocket][kError] = err, this[kClient][kOnError](err);
  }
  __name(onHttp2SessionError, "onHttp2SessionError");
  function onHttp2FrameError(type, code, id) {
    if (id === 0) {
      let err = new InformationalError(`HTTP/2: "frameError" received - type ${type}, code ${code}`);
      this[kSocket][kError] = err, this[kClient][kOnError](err);
    }
  }
  __name(onHttp2FrameError, "onHttp2FrameError");
  function onHttp2SessionEnd() {
    let err = new SocketError("other side closed", util.getSocketInfo(this[kSocket]));
    this.destroy(err), util.destroy(this[kSocket], err);
  }
  __name(onHttp2SessionEnd, "onHttp2SessionEnd");
  function onHTTP2GoAway(code) {
    let err = this[kError] || new SocketError(`HTTP/2: "GOAWAY" frame received with code ${code}`, util.getSocketInfo(this)),
      client = this[kClient];
    if (client[kSocket] = null, client[kHTTPContext] = null, this[kHTTP2Session] != null && (this[kHTTP2Session].destroy(err), this[kHTTP2Session] = null), util.destroy(this[kSocket], err), client[kRunningIdx] < client[kQueue].length) {
      let request = client[kQueue][client[kRunningIdx]];
      client[kQueue][client[kRunningIdx]++] = null, util.errorRequest(client, request, err), client[kPendingIdx] = client[kRunningIdx];
    }
    assert(client[kRunning] === 0), client.emit("disconnect", client[kUrl], [client], err), client[kResume]();
  }
  __name(onHTTP2GoAway, "onHTTP2GoAway");
  function shouldSendContentLength(method) {
    return method !== "GET" && method !== "HEAD" && method !== "OPTIONS" && method !== "TRACE" && method !== "CONNECT";
  }
  __name(shouldSendContentLength, "shouldSendContentLength");
  function writeH2(client, request) {
    let session = client[kHTTP2Session],
      {
        method: method,
        path: path,
        host: host,
        upgrade: upgrade,
        expectContinue: expectContinue,
        signal: signal,
        headers: reqHeaders
      } = request,
      {
        body: body
      } = request;
    if (upgrade) return util.errorRequest(client, request, new Error("Upgrade not supported for H2")), !1;
    let headers = {};
    for (let n = 0; n < reqHeaders.length; n += 2) {
      let key = reqHeaders[n + 0],
        val = reqHeaders[n + 1];
      if (Array.isArray(val)) for (let i = 0; i < val.length; i++) headers[key] ? headers[key] += `,${val[i]}` : headers[key] = val[i];else headers[key] = val;
    }
    let stream,
      {
        hostname: hostname,
        port: port
      } = client[kUrl];
    headers[HTTP2_HEADER_AUTHORITY] = host || `${hostname}${port ? `:${port}` : ""}`, headers[HTTP2_HEADER_METHOD] = method;
    let abort = __name(err => {
      request.aborted || request.completed || (err = err || new RequestAbortedError(), util.errorRequest(client, request, err), stream != null && util.destroy(stream, err), util.destroy(body, err), client[kQueue][client[kRunningIdx]++] = null, client[kResume]());
    }, "abort");
    try {
      request.onConnect(abort);
    } catch (err) {
      util.errorRequest(client, request, err);
    }
    if (request.aborted) return !1;
    if (method === "CONNECT") return session.ref(), stream = session.request(headers, {
      endStream: !1,
      signal: signal
    }), stream.id && !stream.pending ? (request.onUpgrade(null, null, stream), ++session[kOpenStreams], client[kQueue][client[kRunningIdx]++] = null) : stream.once("ready", () => {
      request.onUpgrade(null, null, stream), ++session[kOpenStreams], client[kQueue][client[kRunningIdx]++] = null;
    }), stream.once("close", () => {
      session[kOpenStreams] -= 1, session[kOpenStreams] === 0 && session.unref();
    }), !0;
    headers[HTTP2_HEADER_PATH] = path, headers[HTTP2_HEADER_SCHEME] = "https";
    let expectsPayload = method === "PUT" || method === "POST" || method === "PATCH";
    body && typeof body.read == "function" && body.read(0);
    let contentLength = util.bodyLength(body);
    if (util.isFormDataLike(body)) {
      extractBody != null || (extractBody = Wv().extractBody);
      let [bodyStream, contentType] = extractBody(body);
      headers["content-type"] = contentType, body = bodyStream.stream, contentLength = bodyStream.length;
    }
    if (contentLength == null && (contentLength = request.contentLength), (contentLength === 0 || !expectsPayload) && (contentLength = null), shouldSendContentLength(method) && contentLength > 0 && request.contentLength != null && request.contentLength !== contentLength) {
      if (client[kStrictContentLength]) return util.errorRequest(client, request, new RequestContentLengthMismatchError()), !1;
      process.emitWarning(new RequestContentLengthMismatchError());
    }
    contentLength != null && (assert(body, "no body must not have content length"), headers[HTTP2_HEADER_CONTENT_LENGTH] = `${contentLength}`), session.ref();
    let shouldEndStream = method === "GET" || method === "HEAD" || body === null;
    return expectContinue ? (headers[HTTP2_HEADER_EXPECT] = "100-continue", stream = session.request(headers, {
      endStream: shouldEndStream,
      signal: signal
    }), stream.once("continue", writeBodyH2)) : (stream = session.request(headers, {
      endStream: shouldEndStream,
      signal: signal
    }), writeBodyH2()), ++session[kOpenStreams], stream.once("response", headers => {
      let {
        [HTTP2_HEADER_STATUS]: statusCode,
        ...realHeaders
      } = headers;
      if (request.onResponseStarted(), request.aborted) {
        let err = new RequestAbortedError();
        util.errorRequest(client, request, err), util.destroy(stream, err);
        return;
      }
      request.onHeaders(Number(statusCode), parseH2Headers(realHeaders), stream.resume.bind(stream), "") === !1 && stream.pause(), stream.on("data", chunk => {
        request.onData(chunk) === !1 && stream.pause();
      });
    }), stream.once("end", () => {
      var _a;
      (((_a = stream.state) == null ? void 0 : _a.state) == null || stream.state.state < 6) && request.onComplete([]), session[kOpenStreams] === 0 && session.unref(), abort(new InformationalError("HTTP/2: stream half-closed (remote)")), client[kQueue][client[kRunningIdx]++] = null, client[kPendingIdx] = client[kRunningIdx], client[kResume]();
    }), stream.once("close", () => {
      session[kOpenStreams] -= 1, session[kOpenStreams] === 0 && session.unref();
    }), stream.once("error", function (err) {
      abort(err);
    }), stream.once("frameError", (type, code) => {
      abort(new InformationalError(`HTTP/2: "frameError" received - type ${type}, code ${code}`));
    }), !0;
    function writeBodyH2() {
      !body || contentLength === 0 ? writeBuffer(abort, stream, null, client, request, client[kSocket], contentLength, expectsPayload) : util.isBuffer(body) ? writeBuffer(abort, stream, body, client, request, client[kSocket], contentLength, expectsPayload) : util.isBlobLike(body) ? typeof body.stream == "function" ? writeIterable(abort, stream, body.stream(), client, request, client[kSocket], contentLength, expectsPayload) : writeBlob(abort, stream, body, client, request, client[kSocket], contentLength, expectsPayload) : util.isStream(body) ? writeStream(abort, client[kSocket], expectsPayload, stream, body, client, request, contentLength) : util.isIterable(body) ? writeIterable(abort, stream, body, client, request, client[kSocket], contentLength, expectsPayload) : assert(!1);
    }
    __name(writeBodyH2, "writeBodyH2");
  }
  __name(writeH2, "writeH2");
  function writeBuffer(abort, h2stream, body, client, request, socket, contentLength, expectsPayload) {
    try {
      body != null && util.isBuffer(body) && (assert(contentLength === body.byteLength, "buffer body must have content length"), h2stream.cork(), h2stream.write(body), h2stream.uncork(), h2stream.end(), request.onBodySent(body)), expectsPayload || (socket[kReset] = !0), request.onRequestSent(), client[kResume]();
    } catch (error) {
      abort(error);
    }
  }
  __name(writeBuffer, "writeBuffer");
  function writeStream(abort, socket, expectsPayload, h2stream, body, client, request, contentLength) {
    assert(contentLength !== 0 || client[kRunning] === 0, "stream body cannot be pipelined");
    let pipe = pipeline(body, h2stream, err => {
      err ? (util.destroy(pipe, err), abort(err)) : (util.removeAllListeners(pipe), request.onRequestSent(), expectsPayload || (socket[kReset] = !0), client[kResume]());
    });
    util.addListener(pipe, "data", onPipeData);
    function onPipeData(chunk) {
      request.onBodySent(chunk);
    }
    __name(onPipeData, "onPipeData");
  }
  __name(writeStream, "writeStream");
  async function writeBlob(abort, h2stream, body, client, request, socket, contentLength, expectsPayload) {
    assert(contentLength === body.size, "blob body must have content length");
    try {
      if (contentLength != null && contentLength !== body.size) throw new RequestContentLengthMismatchError();
      let buffer = Buffer.from(await body.arrayBuffer());
      h2stream.cork(), h2stream.write(buffer), h2stream.uncork(), h2stream.end(), request.onBodySent(buffer), request.onRequestSent(), expectsPayload || (socket[kReset] = !0), client[kResume]();
    } catch (err) {
      abort(err);
    }
  }
  __name(writeBlob, "writeBlob");
  async function writeIterable(abort, h2stream, body, client, request, socket, contentLength, expectsPayload) {
    assert(contentLength !== 0 || client[kRunning] === 0, "iterator body cannot be pipelined");
    let callback = null;
    function onDrain() {
      if (callback) {
        let cb = callback;
        callback = null, cb();
      }
    }
    __name(onDrain, "onDrain");
    let waitForDrain = __name(() => new Promise((resolve, reject) => {
      assert(callback === null), socket[kError] ? reject(socket[kError]) : callback = resolve;
    }), "waitForDrain");
    h2stream.on("close", onDrain).on("drain", onDrain);
    try {
      for await (let chunk of body) {
        if (socket[kError]) throw socket[kError];
        let res = h2stream.write(chunk);
        request.onBodySent(chunk), res || (await waitForDrain());
      }
      h2stream.end(), request.onRequestSent(), expectsPayload || (socket[kReset] = !0), client[kResume]();
    } catch (err) {
      abort(err);
    } finally {
      h2stream.off("close", onDrain).off("drain", onDrain);
    }
  }
  __name(writeIterable, "writeIterable");
  module.exports = connectH2;
});