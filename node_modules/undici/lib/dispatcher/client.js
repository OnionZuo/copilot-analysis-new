var require_client = __commonJSMin((exports, module) => {
  "use strict";

  var assert = require("assert"),
    net = require("net"),
    http = require("http"),
    util = oi(),
    {
      channels: channels
    } = Sv(),
    Request = IFe(),
    DispatcherBase = Lv(),
    {
      InvalidArgumentError: InvalidArgumentError,
      InformationalError: InformationalError,
      ClientDestroyedError: ClientDestroyedError
    } = rr(),
    buildConnector = U4(),
    {
      kUrl: kUrl,
      kServerName: kServerName,
      kClient: kClient,
      kBusy: kBusy,
      kConnect: kConnect,
      kResuming: kResuming,
      kRunning: kRunning,
      kPending: kPending,
      kSize: kSize,
      kQueue: kQueue,
      kConnected: kConnected,
      kConnecting: kConnecting,
      kNeedDrain: kNeedDrain,
      kKeepAliveDefaultTimeout: kKeepAliveDefaultTimeout,
      kHostHeader: kHostHeader,
      kPendingIdx: kPendingIdx,
      kRunningIdx: kRunningIdx,
      kError: kError,
      kPipelining: kPipelining,
      kKeepAliveTimeoutValue: kKeepAliveTimeoutValue,
      kMaxHeadersSize: kMaxHeadersSize,
      kKeepAliveMaxTimeout: kKeepAliveMaxTimeout,
      kKeepAliveTimeoutThreshold: kKeepAliveTimeoutThreshold,
      kHeadersTimeout: kHeadersTimeout,
      kBodyTimeout: kBodyTimeout,
      kStrictContentLength: kStrictContentLength,
      kConnector: kConnector,
      kMaxRedirections: kMaxRedirections,
      kMaxRequests: kMaxRequests,
      kCounter: kCounter,
      kClose: kClose,
      kDestroy: kDestroy,
      kDispatch: kDispatch,
      kInterceptors: kInterceptors,
      kLocalAddress: kLocalAddress,
      kMaxResponseSize: kMaxResponseSize,
      kOnError: kOnError,
      kHTTPContext: kHTTPContext,
      kMaxConcurrentStreams: kMaxConcurrentStreams,
      kResume: kResume
    } = fo(),
    connectH1 = nTe(),
    connectH2 = lTe(),
    deprecatedInterceptorWarned = !1,
    kClosedResolve = Symbol("kClosedResolve"),
    noop = __name(() => {}, "noop");
  function getPipelining(client) {
    var _a, _b, _c;
    return (_c = (_b = client[kPipelining]) != null ? _b : (_a = client[kHTTPContext]) == null ? void 0 : _a.defaultPipelining) != null ? _c : 1;
  }
  __name(getPipelining, "getPipelining");
  var _Client = class _Client extends DispatcherBase {
    constructor(url, {
      interceptors: interceptors,
      maxHeaderSize: maxHeaderSize,
      headersTimeout: headersTimeout,
      socketTimeout: socketTimeout,
      requestTimeout: requestTimeout,
      connectTimeout: connectTimeout,
      bodyTimeout: bodyTimeout,
      idleTimeout: idleTimeout,
      keepAlive: keepAlive,
      keepAliveTimeout: keepAliveTimeout,
      maxKeepAliveTimeout: maxKeepAliveTimeout,
      keepAliveMaxTimeout: keepAliveMaxTimeout,
      keepAliveTimeoutThreshold: keepAliveTimeoutThreshold,
      socketPath: socketPath,
      pipelining: pipelining,
      tls: tls,
      strictContentLength: strictContentLength,
      maxCachedSessions: maxCachedSessions,
      maxRedirections: maxRedirections,
      connect: connect,
      maxRequestsPerClient: maxRequestsPerClient,
      localAddress: localAddress,
      maxResponseSize: maxResponseSize,
      autoSelectFamily: autoSelectFamily,
      autoSelectFamilyAttemptTimeout: autoSelectFamilyAttemptTimeout,
      maxConcurrentStreams: maxConcurrentStreams,
      allowH2: allowH2
    } = {}) {
      if (super(), keepAlive !== void 0) throw new InvalidArgumentError("unsupported keepAlive, use pipelining=0 instead");
      if (socketTimeout !== void 0) throw new InvalidArgumentError("unsupported socketTimeout, use headersTimeout & bodyTimeout instead");
      if (requestTimeout !== void 0) throw new InvalidArgumentError("unsupported requestTimeout, use headersTimeout & bodyTimeout instead");
      if (idleTimeout !== void 0) throw new InvalidArgumentError("unsupported idleTimeout, use keepAliveTimeout instead");
      if (maxKeepAliveTimeout !== void 0) throw new InvalidArgumentError("unsupported maxKeepAliveTimeout, use keepAliveMaxTimeout instead");
      if (maxHeaderSize != null && !Number.isFinite(maxHeaderSize)) throw new InvalidArgumentError("invalid maxHeaderSize");
      if (socketPath != null && typeof socketPath != "string") throw new InvalidArgumentError("invalid socketPath");
      if (connectTimeout != null && (!Number.isFinite(connectTimeout) || connectTimeout < 0)) throw new InvalidArgumentError("invalid connectTimeout");
      if (keepAliveTimeout != null && (!Number.isFinite(keepAliveTimeout) || keepAliveTimeout <= 0)) throw new InvalidArgumentError("invalid keepAliveTimeout");
      if (keepAliveMaxTimeout != null && (!Number.isFinite(keepAliveMaxTimeout) || keepAliveMaxTimeout <= 0)) throw new InvalidArgumentError("invalid keepAliveMaxTimeout");
      if (keepAliveTimeoutThreshold != null && !Number.isFinite(keepAliveTimeoutThreshold)) throw new InvalidArgumentError("invalid keepAliveTimeoutThreshold");
      if (headersTimeout != null && (!Number.isInteger(headersTimeout) || headersTimeout < 0)) throw new InvalidArgumentError("headersTimeout must be a positive integer or zero");
      if (bodyTimeout != null && (!Number.isInteger(bodyTimeout) || bodyTimeout < 0)) throw new InvalidArgumentError("bodyTimeout must be a positive integer or zero");
      if (connect != null && typeof connect != "function" && typeof connect != "object") throw new InvalidArgumentError("connect must be a function or an object");
      if (maxRedirections != null && (!Number.isInteger(maxRedirections) || maxRedirections < 0)) throw new InvalidArgumentError("maxRedirections must be a positive number");
      if (maxRequestsPerClient != null && (!Number.isInteger(maxRequestsPerClient) || maxRequestsPerClient < 0)) throw new InvalidArgumentError("maxRequestsPerClient must be a positive number");
      if (localAddress != null && (typeof localAddress != "string" || net.isIP(localAddress) === 0)) throw new InvalidArgumentError("localAddress must be valid string IP address");
      if (maxResponseSize != null && (!Number.isInteger(maxResponseSize) || maxResponseSize < -1)) throw new InvalidArgumentError("maxResponseSize must be a positive number");
      if (autoSelectFamilyAttemptTimeout != null && (!Number.isInteger(autoSelectFamilyAttemptTimeout) || autoSelectFamilyAttemptTimeout < -1)) throw new InvalidArgumentError("autoSelectFamilyAttemptTimeout must be a positive number");
      if (allowH2 != null && typeof allowH2 != "boolean") throw new InvalidArgumentError("allowH2 must be a valid boolean value");
      if (maxConcurrentStreams != null && (typeof maxConcurrentStreams != "number" || maxConcurrentStreams < 1)) throw new InvalidArgumentError("maxConcurrentStreams must be a positive integer, greater than 0");
      typeof connect != "function" && (connect = buildConnector({
        ...tls,
        maxCachedSessions: maxCachedSessions,
        allowH2: allowH2,
        socketPath: socketPath,
        timeout: connectTimeout,
        ...(autoSelectFamily ? {
          autoSelectFamily: autoSelectFamily,
          autoSelectFamilyAttemptTimeout: autoSelectFamilyAttemptTimeout
        } : void 0),
        ...connect
      })), interceptors != null && interceptors.Client && Array.isArray(interceptors.Client) ? (this[kInterceptors] = interceptors.Client, deprecatedInterceptorWarned || (deprecatedInterceptorWarned = !0, process.emitWarning("Client.Options#interceptor is deprecated. Use Dispatcher#compose instead.", {
        code: "UNDICI-CLIENT-INTERCEPTOR-DEPRECATED"
      }))) : this[kInterceptors] = [createRedirectInterceptor({
        maxRedirections: maxRedirections
      })], this[kUrl] = util.parseOrigin(url), this[kConnector] = connect, this[kPipelining] = pipelining != null ? pipelining : 1, this[kMaxHeadersSize] = maxHeaderSize || http.maxHeaderSize, this[kKeepAliveDefaultTimeout] = keepAliveTimeout == null ? 4e3 : keepAliveTimeout, this[kKeepAliveMaxTimeout] = keepAliveMaxTimeout == null ? 6e5 : keepAliveMaxTimeout, this[kKeepAliveTimeoutThreshold] = keepAliveTimeoutThreshold == null ? 2e3 : keepAliveTimeoutThreshold, this[kKeepAliveTimeoutValue] = this[kKeepAliveDefaultTimeout], this[kServerName] = null, this[kLocalAddress] = localAddress != null ? localAddress : null, this[kResuming] = 0, this[kNeedDrain] = 0, this[kHostHeader] = `host: ${this[kUrl].hostname}${this[kUrl].port ? `:${this[kUrl].port}` : ""}\r
`, this[kBodyTimeout] = bodyTimeout != null ? bodyTimeout : 3e5, this[kHeadersTimeout] = headersTimeout != null ? headersTimeout : 3e5, this[kStrictContentLength] = strictContentLength == null ? !0 : strictContentLength, this[kMaxRedirections] = maxRedirections, this[kMaxRequests] = maxRequestsPerClient, this[kClosedResolve] = null, this[kMaxResponseSize] = maxResponseSize > -1 ? maxResponseSize : -1, this[kMaxConcurrentStreams] = maxConcurrentStreams != null ? maxConcurrentStreams : 100, this[kHTTPContext] = null, this[kQueue] = [], this[kRunningIdx] = 0, this[kPendingIdx] = 0, this[kResume] = sync => resume(this, sync), this[kOnError] = err => onError(this, err);
    }
    get pipelining() {
      return this[kPipelining];
    }
    set pipelining(value) {
      this[kPipelining] = value, this[kResume](!0);
    }
    get [kPending]() {
      return this[kQueue].length - this[kPendingIdx];
    }
    get [kRunning]() {
      return this[kPendingIdx] - this[kRunningIdx];
    }
    get [kSize]() {
      return this[kQueue].length - this[kRunningIdx];
    }
    get [kConnected]() {
      return !!this[kHTTPContext] && !this[kConnecting] && !this[kHTTPContext].destroyed;
    }
    get [kBusy]() {
      var _a;
      return !!((_a = this[kHTTPContext]) != null && _a.busy(null) || this[kSize] >= (getPipelining(this) || 1) || this[kPending] > 0);
    }
    [kConnect](cb) {
      connect(this), this.once("connect", cb);
    }
    [kDispatch](opts, handler) {
      let origin = opts.origin || this[kUrl].origin,
        request = new Request(origin, opts, handler);
      return this[kQueue].push(request), this[kResuming] || (util.bodyLength(request.body) == null && util.isIterable(request.body) ? (this[kResuming] = 1, queueMicrotask(() => resume(this))) : this[kResume](!0)), this[kResuming] && this[kNeedDrain] !== 2 && this[kBusy] && (this[kNeedDrain] = 2), this[kNeedDrain] < 2;
    }
    async [kClose]() {
      return new Promise(resolve => {
        this[kSize] ? this[kClosedResolve] = resolve : resolve(null);
      });
    }
    async [kDestroy](err) {
      return new Promise(resolve => {
        let requests = this[kQueue].splice(this[kPendingIdx]);
        for (let i = 0; i < requests.length; i++) {
          let request = requests[i];
          util.errorRequest(this, request, err);
        }
        let callback = __name(() => {
          this[kClosedResolve] && (this[kClosedResolve](), this[kClosedResolve] = null), resolve(null);
        }, "callback");
        this[kHTTPContext] ? (this[kHTTPContext].destroy(err, callback), this[kHTTPContext] = null) : queueMicrotask(callback), this[kResume]();
      });
    }
  };
  __name(_Client, "Client");
  var Client = _Client,
    createRedirectInterceptor = _M();
  function onError(client, err) {
    if (client[kRunning] === 0 && err.code !== "UND_ERR_INFO" && err.code !== "UND_ERR_SOCKET") {
      assert(client[kPendingIdx] === client[kRunningIdx]);
      let requests = client[kQueue].splice(client[kRunningIdx]);
      for (let i = 0; i < requests.length; i++) {
        let request = requests[i];
        util.errorRequest(client, request, err);
      }
      assert(client[kSize] === 0);
    }
  }
  __name(onError, "onError");
  async function connect(client) {
    var _a, _b, _c;
    assert(!client[kConnecting]), assert(!client[kHTTPContext]);
    let {
      host: host,
      hostname: hostname,
      protocol: protocol,
      port: port
    } = client[kUrl];
    if (hostname[0] === "[") {
      let idx = hostname.indexOf("]");
      assert(idx !== -1);
      let ip = hostname.substring(1, idx);
      assert(net.isIP(ip)), hostname = ip;
    }
    client[kConnecting] = !0, channels.beforeConnect.hasSubscribers && channels.beforeConnect.publish({
      connectParams: {
        host: host,
        hostname: hostname,
        protocol: protocol,
        port: port,
        version: (_a = client[kHTTPContext]) == null ? void 0 : _a.version,
        servername: client[kServerName],
        localAddress: client[kLocalAddress]
      },
      connector: client[kConnector]
    });
    try {
      let socket = await new Promise((resolve, reject) => {
        client[kConnector]({
          host: host,
          hostname: hostname,
          protocol: protocol,
          port: port,
          servername: client[kServerName],
          localAddress: client[kLocalAddress]
        }, (err, socket) => {
          err ? reject(err) : resolve(socket);
        });
      });
      if (client.destroyed) {
        util.destroy(socket.on("error", noop), new ClientDestroyedError());
        return;
      }
      assert(socket);
      try {
        client[kHTTPContext] = socket.alpnProtocol === "h2" ? await connectH2(client, socket) : await connectH1(client, socket);
      } catch (err) {
        throw socket.destroy().on("error", noop), err;
      }
      client[kConnecting] = !1, socket[kCounter] = 0, socket[kMaxRequests] = client[kMaxRequests], socket[kClient] = client, socket[kError] = null, channels.connected.hasSubscribers && channels.connected.publish({
        connectParams: {
          host: host,
          hostname: hostname,
          protocol: protocol,
          port: port,
          version: (_b = client[kHTTPContext]) == null ? void 0 : _b.version,
          servername: client[kServerName],
          localAddress: client[kLocalAddress]
        },
        connector: client[kConnector],
        socket: socket
      }), client.emit("connect", client[kUrl], [client]);
    } catch (err) {
      if (client.destroyed) return;
      if (client[kConnecting] = !1, channels.connectError.hasSubscribers && channels.connectError.publish({
        connectParams: {
          host: host,
          hostname: hostname,
          protocol: protocol,
          port: port,
          version: (_c = client[kHTTPContext]) == null ? void 0 : _c.version,
          servername: client[kServerName],
          localAddress: client[kLocalAddress]
        },
        connector: client[kConnector],
        error: err
      }), err.code === "ERR_TLS_CERT_ALTNAME_INVALID") for (assert(client[kRunning] === 0); client[kPending] > 0 && client[kQueue][client[kPendingIdx]].servername === client[kServerName];) {
        let request = client[kQueue][client[kPendingIdx]++];
        util.errorRequest(client, request, err);
      } else onError(client, err);
      client.emit("connectionError", client[kUrl], [client], err);
    }
    client[kResume]();
  }
  __name(connect, "connect");
  function emitDrain(client) {
    client[kNeedDrain] = 0, client.emit("drain", client[kUrl], [client]);
  }
  __name(emitDrain, "emitDrain");
  function resume(client, sync) {
    client[kResuming] !== 2 && (client[kResuming] = 2, _resume(client, sync), client[kResuming] = 0, client[kRunningIdx] > 256 && (client[kQueue].splice(0, client[kRunningIdx]), client[kPendingIdx] -= client[kRunningIdx], client[kRunningIdx] = 0));
  }
  __name(resume, "resume");
  function _resume(client, sync) {
    var _a;
    for (;;) {
      if (client.destroyed) {
        assert(client[kPending] === 0);
        return;
      }
      if (client[kClosedResolve] && !client[kSize]) {
        client[kClosedResolve](), client[kClosedResolve] = null;
        return;
      }
      if (client[kHTTPContext] && client[kHTTPContext].resume(), client[kBusy]) client[kNeedDrain] = 2;else if (client[kNeedDrain] === 2) {
        sync ? (client[kNeedDrain] = 1, queueMicrotask(() => emitDrain(client))) : emitDrain(client);
        continue;
      }
      if (client[kPending] === 0 || client[kRunning] >= (getPipelining(client) || 1)) return;
      let request = client[kQueue][client[kPendingIdx]];
      if (client[kUrl].protocol === "https:" && client[kServerName] !== request.servername) {
        if (client[kRunning] > 0) return;
        client[kServerName] = request.servername, (_a = client[kHTTPContext]) == null || _a.destroy(new InformationalError("servername changed"), () => {
          client[kHTTPContext] = null, resume(client);
        });
      }
      if (client[kConnecting]) return;
      if (!client[kHTTPContext]) {
        connect(client);
        return;
      }
      if (client[kHTTPContext].destroyed || client[kHTTPContext].busy(request)) return;
      !request.aborted && client[kHTTPContext].write(request) ? client[kPendingIdx]++ : client[kQueue].splice(client[kPendingIdx], 1);
    }
  }
  __name(_resume, "_resume");
  module.exports = Client;
});