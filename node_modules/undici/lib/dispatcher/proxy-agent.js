var require_proxy_agent = __commonJSMin((exports, module) => {
  "use strict";

  var {
      kProxy: kProxy,
      kClose: kClose,
      kDestroy: kDestroy,
      kInterceptors: kInterceptors
    } = fo(),
    {
      URL: URL
    } = require("url"),
    Agent = aI(),
    Pool = nI(),
    DispatcherBase = Lv(),
    {
      InvalidArgumentError: InvalidArgumentError,
      RequestAbortedError: RequestAbortedError,
      SecureProxyConnectionError: SecureProxyConnectionError
    } = rr(),
    buildConnector = U4(),
    kAgent = Symbol("proxy agent"),
    kClient = Symbol("proxy client"),
    kProxyHeaders = Symbol("proxy headers"),
    kRequestTls = Symbol("request tls settings"),
    kProxyTls = Symbol("proxy tls settings"),
    kConnectEndpoint = Symbol("connect endpoint function");
  function defaultProtocolPort(protocol) {
    return protocol === "https:" ? 443 : 80;
  }
  __name(defaultProtocolPort, "defaultProtocolPort");
  function defaultFactory(origin, opts) {
    return new Pool(origin, opts);
  }
  __name(defaultFactory, "defaultFactory");
  var noop = __name(() => {}, "noop"),
    _ProxyAgent_instances,
    getUrl_fn,
    _ProxyAgent = class _ProxyAgent extends DispatcherBase {
      constructor(opts) {
        var _a;
        super();
        __privateAdd(this, _ProxyAgent_instances);
        if (!opts || typeof opts == "object" && !(opts instanceof URL) && !opts.uri) throw new InvalidArgumentError("Proxy uri is mandatory");
        let {
          clientFactory = defaultFactory
        } = opts;
        if (typeof clientFactory != "function") throw new InvalidArgumentError("Proxy opts.clientFactory must be a function.");
        let url = __privateMethod(this, _ProxyAgent_instances, getUrl_fn).call(this, opts),
          {
            href: href,
            origin: origin,
            port: port,
            protocol: protocol,
            username: username,
            password: password,
            hostname: proxyHostname
          } = url;
        if (this[kProxy] = {
          uri: href,
          protocol: protocol
        }, this[kInterceptors] = (_a = opts.interceptors) != null && _a.ProxyAgent && Array.isArray(opts.interceptors.ProxyAgent) ? opts.interceptors.ProxyAgent : [], this[kRequestTls] = opts.requestTls, this[kProxyTls] = opts.proxyTls, this[kProxyHeaders] = opts.headers || {}, opts.auth && opts.token) throw new InvalidArgumentError("opts.auth cannot be used in combination with opts.token");
        opts.auth ? this[kProxyHeaders]["proxy-authorization"] = `Basic ${opts.auth}` : opts.token ? this[kProxyHeaders]["proxy-authorization"] = opts.token : username && password && (this[kProxyHeaders]["proxy-authorization"] = `Basic ${Buffer.from(`${decodeURIComponent(username)}:${decodeURIComponent(password)}`).toString("base64")}`);
        let connect = buildConnector({
          ...opts.proxyTls
        });
        this[kConnectEndpoint] = buildConnector({
          ...opts.requestTls
        }), this[kClient] = clientFactory(url, {
          connect: connect
        }), this[kAgent] = new Agent({
          ...opts,
          connect: __name(async (opts, callback) => {
            var _a;
            let requestedPath = opts.host;
            opts.port || (requestedPath += `:${defaultProtocolPort(opts.protocol)}`);
            try {
              let {
                socket: socket,
                statusCode: statusCode
              } = await this[kClient].connect({
                origin: origin,
                port: port,
                path: requestedPath,
                signal: opts.signal,
                headers: {
                  ...this[kProxyHeaders],
                  host: opts.host
                },
                servername: ((_a = this[kProxyTls]) == null ? void 0 : _a.servername) || proxyHostname
              });
              if (statusCode !== 200 && (socket.on("error", noop).destroy(), callback(new RequestAbortedError(`Proxy response (${statusCode}) !== 200 when HTTP Tunneling`))), opts.protocol !== "https:") {
                callback(null, socket);
                return;
              }
              let servername;
              this[kRequestTls] ? servername = this[kRequestTls].servername : servername = opts.servername, this[kConnectEndpoint]({
                ...opts,
                servername: servername,
                httpSocket: socket
              }, callback);
            } catch (err) {
              err.code === "ERR_TLS_CERT_ALTNAME_INVALID" ? callback(new SecureProxyConnectionError(err)) : callback(err);
            }
          }, "connect")
        });
      }
      dispatch(opts, handler) {
        let headers = buildHeaders(opts.headers);
        if (throwIfProxyAuthIsSent(headers), headers && !("host" in headers) && !("Host" in headers)) {
          let {
            host: host
          } = new URL(opts.origin);
          headers.host = host;
        }
        return this[kAgent].dispatch({
          ...opts,
          headers: headers
        }, handler);
      }
      async [kClose]() {
        await this[kAgent].close(), await this[kClient].close();
      }
      async [kDestroy]() {
        await this[kAgent].destroy(), await this[kClient].destroy();
      }
    };
  _ProxyAgent_instances = new WeakSet(), getUrl_fn = __name(function (opts) {
    return typeof opts == "string" ? new URL(opts) : opts instanceof URL ? opts : new URL(opts.uri);
  }, "#getUrl"), __name(_ProxyAgent, "ProxyAgent");
  var ProxyAgent = _ProxyAgent;
  function buildHeaders(headers) {
    if (Array.isArray(headers)) {
      let headersPair = {};
      for (let i = 0; i < headers.length; i += 2) headersPair[headers[i]] = headers[i + 1];
      return headersPair;
    }
    return headers;
  }
  __name(buildHeaders, "buildHeaders");
  function throwIfProxyAuthIsSent(headers) {
    if (headers && Object.keys(headers).find(key => key.toLowerCase() === "proxy-authorization")) throw new InvalidArgumentError("Proxy-Authorization should be sent in ProxyAgent constructor");
  }
  __name(throwIfProxyAuthIsSent, "throwIfProxyAuthIsSent");
  module.exports = ProxyAgent;
});