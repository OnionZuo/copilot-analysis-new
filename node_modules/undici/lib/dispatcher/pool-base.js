var require_pool_base = __commonJSMin((exports, module) => {
  "use strict";

  var DispatcherBase = Lv(),
    FixedQueue = rre(),
    {
      kConnected: kConnected,
      kSize: kSize,
      kRunning: kRunning,
      kPending: kPending,
      kQueued: kQueued,
      kBusy: kBusy,
      kFree: kFree,
      kUrl: kUrl,
      kClose: kClose,
      kDestroy: kDestroy,
      kDispatch: kDispatch
    } = fo(),
    PoolStats = BTe(),
    kClients = Symbol("clients"),
    kNeedDrain = Symbol("needDrain"),
    kQueue = Symbol("queue"),
    kClosedResolve = Symbol("closed resolve"),
    kOnDrain = Symbol("onDrain"),
    kOnConnect = Symbol("onConnect"),
    kOnDisconnect = Symbol("onDisconnect"),
    kOnConnectionError = Symbol("onConnectionError"),
    kGetDispatcher = Symbol("get dispatcher"),
    kAddClient = Symbol("add client"),
    kRemoveClient = Symbol("remove client"),
    kStats = Symbol("stats"),
    _PoolBase = class _PoolBase extends DispatcherBase {
      constructor() {
        super(), this[kQueue] = new FixedQueue(), this[kClients] = [], this[kQueued] = 0;
        let pool = this;
        this[kOnDrain] = __name(function (origin, targets) {
          let queue = pool[kQueue],
            needDrain = !1;
          for (; !needDrain;) {
            let item = queue.shift();
            if (!item) break;
            pool[kQueued]--, needDrain = !this.dispatch(item.opts, item.handler);
          }
          this[kNeedDrain] = needDrain, !this[kNeedDrain] && pool[kNeedDrain] && (pool[kNeedDrain] = !1, pool.emit("drain", origin, [pool, ...targets])), pool[kClosedResolve] && queue.isEmpty() && Promise.all(pool[kClients].map(c => c.close())).then(pool[kClosedResolve]);
        }, "onDrain"), this[kOnConnect] = (origin, targets) => {
          pool.emit("connect", origin, [pool, ...targets]);
        }, this[kOnDisconnect] = (origin, targets, err) => {
          pool.emit("disconnect", origin, [pool, ...targets], err);
        }, this[kOnConnectionError] = (origin, targets, err) => {
          pool.emit("connectionError", origin, [pool, ...targets], err);
        }, this[kStats] = new PoolStats(this);
      }
      get [kBusy]() {
        return this[kNeedDrain];
      }
      get [kConnected]() {
        return this[kClients].filter(client => client[kConnected]).length;
      }
      get [kFree]() {
        return this[kClients].filter(client => client[kConnected] && !client[kNeedDrain]).length;
      }
      get [kPending]() {
        let ret = this[kQueued];
        for (let {
          [kPending]: pending
        } of this[kClients]) ret += pending;
        return ret;
      }
      get [kRunning]() {
        let ret = 0;
        for (let {
          [kRunning]: running
        } of this[kClients]) ret += running;
        return ret;
      }
      get [kSize]() {
        let ret = this[kQueued];
        for (let {
          [kSize]: size
        } of this[kClients]) ret += size;
        return ret;
      }
      get stats() {
        return this[kStats];
      }
      async [kClose]() {
        this[kQueue].isEmpty() ? await Promise.all(this[kClients].map(c => c.close())) : await new Promise(resolve => {
          this[kClosedResolve] = resolve;
        });
      }
      async [kDestroy](err) {
        for (;;) {
          let item = this[kQueue].shift();
          if (!item) break;
          item.handler.onError(err);
        }
        await Promise.all(this[kClients].map(c => c.destroy(err)));
      }
      [kDispatch](opts, handler) {
        let dispatcher = this[kGetDispatcher]();
        return dispatcher ? dispatcher.dispatch(opts, handler) || (dispatcher[kNeedDrain] = !0, this[kNeedDrain] = !this[kGetDispatcher]()) : (this[kNeedDrain] = !0, this[kQueue].push({
          opts: opts,
          handler: handler
        }), this[kQueued]++), !this[kNeedDrain];
      }
      [kAddClient](client) {
        return client.on("drain", this[kOnDrain]).on("connect", this[kOnConnect]).on("disconnect", this[kOnDisconnect]).on("connectionError", this[kOnConnectionError]), this[kClients].push(client), this[kNeedDrain] && queueMicrotask(() => {
          this[kNeedDrain] && this[kOnDrain](client[kUrl], [this, client]);
        }), this;
      }
      [kRemoveClient](client) {
        client.close(() => {
          let idx = this[kClients].indexOf(client);
          idx !== -1 && this[kClients].splice(idx, 1);
        }), this[kNeedDrain] = this[kClients].some(dispatcher => !dispatcher[kNeedDrain] && dispatcher.closed !== !0 && dispatcher.destroyed !== !0);
      }
    };
  __name(_PoolBase, "PoolBase");
  var PoolBase = _PoolBase;
  module.exports = {
    PoolBase: PoolBase,
    kClients: kClients,
    kNeedDrain: kNeedDrain,
    kAddClient: kAddClient,
    kRemoveClient: kRemoveClient,
    kGetDispatcher: kGetDispatcher
  };
});