var require_env_http_proxy_agent = __commonJSMin((exports, module) => {
  "use strict";

  var DispatcherBase = Lv(),
    {
      kClose: kClose,
      kDestroy: kDestroy,
      kClosed: kClosed,
      kDestroyed: kDestroyed,
      kDispatch: kDispatch,
      kNoProxyAgent: kNoProxyAgent,
      kHttpProxyAgent: kHttpProxyAgent,
      kHttpsProxyAgent: kHttpsProxyAgent
    } = fo(),
    ProxyAgent = Qre(),
    Agent = aI(),
    DEFAULT_PORTS = {
      "http:": 80,
      "https:": 443
    },
    experimentalWarned = !1,
    _noProxyValue,
    _noProxyEntries,
    _opts,
    _EnvHttpProxyAgent_instances,
    getProxyAgentForUrl_fn,
    shouldProxy_fn,
    parseNoProxy_fn,
    noProxyChanged_get,
    noProxyEnv_get,
    _EnvHttpProxyAgent = class _EnvHttpProxyAgent extends DispatcherBase {
      constructor(opts = {}) {
        var _a, _b;
        super();
        __privateAdd(this, _EnvHttpProxyAgent_instances);
        __privateAdd(this, _noProxyValue, null);
        __privateAdd(this, _noProxyEntries, null);
        __privateAdd(this, _opts, null);
        __privateSet(this, _opts, opts), experimentalWarned || (experimentalWarned = !0, process.emitWarning("EnvHttpProxyAgent is experimental, expect them to change at any time.", {
          code: "UNDICI-EHPA"
        }));
        let {
          httpProxy: httpProxy,
          httpsProxy: httpsProxy,
          noProxy: noProxy,
          ...agentOpts
        } = opts;
        this[kNoProxyAgent] = new Agent(agentOpts);
        let HTTP_PROXY = (_a = httpProxy != null ? httpProxy : process.env.http_proxy) != null ? _a : process.env.HTTP_PROXY;
        HTTP_PROXY ? this[kHttpProxyAgent] = new ProxyAgent({
          ...agentOpts,
          uri: HTTP_PROXY
        }) : this[kHttpProxyAgent] = this[kNoProxyAgent];
        let HTTPS_PROXY = (_b = httpsProxy != null ? httpsProxy : process.env.https_proxy) != null ? _b : process.env.HTTPS_PROXY;
        HTTPS_PROXY ? this[kHttpsProxyAgent] = new ProxyAgent({
          ...agentOpts,
          uri: HTTPS_PROXY
        }) : this[kHttpsProxyAgent] = this[kHttpProxyAgent], __privateMethod(this, _EnvHttpProxyAgent_instances, parseNoProxy_fn).call(this);
      }
      [kDispatch](opts, handler) {
        let url = new URL(opts.origin);
        return __privateMethod(this, _EnvHttpProxyAgent_instances, getProxyAgentForUrl_fn).call(this, url).dispatch(opts, handler);
      }
      async [kClose]() {
        await this[kNoProxyAgent].close(), this[kHttpProxyAgent][kClosed] || (await this[kHttpProxyAgent].close()), this[kHttpsProxyAgent][kClosed] || (await this[kHttpsProxyAgent].close());
      }
      async [kDestroy](err) {
        await this[kNoProxyAgent].destroy(err), this[kHttpProxyAgent][kDestroyed] || (await this[kHttpProxyAgent].destroy(err)), this[kHttpsProxyAgent][kDestroyed] || (await this[kHttpsProxyAgent].destroy(err));
      }
    };
  _noProxyValue = new WeakMap(), _noProxyEntries = new WeakMap(), _opts = new WeakMap(), _EnvHttpProxyAgent_instances = new WeakSet(), getProxyAgentForUrl_fn = __name(function (url) {
    let {
      protocol: protocol,
      host: hostname,
      port: port
    } = url;
    return hostname = hostname.replace(/:\d*$/, "").toLowerCase(), port = Number.parseInt(port, 10) || DEFAULT_PORTS[protocol] || 0, __privateMethod(this, _EnvHttpProxyAgent_instances, shouldProxy_fn).call(this, hostname, port) ? protocol === "https:" ? this[kHttpsProxyAgent] : this[kHttpProxyAgent] : this[kNoProxyAgent];
  }, "#getProxyAgentForUrl"), shouldProxy_fn = __name(function (hostname, port) {
    if (__privateGet(this, _EnvHttpProxyAgent_instances, noProxyChanged_get) && __privateMethod(this, _EnvHttpProxyAgent_instances, parseNoProxy_fn).call(this), __privateGet(this, _noProxyEntries).length === 0) return !0;
    if (__privateGet(this, _noProxyValue) === "*") return !1;
    for (let i = 0; i < __privateGet(this, _noProxyEntries).length; i++) {
      let entry = __privateGet(this, _noProxyEntries)[i];
      if (!(entry.port && entry.port !== port)) {
        if (/^[.*]/.test(entry.hostname)) {
          if (hostname.endsWith(entry.hostname.replace(/^\*/, ""))) return !1;
        } else if (hostname === entry.hostname) return !1;
      }
    }
    return !0;
  }, "#shouldProxy"), parseNoProxy_fn = __name(function () {
    var _a;
    let noProxyValue = (_a = __privateGet(this, _opts).noProxy) != null ? _a : __privateGet(this, _EnvHttpProxyAgent_instances, noProxyEnv_get),
      noProxySplit = noProxyValue.split(/[,\s]/),
      noProxyEntries = [];
    for (let i = 0; i < noProxySplit.length; i++) {
      let entry = noProxySplit[i];
      if (!entry) continue;
      let parsed = entry.match(/^(.+):(\d+)$/);
      noProxyEntries.push({
        hostname: (parsed ? parsed[1] : entry).toLowerCase(),
        port: parsed ? Number.parseInt(parsed[2], 10) : 0
      });
    }
    __privateSet(this, _noProxyValue, noProxyValue), __privateSet(this, _noProxyEntries, noProxyEntries);
  }, "#parseNoProxy"), noProxyChanged_get = __name(function () {
    return __privateGet(this, _opts).noProxy !== void 0 ? !1 : __privateGet(this, _noProxyValue) !== __privateGet(this, _EnvHttpProxyAgent_instances, noProxyEnv_get);
  }, "#noProxyChanged"), noProxyEnv_get = __name(function () {
    var _a, _b;
    return (_b = (_a = process.env.no_proxy) != null ? _a : process.env.NO_PROXY) != null ? _b : "";
  }, "#noProxyEnv"), __name(_EnvHttpProxyAgent, "EnvHttpProxyAgent");
  var EnvHttpProxyAgent = _EnvHttpProxyAgent;
  module.exports = EnvHttpProxyAgent;
});