var require_agent = __commonJSMin((exports, module) => {
  "use strict";

  var {
      InvalidArgumentError: InvalidArgumentError
    } = rr(),
    {
      kClients: kClients,
      kRunning: kRunning,
      kClose: kClose,
      kDestroy: kDestroy,
      kDispatch: kDispatch,
      kInterceptors: kInterceptors
    } = fo(),
    DispatcherBase = Lv(),
    Pool = nI(),
    Client = l9(),
    util = oi(),
    createRedirectInterceptor = _M(),
    kOnConnect = Symbol("onConnect"),
    kOnDisconnect = Symbol("onDisconnect"),
    kOnConnectionError = Symbol("onConnectionError"),
    kMaxRedirections = Symbol("maxRedirections"),
    kOnDrain = Symbol("onDrain"),
    kFactory = Symbol("factory"),
    kOptions = Symbol("options");
  function defaultFactory(origin, opts) {
    return opts && opts.connections === 1 ? new Client(origin, opts) : new Pool(origin, opts);
  }
  __name(defaultFactory, "defaultFactory");
  var _Agent = class _Agent extends DispatcherBase {
    constructor({
      factory = defaultFactory,
      maxRedirections = 0,
      connect: connect,
      ...options
    } = {}) {
      var _a;
      if (super(), typeof factory != "function") throw new InvalidArgumentError("factory must be a function.");
      if (connect != null && typeof connect != "function" && typeof connect != "object") throw new InvalidArgumentError("connect must be a function or an object");
      if (!Number.isInteger(maxRedirections) || maxRedirections < 0) throw new InvalidArgumentError("maxRedirections must be a positive number");
      connect && typeof connect != "function" && (connect = {
        ...connect
      }), this[kInterceptors] = (_a = options.interceptors) != null && _a.Agent && Array.isArray(options.interceptors.Agent) ? options.interceptors.Agent : [createRedirectInterceptor({
        maxRedirections: maxRedirections
      })], this[kOptions] = {
        ...util.deepClone(options),
        connect: connect
      }, this[kOptions].interceptors = options.interceptors ? {
        ...options.interceptors
      } : void 0, this[kMaxRedirections] = maxRedirections, this[kFactory] = factory, this[kClients] = new Map(), this[kOnDrain] = (origin, targets) => {
        this.emit("drain", origin, [this, ...targets]);
      }, this[kOnConnect] = (origin, targets) => {
        this.emit("connect", origin, [this, ...targets]);
      }, this[kOnDisconnect] = (origin, targets, err) => {
        this.emit("disconnect", origin, [this, ...targets], err);
      }, this[kOnConnectionError] = (origin, targets, err) => {
        this.emit("connectionError", origin, [this, ...targets], err);
      };
    }
    get [kRunning]() {
      let ret = 0;
      for (let client of this[kClients].values()) ret += client[kRunning];
      return ret;
    }
    [kDispatch](opts, handler) {
      let key;
      if (opts.origin && (typeof opts.origin == "string" || opts.origin instanceof URL)) key = String(opts.origin);else throw new InvalidArgumentError("opts.origin must be a non-empty string or URL.");
      let dispatcher = this[kClients].get(key);
      return dispatcher || (dispatcher = this[kFactory](opts.origin, this[kOptions]).on("drain", this[kOnDrain]).on("connect", this[kOnConnect]).on("disconnect", this[kOnDisconnect]).on("connectionError", this[kOnConnectionError]), this[kClients].set(key, dispatcher)), dispatcher.dispatch(opts, handler);
    }
    async [kClose]() {
      let closePromises = [];
      for (let client of this[kClients].values()) closePromises.push(client.close());
      this[kClients].clear(), await Promise.all(closePromises);
    }
    async [kDestroy](err) {
      let destroyPromises = [];
      for (let client of this[kClients].values()) destroyPromises.push(client.destroy(err));
      this[kClients].clear(), await Promise.all(destroyPromises);
    }
  };
  __name(_Agent, "Agent");
  var Agent = _Agent;
  module.exports = Agent;
});