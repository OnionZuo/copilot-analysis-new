var require_client_h1 = __commonJSMin((exports, module) => {
  "use strict";

  var assert = require("assert"),
    util = oi(),
    {
      channels: channels
    } = Sv(),
    timers = Aie(),
    {
      RequestContentLengthMismatchError: RequestContentLengthMismatchError,
      ResponseContentLengthMismatchError: ResponseContentLengthMismatchError,
      RequestAbortedError: RequestAbortedError,
      HeadersTimeoutError: HeadersTimeoutError,
      HeadersOverflowError: HeadersOverflowError,
      SocketError: SocketError,
      InformationalError: InformationalError,
      BodyTimeoutError: BodyTimeoutError,
      HTTPParserError: HTTPParserError,
      ResponseExceededMaxSizeError: ResponseExceededMaxSizeError
    } = rr(),
    {
      kUrl: kUrl,
      kReset: kReset,
      kClient: kClient,
      kParser: kParser,
      kBlocking: kBlocking,
      kRunning: kRunning,
      kPending: kPending,
      kSize: kSize,
      kWriting: kWriting,
      kQueue: kQueue,
      kNoRef: kNoRef,
      kKeepAliveDefaultTimeout: kKeepAliveDefaultTimeout,
      kHostHeader: kHostHeader,
      kPendingIdx: kPendingIdx,
      kRunningIdx: kRunningIdx,
      kError: kError,
      kPipelining: kPipelining,
      kSocket: kSocket,
      kKeepAliveTimeoutValue: kKeepAliveTimeoutValue,
      kMaxHeadersSize: kMaxHeadersSize,
      kKeepAliveMaxTimeout: kKeepAliveMaxTimeout,
      kKeepAliveTimeoutThreshold: kKeepAliveTimeoutThreshold,
      kHeadersTimeout: kHeadersTimeout,
      kBodyTimeout: kBodyTimeout,
      kStrictContentLength: kStrictContentLength,
      kMaxRequests: kMaxRequests,
      kCounter: kCounter,
      kMaxResponseSize: kMaxResponseSize,
      kOnError: kOnError,
      kResume: kResume,
      kHTTPContext: kHTTPContext
    } = fo(),
    constants = jFe(),
    EMPTY_BUF = Buffer.alloc(0),
    FastBuffer = Buffer[Symbol.species],
    addListener = util.addListener,
    removeAllListeners = util.removeAllListeners,
    extractBody;
  async function lazyllhttp() {
    let llhttpWasmData = process.env.JEST_WORKER_ID ? pie() : void 0,
      mod;
    try {
      mod = await WebAssembly.compile(GFe());
    } catch {
      mod = await WebAssembly.compile(llhttpWasmData || pie());
    }
    return await WebAssembly.instantiate(mod, {
      env: {
        wasm_on_url: __name((p, at, len) => 0, "wasm_on_url"),
        wasm_on_status: __name((p, at, len) => {
          assert(currentParser.ptr === p);
          let start = at - currentBufferPtr + currentBufferRef.byteOffset;
          return currentParser.onStatus(new FastBuffer(currentBufferRef.buffer, start, len)) || 0;
        }, "wasm_on_status"),
        wasm_on_message_begin: __name(p => (assert(currentParser.ptr === p), currentParser.onMessageBegin() || 0), "wasm_on_message_begin"),
        wasm_on_header_field: __name((p, at, len) => {
          assert(currentParser.ptr === p);
          let start = at - currentBufferPtr + currentBufferRef.byteOffset;
          return currentParser.onHeaderField(new FastBuffer(currentBufferRef.buffer, start, len)) || 0;
        }, "wasm_on_header_field"),
        wasm_on_header_value: __name((p, at, len) => {
          assert(currentParser.ptr === p);
          let start = at - currentBufferPtr + currentBufferRef.byteOffset;
          return currentParser.onHeaderValue(new FastBuffer(currentBufferRef.buffer, start, len)) || 0;
        }, "wasm_on_header_value"),
        wasm_on_headers_complete: __name((p, statusCode, upgrade, shouldKeepAlive) => (assert(currentParser.ptr === p), currentParser.onHeadersComplete(statusCode, !!upgrade, !!shouldKeepAlive) || 0), "wasm_on_headers_complete"),
        wasm_on_body: __name((p, at, len) => {
          assert(currentParser.ptr === p);
          let start = at - currentBufferPtr + currentBufferRef.byteOffset;
          return currentParser.onBody(new FastBuffer(currentBufferRef.buffer, start, len)) || 0;
        }, "wasm_on_body"),
        wasm_on_message_complete: __name(p => (assert(currentParser.ptr === p), currentParser.onMessageComplete() || 0), "wasm_on_message_complete")
      }
    });
  }
  __name(lazyllhttp, "lazyllhttp");
  var llhttpInstance = null,
    llhttpPromise = lazyllhttp();
  llhttpPromise.catch();
  var currentParser = null,
    currentBufferRef = null,
    currentBufferSize = 0,
    currentBufferPtr = null,
    USE_NATIVE_TIMER = 0,
    USE_FAST_TIMER = 1,
    TIMEOUT_HEADERS = 2 | USE_FAST_TIMER,
    TIMEOUT_BODY = 4 | USE_FAST_TIMER,
    TIMEOUT_KEEP_ALIVE = 8 | USE_NATIVE_TIMER,
    _Parser = class _Parser {
      constructor(client, socket, {
        exports: exports
      }) {
        assert(Number.isFinite(client[kMaxHeadersSize]) && client[kMaxHeadersSize] > 0), this.llhttp = exports, this.ptr = this.llhttp.llhttp_alloc(constants.TYPE.RESPONSE), this.client = client, this.socket = socket, this.timeout = null, this.timeoutValue = null, this.timeoutType = null, this.statusCode = null, this.statusText = "", this.upgrade = !1, this.headers = [], this.headersSize = 0, this.headersMaxSize = client[kMaxHeadersSize], this.shouldKeepAlive = !1, this.paused = !1, this.resume = this.resume.bind(this), this.bytesRead = 0, this.keepAlive = "", this.contentLength = "", this.connection = "", this.maxResponseSize = client[kMaxResponseSize];
      }
      setTimeout(delay, type) {
        delay !== this.timeoutValue || type & USE_FAST_TIMER ^ this.timeoutType & USE_FAST_TIMER ? (this.timeout && (timers.clearTimeout(this.timeout), this.timeout = null), delay && (type & USE_FAST_TIMER ? this.timeout = timers.setFastTimeout(onParserTimeout, delay, new WeakRef(this)) : (this.timeout = setTimeout(onParserTimeout, delay, new WeakRef(this)), this.timeout.unref())), this.timeoutValue = delay) : this.timeout && this.timeout.refresh && this.timeout.refresh(), this.timeoutType = type;
      }
      resume() {
        this.socket.destroyed || !this.paused || (assert(this.ptr != null), assert(currentParser == null), this.llhttp.llhttp_resume(this.ptr), assert(this.timeoutType === TIMEOUT_BODY), this.timeout && this.timeout.refresh && this.timeout.refresh(), this.paused = !1, this.execute(this.socket.read() || EMPTY_BUF), this.readMore());
      }
      readMore() {
        for (; !this.paused && this.ptr;) {
          let chunk = this.socket.read();
          if (chunk === null) break;
          this.execute(chunk);
        }
      }
      execute(data) {
        assert(this.ptr != null), assert(currentParser == null), assert(!this.paused);
        let {
          socket: socket,
          llhttp: llhttp
        } = this;
        data.length > currentBufferSize && (currentBufferPtr && llhttp.free(currentBufferPtr), currentBufferSize = Math.ceil(data.length / 4096) * 4096, currentBufferPtr = llhttp.malloc(currentBufferSize)), new Uint8Array(llhttp.memory.buffer, currentBufferPtr, currentBufferSize).set(data);
        try {
          let ret;
          try {
            currentBufferRef = data, currentParser = this, ret = llhttp.llhttp_execute(this.ptr, currentBufferPtr, data.length);
          } catch (err) {
            throw err;
          } finally {
            currentParser = null, currentBufferRef = null;
          }
          let offset = llhttp.llhttp_get_error_pos(this.ptr) - currentBufferPtr;
          if (ret === constants.ERROR.PAUSED_UPGRADE) this.onUpgrade(data.slice(offset));else if (ret === constants.ERROR.PAUSED) this.paused = !0, socket.unshift(data.slice(offset));else if (ret !== constants.ERROR.OK) {
            let ptr = llhttp.llhttp_get_error_reason(this.ptr),
              message = "";
            if (ptr) {
              let len = new Uint8Array(llhttp.memory.buffer, ptr).indexOf(0);
              message = "Response does not match the HTTP/1.1 protocol (" + Buffer.from(llhttp.memory.buffer, ptr, len).toString() + ")";
            }
            throw new HTTPParserError(message, constants.ERROR[ret], data.slice(offset));
          }
        } catch (err) {
          util.destroy(socket, err);
        }
      }
      destroy() {
        assert(this.ptr != null), assert(currentParser == null), this.llhttp.llhttp_free(this.ptr), this.ptr = null, this.timeout && timers.clearTimeout(this.timeout), this.timeout = null, this.timeoutValue = null, this.timeoutType = null, this.paused = !1;
      }
      onStatus(buf) {
        this.statusText = buf.toString();
      }
      onMessageBegin() {
        let {
          socket: socket,
          client: client
        } = this;
        if (socket.destroyed) return -1;
        let request = client[kQueue][client[kRunningIdx]];
        if (!request) return -1;
        request.onResponseStarted();
      }
      onHeaderField(buf) {
        let len = this.headers.length;
        (len & 1) === 0 ? this.headers.push(buf) : this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf]), this.trackHeader(buf.length);
      }
      onHeaderValue(buf) {
        let len = this.headers.length;
        (len & 1) === 1 ? (this.headers.push(buf), len += 1) : this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf]);
        let key = this.headers[len - 2];
        if (key.length === 10) {
          let headerName = util.bufferToLowerCasedHeaderName(key);
          headerName === "keep-alive" ? this.keepAlive += buf.toString() : headerName === "connection" && (this.connection += buf.toString());
        } else key.length === 14 && util.bufferToLowerCasedHeaderName(key) === "content-length" && (this.contentLength += buf.toString());
        this.trackHeader(buf.length);
      }
      trackHeader(len) {
        this.headersSize += len, this.headersSize >= this.headersMaxSize && util.destroy(this.socket, new HeadersOverflowError());
      }
      onUpgrade(head) {
        let {
          upgrade: upgrade,
          client: client,
          socket: socket,
          headers: headers,
          statusCode: statusCode
        } = this;
        assert(upgrade), assert(client[kSocket] === socket), assert(!socket.destroyed), assert(!this.paused), assert((headers.length & 1) === 0);
        let request = client[kQueue][client[kRunningIdx]];
        assert(request), assert(request.upgrade || request.method === "CONNECT"), this.statusCode = null, this.statusText = "", this.shouldKeepAlive = null, this.headers = [], this.headersSize = 0, socket.unshift(head), socket[kParser].destroy(), socket[kParser] = null, socket[kClient] = null, socket[kError] = null, removeAllListeners(socket), client[kSocket] = null, client[kHTTPContext] = null, client[kQueue][client[kRunningIdx]++] = null, client.emit("disconnect", client[kUrl], [client], new InformationalError("upgrade"));
        try {
          request.onUpgrade(statusCode, headers, socket);
        } catch (err) {
          util.destroy(socket, err);
        }
        client[kResume]();
      }
      onHeadersComplete(statusCode, upgrade, shouldKeepAlive) {
        let {
          client: client,
          socket: socket,
          headers: headers,
          statusText: statusText
        } = this;
        if (socket.destroyed) return -1;
        let request = client[kQueue][client[kRunningIdx]];
        if (!request) return -1;
        if (assert(!this.upgrade), assert(this.statusCode < 200), statusCode === 100) return util.destroy(socket, new SocketError("bad response", util.getSocketInfo(socket))), -1;
        if (upgrade && !request.upgrade) return util.destroy(socket, new SocketError("bad upgrade", util.getSocketInfo(socket))), -1;
        if (assert(this.timeoutType === TIMEOUT_HEADERS), this.statusCode = statusCode, this.shouldKeepAlive = shouldKeepAlive || request.method === "HEAD" && !socket[kReset] && this.connection.toLowerCase() === "keep-alive", this.statusCode >= 200) {
          let bodyTimeout = request.bodyTimeout != null ? request.bodyTimeout : client[kBodyTimeout];
          this.setTimeout(bodyTimeout, TIMEOUT_BODY);
        } else this.timeout && this.timeout.refresh && this.timeout.refresh();
        if (request.method === "CONNECT") return assert(client[kRunning] === 1), this.upgrade = !0, 2;
        if (upgrade) return assert(client[kRunning] === 1), this.upgrade = !0, 2;
        if (assert((this.headers.length & 1) === 0), this.headers = [], this.headersSize = 0, this.shouldKeepAlive && client[kPipelining]) {
          let keepAliveTimeout = this.keepAlive ? util.parseKeepAliveTimeout(this.keepAlive) : null;
          if (keepAliveTimeout != null) {
            let timeout = Math.min(keepAliveTimeout - client[kKeepAliveTimeoutThreshold], client[kKeepAliveMaxTimeout]);
            timeout <= 0 ? socket[kReset] = !0 : client[kKeepAliveTimeoutValue] = timeout;
          } else client[kKeepAliveTimeoutValue] = client[kKeepAliveDefaultTimeout];
        } else socket[kReset] = !0;
        let pause = request.onHeaders(statusCode, headers, this.resume, statusText) === !1;
        return request.aborted ? -1 : request.method === "HEAD" || statusCode < 200 ? 1 : (socket[kBlocking] && (socket[kBlocking] = !1, client[kResume]()), pause ? constants.ERROR.PAUSED : 0);
      }
      onBody(buf) {
        let {
          client: client,
          socket: socket,
          statusCode: statusCode,
          maxResponseSize: maxResponseSize
        } = this;
        if (socket.destroyed) return -1;
        let request = client[kQueue][client[kRunningIdx]];
        if (assert(request), assert(this.timeoutType === TIMEOUT_BODY), this.timeout && this.timeout.refresh && this.timeout.refresh(), assert(statusCode >= 200), maxResponseSize > -1 && this.bytesRead + buf.length > maxResponseSize) return util.destroy(socket, new ResponseExceededMaxSizeError()), -1;
        if (this.bytesRead += buf.length, request.onData(buf) === !1) return constants.ERROR.PAUSED;
      }
      onMessageComplete() {
        let {
          client: client,
          socket: socket,
          statusCode: statusCode,
          upgrade: upgrade,
          headers: headers,
          contentLength: contentLength,
          bytesRead: bytesRead,
          shouldKeepAlive: shouldKeepAlive
        } = this;
        if (socket.destroyed && (!statusCode || shouldKeepAlive)) return -1;
        if (upgrade) return;
        assert(statusCode >= 100), assert((this.headers.length & 1) === 0);
        let request = client[kQueue][client[kRunningIdx]];
        if (assert(request), this.statusCode = null, this.statusText = "", this.bytesRead = 0, this.contentLength = "", this.keepAlive = "", this.connection = "", this.headers = [], this.headersSize = 0, !(statusCode < 200)) {
          if (request.method !== "HEAD" && contentLength && bytesRead !== parseInt(contentLength, 10)) return util.destroy(socket, new ResponseContentLengthMismatchError()), -1;
          if (request.onComplete(headers), client[kQueue][client[kRunningIdx]++] = null, socket[kWriting]) return assert(client[kRunning] === 0), util.destroy(socket, new InformationalError("reset")), constants.ERROR.PAUSED;
          if (shouldKeepAlive) {
            if (socket[kReset] && client[kRunning] === 0) return util.destroy(socket, new InformationalError("reset")), constants.ERROR.PAUSED;
            client[kPipelining] == null || client[kPipelining] === 1 ? setImmediate(() => client[kResume]()) : client[kResume]();
          } else return util.destroy(socket, new InformationalError("reset")), constants.ERROR.PAUSED;
        }
      }
    };
  __name(_Parser, "Parser");
  var Parser = _Parser;
  function onParserTimeout(parser) {
    let {
      socket: socket,
      timeoutType: timeoutType,
      client: client,
      paused: paused
    } = parser.deref();
    timeoutType === TIMEOUT_HEADERS ? (!socket[kWriting] || socket.writableNeedDrain || client[kRunning] > 1) && (assert(!paused, "cannot be paused while waiting for headers"), util.destroy(socket, new HeadersTimeoutError())) : timeoutType === TIMEOUT_BODY ? paused || util.destroy(socket, new BodyTimeoutError()) : timeoutType === TIMEOUT_KEEP_ALIVE && (assert(client[kRunning] === 0 && client[kKeepAliveTimeoutValue]), util.destroy(socket, new InformationalError("socket idle timeout")));
  }
  __name(onParserTimeout, "onParserTimeout");
  async function connectH1(client, socket) {
    client[kSocket] = socket, llhttpInstance || (llhttpInstance = await llhttpPromise, llhttpPromise = null), socket[kNoRef] = !1, socket[kWriting] = !1, socket[kReset] = !1, socket[kBlocking] = !1, socket[kParser] = new Parser(client, socket, llhttpInstance), addListener(socket, "error", function (err) {
      assert(err.code !== "ERR_TLS_CERT_ALTNAME_INVALID");
      let parser = this[kParser];
      if (err.code === "ECONNRESET" && parser.statusCode && !parser.shouldKeepAlive) {
        parser.onMessageComplete();
        return;
      }
      this[kError] = err, this[kClient][kOnError](err);
    }), addListener(socket, "readable", function () {
      let parser = this[kParser];
      parser && parser.readMore();
    }), addListener(socket, "end", function () {
      let parser = this[kParser];
      if (parser.statusCode && !parser.shouldKeepAlive) {
        parser.onMessageComplete();
        return;
      }
      util.destroy(this, new SocketError("other side closed", util.getSocketInfo(this)));
    }), addListener(socket, "close", function () {
      let client = this[kClient],
        parser = this[kParser];
      parser && (!this[kError] && parser.statusCode && !parser.shouldKeepAlive && parser.onMessageComplete(), this[kParser].destroy(), this[kParser] = null);
      let err = this[kError] || new SocketError("closed", util.getSocketInfo(this));
      if (client[kSocket] = null, client[kHTTPContext] = null, client.destroyed) {
        assert(client[kPending] === 0);
        let requests = client[kQueue].splice(client[kRunningIdx]);
        for (let i = 0; i < requests.length; i++) {
          let request = requests[i];
          util.errorRequest(client, request, err);
        }
      } else if (client[kRunning] > 0 && err.code !== "UND_ERR_INFO") {
        let request = client[kQueue][client[kRunningIdx]];
        client[kQueue][client[kRunningIdx]++] = null, util.errorRequest(client, request, err);
      }
      client[kPendingIdx] = client[kRunningIdx], assert(client[kRunning] === 0), client.emit("disconnect", client[kUrl], [client], err), client[kResume]();
    });
    let closed = !1;
    return socket.on("close", () => {
      closed = !0;
    }), {
      version: "h1",
      defaultPipelining: 1,
      write(...args) {
        return writeH1(client, ...args);
      },
      resume() {
        resumeH1(client);
      },
      destroy(err, callback) {
        closed ? queueMicrotask(callback) : socket.destroy(err).on("close", callback);
      },
      get destroyed() {
        return socket.destroyed;
      },
      busy(request) {
        return !!(socket[kWriting] || socket[kReset] || socket[kBlocking] || request && (client[kRunning] > 0 && !request.idempotent || client[kRunning] > 0 && (request.upgrade || request.method === "CONNECT") || client[kRunning] > 0 && util.bodyLength(request.body) !== 0 && (util.isStream(request.body) || util.isAsyncIterable(request.body) || util.isFormDataLike(request.body))));
      }
    };
  }
  __name(connectH1, "connectH1");
  function resumeH1(client) {
    let socket = client[kSocket];
    if (socket && !socket.destroyed) {
      if (client[kSize] === 0 ? !socket[kNoRef] && socket.unref && (socket.unref(), socket[kNoRef] = !0) : socket[kNoRef] && socket.ref && (socket.ref(), socket[kNoRef] = !1), client[kSize] === 0) socket[kParser].timeoutType !== TIMEOUT_KEEP_ALIVE && socket[kParser].setTimeout(client[kKeepAliveTimeoutValue], TIMEOUT_KEEP_ALIVE);else if (client[kRunning] > 0 && socket[kParser].statusCode < 200 && socket[kParser].timeoutType !== TIMEOUT_HEADERS) {
        let request = client[kQueue][client[kRunningIdx]],
          headersTimeout = request.headersTimeout != null ? request.headersTimeout : client[kHeadersTimeout];
        socket[kParser].setTimeout(headersTimeout, TIMEOUT_HEADERS);
      }
    }
  }
  __name(resumeH1, "resumeH1");
  function shouldSendContentLength(method) {
    return method !== "GET" && method !== "HEAD" && method !== "OPTIONS" && method !== "TRACE" && method !== "CONNECT";
  }
  __name(shouldSendContentLength, "shouldSendContentLength");
  function writeH1(client, request) {
    let {
        method: method,
        path: path,
        host: host,
        upgrade: upgrade,
        blocking: blocking,
        reset: reset
      } = request,
      {
        body: body,
        headers: headers,
        contentLength: contentLength
      } = request,
      expectsPayload = method === "PUT" || method === "POST" || method === "PATCH" || method === "QUERY" || method === "PROPFIND" || method === "PROPPATCH";
    if (util.isFormDataLike(body)) {
      extractBody || (extractBody = Wv().extractBody);
      let [bodyStream, contentType] = extractBody(body);
      request.contentType == null && headers.push("content-type", contentType), body = bodyStream.stream, contentLength = bodyStream.length;
    } else util.isBlobLike(body) && request.contentType == null && body.type && headers.push("content-type", body.type);
    body && typeof body.read == "function" && body.read(0);
    let bodyLength = util.bodyLength(body);
    if (contentLength = bodyLength != null ? bodyLength : contentLength, contentLength === null && (contentLength = request.contentLength), contentLength === 0 && !expectsPayload && (contentLength = null), shouldSendContentLength(method) && contentLength > 0 && request.contentLength !== null && request.contentLength !== contentLength) {
      if (client[kStrictContentLength]) return util.errorRequest(client, request, new RequestContentLengthMismatchError()), !1;
      process.emitWarning(new RequestContentLengthMismatchError());
    }
    let socket = client[kSocket],
      abort = __name(err => {
        request.aborted || request.completed || (util.errorRequest(client, request, err || new RequestAbortedError()), util.destroy(body), util.destroy(socket, new InformationalError("aborted")));
      }, "abort");
    try {
      request.onConnect(abort);
    } catch (err) {
      util.errorRequest(client, request, err);
    }
    if (request.aborted) return !1;
    method === "HEAD" && (socket[kReset] = !0), (upgrade || method === "CONNECT") && (socket[kReset] = !0), reset != null && (socket[kReset] = reset), client[kMaxRequests] && socket[kCounter]++ >= client[kMaxRequests] && (socket[kReset] = !0), blocking && (socket[kBlocking] = !0);
    let header = `${method} ${path} HTTP/1.1\r
`;
    if (typeof host == "string" ? header += `host: ${host}\r
` : header += client[kHostHeader], upgrade ? header += `connection: upgrade\r
upgrade: ${upgrade}\r
` : client[kPipelining] && !socket[kReset] ? header += `connection: keep-alive\r
` : header += `connection: close\r
`, Array.isArray(headers)) for (let n = 0; n < headers.length; n += 2) {
      let key = headers[n + 0],
        val = headers[n + 1];
      if (Array.isArray(val)) for (let i = 0; i < val.length; i++) header += `${key}: ${val[i]}\r
`;else header += `${key}: ${val}\r
`;
    }
    return channels.sendHeaders.hasSubscribers && channels.sendHeaders.publish({
      request: request,
      headers: header,
      socket: socket
    }), !body || bodyLength === 0 ? writeBuffer(abort, null, client, request, socket, contentLength, header, expectsPayload) : util.isBuffer(body) ? writeBuffer(abort, body, client, request, socket, contentLength, header, expectsPayload) : util.isBlobLike(body) ? typeof body.stream == "function" ? writeIterable(abort, body.stream(), client, request, socket, contentLength, header, expectsPayload) : writeBlob(abort, body, client, request, socket, contentLength, header, expectsPayload) : util.isStream(body) ? writeStream(abort, body, client, request, socket, contentLength, header, expectsPayload) : util.isIterable(body) ? writeIterable(abort, body, client, request, socket, contentLength, header, expectsPayload) : assert(!1), !0;
  }
  __name(writeH1, "writeH1");
  function writeStream(abort, body, client, request, socket, contentLength, header, expectsPayload) {
    var _a, _b, _c;
    assert(contentLength !== 0 || client[kRunning] === 0, "stream body cannot be pipelined");
    let finished = !1,
      writer = new AsyncWriter({
        abort: abort,
        socket: socket,
        request: request,
        contentLength: contentLength,
        client: client,
        expectsPayload: expectsPayload,
        header: header
      }),
      onData = __name(function (chunk) {
        if (!finished) try {
          !writer.write(chunk) && this.pause && this.pause();
        } catch (err) {
          util.destroy(this, err);
        }
      }, "onData"),
      onDrain = __name(function () {
        finished || body.resume && body.resume();
      }, "onDrain"),
      onClose = __name(function () {
        if (queueMicrotask(() => {
          body.removeListener("error", onFinished);
        }), !finished) {
          let err = new RequestAbortedError();
          queueMicrotask(() => onFinished(err));
        }
      }, "onClose"),
      onFinished = __name(function (err) {
        if (!finished) {
          if (finished = !0, assert(socket.destroyed || socket[kWriting] && client[kRunning] <= 1), socket.off("drain", onDrain).off("error", onFinished), body.removeListener("data", onData).removeListener("end", onFinished).removeListener("close", onClose), !err) try {
            writer.end();
          } catch (er) {
            err = er;
          }
          writer.destroy(err), err && (err.code !== "UND_ERR_INFO" || err.message !== "reset") ? util.destroy(body, err) : util.destroy(body);
        }
      }, "onFinished");
    body.on("data", onData).on("end", onFinished).on("error", onFinished).on("close", onClose), body.resume && body.resume(), socket.on("drain", onDrain).on("error", onFinished), ((_a = body.errorEmitted) != null ? _a : body.errored) ? setImmediate(() => onFinished(body.errored)) : ((_b = body.endEmitted) != null ? _b : body.readableEnded) && setImmediate(() => onFinished(null)), ((_c = body.closeEmitted) != null ? _c : body.closed) && setImmediate(onClose);
  }
  __name(writeStream, "writeStream");
  function writeBuffer(abort, body, client, request, socket, contentLength, header, expectsPayload) {
    try {
      body ? util.isBuffer(body) && (assert(contentLength === body.byteLength, "buffer body must have content length"), socket.cork(), socket.write(`${header}content-length: ${contentLength}\r
\r
`, "latin1"), socket.write(body), socket.uncork(), request.onBodySent(body), !expectsPayload && request.reset !== !1 && (socket[kReset] = !0)) : contentLength === 0 ? socket.write(`${header}content-length: 0\r
\r
`, "latin1") : (assert(contentLength === null, "no body must not have content length"), socket.write(`${header}\r
`, "latin1")), request.onRequestSent(), client[kResume]();
    } catch (err) {
      abort(err);
    }
  }
  __name(writeBuffer, "writeBuffer");
  async function writeBlob(abort, body, client, request, socket, contentLength, header, expectsPayload) {
    assert(contentLength === body.size, "blob body must have content length");
    try {
      if (contentLength != null && contentLength !== body.size) throw new RequestContentLengthMismatchError();
      let buffer = Buffer.from(await body.arrayBuffer());
      socket.cork(), socket.write(`${header}content-length: ${contentLength}\r
\r
`, "latin1"), socket.write(buffer), socket.uncork(), request.onBodySent(buffer), request.onRequestSent(), !expectsPayload && request.reset !== !1 && (socket[kReset] = !0), client[kResume]();
    } catch (err) {
      abort(err);
    }
  }
  __name(writeBlob, "writeBlob");
  async function writeIterable(abort, body, client, request, socket, contentLength, header, expectsPayload) {
    assert(contentLength !== 0 || client[kRunning] === 0, "iterator body cannot be pipelined");
    let callback = null;
    function onDrain() {
      if (callback) {
        let cb = callback;
        callback = null, cb();
      }
    }
    __name(onDrain, "onDrain");
    let waitForDrain = __name(() => new Promise((resolve, reject) => {
      assert(callback === null), socket[kError] ? reject(socket[kError]) : callback = resolve;
    }), "waitForDrain");
    socket.on("close", onDrain).on("drain", onDrain);
    let writer = new AsyncWriter({
      abort: abort,
      socket: socket,
      request: request,
      contentLength: contentLength,
      client: client,
      expectsPayload: expectsPayload,
      header: header
    });
    try {
      for await (let chunk of body) {
        if (socket[kError]) throw socket[kError];
        writer.write(chunk) || (await waitForDrain());
      }
      writer.end();
    } catch (err) {
      writer.destroy(err);
    } finally {
      socket.off("close", onDrain).off("drain", onDrain);
    }
  }
  __name(writeIterable, "writeIterable");
  var _AsyncWriter = class _AsyncWriter {
    constructor({
      abort: abort,
      socket: socket,
      request: request,
      contentLength: contentLength,
      client: client,
      expectsPayload: expectsPayload,
      header: header
    }) {
      this.socket = socket, this.request = request, this.contentLength = contentLength, this.client = client, this.bytesWritten = 0, this.expectsPayload = expectsPayload, this.header = header, this.abort = abort, socket[kWriting] = !0;
    }
    write(chunk) {
      let {
        socket: socket,
        request: request,
        contentLength: contentLength,
        client: client,
        bytesWritten: bytesWritten,
        expectsPayload: expectsPayload,
        header: header
      } = this;
      if (socket[kError]) throw socket[kError];
      if (socket.destroyed) return !1;
      let len = Buffer.byteLength(chunk);
      if (!len) return !0;
      if (contentLength !== null && bytesWritten + len > contentLength) {
        if (client[kStrictContentLength]) throw new RequestContentLengthMismatchError();
        process.emitWarning(new RequestContentLengthMismatchError());
      }
      socket.cork(), bytesWritten === 0 && (!expectsPayload && request.reset !== !1 && (socket[kReset] = !0), contentLength === null ? socket.write(`${header}transfer-encoding: chunked\r
`, "latin1") : socket.write(`${header}content-length: ${contentLength}\r
\r
`, "latin1")), contentLength === null && socket.write(`\r
${len.toString(16)}\r
`, "latin1"), this.bytesWritten += len;
      let ret = socket.write(chunk);
      return socket.uncork(), request.onBodySent(chunk), ret || socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS && socket[kParser].timeout.refresh && socket[kParser].timeout.refresh(), ret;
    }
    end() {
      let {
        socket: socket,
        contentLength: contentLength,
        client: client,
        bytesWritten: bytesWritten,
        expectsPayload: expectsPayload,
        header: header,
        request: request
      } = this;
      if (request.onRequestSent(), socket[kWriting] = !1, socket[kError]) throw socket[kError];
      if (!socket.destroyed) {
        if (bytesWritten === 0 ? expectsPayload ? socket.write(`${header}content-length: 0\r
\r
`, "latin1") : socket.write(`${header}\r
`, "latin1") : contentLength === null && socket.write(`\r
0\r
\r
`, "latin1"), contentLength !== null && bytesWritten !== contentLength) {
          if (client[kStrictContentLength]) throw new RequestContentLengthMismatchError();
          process.emitWarning(new RequestContentLengthMismatchError());
        }
        socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS && socket[kParser].timeout.refresh && socket[kParser].timeout.refresh(), client[kResume]();
      }
    }
    destroy(err) {
      let {
        socket: socket,
        client: client,
        abort: abort
      } = this;
      socket[kWriting] = !1, err && (assert(client[kRunning] <= 1, "pipeline should only contain this request"), abort(err));
    }
  };
  __name(_AsyncWriter, "AsyncWriter");
  var AsyncWriter = _AsyncWriter;
  module.exports = connectH1;
});