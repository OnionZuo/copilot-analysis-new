var require_dispatcher_base = __commonJSMin((exports, module) => {
  "use strict";

  var Dispatcher = q4(),
    {
      ClientDestroyedError: ClientDestroyedError,
      ClientClosedError: ClientClosedError,
      InvalidArgumentError: InvalidArgumentError
    } = rr(),
    {
      kDestroy: kDestroy,
      kClose: kClose,
      kClosed: kClosed,
      kDestroyed: kDestroyed,
      kDispatch: kDispatch,
      kInterceptors: kInterceptors
    } = fo(),
    kOnDestroyed = Symbol("onDestroyed"),
    kOnClosed = Symbol("onClosed"),
    kInterceptedDispatch = Symbol("Intercepted Dispatch"),
    _DispatcherBase = class _DispatcherBase extends Dispatcher {
      constructor() {
        super(), this[kDestroyed] = !1, this[kOnDestroyed] = null, this[kClosed] = !1, this[kOnClosed] = [];
      }
      get destroyed() {
        return this[kDestroyed];
      }
      get closed() {
        return this[kClosed];
      }
      get interceptors() {
        return this[kInterceptors];
      }
      set interceptors(newInterceptors) {
        if (newInterceptors) {
          for (let i = newInterceptors.length - 1; i >= 0; i--) if (typeof this[kInterceptors][i] != "function") throw new InvalidArgumentError("interceptor must be an function");
        }
        this[kInterceptors] = newInterceptors;
      }
      close(callback) {
        if (callback === void 0) return new Promise((resolve, reject) => {
          this.close((err, data) => err ? reject(err) : resolve(data));
        });
        if (typeof callback != "function") throw new InvalidArgumentError("invalid callback");
        if (this[kDestroyed]) {
          queueMicrotask(() => callback(new ClientDestroyedError(), null));
          return;
        }
        if (this[kClosed]) {
          this[kOnClosed] ? this[kOnClosed].push(callback) : queueMicrotask(() => callback(null, null));
          return;
        }
        this[kClosed] = !0, this[kOnClosed].push(callback);
        let onClosed = __name(() => {
          let callbacks = this[kOnClosed];
          this[kOnClosed] = null;
          for (let i = 0; i < callbacks.length; i++) callbacks[i](null, null);
        }, "onClosed");
        this[kClose]().then(() => this.destroy()).then(() => {
          queueMicrotask(onClosed);
        });
      }
      destroy(err, callback) {
        if (typeof err == "function" && (callback = err, err = null), callback === void 0) return new Promise((resolve, reject) => {
          this.destroy(err, (err, data) => err ? reject(err) : resolve(data));
        });
        if (typeof callback != "function") throw new InvalidArgumentError("invalid callback");
        if (this[kDestroyed]) {
          this[kOnDestroyed] ? this[kOnDestroyed].push(callback) : queueMicrotask(() => callback(null, null));
          return;
        }
        err || (err = new ClientDestroyedError()), this[kDestroyed] = !0, this[kOnDestroyed] = this[kOnDestroyed] || [], this[kOnDestroyed].push(callback);
        let onDestroyed = __name(() => {
          let callbacks = this[kOnDestroyed];
          this[kOnDestroyed] = null;
          for (let i = 0; i < callbacks.length; i++) callbacks[i](null, null);
        }, "onDestroyed");
        this[kDestroy](err).then(() => {
          queueMicrotask(onDestroyed);
        });
      }
      [kInterceptedDispatch](opts, handler) {
        if (!this[kInterceptors] || this[kInterceptors].length === 0) return this[kInterceptedDispatch] = this[kDispatch], this[kDispatch](opts, handler);
        let dispatch = this[kDispatch].bind(this);
        for (let i = this[kInterceptors].length - 1; i >= 0; i--) dispatch = this[kInterceptors][i](dispatch);
        return this[kInterceptedDispatch] = dispatch, dispatch(opts, handler);
      }
      dispatch(opts, handler) {
        if (!handler || typeof handler != "object") throw new InvalidArgumentError("handler must be an object");
        try {
          if (!opts || typeof opts != "object") throw new InvalidArgumentError("opts must be an object.");
          if (this[kDestroyed] || this[kOnDestroyed]) throw new ClientDestroyedError();
          if (this[kClosed]) throw new ClientClosedError();
          return this[kInterceptedDispatch](opts, handler);
        } catch (err) {
          if (typeof handler.onError != "function") throw new InvalidArgumentError("invalid onError method");
          return handler.onError(err), !1;
        }
      }
    };
  __name(_DispatcherBase, "DispatcherBase");
  var DispatcherBase = _DispatcherBase;
  module.exports = DispatcherBase;
});