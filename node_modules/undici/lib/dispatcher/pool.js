var require_pool = __commonJSMin((exports, module) => {
  "use strict";

  var {
      PoolBase: PoolBase,
      kClients: kClients,
      kNeedDrain: kNeedDrain,
      kAddClient: kAddClient,
      kGetDispatcher: kGetDispatcher
    } = dre(),
    Client = l9(),
    {
      InvalidArgumentError: InvalidArgumentError
    } = rr(),
    util = oi(),
    {
      kUrl: kUrl,
      kInterceptors: kInterceptors
    } = fo(),
    buildConnector = U4(),
    kOptions = Symbol("options"),
    kConnections = Symbol("connections"),
    kFactory = Symbol("factory");
  function defaultFactory(origin, opts) {
    return new Client(origin, opts);
  }
  __name(defaultFactory, "defaultFactory");
  var _Pool = class _Pool extends PoolBase {
    constructor(origin, {
      connections: connections,
      factory = defaultFactory,
      connect: connect,
      connectTimeout: connectTimeout,
      tls: tls,
      maxCachedSessions: maxCachedSessions,
      socketPath: socketPath,
      autoSelectFamily: autoSelectFamily,
      autoSelectFamilyAttemptTimeout: autoSelectFamilyAttemptTimeout,
      allowH2: allowH2,
      ...options
    } = {}) {
      var _a;
      if (super(), connections != null && (!Number.isFinite(connections) || connections < 0)) throw new InvalidArgumentError("invalid connections");
      if (typeof factory != "function") throw new InvalidArgumentError("factory must be a function.");
      if (connect != null && typeof connect != "function" && typeof connect != "object") throw new InvalidArgumentError("connect must be a function or an object");
      typeof connect != "function" && (connect = buildConnector({
        ...tls,
        maxCachedSessions: maxCachedSessions,
        allowH2: allowH2,
        socketPath: socketPath,
        timeout: connectTimeout,
        ...(autoSelectFamily ? {
          autoSelectFamily: autoSelectFamily,
          autoSelectFamilyAttemptTimeout: autoSelectFamilyAttemptTimeout
        } : void 0),
        ...connect
      })), this[kInterceptors] = (_a = options.interceptors) != null && _a.Pool && Array.isArray(options.interceptors.Pool) ? options.interceptors.Pool : [], this[kConnections] = connections || null, this[kUrl] = util.parseOrigin(origin), this[kOptions] = {
        ...util.deepClone(options),
        connect: connect,
        allowH2: allowH2
      }, this[kOptions].interceptors = options.interceptors ? {
        ...options.interceptors
      } : void 0, this[kFactory] = factory;
    }
    [kGetDispatcher]() {
      for (let client of this[kClients]) if (!client[kNeedDrain]) return client;
      if (!this[kConnections] || this[kClients].length < this[kConnections]) {
        let dispatcher = this[kFactory](this[kUrl], this[kOptions]);
        return this[kAddClient](dispatcher), dispatcher;
      }
    }
  };
  __name(_Pool, "Pool");
  var Pool = _Pool;
  module.exports = Pool;
});