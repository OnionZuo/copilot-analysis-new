var require_balanced_pool = __commonJSMin((exports, module) => {
  "use strict";

  var {
      BalancedPoolMissingUpstreamError: BalancedPoolMissingUpstreamError,
      InvalidArgumentError: InvalidArgumentError
    } = rr(),
    {
      PoolBase: PoolBase,
      kClients: kClients,
      kNeedDrain: kNeedDrain,
      kAddClient: kAddClient,
      kRemoveClient: kRemoveClient,
      kGetDispatcher: kGetDispatcher
    } = dre(),
    Pool = nI(),
    {
      kUrl: kUrl,
      kInterceptors: kInterceptors
    } = fo(),
    {
      parseOrigin: parseOrigin
    } = oi(),
    kFactory = Symbol("factory"),
    kOptions = Symbol("options"),
    kGreatestCommonDivisor = Symbol("kGreatestCommonDivisor"),
    kCurrentWeight = Symbol("kCurrentWeight"),
    kIndex = Symbol("kIndex"),
    kWeight = Symbol("kWeight"),
    kMaxWeightPerServer = Symbol("kMaxWeightPerServer"),
    kErrorPenalty = Symbol("kErrorPenalty");
  function getGreatestCommonDivisor(a, b) {
    if (a === 0) return b;
    for (; b !== 0;) {
      let t = b;
      b = a % b, a = t;
    }
    return a;
  }
  __name(getGreatestCommonDivisor, "getGreatestCommonDivisor");
  function defaultFactory(origin, opts) {
    return new Pool(origin, opts);
  }
  __name(defaultFactory, "defaultFactory");
  var _BalancedPool = class _BalancedPool extends PoolBase {
    constructor(upstreams = [], {
      factory = defaultFactory,
      ...opts
    } = {}) {
      var _a;
      if (super(), this[kOptions] = opts, this[kIndex] = -1, this[kCurrentWeight] = 0, this[kMaxWeightPerServer] = this[kOptions].maxWeightPerServer || 100, this[kErrorPenalty] = this[kOptions].errorPenalty || 15, Array.isArray(upstreams) || (upstreams = [upstreams]), typeof factory != "function") throw new InvalidArgumentError("factory must be a function.");
      this[kInterceptors] = (_a = opts.interceptors) != null && _a.BalancedPool && Array.isArray(opts.interceptors.BalancedPool) ? opts.interceptors.BalancedPool : [], this[kFactory] = factory;
      for (let upstream of upstreams) this.addUpstream(upstream);
      this._updateBalancedPoolStats();
    }
    addUpstream(upstream) {
      let upstreamOrigin = parseOrigin(upstream).origin;
      if (this[kClients].find(pool => pool[kUrl].origin === upstreamOrigin && pool.closed !== !0 && pool.destroyed !== !0)) return this;
      let pool = this[kFactory](upstreamOrigin, Object.assign({}, this[kOptions]));
      this[kAddClient](pool), pool.on("connect", () => {
        pool[kWeight] = Math.min(this[kMaxWeightPerServer], pool[kWeight] + this[kErrorPenalty]);
      }), pool.on("connectionError", () => {
        pool[kWeight] = Math.max(1, pool[kWeight] - this[kErrorPenalty]), this._updateBalancedPoolStats();
      }), pool.on("disconnect", (...args) => {
        let err = args[2];
        err && err.code === "UND_ERR_SOCKET" && (pool[kWeight] = Math.max(1, pool[kWeight] - this[kErrorPenalty]), this._updateBalancedPoolStats());
      });
      for (let client of this[kClients]) client[kWeight] = this[kMaxWeightPerServer];
      return this._updateBalancedPoolStats(), this;
    }
    _updateBalancedPoolStats() {
      let result = 0;
      for (let i = 0; i < this[kClients].length; i++) result = getGreatestCommonDivisor(this[kClients][i][kWeight], result);
      this[kGreatestCommonDivisor] = result;
    }
    removeUpstream(upstream) {
      let upstreamOrigin = parseOrigin(upstream).origin,
        pool = this[kClients].find(pool => pool[kUrl].origin === upstreamOrigin && pool.closed !== !0 && pool.destroyed !== !0);
      return pool && this[kRemoveClient](pool), this;
    }
    get upstreams() {
      return this[kClients].filter(dispatcher => dispatcher.closed !== !0 && dispatcher.destroyed !== !0).map(p => p[kUrl].origin);
    }
    [kGetDispatcher]() {
      if (this[kClients].length === 0) throw new BalancedPoolMissingUpstreamError();
      if (!this[kClients].find(dispatcher => !dispatcher[kNeedDrain] && dispatcher.closed !== !0 && dispatcher.destroyed !== !0) || this[kClients].map(pool => pool[kNeedDrain]).reduce((a, b) => a && b, !0)) return;
      let counter = 0,
        maxWeightIndex = this[kClients].findIndex(pool => !pool[kNeedDrain]);
      for (; counter++ < this[kClients].length;) {
        this[kIndex] = (this[kIndex] + 1) % this[kClients].length;
        let pool = this[kClients][this[kIndex]];
        if (pool[kWeight] > this[kClients][maxWeightIndex][kWeight] && !pool[kNeedDrain] && (maxWeightIndex = this[kIndex]), this[kIndex] === 0 && (this[kCurrentWeight] = this[kCurrentWeight] - this[kGreatestCommonDivisor], this[kCurrentWeight] <= 0 && (this[kCurrentWeight] = this[kMaxWeightPerServer])), pool[kWeight] >= this[kCurrentWeight] && !pool[kNeedDrain]) return pool;
      }
      return this[kCurrentWeight] = this[kClients][maxWeightIndex][kWeight], this[kIndex] = maxWeightIndex, this[kClients][maxWeightIndex];
    }
  };
  __name(_BalancedPool, "BalancedPool");
  var BalancedPool = _BalancedPool;
  module.exports = BalancedPool;
});