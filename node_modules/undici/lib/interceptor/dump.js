var require_dump = __commonJSMin((exports, module) => {
  "use strict";

  var util = oi(),
    {
      InvalidArgumentError: InvalidArgumentError,
      RequestAbortedError: RequestAbortedError
    } = rr(),
    DecoratorHandler = ZM(),
    _maxSize,
    _abort,
    _dumped,
    _aborted,
    _size,
    _reason,
    _handler,
    _DumpHandler_instances,
    customAbort_fn,
    _DumpHandler = class _DumpHandler extends DecoratorHandler {
      constructor({
        maxSize: maxSize
      }, handler) {
        super(handler);
        __privateAdd(this, _DumpHandler_instances);
        __privateAdd(this, _maxSize, 1024 * 1024);
        __privateAdd(this, _abort, null);
        __privateAdd(this, _dumped, !1);
        __privateAdd(this, _aborted, !1);
        __privateAdd(this, _size, 0);
        __privateAdd(this, _reason, null);
        __privateAdd(this, _handler, null);
        if (maxSize != null && (!Number.isFinite(maxSize) || maxSize < 1)) throw new InvalidArgumentError("maxSize must be a number greater than 0");
        __privateSet(this, _maxSize, maxSize != null ? maxSize : __privateGet(this, _maxSize)), __privateSet(this, _handler, handler);
      }
      onConnect(abort) {
        __privateSet(this, _abort, abort), __privateGet(this, _handler).onConnect(__privateMethod(this, _DumpHandler_instances, customAbort_fn).bind(this));
      }
      onHeaders(statusCode, rawHeaders, resume, statusMessage) {
        let contentLength = util.parseHeaders(rawHeaders)["content-length"];
        if (contentLength != null && contentLength > __privateGet(this, _maxSize)) throw new RequestAbortedError(`Response size (${contentLength}) larger than maxSize (${__privateGet(this, _maxSize)})`);
        return __privateGet(this, _aborted) ? !0 : __privateGet(this, _handler).onHeaders(statusCode, rawHeaders, resume, statusMessage);
      }
      onError(err) {
        var _a;
        __privateGet(this, _dumped) || (err = (_a = __privateGet(this, _reason)) != null ? _a : err, __privateGet(this, _handler).onError(err));
      }
      onData(chunk) {
        return __privateSet(this, _size, __privateGet(this, _size) + chunk.length), __privateGet(this, _size) >= __privateGet(this, _maxSize) && (__privateSet(this, _dumped, !0), __privateGet(this, _aborted) ? __privateGet(this, _handler).onError(__privateGet(this, _reason)) : __privateGet(this, _handler).onComplete([])), !0;
      }
      onComplete(trailers) {
        if (!__privateGet(this, _dumped)) {
          if (__privateGet(this, _aborted)) {
            __privateGet(this, _handler).onError(this.reason);
            return;
          }
          __privateGet(this, _handler).onComplete(trailers);
        }
      }
    };
  _maxSize = new WeakMap(), _abort = new WeakMap(), _dumped = new WeakMap(), _aborted = new WeakMap(), _size = new WeakMap(), _reason = new WeakMap(), _handler = new WeakMap(), _DumpHandler_instances = new WeakSet(), customAbort_fn = __name(function (reason) {
    __privateSet(this, _aborted, !0), __privateSet(this, _reason, reason);
  }, "#customAbort"), __name(_DumpHandler, "DumpHandler");
  var DumpHandler = _DumpHandler;
  function createDumpInterceptor({
    maxSize: defaultMaxSize
  } = {
    maxSize: 1024 * 1024
  }) {
    return dispatch => __name(function (opts, handler) {
      let {
          dumpMaxSize = defaultMaxSize
        } = opts,
        dumpHandler = new DumpHandler({
          maxSize: dumpMaxSize
        }, handler);
      return dispatch(opts, dumpHandler);
    }, "Intercept");
  }
  __name(createDumpInterceptor, "createDumpInterceptor");
  module.exports = createDumpInterceptor;
});