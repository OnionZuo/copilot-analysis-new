var require_dns = __commonJSMin((exports, module) => {
  "use strict";

  var {
      isIP: isIP
    } = require("net"),
    {
      lookup: lookup
    } = require("dns"),
    DecoratorHandler = ZM(),
    {
      InvalidArgumentError: InvalidArgumentError,
      InformationalError: InformationalError
    } = rr(),
    maxInt = Math.pow(2, 31) - 1,
    _maxTTL,
    _maxItems,
    _records,
    _DNSInstance_instances,
    defaultLookup_fn,
    defaultPick_fn,
    _DNSInstance = class _DNSInstance {
      constructor(opts) {
        __privateAdd(this, _DNSInstance_instances);
        __privateAdd(this, _maxTTL, 0);
        __privateAdd(this, _maxItems, 0);
        __privateAdd(this, _records, new Map());
        __publicField(this, "dualStack", !0);
        __publicField(this, "affinity", null);
        __publicField(this, "lookup", null);
        __publicField(this, "pick", null);
        var _a, _b;
        __privateSet(this, _maxTTL, opts.maxTTL), __privateSet(this, _maxItems, opts.maxItems), this.dualStack = opts.dualStack, this.affinity = opts.affinity, this.lookup = (_a = opts.lookup) != null ? _a : __privateMethod(this, _DNSInstance_instances, defaultLookup_fn), this.pick = (_b = opts.pick) != null ? _b : __privateMethod(this, _DNSInstance_instances, defaultPick_fn);
      }
      get full() {
        return __privateGet(this, _records).size === __privateGet(this, _maxItems);
      }
      runLookup(origin, opts, cb) {
        let ips = __privateGet(this, _records).get(origin.hostname);
        if (ips == null && this.full) {
          cb(null, origin.origin);
          return;
        }
        let newOpts = {
          affinity: this.affinity,
          dualStack: this.dualStack,
          lookup: this.lookup,
          pick: this.pick,
          ...opts.dns,
          maxTTL: __privateGet(this, _maxTTL),
          maxItems: __privateGet(this, _maxItems)
        };
        if (ips == null) this.lookup(origin, newOpts, (err, addresses) => {
          if (err || addresses == null || addresses.length === 0) {
            cb(err != null ? err : new InformationalError("No DNS entries found"));
            return;
          }
          this.setRecords(origin, addresses);
          let records = __privateGet(this, _records).get(origin.hostname),
            ip = this.pick(origin, records, newOpts.affinity),
            port;
          typeof ip.port == "number" ? port = `:${ip.port}` : origin.port !== "" ? port = `:${origin.port}` : port = "", cb(null, `${origin.protocol}//${ip.family === 6 ? `[${ip.address}]` : ip.address}${port}`);
        });else {
          let ip = this.pick(origin, ips, newOpts.affinity);
          if (ip == null) {
            __privateGet(this, _records).delete(origin.hostname), this.runLookup(origin, opts, cb);
            return;
          }
          let port;
          typeof ip.port == "number" ? port = `:${ip.port}` : origin.port !== "" ? port = `:${origin.port}` : port = "", cb(null, `${origin.protocol}//${ip.family === 6 ? `[${ip.address}]` : ip.address}${port}`);
        }
      }
      setRecords(origin, addresses) {
        var _a;
        let timestamp = Date.now(),
          records = {
            records: {
              4: null,
              6: null
            }
          };
        for (let record of addresses) {
          record.timestamp = timestamp, typeof record.ttl == "number" ? record.ttl = Math.min(record.ttl, __privateGet(this, _maxTTL)) : record.ttl = __privateGet(this, _maxTTL);
          let familyRecords = (_a = records.records[record.family]) != null ? _a : {
            ips: []
          };
          familyRecords.ips.push(record), records.records[record.family] = familyRecords;
        }
        __privateGet(this, _records).set(origin.hostname, records);
      }
      getHandler(meta, opts) {
        return new DNSDispatchHandler(this, meta, opts);
      }
    };
  _maxTTL = new WeakMap(), _maxItems = new WeakMap(), _records = new WeakMap(), _DNSInstance_instances = new WeakSet(), defaultLookup_fn = __name(function (origin, opts, cb) {
    lookup(origin.hostname, {
      all: !0,
      family: this.dualStack === !1 ? this.affinity : 0,
      order: "ipv4first"
    }, (err, addresses) => {
      if (err) return cb(err);
      let results = new Map();
      for (let addr of addresses) results.set(`${addr.address}:${addr.family}`, addr);
      cb(null, results.values());
    });
  }, "#defaultLookup"), defaultPick_fn = __name(function (origin, hostnameRecords, affinity) {
    var _a;
    let ip = null,
      {
        records: records,
        offset: offset
      } = hostnameRecords,
      family;
    if (this.dualStack ? (affinity == null && (offset == null || offset === maxInt ? (hostnameRecords.offset = 0, affinity = 4) : (hostnameRecords.offset++, affinity = (hostnameRecords.offset & 1) === 1 ? 6 : 4)), records[affinity] != null && records[affinity].ips.length > 0 ? family = records[affinity] : family = records[affinity === 4 ? 6 : 4]) : family = records[affinity], family == null || family.ips.length === 0) return ip;
    family.offset == null || family.offset === maxInt ? family.offset = 0 : family.offset++;
    let position = family.offset % family.ips.length;
    return ip = (_a = family.ips[position]) != null ? _a : null, ip == null ? ip : Date.now() - ip.timestamp > ip.ttl ? (family.ips.splice(position, 1), this.pick(origin, hostnameRecords, affinity)) : ip;
  }, "#defaultPick"), __name(_DNSInstance, "DNSInstance");
  var DNSInstance = _DNSInstance,
    _state,
    _opts,
    _dispatch,
    _handler,
    _origin,
    _DNSDispatchHandler = class _DNSDispatchHandler extends DecoratorHandler {
      constructor(state, {
        origin: origin,
        handler: handler,
        dispatch: dispatch
      }, opts) {
        super(handler);
        __privateAdd(this, _state, null);
        __privateAdd(this, _opts, null);
        __privateAdd(this, _dispatch, null);
        __privateAdd(this, _handler, null);
        __privateAdd(this, _origin, null);
        __privateSet(this, _origin, origin), __privateSet(this, _handler, handler), __privateSet(this, _opts, {
          ...opts
        }), __privateSet(this, _state, state), __privateSet(this, _dispatch, dispatch);
      }
      onError(err) {
        switch (err.code) {
          case "ETIMEDOUT":
          case "ECONNREFUSED":
            {
              if (__privateGet(this, _state).dualStack) {
                __privateGet(this, _state).runLookup(__privateGet(this, _origin), __privateGet(this, _opts), (err, newOrigin) => {
                  if (err) return __privateGet(this, _handler).onError(err);
                  let dispatchOpts = {
                    ...__privateGet(this, _opts),
                    origin: newOrigin
                  };
                  __privateGet(this, _dispatch).call(this, dispatchOpts, this);
                });
                return;
              }
              __privateGet(this, _handler).onError(err);
              return;
            }
          case "ENOTFOUND":
            __privateGet(this, _state).deleteRecord(__privateGet(this, _origin));
          default:
            __privateGet(this, _handler).onError(err);
            break;
        }
      }
    };
  _state = new WeakMap(), _opts = new WeakMap(), _dispatch = new WeakMap(), _handler = new WeakMap(), _origin = new WeakMap(), __name(_DNSDispatchHandler, "DNSDispatchHandler");
  var DNSDispatchHandler = _DNSDispatchHandler;
  module.exports = interceptorOpts => {
    var _a, _b, _c, _d, _e, _f, _g;
    if ((interceptorOpts == null ? void 0 : interceptorOpts.maxTTL) != null && (typeof (interceptorOpts == null ? void 0 : interceptorOpts.maxTTL) != "number" || (interceptorOpts == null ? void 0 : interceptorOpts.maxTTL) < 0)) throw new InvalidArgumentError("Invalid maxTTL. Must be a positive number");
    if ((interceptorOpts == null ? void 0 : interceptorOpts.maxItems) != null && (typeof (interceptorOpts == null ? void 0 : interceptorOpts.maxItems) != "number" || (interceptorOpts == null ? void 0 : interceptorOpts.maxItems) < 1)) throw new InvalidArgumentError("Invalid maxItems. Must be a positive number and greater than zero");
    if ((interceptorOpts == null ? void 0 : interceptorOpts.affinity) != null && (interceptorOpts == null ? void 0 : interceptorOpts.affinity) !== 4 && (interceptorOpts == null ? void 0 : interceptorOpts.affinity) !== 6) throw new InvalidArgumentError("Invalid affinity. Must be either 4 or 6");
    if ((interceptorOpts == null ? void 0 : interceptorOpts.dualStack) != null && typeof (interceptorOpts == null ? void 0 : interceptorOpts.dualStack) != "boolean") throw new InvalidArgumentError("Invalid dualStack. Must be a boolean");
    if ((interceptorOpts == null ? void 0 : interceptorOpts.lookup) != null && typeof (interceptorOpts == null ? void 0 : interceptorOpts.lookup) != "function") throw new InvalidArgumentError("Invalid lookup. Must be a function");
    if ((interceptorOpts == null ? void 0 : interceptorOpts.pick) != null && typeof (interceptorOpts == null ? void 0 : interceptorOpts.pick) != "function") throw new InvalidArgumentError("Invalid pick. Must be a function");
    let dualStack = (_a = interceptorOpts == null ? void 0 : interceptorOpts.dualStack) != null ? _a : !0,
      affinity;
    dualStack ? affinity = (_b = interceptorOpts == null ? void 0 : interceptorOpts.affinity) != null ? _b : null : affinity = (_c = interceptorOpts == null ? void 0 : interceptorOpts.affinity) != null ? _c : 4;
    let opts = {
        maxTTL: (_d = interceptorOpts == null ? void 0 : interceptorOpts.maxTTL) != null ? _d : 1e4,
        lookup: (_e = interceptorOpts == null ? void 0 : interceptorOpts.lookup) != null ? _e : null,
        pick: (_f = interceptorOpts == null ? void 0 : interceptorOpts.pick) != null ? _f : null,
        dualStack: dualStack,
        affinity: affinity,
        maxItems: (_g = interceptorOpts == null ? void 0 : interceptorOpts.maxItems) != null ? _g : 1 / 0
      },
      instance = new DNSInstance(opts);
    return dispatch => __name(function (origDispatchOpts, handler) {
      let origin = origDispatchOpts.origin.constructor === URL ? origDispatchOpts.origin : new URL(origDispatchOpts.origin);
      return isIP(origin.hostname) !== 0 ? dispatch(origDispatchOpts, handler) : (instance.runLookup(origin, origDispatchOpts, (err, newOrigin) => {
        if (err) return handler.onError(err);
        let dispatchOpts = null;
        dispatchOpts = {
          ...origDispatchOpts,
          servername: origin.hostname,
          origin: newOrigin,
          headers: {
            host: origin.hostname,
            ...origDispatchOpts.headers
          }
        }, dispatch(dispatchOpts, instance.getHandler({
          origin: origin,
          dispatch: dispatch,
          handler: handler
        }, origDispatchOpts));
      }), !0);
    }, "dnsInterceptor");
  };
});