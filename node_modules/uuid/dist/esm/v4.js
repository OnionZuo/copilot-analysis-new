function v4(options, buf, offset) {
  var _a, _b, _c;
  if (native_default.randomUUID && !buf && !options) return native_default.randomUUID();
  options = options || {};
  let rnds = (_c = (_b = options.random) != null ? _b : (_a = options.rng) == null ? void 0 : _a.call(options)) != null ? _c : rng();
  if (rnds.length < 16) throw new Error("Random bytes length must be >= 16");
  if (rnds[6] = rnds[6] & 15 | 64, rnds[8] = rnds[8] & 63 | 128, buf) {
    if (offset = offset || 0, offset < 0 || offset + 16 > buf.length) throw new RangeError(`UUID byte range ${offset}:${offset + 15} is out of buffer bounds`);
    for (let i = 0; i < 16; ++i) buf[offset + i] = rnds[i];
    return buf;
  }
  return unsafeStringify(rnds);
},__name(v4, "v4");,var v4_default = v4;,var import_vscode_languageserver_protocol = fn(Un());,function isRestricted(store) {
  return store === 1;
},__name(isRestricted, "isRestricted");,var ftTelemetryEvents = ["engine.prompt", "engine.completion", "ghostText.capturedAfterAccepted", "ghostText.capturedAfterRejected"],
  MAX_PROPERTY_LENGTH = 8192,
  MAX_CONCATENATED_PROPERTIES = 21;,var _TelemetryReporters = class _TelemetryReporters {
  getReporter(ctx, store = 0) {
    return isRestricted(store) ? this.getRestrictedReporter(ctx) : this.reporter;
  }
  getRestrictedReporter(ctx) {
    if (shouldSendRestricted(ctx)) return this.reporterRestricted;
    if (shouldFailForDebugPurposes(ctx)) return new FailingTelemetryReporter();
  }
  getFTReporter(ctx) {
    if (shouldSendFinetuningTelemetry(ctx)) return this.reporterFT;
    if (shouldFailForDebugPurposes(ctx)) return new FailingTelemetryReporter();
  }
  setReporter(reporter) {
    this.reporter = reporter;
  }
  setRestrictedReporter(reporter) {
    this.reporterRestricted = reporter;
  }
  setFTReporter(reporter) {
    this.reporterFT = reporter;
  }
  async deactivate() {
    let disposeReporter = Promise.resolve();
    this.reporter && (disposeReporter = this.reporter.dispose(), this.reporter = void 0);
    let disposeReporterRestricted = Promise.resolve();
    this.reporterRestricted && (disposeReporterRestricted = this.reporterRestricted.dispose(), this.reporterRestricted = void 0);
    let disposeReporterFT = Promise.resolve();
    this.reporterFT && (disposeReporterFT = this.reporterFT.dispose(), this.reporterFT = void 0), await Promise.all([disposeReporter, disposeReporterRestricted, disposeReporterFT]);
  }
};,__name(_TelemetryReporters, "TelemetryReporters");,var TelemetryReporters = _TelemetryReporters,
  propertiesSchema = Type.Object({}, {
    additionalProperties: Type.String()
  }),
  measurementsSchema = Type.Object({
    meanLogProb: Type.Optional(Type.Number()),
    meanAlternativeLogProb: Type.Optional(Type.Number())
  }, {
    additionalProperties: Type.Number()
  }),
  oomCodes = new Set(["ERR_WORKER_OUT_OF_MEMORY", "ENOMEM"]);,function isOomError(error) {
  var _a;
  return oomCodes.has((_a = error.code) != null ? _a : "") || error.name === "RangeError" && error.message === "WebAssembly.Memory(): could not allocate memory";
},__name(isOomError, "isOomError");,function getErrorType(error) {
  return isNetworkError(error) ? "network" : isOomError(error) || error.code === "EMFILE" || error.code === "ENFILE" || error.syscall === "uv_cwd" && (error.code === "ENOENT" || error.code == "EIO") || error.code === "CopilotPromptLoadFailure" || `${error.code}`.startsWith("CopilotPromptWorkerExit") ? "local" : "exception";
},__name(getErrorType, "getErrorType");,var _TelemetryData = class _TelemetryData {
  constructor(properties, measurements, issuedTime) {
    this.properties = properties, this.measurements = measurements, this.issuedTime = issuedTime;
  }
  static createAndMarkAsIssued(properties, measurements) {
    return new _TelemetryData(properties || {}, measurements || {}, now());
  }
  extendedBy(properties, measurements) {
    let newProperties = {
        ...this.properties,
        ...properties
      },
      newMeasurements = {
        ...this.measurements,
        ...measurements
      },
      newData = new _TelemetryData(newProperties, newMeasurements, this.issuedTime);
    return newData.displayedTime = this.displayedTime, newData;
  }
  markAsDisplayed() {
    this.displayedTime === void 0 && (this.displayedTime = now());
  }
  async extendWithExpTelemetry(ctx) {
    let {
      filters: filters,
      exp: exp
    } = await ctx.get(Features).getFallbackExpAndFilters();
    exp.addToTelemetry(this), filters.addToTelemetry(this);
  }
  extendWithEditorAgnosticFields(ctx) {
    this.properties.editor_version = formatNameAndVersion(ctx.get(EditorAndPluginInfo).getEditorInfo()), this.properties.editor_plugin_version = formatNameAndVersion(ctx.get(EditorAndPluginInfo).getEditorPluginInfo());
    let editorSession = ctx.get(EditorSession);
    this.properties.client_machineid = editorSession.machineId, this.properties.client_sessionid = editorSession.sessionId, this.properties.copilot_version = `copilot/${getVersion(ctx)}`, this.properties.runtime_version = `node/${process.versions.node}`;
    let editorInfo = ctx.get(EditorAndPluginInfo);
    this.properties.common_extname = editorInfo.getEditorPluginInfo().name, this.properties.common_extversion = editorInfo.getEditorPluginInfo().version, this.properties.common_vscodeversion = formatNameAndVersion(editorInfo.getEditorInfo());
    let fetcher = ctx.get(Fetcher);
    this.properties.fetcher = fetcher.name;
    let proxySettings = fetcher.proxySettings;
    this.properties.proxy_enabled = proxySettings ? "true" : "false", this.properties.proxy_auth = proxySettings != null && proxySettings.proxyAuth ? "true" : "false", this.properties.proxy_kerberos_spn = proxySettings != null && proxySettings.kerberosServicePrincipal ? "true" : "false", this.properties.reject_unauthorized = fetcher.rejectUnauthorized ? "true" : "false";
  }
  extendWithConfigProperties(ctx) {
    let configProperties = dumpForTelemetry(ctx);
    configProperties["copilot.build"] = getBuild(ctx), configProperties["copilot.buildType"] = getBuildType(ctx), this.properties = {
      ...this.properties,
      ...configProperties
    };
  }
  extendWithRequestId(requestId) {
    let requestProperties = {
      completionId: requestId.completionId,
      created: requestId.created.toString(),
      headerRequestId: requestId.headerRequestId,
      serverExperiments: requestId.serverExperiments,
      deploymentId: requestId.deploymentId
    };
    this.properties = {
      ...this.properties,
      ...requestProperties
    };
  }
  static maybeRemoveRepoInfoFromPropertiesHack(store, map) {
    if (isRestricted(store)) return map;
    let returnValue = {};
    for (let key in map) _TelemetryData.keysToRemoveFromStandardTelemetryHack.includes(key) || (returnValue[key] = map[key]);
    return returnValue;
  }
  sanitizeKeys() {
    this.properties = _TelemetryData.sanitizeKeys(this.properties), this.measurements = _TelemetryData.sanitizeKeys(this.measurements);
    for (let key in this.measurements) isNaN(this.measurements[key]) && delete this.measurements[key];
  }
  multiplexProperties() {
    this.properties = _TelemetryData.multiplexProperties(this.properties);
  }
  static sanitizeKeys(map) {
    map = map || {};
    let returnValue = {};
    for (let key in map) {
      let newKey = _TelemetryData.keysExemptedFromSanitization.includes(key) ? key : key.replace(/\./g, "_");
      returnValue[newKey] = map[key];
    }
    return returnValue;
  }
  static multiplexProperties(properties) {
    var _a;
    let newProperties = {
      ...properties
    };
    for (let key in properties) {
      let value = properties[key],
        remainingValueCharactersLength = (_a = value == null ? void 0 : value.length) != null ? _a : 0;
      if (remainingValueCharactersLength > MAX_PROPERTY_LENGTH) {
        let lastStartIndex = 0,
          newPropertiesCount = 0;
        for (; remainingValueCharactersLength > 0 && newPropertiesCount < MAX_CONCATENATED_PROPERTIES;) {
          newPropertiesCount += 1;
          let propertyName = key;
          newPropertiesCount > 1 && (propertyName = key + "_" + (newPropertiesCount < 10 ? "0" : "") + newPropertiesCount);
          let offsetIndex = lastStartIndex + MAX_PROPERTY_LENGTH;
          remainingValueCharactersLength < MAX_PROPERTY_LENGTH && (offsetIndex = lastStartIndex + remainingValueCharactersLength), newProperties[propertyName] = value.slice(lastStartIndex, offsetIndex), remainingValueCharactersLength -= MAX_PROPERTY_LENGTH, lastStartIndex += MAX_PROPERTY_LENGTH;
        }
      }
    }
    return newProperties;
  }
  updateMeasurements(now) {
    let timeSinceIssued = now - this.issuedTime;
    if (this.measurements.timeSinceIssuedMs = timeSinceIssued, this.displayedTime !== void 0) {
      let timeSinceDisplayed = now - this.displayedTime;
      this.measurements.timeSinceDisplayedMs = timeSinceDisplayed;
    }
    this.measurements.current_time === void 0 && (this.measurements.current_time = nowSeconds(now));
  }
  validateData(ctx, store) {
    var _a;
    let invalid;
    if (_TelemetryData.validateTelemetryProperties.Check(this.properties) || (invalid = {
      problem: "properties",
      error: JSON.stringify([..._TelemetryData.validateTelemetryProperties.Errors(this.properties)])
    }), !_TelemetryData.validateTelemetryMeasurements.Check(this.measurements)) {
      let m_err = JSON.stringify([..._TelemetryData.validateTelemetryMeasurements.Errors(this.measurements)]);
      invalid === void 0 ? invalid = {
        problem: "measurements",
        error: m_err
      } : (invalid.problem = "both", invalid.error += `; ${m_err}`);
    }
    if (invalid === void 0) return !0;
    if (shouldFailForDebugPurposes(ctx)) throw new Error(`Invalid telemetry data: ${invalid.problem} ${invalid.error} properties=${JSON.stringify(this.properties)} measurements=${JSON.stringify(this.measurements)}`);
    return telemetryError(ctx, "invalidTelemetryData", _TelemetryData.createAndMarkAsIssued({
      properties: JSON.stringify(this.properties),
      measurements: JSON.stringify(this.measurements),
      problem: invalid.problem,
      validationError: invalid.error
    }), store), isRestricted(store) && telemetryError(ctx, "invalidTelemetryData_in_secure", _TelemetryData.createAndMarkAsIssued({
      problem: invalid.problem,
      requestId: (_a = this.properties.requestId) != null ? _a : "unknown"
    }), 0), !1;
  }
  async makeReadyForSending(ctx, store, includeExp, now) {
    this.extendWithConfigProperties(ctx), this.extendWithEditorAgnosticFields(ctx), this.sanitizeKeys(), this.multiplexProperties(), includeExp === "IncludeExp" && (await this.extendWithExpTelemetry(ctx)), this.updateMeasurements(now), this.validateData(ctx, store) || (this.properties.telemetry_failed_validation = "true"), Object.assign(this.properties, createRequiredProperties(ctx));
  }
};,__name(_TelemetryData, "TelemetryData"), _TelemetryData.validateTelemetryProperties = TypeCompiler.Compile(propertiesSchema), _TelemetryData.validateTelemetryMeasurements = TypeCompiler.Compile(measurementsSchema), _TelemetryData.keysExemptedFromSanitization = ["abexp.assignmentcontext", "VSCode.ABExp.Features"], _TelemetryData.keysToRemoveFromStandardTelemetryHack = ["gitRepoHost", "gitRepoName", "gitRepoOwner", "gitRepoUrl", "gitRepoPath", "repo", "request_option_nwo", "userKind"];,var TelemetryData = _TelemetryData,
  _TelemetryWithExp = class _TelemetryWithExp extends TelemetryData {
    constructor(properties, measurements, issuedTime, filtersAndExp) {
      super(properties, measurements, issuedTime), this.filtersAndExp = filtersAndExp;
    }
    extendedBy(properties, measurements) {
      let newProperties = {
          ...this.properties,
          ...properties
        },
        newMeasurements = {
          ...this.measurements,
          ...measurements
        },
        newData = new _TelemetryWithExp(newProperties, newMeasurements, this.issuedTime, this.filtersAndExp);
      return newData.displayedTime = this.displayedTime, newData;
    }
    async extendWithExpTelemetry(ctx) {
      this.filtersAndExp.exp.addToTelemetry(this), this.filtersAndExp.filters.addToTelemetry(this);
    }
    static createEmptyConfigForTesting() {
      return new _TelemetryWithExp({}, {}, 0, {
        filters: new FilterSettings({}),
        exp: ExpConfig.createEmptyConfig()
      });
    }
  };,__name(_TelemetryWithExp, "TelemetryWithExp");,var TelemetryWithExp = _TelemetryWithExp;,function sendTelemetryEvent(ctx, store, name, data) {
  var _a;
  (_a = ctx.get(TelemetryReporters).getReporter(ctx, store)) == null || _a.sendTelemetryEvent(name, TelemetryData.maybeRemoveRepoInfoFromPropertiesHack(store, data.properties), data.measurements);
},__name(sendTelemetryEvent, "sendTelemetryEvent");,function sendTelemetryErrorEvent(ctx, store, name, data) {
  var _a;
  (_a = ctx.get(TelemetryReporters).getReporter(ctx, store)) == null || _a.sendTelemetryErrorEvent(name, TelemetryData.maybeRemoveRepoInfoFromPropertiesHack(store, data.properties), data.measurements);
},__name(sendTelemetryErrorEvent, "sendTelemetryErrorEvent");,function sendFTTelemetryEvent(ctx, store, name, data) {
  var _a;
  (_a = ctx.get(TelemetryReporters).getFTReporter(ctx)) == null || _a.sendTelemetryEvent(name, TelemetryData.maybeRemoveRepoInfoFromPropertiesHack(store, data.properties), data.measurements);
},__name(sendFTTelemetryEvent, "sendFTTelemetryEvent");,function telemetrizePromptLength(prompt) {
  return prompt.isFimEnabled ? {
    promptPrefixCharLen: prompt.prefix.length,
    promptSuffixCharLen: prompt.suffix.length
  } : {
    promptCharLen: prompt.prefix.length
  };
},__name(telemetrizePromptLength, "telemetrizePromptLength");,function now() {
  return performance.now();
},__name(now, "now");,function nowSeconds(now) {
  return Math.floor(now / 1e3);
},__name(nowSeconds, "nowSeconds");,function shouldSendRestricted(ctx) {
  return ctx.get(TelemetryUserConfig).optedIn;
},__name(shouldSendRestricted, "shouldSendRestricted");,function shouldSendFinetuningTelemetry(ctx) {
  return ctx.get(TelemetryUserConfig).ftFlag !== "";
},__name(shouldSendFinetuningTelemetry, "shouldSendFinetuningTelemetry");,function telemetry(ctx, name, telemetryData, store) {
  return ctx.get(PromiseQueue).register(_telemetry(ctx, name, now(), telemetryData == null ? void 0 : telemetryData.extendedBy(), store));
},__name(telemetry, "telemetry");,async function _telemetry(ctx, name, now, telemetryData, store = 0) {
  let definedTelemetryData = telemetryData || TelemetryData.createAndMarkAsIssued({}, {});
  await definedTelemetryData.makeReadyForSending(ctx, store != null ? store : !1, "IncludeExp", now), (!isRestricted(store) || shouldSendRestricted(ctx)) && sendTelemetryEvent(ctx, store, name, definedTelemetryData), isRestricted(store) && ftTelemetryEvents.includes(name) && shouldSendFinetuningTelemetry(ctx) && sendFTTelemetryEvent(ctx, store, name, definedTelemetryData);
},__name(_telemetry, "_telemetry");,function telemetryExpProblem(ctx, telemetryProperties) {
  return ctx.get(PromiseQueue).register(_telemetryExpProblem(ctx, telemetryProperties, now()));
},__name(telemetryExpProblem, "telemetryExpProblem");,async function _telemetryExpProblem(ctx, telemetryProperties, now) {
  let name = "expProblem",
    definedTelemetryData = TelemetryData.createAndMarkAsIssued(telemetryProperties, {});
  await definedTelemetryData.makeReadyForSending(ctx, 0, "SkipExp", now), sendTelemetryEvent(ctx, 0, name, definedTelemetryData);
},__name(_telemetryExpProblem, "_telemetryExpProblem");,function telemetryRaw(ctx, name, properties, measurements) {
  return ctx.get(PromiseQueue).register(_telemetryRaw(ctx, name, properties, measurements));
},__name(telemetryRaw, "telemetryRaw");,async function _telemetryRaw(ctx, name, props, measurements) {
  let properties = {
    ...props,
    ...createRequiredProperties(ctx)
  };
  sendTelemetryEvent(ctx, 0, name, {
    properties: properties,
    measurements: measurements
  });
},__name(_telemetryRaw, "_telemetryRaw");,function createRequiredProperties(ctx) {
  let editorInfo = ctx.get(EditorAndPluginInfo),
    properties = {
      unique_id: v4_default(),
      common_extname: editorInfo.getEditorPluginInfo().name,
      common_extversion: editorInfo.getEditorPluginInfo().version,
      common_vscodeversion: formatNameAndVersion(editorInfo.getEditorInfo())
    },
    telemetryConfig = ctx.get(TelemetryUserConfig);
  return telemetryConfig.trackingId && (properties.copilot_trackingId = telemetryConfig.trackingId), telemetryConfig.organizationsList && (properties.organizations_list = telemetryConfig.organizationsList), telemetryConfig.enterpriseList && (properties.enterprise_list = telemetryConfig.enterpriseList), telemetryConfig.sku && (properties.sku = telemetryConfig.sku), properties;
},__name(createRequiredProperties, "createRequiredProperties");,var _CopilotNonError = class _CopilotNonError extends Error {
  constructor(thrown) {
    let message;
    try {
      message = JSON.stringify(thrown);
    } catch {
      message = String(thrown);
    }
    super(message), this.name = "CopilotNonError", this.code = (0, t6.SHA256)(t6.enc.Utf16.parse(this.message)).toString().slice(0, 16);
  }
};,__name(_CopilotNonError, "CopilotNonError");,var CopilotNonError = _CopilotNonError;,function telemetryException(ctx, maybeError, transaction, properties, failbotPayload) {
  return ctx.get(PromiseQueue).register(_telemetryException(ctx, maybeError, now(), transaction, {
    ...properties
  }, failbotPayload));
},__name(telemetryException, "telemetryException");,async function _telemetryException(ctx, maybeError, now, transaction, properties, failbotPayload) {
  var _a, _b, _c, _d, _e, _f;
  let error;
  if (maybeError instanceof Error) {
    if (error = maybeError, error.name === "Canceled" && error.message === "Canceled" || error.name === "CodeExpectedError" || error instanceof CopilotAuthError || error instanceof n6.ConnectionError || error instanceof n6.ResponseError) return;
  } else {
    if (error = new CopilotNonError(maybeError), maybeError && typeof maybeError == "object" && maybeError.name === "ExitStatus") return;
    if ((_a = error.stack) != null && _a.startsWith(`${error}
`)) {
      let frames = error.stack.slice(`${error}
`.length).split(`
`);
      /^\s*(?:at )?(?:\w+\.)*_telemetryException\b/.test((_b = frames[0]) != null ? _b : "") && frames.shift(), /^\s*(?:at )?(?:\w+\.)*telemetryException\b/.test((_c = frames[0]) != null ? _c : "") && frames.shift(), error.stack = `${error}
${frames.join(`
`)}`;
    }
  }
  let editorInfo = ctx.get(EditorAndPluginInfo).getEditorInfo(),
    stackPaths;
  editorInfo.root && (stackPaths = [{
    prefix: `${editorInfo.name}:`,
    path: editorInfo.root
  }]);
  let redactedError = redactError(error, stackPaths),
    sendRestricted = shouldSendRestricted(ctx),
    errorType = getErrorType(error),
    sendAsException = errorType === "exception",
    definedTelemetryDataStub = TelemetryData.createAndMarkAsIssued({
      origin: transaction != null ? transaction : "",
      type: error.name,
      code: `${(_d = error.code) != null ? _d : ""}`,
      reason: redactedError.stack || redactedError.toString(),
      message: redactedError.message,
      ...properties
    });
  if (await definedTelemetryDataStub.makeReadyForSending(ctx, 0, "IncludeExp", now), failbotPayload != null && failbotPayload.exception_detail) for (let ed of failbotPayload.exception_detail) ed.value && (sendRestricted ? ed.value = redactMessage(ed.value) : ed.value = "[redacted]");
  if (failbotPayload != null || (failbotPayload = buildPayload(ctx, redactError(error, stackPaths, sendRestricted))), failbotPayload.context = {
    ...failbotPayload.context,
    "copilot_event.unique_id": definedTelemetryDataStub.properties.unique_id,
    "#restricted_telemetry": sendRestricted ? "true" : "false"
  }, transaction && (failbotPayload.context["#origin"] = transaction, failbotPayload.transaction = transaction), failbotPayload.rollup_id !== "auto" && (definedTelemetryDataStub.properties.errno = failbotPayload.rollup_id), failbotPayload.created_at = new Date(definedTelemetryDataStub.issuedTime).toISOString(), sendRestricted) {
    let restrictedError = prepareErrorForRestrictedTelemetry(error, stackPaths),
      definedTelemetryDataRestricted = TelemetryData.createAndMarkAsIssued({
        origin: transaction != null ? transaction : "",
        type: error.name,
        code: `${(_e = error.code) != null ? _e : ""}`,
        reason: restrictedError.stack || restrictedError.toString(),
        message: restrictedError.message,
        ...properties
      });
    failbotPayload.rollup_id !== "auto" && (definedTelemetryDataRestricted.properties.errno = failbotPayload.rollup_id), await definedTelemetryDataRestricted.makeReadyForSending(ctx, 1, "IncludeExp", now), definedTelemetryDataRestricted.properties.unique_id = definedTelemetryDataStub.properties.unique_id, definedTelemetryDataStub.properties.restricted_unique_id = definedTelemetryDataRestricted.properties.unique_id, sendTelemetryEvent(ctx, 1, `error.${errorType}`, definedTelemetryDataRestricted);
  }
  let cacheKey = failbotPayload.rollup_id === "auto" ? (_f = error.stack) != null ? _f : "" : failbotPayload.rollup_id;
  sendAsException && !ctx.get(ExceptionRateLimiter).isThrottled(cacheKey) && (definedTelemetryDataStub.properties.failbot_payload = JSON.stringify(failbotPayload)), sendTelemetryEvent(ctx, 0, `error.${errorType}`, definedTelemetryDataStub);
},__name(_telemetryException, "_telemetryException");,function telemetryCatch(ctx, fn, transaction, properties) {
  let wrapped = __name(async (...args) => {
    try {
      await fn(...args);
    } catch (error) {
      await _telemetryException(ctx, error, now(), transaction, properties);
    }
  }, "wrapped");
  return (...args) => ctx.get(PromiseQueue).register(wrapped(...args));
},__name(telemetryCatch, "telemetryCatch");,function telemetryError(ctx, name, telemetryData, store) {
  return ctx.get(PromiseQueue).register(_telemetryError(ctx, name, now(), telemetryData == null ? void 0 : telemetryData.extendedBy(), store));
},__name(telemetryError, "telemetryError");,async function _telemetryError(ctx, name, now, telemetryData, store = 0) {
  if (isRestricted(store) && !shouldSendRestricted(ctx)) return;
  let definedTelemetryData = telemetryData || TelemetryData.createAndMarkAsIssued({}, {});
  await definedTelemetryData.makeReadyForSending(ctx, store, "IncludeExp", now), sendTelemetryErrorEvent(ctx, store, name, definedTelemetryData);
},__name(_telemetryError, "_telemetryError");,function logEngineCompletion(ctx, completionText, jsonData, requestId, choiceIndex) {
  var _a;
  let telemetryData = TelemetryData.createAndMarkAsIssued({
    completionTextJson: JSON.stringify(completionText),
    choiceIndex: choiceIndex.toString()
  });
  if (jsonData.logprobs) for (let [key, value] of Object.entries(jsonData.logprobs)) telemetryData.properties["logprobs_" + key] = (_a = JSON.stringify(value)) != null ? _a : "unset";
  return telemetryData.extendWithRequestId(requestId), telemetry(ctx, "engine.completion", telemetryData, 1);
},__name(logEngineCompletion, "logEngineCompletion");,function logEnginePrompt(ctx, prompt, telemetryData) {
  let promptTelemetry;
  prompt.isFimEnabled ? promptTelemetry = {
    promptPrefixJson: JSON.stringify(prompt.prefix),
    promptSuffixJson: JSON.stringify(prompt.suffix),
    promptElementRanges: JSON.stringify(prompt.promptElementRanges)
  } : promptTelemetry = {
    promptJson: JSON.stringify(prompt.prefix),
    promptElementRanges: JSON.stringify(prompt.promptElementRanges)
  };
  let telemetryDataWithPrompt = telemetryData.extendedBy(promptTelemetry);
  return telemetry(ctx, "engine.prompt", telemetryDataWithPrompt, 1);
},__name(logEnginePrompt, "logEnginePrompt");