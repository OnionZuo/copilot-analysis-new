var require_source_map_support = __commonJSMin((exports, module) => {
  var SourceMapConsumer = D_e().SourceMapConsumer,
    path = require("path"),
    fs;
  try {
    fs = require("fs"), (!fs.existsSync || !fs.readFileSync) && (fs = null);
  } catch {}
  var bufferFrom = F_e();
  function dynamicRequire(mod, request) {
    return mod.require(request);
  }
  __name(dynamicRequire, "dynamicRequire");
  var errorFormatterInstalled = !1,
    uncaughtShimInstalled = !1,
    emptyCacheBetweenOperations = !1,
    environment = "auto",
    fileContentsCache = {},
    sourceMapCache = {},
    reSourceMap = /^data:application\/json[^,]+base64,/,
    retrieveFileHandlers = [],
    retrieveMapHandlers = [];
  function isInBrowser() {
    return environment === "browser" ? !0 : environment === "node" ? !1 : typeof window < "u" && typeof XMLHttpRequest == "function" && !(window.require && window.module && window.process && window.process.type === "renderer");
  }
  __name(isInBrowser, "isInBrowser");
  function hasGlobalProcessEventEmitter() {
    return typeof process == "object" && process !== null && typeof process.on == "function";
  }
  __name(hasGlobalProcessEventEmitter, "hasGlobalProcessEventEmitter");
  function globalProcessVersion() {
    return typeof process == "object" && process !== null ? process.version : "";
  }
  __name(globalProcessVersion, "globalProcessVersion");
  function globalProcessStderr() {
    if (typeof process == "object" && process !== null) return process.stderr;
  }
  __name(globalProcessStderr, "globalProcessStderr");
  function globalProcessExit(code) {
    if (typeof process == "object" && process !== null && typeof process.exit == "function") return process.exit(code);
  }
  __name(globalProcessExit, "globalProcessExit");
  function handlerExec(list) {
    return function (arg) {
      for (var i = 0; i < list.length; i++) {
        var ret = list[i](arg);
        if (ret) return ret;
      }
      return null;
    };
  }
  __name(handlerExec, "handlerExec");
  var retrieveFile = handlerExec(retrieveFileHandlers);
  retrieveFileHandlers.push(function (path) {
    if (path = path.trim(), /^file:/.test(path) && (path = path.replace(/file:\/\/\/(\w:)?/, function (protocol, drive) {
      return drive ? "" : "/";
    })), path in fileContentsCache) return fileContentsCache[path];
    var contents = "";
    try {
      if (fs) fs.existsSync(path) && (contents = fs.readFileSync(path, "utf8"));else {
        var xhr = new XMLHttpRequest();
        xhr.open("GET", path, !1), xhr.send(null), xhr.readyState === 4 && xhr.status === 200 && (contents = xhr.responseText);
      }
    } catch {}
    return fileContentsCache[path] = contents;
  });
  function supportRelativeURL(file, url) {
    if (!file) return url;
    var dir = path.dirname(file),
      match = /^\w+:\/\/[^\/]*/.exec(dir),
      protocol = match ? match[0] : "",
      startPath = dir.slice(protocol.length);
    return protocol && /^\/\w\:/.test(startPath) ? (protocol += "/", protocol + path.resolve(dir.slice(protocol.length), url).replace(/\\/g, "/")) : protocol + path.resolve(dir.slice(protocol.length), url);
  }
  __name(supportRelativeURL, "supportRelativeURL");
  function retrieveSourceMapURL(source) {
    var fileData;
    if (isInBrowser()) try {
      var xhr = new XMLHttpRequest();
      xhr.open("GET", source, !1), xhr.send(null), fileData = xhr.readyState === 4 ? xhr.responseText : null;
      var sourceMapHeader = xhr.getResponseHeader("SourceMap") || xhr.getResponseHeader("X-SourceMap");
      if (sourceMapHeader) return sourceMapHeader;
    } catch {}
    fileData = retrieveFile(source);
    for (var re = /(?:\/\/[@#][\s]*sourceMappingURL=([^\s'"]+)[\s]*$)|(?:\/\*[@#][\s]*sourceMappingURL=([^\s*'"]+)[\s]*(?:\*\/)[\s]*$)/mg, lastMatch, match; match = re.exec(fileData);) lastMatch = match;
    return lastMatch ? lastMatch[1] : null;
  }
  __name(retrieveSourceMapURL, "retrieveSourceMapURL");
  var retrieveSourceMap = handlerExec(retrieveMapHandlers);
  retrieveMapHandlers.push(function (source) {
    var sourceMappingURL = retrieveSourceMapURL(source);
    if (!sourceMappingURL) return null;
    var sourceMapData;
    if (reSourceMap.test(sourceMappingURL)) {
      var rawData = sourceMappingURL.slice(sourceMappingURL.indexOf(",") + 1);
      sourceMapData = bufferFrom(rawData, "base64").toString(), sourceMappingURL = source;
    } else sourceMappingURL = supportRelativeURL(source, sourceMappingURL), sourceMapData = retrieveFile(sourceMappingURL);
    return sourceMapData ? {
      url: sourceMappingURL,
      map: sourceMapData
    } : null;
  });
  function mapSourcePosition(position) {
    var sourceMap = sourceMapCache[position.source];
    if (!sourceMap) {
      var urlAndMap = retrieveSourceMap(position.source);
      urlAndMap ? (sourceMap = sourceMapCache[position.source] = {
        url: urlAndMap.url,
        map: new SourceMapConsumer(urlAndMap.map)
      }, sourceMap.map.sourcesContent && sourceMap.map.sources.forEach(function (source, i) {
        var contents = sourceMap.map.sourcesContent[i];
        if (contents) {
          var url = supportRelativeURL(sourceMap.url, source);
          fileContentsCache[url] = contents;
        }
      })) : sourceMap = sourceMapCache[position.source] = {
        url: null,
        map: null
      };
    }
    if (sourceMap && sourceMap.map && typeof sourceMap.map.originalPositionFor == "function") {
      var originalPosition = sourceMap.map.originalPositionFor(position);
      if (originalPosition.source !== null) return originalPosition.source = supportRelativeURL(sourceMap.url, originalPosition.source), originalPosition;
    }
    return position;
  }
  __name(mapSourcePosition, "mapSourcePosition");
  function mapEvalOrigin(origin) {
    var match = /^eval at ([^(]+) \((.+):(\d+):(\d+)\)$/.exec(origin);
    if (match) {
      var position = mapSourcePosition({
        source: match[2],
        line: +match[3],
        column: match[4] - 1
      });
      return "eval at " + match[1] + " (" + position.source + ":" + position.line + ":" + (position.column + 1) + ")";
    }
    return match = /^eval at ([^(]+) \((.+)\)$/.exec(origin), match ? "eval at " + match[1] + " (" + mapEvalOrigin(match[2]) + ")" : origin;
  }
  __name(mapEvalOrigin, "mapEvalOrigin");
  function CallSiteToString() {
    var fileName,
      fileLocation = "";
    if (this.isNative()) fileLocation = "native";else {
      fileName = this.getScriptNameOrSourceURL(), !fileName && this.isEval() && (fileLocation = this.getEvalOrigin(), fileLocation += ", "), fileName ? fileLocation += fileName : fileLocation += "<anonymous>";
      var lineNumber = this.getLineNumber();
      if (lineNumber != null) {
        fileLocation += ":" + lineNumber;
        var columnNumber = this.getColumnNumber();
        columnNumber && (fileLocation += ":" + columnNumber);
      }
    }
    var line = "",
      functionName = this.getFunctionName(),
      addSuffix = !0,
      isConstructor = this.isConstructor(),
      isMethodCall = !(this.isToplevel() || isConstructor);
    if (isMethodCall) {
      var typeName = this.getTypeName();
      typeName === "[object Object]" && (typeName = "null");
      var methodName = this.getMethodName();
      functionName ? (typeName && functionName.indexOf(typeName) != 0 && (line += typeName + "."), line += functionName, methodName && functionName.indexOf("." + methodName) != functionName.length - methodName.length - 1 && (line += " [as " + methodName + "]")) : line += typeName + "." + (methodName || "<anonymous>");
    } else isConstructor ? line += "new " + (functionName || "<anonymous>") : functionName ? line += functionName : (line += fileLocation, addSuffix = !1);
    return addSuffix && (line += " (" + fileLocation + ")"), line;
  }
  __name(CallSiteToString, "CallSiteToString");
  function cloneCallSite(frame) {
    var object = {};
    return Object.getOwnPropertyNames(Object.getPrototypeOf(frame)).forEach(function (name) {
      object[name] = /^(?:is|get)/.test(name) ? function () {
        return frame[name].call(frame);
      } : frame[name];
    }), object.toString = CallSiteToString, object;
  }
  __name(cloneCallSite, "cloneCallSite");
  function wrapCallSite(frame, state) {
    if (state === void 0 && (state = {
      nextPosition: null,
      curPosition: null
    }), frame.isNative()) return state.curPosition = null, frame;
    var source = frame.getFileName() || frame.getScriptNameOrSourceURL();
    if (source) {
      var line = frame.getLineNumber(),
        column = frame.getColumnNumber() - 1,
        noHeader = /^v(10\.1[6-9]|10\.[2-9][0-9]|10\.[0-9]{3,}|1[2-9]\d*|[2-9]\d|\d{3,}|11\.11)/,
        headerLength = noHeader.test(globalProcessVersion()) ? 0 : 62;
      line === 1 && column > headerLength && !isInBrowser() && !frame.isEval() && (column -= headerLength);
      var position = mapSourcePosition({
        source: source,
        line: line,
        column: column
      });
      state.curPosition = position, frame = cloneCallSite(frame);
      var originalFunctionName = frame.getFunctionName;
      return frame.getFunctionName = function () {
        return state.nextPosition == null ? originalFunctionName() : state.nextPosition.name || originalFunctionName();
      }, frame.getFileName = function () {
        return position.source;
      }, frame.getLineNumber = function () {
        return position.line;
      }, frame.getColumnNumber = function () {
        return position.column + 1;
      }, frame.getScriptNameOrSourceURL = function () {
        return position.source;
      }, frame;
    }
    var origin = frame.isEval() && frame.getEvalOrigin();
    return origin && (origin = mapEvalOrigin(origin), frame = cloneCallSite(frame), frame.getEvalOrigin = function () {
      return origin;
    }), frame;
  }
  __name(wrapCallSite, "wrapCallSite");
  function prepareStackTrace(error, stack) {
    emptyCacheBetweenOperations && (fileContentsCache = {}, sourceMapCache = {});
    for (var name = error.name || "Error", message = error.message || "", errorString = name + ": " + message, state = {
        nextPosition: null,
        curPosition: null
      }, processedStack = [], i = stack.length - 1; i >= 0; i--) processedStack.push(`
    at ` + wrapCallSite(stack[i], state)), state.nextPosition = state.curPosition;
    return state.curPosition = state.nextPosition = null, errorString + processedStack.reverse().join("");
  }
  __name(prepareStackTrace, "prepareStackTrace");
  function getErrorSource(error) {
    var match = /\n    at [^(]+ \((.*):(\d+):(\d+)\)/.exec(error.stack);
    if (match) {
      var source = match[1],
        line = +match[2],
        column = +match[3],
        contents = fileContentsCache[source];
      if (!contents && fs && fs.existsSync(source)) try {
        contents = fs.readFileSync(source, "utf8");
      } catch {
        contents = "";
      }
      if (contents) {
        var code = contents.split(/(?:\r\n|\r|\n)/)[line - 1];
        if (code) return source + ":" + line + `
` + code + `
` + new Array(column).join(" ") + "^";
      }
    }
    return null;
  }
  __name(getErrorSource, "getErrorSource");
  function printErrorAndExit(error) {
    var source = getErrorSource(error),
      stderr = globalProcessStderr();
    stderr && stderr._handle && stderr._handle.setBlocking && stderr._handle.setBlocking(!0), source && (console.error(), console.error(source)), console.error(error.stack), globalProcessExit(1);
  }
  __name(printErrorAndExit, "printErrorAndExit");
  function shimEmitUncaughtException() {
    var origEmit = process.emit;
    process.emit = function (type) {
      if (type === "uncaughtException") {
        var hasStack = arguments[1] && arguments[1].stack,
          hasListeners = this.listeners(type).length > 0;
        if (hasStack && !hasListeners) return printErrorAndExit(arguments[1]);
      }
      return origEmit.apply(this, arguments);
    };
  }
  __name(shimEmitUncaughtException, "shimEmitUncaughtException");
  var originalRetrieveFileHandlers = retrieveFileHandlers.slice(0),
    originalRetrieveMapHandlers = retrieveMapHandlers.slice(0);
  exports.wrapCallSite = wrapCallSite;
  exports.getErrorSource = getErrorSource;
  exports.mapSourcePosition = mapSourcePosition;
  exports.retrieveSourceMap = retrieveSourceMap;
  exports.install = function (options) {
    if (options = options || {}, options.environment && (environment = options.environment, ["node", "browser", "auto"].indexOf(environment) === -1)) throw new Error("environment " + environment + " was unknown. Available options are {auto, browser, node}");
    if (options.retrieveFile && (options.overrideRetrieveFile && (retrieveFileHandlers.length = 0), retrieveFileHandlers.unshift(options.retrieveFile)), options.retrieveSourceMap && (options.overrideRetrieveSourceMap && (retrieveMapHandlers.length = 0), retrieveMapHandlers.unshift(options.retrieveSourceMap)), options.hookRequire && !isInBrowser()) {
      var Module = dynamicRequire(module, "module"),
        $compile = Module.prototype._compile;
      $compile.__sourceMapSupport || (Module.prototype._compile = function (content, filename) {
        return fileContentsCache[filename] = content, sourceMapCache[filename] = void 0, $compile.call(this, content, filename);
      }, Module.prototype._compile.__sourceMapSupport = !0);
    }
    if (emptyCacheBetweenOperations || (emptyCacheBetweenOperations = "emptyCacheBetweenOperations" in options ? options.emptyCacheBetweenOperations : !1), errorFormatterInstalled || (errorFormatterInstalled = !0, Error.prepareStackTrace = prepareStackTrace), !uncaughtShimInstalled) {
      var installHandler = "handleUncaughtExceptions" in options ? options.handleUncaughtExceptions : !0;
      try {
        var worker_threads = dynamicRequire(module, "worker_threads");
        worker_threads.isMainThread === !1 && (installHandler = !1);
      } catch {}
      installHandler && hasGlobalProcessEventEmitter() && (uncaughtShimInstalled = !0, shimEmitUncaughtException());
    }
  };
  exports.resetRetrieveHandlers = function () {
    retrieveFileHandlers.length = 0, retrieveMapHandlers.length = 0, retrieveFileHandlers = originalRetrieveFileHandlers.slice(0), retrieveMapHandlers = originalRetrieveMapHandlers.slice(0), retrieveSourceMap = handlerExec(retrieveMapHandlers), retrieveFile = handlerExec(retrieveFileHandlers);
  };
});