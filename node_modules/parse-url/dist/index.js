var require_dist = __commonJSMin((exports, module) => {
  "use strict";

  var require$$1 = uve();
  function _interopDefaultLegacy(e) {
    return e && typeof e == "object" && "default" in e ? e : {
      default: e
    };
  }
  __name(_interopDefaultLegacy, "_interopDefaultLegacy");
  var require$$1__default = _interopDefaultLegacy(require$$1);
  function getAugmentedNamespace(n) {
    if (n.__esModule) return n;
    var f = n.default;
    if (typeof f == "function") {
      var a = __name(function a() {
        if (this instanceof a) {
          var args = [null];
          args.push.apply(args, arguments);
          var Ctor = Function.bind.apply(f, args);
          return new Ctor();
        }
        return f.apply(this, arguments);
      }, "a");
      a.prototype = f.prototype;
    } else a = {};
    return Object.defineProperty(a, "__esModule", {
      value: !0
    }), Object.keys(n).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(n, k);
      Object.defineProperty(a, k, d.get ? d : {
        enumerable: !0,
        get: __name(function () {
          return n[k];
        }, "get")
      });
    }), a;
  }
  __name(getAugmentedNamespace, "getAugmentedNamespace");
  var src = {},
    DATA_URL_DEFAULT_MIME_TYPE = "text/plain",
    DATA_URL_DEFAULT_CHARSET = "us-ascii",
    testParameter = __name((name, filters) => filters.some(filter => filter instanceof RegExp ? filter.test(name) : filter === name), "testParameter"),
    normalizeDataURL = __name((urlString, {
      stripHash: stripHash
    }) => {
      let match = /^data:(?<type>[^,]*?),(?<data>[^#]*?)(?:#(?<hash>.*))?$/.exec(urlString);
      if (!match) throw new Error(`Invalid URL: ${urlString}`);
      let {
          type: type,
          data: data,
          hash: hash
        } = match.groups,
        mediaType = type.split(";");
      hash = stripHash ? "" : hash;
      let isBase64 = !1;
      mediaType[mediaType.length - 1] === "base64" && (mediaType.pop(), isBase64 = !0);
      let mimeType = (mediaType.shift() || "").toLowerCase(),
        normalizedMediaType = [...mediaType.map(attribute => {
          let [key, value = ""] = attribute.split("=").map(string => string.trim());
          return key === "charset" && (value = value.toLowerCase(), value === DATA_URL_DEFAULT_CHARSET) ? "" : `${key}${value ? `=${value}` : ""}`;
        }).filter(Boolean)];
      return isBase64 && normalizedMediaType.push("base64"), (normalizedMediaType.length > 0 || mimeType && mimeType !== DATA_URL_DEFAULT_MIME_TYPE) && normalizedMediaType.unshift(mimeType), `data:${normalizedMediaType.join(";")},${isBase64 ? data.trim() : data}${hash ? `#${hash}` : ""}`;
    }, "normalizeDataURL");
  function normalizeUrl(urlString, options) {
    if (options = {
      defaultProtocol: "http:",
      normalizeProtocol: !0,
      forceHttp: !1,
      forceHttps: !1,
      stripAuthentication: !0,
      stripHash: !1,
      stripTextFragment: !0,
      stripWWW: !0,
      removeQueryParameters: [/^utm_\w+/i],
      removeTrailingSlash: !0,
      removeSingleSlash: !0,
      removeDirectoryIndex: !1,
      sortQueryParameters: !0,
      ...options
    }, urlString = urlString.trim(), /^data:/i.test(urlString)) return normalizeDataURL(urlString, options);
    if (/^view-source:/i.test(urlString)) throw new Error("`view-source:` is not supported as it is a non-standard protocol");
    let hasRelativeProtocol = urlString.startsWith("//");
    !hasRelativeProtocol && /^\.*\//.test(urlString) || (urlString = urlString.replace(/^(?!(?:\w+:)?\/\/)|^\/\//, options.defaultProtocol));
    let urlObject = new URL(urlString);
    if (options.forceHttp && options.forceHttps) throw new Error("The `forceHttp` and `forceHttps` options cannot be used together");
    if (options.forceHttp && urlObject.protocol === "https:" && (urlObject.protocol = "http:"), options.forceHttps && urlObject.protocol === "http:" && (urlObject.protocol = "https:"), options.stripAuthentication && (urlObject.username = "", urlObject.password = ""), options.stripHash ? urlObject.hash = "" : options.stripTextFragment && (urlObject.hash = urlObject.hash.replace(/#?:~:text.*?$/i, "")), urlObject.pathname) {
      let protocolRegex = /\b[a-z][a-z\d+\-.]{1,50}:\/\//g,
        lastIndex = 0,
        result = "";
      for (;;) {
        let match = protocolRegex.exec(urlObject.pathname);
        if (!match) break;
        let protocol = match[0],
          protocolAtIndex = match.index,
          intermediate = urlObject.pathname.slice(lastIndex, protocolAtIndex);
        result += intermediate.replace(/\/{2,}/g, "/"), result += protocol, lastIndex = protocolAtIndex + protocol.length;
      }
      let remnant = urlObject.pathname.slice(lastIndex, urlObject.pathname.length);
      result += remnant.replace(/\/{2,}/g, "/"), urlObject.pathname = result;
    }
    if (urlObject.pathname) try {
      urlObject.pathname = decodeURI(urlObject.pathname);
    } catch {}
    if (options.removeDirectoryIndex === !0 && (options.removeDirectoryIndex = [/^index\.[a-z]+$/]), Array.isArray(options.removeDirectoryIndex) && options.removeDirectoryIndex.length > 0) {
      let pathComponents = urlObject.pathname.split("/"),
        lastComponent = pathComponents[pathComponents.length - 1];
      testParameter(lastComponent, options.removeDirectoryIndex) && (pathComponents = pathComponents.slice(0, -1), urlObject.pathname = pathComponents.slice(1).join("/") + "/");
    }
    if (urlObject.hostname && (urlObject.hostname = urlObject.hostname.replace(/\.$/, ""), options.stripWWW && /^www\.(?!www\.)[a-z\-\d]{1,63}\.[a-z.\-\d]{2,63}$/.test(urlObject.hostname) && (urlObject.hostname = urlObject.hostname.replace(/^www\./, ""))), Array.isArray(options.removeQueryParameters)) for (let key of [...urlObject.searchParams.keys()]) testParameter(key, options.removeQueryParameters) && urlObject.searchParams.delete(key);
    if (options.removeQueryParameters === !0 && (urlObject.search = ""), options.sortQueryParameters) {
      urlObject.searchParams.sort();
      try {
        urlObject.search = decodeURIComponent(urlObject.search);
      } catch {}
    }
    options.removeTrailingSlash && (urlObject.pathname = urlObject.pathname.replace(/\/$/, ""));
    let oldUrlString = urlString;
    return urlString = urlObject.toString(), !options.removeSingleSlash && urlObject.pathname === "/" && !oldUrlString.endsWith("/") && urlObject.hash === "" && (urlString = urlString.replace(/\/$/, "")), (options.removeTrailingSlash || urlObject.pathname === "/") && urlObject.hash === "" && options.removeSingleSlash && (urlString = urlString.replace(/\/$/, "")), hasRelativeProtocol && !options.normalizeProtocol && (urlString = urlString.replace(/^http:\/\//, "//")), options.stripProtocol && (urlString = urlString.replace(/^(?:https?:)?\/\//, "")), urlString;
  }
  __name(normalizeUrl, "normalizeUrl");
  var normalizeUrl$1 = Object.freeze({
      __proto__: null,
      default: normalizeUrl
    }),
    require$$0 = getAugmentedNamespace(normalizeUrl$1);
  Object.defineProperty(src, "__esModule", {
    value: !0
  });
  var _typeof = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function (obj) {
      return typeof obj;
    } : function (obj) {
      return obj && typeof Symbol == "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    },
    _normalizeUrl = require$$0,
    _normalizeUrl2 = _interopRequireDefault(_normalizeUrl),
    _parsePath = require$$1__default.default,
    _parsePath2 = _interopRequireDefault(_parsePath);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }
  __name(_interopRequireDefault, "_interopRequireDefault");
  var parseUrl = __name(function parseUrl(url) {
    var normalize = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1,
      GIT_RE = /^(?:([a-zA-Z_][a-zA-Z0-9_-]{0,31})@|https?:\/\/)([\w\.\-@]+)[\/:](([\~,\.\w,\-,\_,\/,\s]|%[0-9A-Fa-f]{2})+?(?:\.git|\/)?)$/,
      throwErr = __name(function (msg) {
        var err = new Error(msg);
        throw err.subject_url = url, err;
      }, "throwErr");
    (typeof url != "string" || !url.trim()) && throwErr("Invalid url."), url.length > parseUrl.MAX_INPUT_LENGTH && throwErr("Input exceeds maximum length. If needed, change the value of parseUrl.MAX_INPUT_LENGTH."), normalize && ((typeof normalize > "u" ? "undefined" : _typeof(normalize)) !== "object" && (normalize = {
      stripHash: !1
    }), url = (0, _normalizeUrl2.default)(url, normalize));
    var parsed = (0, _parsePath2.default)(url);
    if (parsed.parse_failed) {
      var matched = parsed.href.match(GIT_RE);
      matched ? (parsed.protocols = ["ssh"], parsed.protocol = "ssh", parsed.resource = matched[2], parsed.host = matched[2], parsed.user = matched[1], parsed.pathname = "/" + matched[3], parsed.parse_failed = !1) : throwErr("URL parsing failed.");
    }
    return parsed;
  }, "parseUrl");
  parseUrl.MAX_INPUT_LENGTH = 2048;
  var _default = src.default = parseUrl;
  module.exports = _default;
});