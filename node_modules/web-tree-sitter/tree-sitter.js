var require_tree_sitter = __commonJSMin((exports, module) => {
  var Module = Module !== void 0 ? Module : {},
    TreeSitter = function () {
      var initPromise,
        document = typeof window == "object" ? {
          currentScript: window.document.currentScript
        } : null;
      let _Parser = class _Parser {
        constructor() {
          this.initialize();
        }
        initialize() {
          throw new Error("cannot construct a Parser before calling `init()`");
        }
        static init(moduleOptions) {
          return initPromise || (Module = Object.assign({}, Module, moduleOptions), initPromise = new Promise(resolveInitPromise => {
            var moduleOverrides = Object.assign({}, Module),
              arguments_ = [],
              thisProgram = "./this.program",
              quit_ = __name((e, t) => {
                throw t;
              }, "quit_"),
              ENVIRONMENT_IS_WEB = typeof window == "object",
              ENVIRONMENT_IS_WORKER = typeof importScripts == "function",
              ENVIRONMENT_IS_NODE = typeof process == "object" && typeof process.versions == "object" && typeof process.versions.node == "string",
              scriptDirectory = "",
              read_,
              readAsync,
              readBinary,
              setWindowTitle;
            function locateFile(e) {
              return Module.locateFile ? Module.locateFile(e, scriptDirectory) : scriptDirectory + e;
            }
            __name(locateFile, "locateFile");
            function logExceptionOnExit(e) {
              e instanceof ExitStatus || err("exiting due to exception: " + e);
            }
            if (__name(logExceptionOnExit, "logExceptionOnExit"), ENVIRONMENT_IS_NODE) {
              var fs = require("fs"),
                nodePath = require("path");
              scriptDirectory = ENVIRONMENT_IS_WORKER ? nodePath.dirname(scriptDirectory) + "/" : __dirname + "/", read_ = __name((e, t) => (e = isFileURI(e) ? new URL(e) : nodePath.normalize(e), fs.readFileSync(e, t ? void 0 : "utf8")), "read_"), readBinary = __name(e => {
                var t = read_(e, !0);
                return t.buffer || (t = new Uint8Array(t)), t;
              }, "readBinary"), readAsync = __name((e, t, r) => {
                e = isFileURI(e) ? new URL(e) : nodePath.normalize(e), fs.readFile(e, function (e, _) {
                  e ? r(e) : t(_.buffer);
                });
              }, "readAsync"), process.argv.length > 1 && (thisProgram = process.argv[1].replace(/\\/g, "/")), arguments_ = process.argv.slice(2), typeof module < "u" && (module.exports = Module), quit_ = __name((e, t) => {
                if (keepRuntimeAlive()) throw process.exitCode = e, t;
                logExceptionOnExit(t), process.exit(e);
              }, "quit_"), Module.inspect = function () {
                return "[Emscripten Module object]";
              };
            } else (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) && (ENVIRONMENT_IS_WORKER ? scriptDirectory = self.location.href : document !== void 0 && document.currentScript && (scriptDirectory = document.currentScript.src), scriptDirectory = scriptDirectory.indexOf("blob:") !== 0 ? scriptDirectory.substr(0, scriptDirectory.replace(/[?#].*/, "").lastIndexOf("/") + 1) : "", read_ = __name(e => {
              var t = new XMLHttpRequest();
              return t.open("GET", e, !1), t.send(null), t.responseText;
            }, "read_"), ENVIRONMENT_IS_WORKER && (readBinary = __name(e => {
              var t = new XMLHttpRequest();
              return t.open("GET", e, !1), t.responseType = "arraybuffer", t.send(null), new Uint8Array(t.response);
            }, "readBinary")), readAsync = __name((e, t, r) => {
              var _ = new XMLHttpRequest();
              _.open("GET", e, !0), _.responseType = "arraybuffer", _.onload = () => {
                _.status == 200 || _.status == 0 && _.response ? t(_.response) : r();
              }, _.onerror = r, _.send(null);
            }, "readAsync"), setWindowTitle = __name(e => document.title = e, "setWindowTitle"));
            var out = Module.print || console.log.bind(console),
              err = Module.printErr || console.warn.bind(console);
            Object.assign(Module, moduleOverrides), moduleOverrides = null, Module.arguments && (arguments_ = Module.arguments), Module.thisProgram && (thisProgram = Module.thisProgram), Module.quit && (quit_ = Module.quit);
            var STACK_ALIGN = 16,
              dynamicLibraries = Module.dynamicLibraries || [],
              wasmBinary;
            Module.wasmBinary && (wasmBinary = Module.wasmBinary);
            var noExitRuntime = Module.noExitRuntime || !0,
              wasmMemory;
            typeof WebAssembly != "object" && abort("no native wasm support detected");
            var ABORT = !1,
              EXITSTATUS,
              UTF8Decoder = typeof TextDecoder < "u" ? new TextDecoder("utf8") : void 0,
              buffer,
              HEAP8,
              HEAPU8,
              HEAP16,
              HEAPU16,
              HEAP32,
              HEAPU32,
              HEAPF32,
              HEAPF64;
            function UTF8ArrayToString(e, t, r) {
              for (var _ = t + r, n = t; e[n] && !(n >= _);) ++n;
              if (n - t > 16 && e.buffer && UTF8Decoder) return UTF8Decoder.decode(e.subarray(t, n));
              for (var s = ""; t < n;) {
                var a = e[t++];
                if (128 & a) {
                  var o = 63 & e[t++];
                  if ((224 & a) != 192) {
                    var i = 63 & e[t++];
                    if ((a = (240 & a) == 224 ? (15 & a) << 12 | o << 6 | i : (7 & a) << 18 | o << 12 | i << 6 | 63 & e[t++]) < 65536) s += String.fromCharCode(a);else {
                      var l = a - 65536;
                      s += String.fromCharCode(55296 | l >> 10, 56320 | 1023 & l);
                    }
                  } else s += String.fromCharCode((31 & a) << 6 | o);
                } else s += String.fromCharCode(a);
              }
              return s;
            }
            __name(UTF8ArrayToString, "UTF8ArrayToString");
            function UTF8ToString(e, t) {
              return e ? UTF8ArrayToString(HEAPU8, e, t) : "";
            }
            __name(UTF8ToString, "UTF8ToString");
            function stringToUTF8Array(e, t, r, _) {
              if (!(_ > 0)) return 0;
              for (var n = r, s = r + _ - 1, a = 0; a < e.length; ++a) {
                var o = e.charCodeAt(a);
                if (o >= 55296 && o <= 57343 && (o = 65536 + ((1023 & o) << 10) | 1023 & e.charCodeAt(++a)), o <= 127) {
                  if (r >= s) break;
                  t[r++] = o;
                } else if (o <= 2047) {
                  if (r + 1 >= s) break;
                  t[r++] = 192 | o >> 6, t[r++] = 128 | 63 & o;
                } else if (o <= 65535) {
                  if (r + 2 >= s) break;
                  t[r++] = 224 | o >> 12, t[r++] = 128 | o >> 6 & 63, t[r++] = 128 | 63 & o;
                } else {
                  if (r + 3 >= s) break;
                  t[r++] = 240 | o >> 18, t[r++] = 128 | o >> 12 & 63, t[r++] = 128 | o >> 6 & 63, t[r++] = 128 | 63 & o;
                }
              }
              return t[r] = 0, r - n;
            }
            __name(stringToUTF8Array, "stringToUTF8Array");
            function stringToUTF8(e, t, r) {
              return stringToUTF8Array(e, HEAPU8, t, r);
            }
            __name(stringToUTF8, "stringToUTF8");
            function lengthBytesUTF8(e) {
              for (var t = 0, r = 0; r < e.length; ++r) {
                var _ = e.charCodeAt(r);
                _ <= 127 ? t++ : _ <= 2047 ? t += 2 : _ >= 55296 && _ <= 57343 ? (t += 4, ++r) : t += 3;
              }
              return t;
            }
            __name(lengthBytesUTF8, "lengthBytesUTF8");
            function updateGlobalBufferAndViews(e) {
              buffer = e, Module.HEAP8 = HEAP8 = new Int8Array(e), Module.HEAP16 = HEAP16 = new Int16Array(e), Module.HEAP32 = HEAP32 = new Int32Array(e), Module.HEAPU8 = HEAPU8 = new Uint8Array(e), Module.HEAPU16 = HEAPU16 = new Uint16Array(e), Module.HEAPU32 = HEAPU32 = new Uint32Array(e), Module.HEAPF32 = HEAPF32 = new Float32Array(e), Module.HEAPF64 = HEAPF64 = new Float64Array(e);
            }
            __name(updateGlobalBufferAndViews, "updateGlobalBufferAndViews");
            var INITIAL_MEMORY = Module.INITIAL_MEMORY || 33554432;
            wasmMemory = Module.wasmMemory ? Module.wasmMemory : new WebAssembly.Memory({
              initial: INITIAL_MEMORY / 65536,
              maximum: 32768
            }), wasmMemory && (buffer = wasmMemory.buffer), INITIAL_MEMORY = buffer.byteLength, updateGlobalBufferAndViews(buffer);
            var wasmTable = new WebAssembly.Table({
                initial: 20,
                element: "anyfunc"
              }),
              __ATPRERUN__ = [],
              __ATINIT__ = [],
              __ATMAIN__ = [],
              __ATPOSTRUN__ = [],
              __RELOC_FUNCS__ = [],
              runtimeInitialized = !1;
            function keepRuntimeAlive() {
              return noExitRuntime;
            }
            __name(keepRuntimeAlive, "keepRuntimeAlive");
            function preRun() {
              if (Module.preRun) for (typeof Module.preRun == "function" && (Module.preRun = [Module.preRun]); Module.preRun.length;) addOnPreRun(Module.preRun.shift());
              callRuntimeCallbacks(__ATPRERUN__);
            }
            __name(preRun, "preRun");
            function initRuntime() {
              runtimeInitialized = !0, callRuntimeCallbacks(__RELOC_FUNCS__), callRuntimeCallbacks(__ATINIT__);
            }
            __name(initRuntime, "initRuntime");
            function preMain() {
              callRuntimeCallbacks(__ATMAIN__);
            }
            __name(preMain, "preMain");
            function postRun() {
              if (Module.postRun) for (typeof Module.postRun == "function" && (Module.postRun = [Module.postRun]); Module.postRun.length;) addOnPostRun(Module.postRun.shift());
              callRuntimeCallbacks(__ATPOSTRUN__);
            }
            __name(postRun, "postRun");
            function addOnPreRun(e) {
              __ATPRERUN__.unshift(e);
            }
            __name(addOnPreRun, "addOnPreRun");
            function addOnInit(e) {
              __ATINIT__.unshift(e);
            }
            __name(addOnInit, "addOnInit");
            function addOnPostRun(e) {
              __ATPOSTRUN__.unshift(e);
            }
            __name(addOnPostRun, "addOnPostRun");
            var runDependencies = 0,
              runDependencyWatcher = null,
              dependenciesFulfilled = null;
            function addRunDependency(e) {
              runDependencies++, Module.monitorRunDependencies && Module.monitorRunDependencies(runDependencies);
            }
            __name(addRunDependency, "addRunDependency");
            function removeRunDependency(e) {
              if (runDependencies--, Module.monitorRunDependencies && Module.monitorRunDependencies(runDependencies), runDependencies == 0 && (runDependencyWatcher !== null && (clearInterval(runDependencyWatcher), runDependencyWatcher = null), dependenciesFulfilled)) {
                var t = dependenciesFulfilled;
                dependenciesFulfilled = null, t();
              }
            }
            __name(removeRunDependency, "removeRunDependency");
            function abort(e) {
              throw Module.onAbort && Module.onAbort(e), err(e = "Aborted(" + e + ")"), ABORT = !0, EXITSTATUS = 1, e += ". Build with -sASSERTIONS for more info.", new WebAssembly.RuntimeError(e);
            }
            __name(abort, "abort");
            var dataURIPrefix = "data:application/octet-stream;base64,",
              wasmBinaryFile,
              tempDouble,
              tempI64;
            function isDataURI(e) {
              return e.startsWith(dataURIPrefix);
            }
            __name(isDataURI, "isDataURI");
            function isFileURI(e) {
              return e.startsWith("file://");
            }
            __name(isFileURI, "isFileURI");
            function getBinary(e) {
              try {
                if (e == wasmBinaryFile && wasmBinary) return new Uint8Array(wasmBinary);
                if (readBinary) return readBinary(e);
                throw "both async and sync fetching of the wasm failed";
              } catch (e) {
                abort(e);
              }
            }
            __name(getBinary, "getBinary");
            function getBinaryPromise() {
              if (!wasmBinary && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER)) {
                if (typeof fetch == "function" && !isFileURI(wasmBinaryFile)) return fetch(wasmBinaryFile, {
                  credentials: "same-origin"
                }).then(function (e) {
                  if (!e.ok) throw "failed to load wasm binary file at '" + wasmBinaryFile + "'";
                  return e.arrayBuffer();
                }).catch(function () {
                  return getBinary(wasmBinaryFile);
                });
                if (readAsync) return new Promise(function (e, t) {
                  readAsync(wasmBinaryFile, function (t) {
                    e(new Uint8Array(t));
                  }, t);
                });
              }
              return Promise.resolve().then(function () {
                return getBinary(wasmBinaryFile);
              });
            }
            __name(getBinaryPromise, "getBinaryPromise");
            function createWasm() {
              var e = {
                env: asmLibraryArg,
                wasi_snapshot_preview1: asmLibraryArg,
                "GOT.mem": new Proxy(asmLibraryArg, GOTHandler),
                "GOT.func": new Proxy(asmLibraryArg, GOTHandler)
              };
              function t(e, t) {
                var r = e.exports;
                r = relocateExports(r, 1024);
                var _ = getDylinkMetadata(t);
                _.neededDynlibs && (dynamicLibraries = _.neededDynlibs.concat(dynamicLibraries)), mergeLibSymbols(r, "main"), Module.asm = r, addOnInit(Module.asm.__wasm_call_ctors), __RELOC_FUNCS__.push(Module.asm.__wasm_apply_data_relocs), removeRunDependency("wasm-instantiate");
              }
              __name(t, "t");
              function r(e) {
                t(e.instance, e.module);
              }
              __name(r, "r");
              function _(t) {
                return getBinaryPromise().then(function (t) {
                  return WebAssembly.instantiate(t, e);
                }).then(function (e) {
                  return e;
                }).then(t, function (e) {
                  err("failed to asynchronously prepare wasm: " + e), abort(e);
                });
              }
              if (__name(_, "_"), addRunDependency("wasm-instantiate"), Module.instantiateWasm) try {
                return Module.instantiateWasm(e, t);
              } catch (e) {
                return err("Module.instantiateWasm callback failed with error: " + e), !1;
              }
              return wasmBinary || typeof WebAssembly.instantiateStreaming != "function" || isDataURI(wasmBinaryFile) || isFileURI(wasmBinaryFile) || ENVIRONMENT_IS_NODE || typeof fetch != "function" ? _(r) : fetch(wasmBinaryFile, {
                credentials: "same-origin"
              }).then(function (t) {
                return WebAssembly.instantiateStreaming(t, e).then(r, function (e) {
                  return err("wasm streaming compile failed: " + e), err("falling back to ArrayBuffer instantiation"), _(r);
                });
              }), {};
            }
            __name(createWasm, "createWasm"), wasmBinaryFile = "tree-sitter.wasm", isDataURI(wasmBinaryFile) || (wasmBinaryFile = locateFile(wasmBinaryFile));
            var ASM_CONSTS = {};
            function ExitStatus(e) {
              this.name = "ExitStatus", this.message = "Program terminated with exit(" + e + ")", this.status = e;
            }
            __name(ExitStatus, "ExitStatus");
            var GOT = {},
              CurrentModuleWeakSymbols = new Set([]),
              GOTHandler = {
                get: __name(function (e, t) {
                  var r = GOT[t];
                  return r || (r = GOT[t] = new WebAssembly.Global({
                    value: "i32",
                    mutable: !0
                  })), CurrentModuleWeakSymbols.has(t) || (r.required = !0), r;
                }, "get")
              };
            function callRuntimeCallbacks(e) {
              for (; e.length > 0;) e.shift()(Module);
            }
            __name(callRuntimeCallbacks, "callRuntimeCallbacks");
            function getDylinkMetadata(e) {
              var t = 0,
                r = 0;
              function _() {
                for (var r = 0, _ = 1;;) {
                  var n = e[t++];
                  if (r += (127 & n) * _, _ *= 128, !(128 & n)) break;
                }
                return r;
              }
              __name(_, "_");
              function n() {
                var r = _();
                return UTF8ArrayToString(e, (t += r) - r, r);
              }
              __name(n, "n");
              function s(e, t) {
                if (e) throw new Error(t);
              }
              __name(s, "s");
              var a = "dylink.0";
              if (e instanceof WebAssembly.Module) {
                var o = WebAssembly.Module.customSections(e, a);
                o.length === 0 && (a = "dylink", o = WebAssembly.Module.customSections(e, a)), s(o.length === 0, "need dylink section"), r = (e = new Uint8Array(o[0])).length;
              } else {
                s(new Uint32Array(new Uint8Array(e.subarray(0, 24)).buffer)[0] != 1836278016, "need to see wasm magic number"), s(e[8] !== 0, "need the dylink section to be first"), t = 9;
                var i = _();
                r = t + i, a = n();
              }
              var l = {
                neededDynlibs: [],
                tlsExports: new Set(),
                weakImports: new Set()
              };
              if (a == "dylink") {
                l.memorySize = _(), l.memoryAlign = _(), l.tableSize = _(), l.tableAlign = _();
                for (var u = _(), d = 0; d < u; ++d) {
                  var c = n();
                  l.neededDynlibs.push(c);
                }
              } else for (s(a !== "dylink.0"); t < r;) {
                var m = e[t++],
                  p = _();
                if (m === 1) l.memorySize = _(), l.memoryAlign = _(), l.tableSize = _(), l.tableAlign = _();else if (m === 2) for (u = _(), d = 0; d < u; ++d) c = n(), l.neededDynlibs.push(c);else if (m === 3) for (var f = _(); f--;) {
                  var h = n();
                  256 & _() && l.tlsExports.add(h);
                } else if (m === 4) for (f = _(); f--;) n(), h = n(), (3 & _()) == 1 && l.weakImports.add(h);else t += p;
              }
              return l;
            }
            __name(getDylinkMetadata, "getDylinkMetadata");
            function getValue(e, t = "i8") {
              switch (t.endsWith("*") && (t = "*"), t) {
                case "i1":
                case "i8":
                  return HEAP8[e >> 0];
                case "i16":
                  return HEAP16[e >> 1];
                case "i32":
                case "i64":
                  return HEAP32[e >> 2];
                case "float":
                  return HEAPF32[e >> 2];
                case "double":
                  return HEAPF64[e >> 3];
                case "*":
                  return HEAPU32[e >> 2];
                default:
                  abort("invalid type for getValue: " + t);
              }
              return null;
            }
            __name(getValue, "getValue");
            function asmjsMangle(e) {
              return e.indexOf("dynCall_") == 0 || ["stackAlloc", "stackSave", "stackRestore", "getTempRet0", "setTempRet0"].includes(e) ? e : "_" + e;
            }
            __name(asmjsMangle, "asmjsMangle");
            function mergeLibSymbols(e, t) {
              for (var r in e) if (e.hasOwnProperty(r)) {
                asmLibraryArg.hasOwnProperty(r) || (asmLibraryArg[r] = e[r]);
                var _ = asmjsMangle(r);
                Module.hasOwnProperty(_) || (Module[_] = e[r]), r == "__main_argc_argv" && (Module._main = e[r]);
              }
            }
            __name(mergeLibSymbols, "mergeLibSymbols");
            var LDSO = {
              loadedLibsByName: {},
              loadedLibsByHandle: {}
            };
            function dynCallLegacy(e, t, r) {
              var _ = Module["dynCall_" + e];
              return r && r.length ? _.apply(null, [t].concat(r)) : _.call(null, t);
            }
            __name(dynCallLegacy, "dynCallLegacy");
            var wasmTableMirror = [];
            function getWasmTableEntry(e) {
              var t = wasmTableMirror[e];
              return t || (e >= wasmTableMirror.length && (wasmTableMirror.length = e + 1), wasmTableMirror[e] = t = wasmTable.get(e)), t;
            }
            __name(getWasmTableEntry, "getWasmTableEntry");
            function dynCall(e, t, r) {
              return e.includes("j") ? dynCallLegacy(e, t, r) : getWasmTableEntry(t).apply(null, r);
            }
            __name(dynCall, "dynCall");
            function createInvokeFunction(e) {
              return function () {
                var t = stackSave();
                try {
                  return dynCall(e, arguments[0], Array.prototype.slice.call(arguments, 1));
                } catch (e) {
                  if (stackRestore(t), e !== e + 0) throw e;
                  _setThrew(1, 0);
                }
              };
            }
            __name(createInvokeFunction, "createInvokeFunction");
            var ___heap_base = 78144;
            function zeroMemory(e, t) {
              return HEAPU8.fill(0, e, e + t), e;
            }
            __name(zeroMemory, "zeroMemory");
            function getMemory(e) {
              if (runtimeInitialized) return zeroMemory(_malloc(e), e);
              var t = ___heap_base,
                r = t + e + 15 & -16;
              return ___heap_base = r, GOT.__heap_base.value = r, t;
            }
            __name(getMemory, "getMemory");
            function isInternalSym(e) {
              return ["__cpp_exception", "__c_longjmp", "__wasm_apply_data_relocs", "__dso_handle", "__tls_size", "__tls_align", "__set_stack_limits", "_emscripten_tls_init", "__wasm_init_tls", "__wasm_call_ctors", "__start_em_asm", "__stop_em_asm"].includes(e);
            }
            __name(isInternalSym, "isInternalSym");
            function uleb128Encode(e, t) {
              e < 128 ? t.push(e) : t.push(e % 128 | 128, e >> 7);
            }
            __name(uleb128Encode, "uleb128Encode");
            function sigToWasmTypes(e) {
              for (var t = {
                  i: "i32",
                  j: "i32",
                  f: "f32",
                  d: "f64",
                  p: "i32"
                }, r = {
                  parameters: [],
                  results: e[0] == "v" ? [] : [t[e[0]]]
                }, _ = 1; _ < e.length; ++_) r.parameters.push(t[e[_]]), e[_] === "j" && r.parameters.push("i32");
              return r;
            }
            __name(sigToWasmTypes, "sigToWasmTypes");
            function generateFuncType(e, t) {
              var r = e.slice(0, 1),
                _ = e.slice(1),
                n = {
                  i: 127,
                  p: 127,
                  j: 126,
                  f: 125,
                  d: 124
                };
              t.push(96), uleb128Encode(_.length, t);
              for (var s = 0; s < _.length; ++s) t.push(n[_[s]]);
              r == "v" ? t.push(0) : t.push(1, n[r]);
            }
            __name(generateFuncType, "generateFuncType");
            function convertJsFunctionToWasm(e, t) {
              if (typeof WebAssembly.Function == "function") return new WebAssembly.Function(sigToWasmTypes(t), e);
              var r = [1];
              generateFuncType(t, r);
              var _ = [0, 97, 115, 109, 1, 0, 0, 0, 1];
              uleb128Encode(r.length, _), _.push.apply(_, r), _.push(2, 7, 1, 1, 101, 1, 102, 0, 0, 7, 5, 1, 1, 102, 0, 0);
              var n = new WebAssembly.Module(new Uint8Array(_));
              return new WebAssembly.Instance(n, {
                e: {
                  f: e
                }
              }).exports.f;
            }
            __name(convertJsFunctionToWasm, "convertJsFunctionToWasm");
            function updateTableMap(e, t) {
              if (functionsInTableMap) for (var r = e; r < e + t; r++) {
                var _ = getWasmTableEntry(r);
                _ && functionsInTableMap.set(_, r);
              }
            }
            __name(updateTableMap, "updateTableMap");
            var functionsInTableMap = void 0,
              freeTableIndexes = [];
            function getEmptyTableSlot() {
              if (freeTableIndexes.length) return freeTableIndexes.pop();
              try {
                wasmTable.grow(1);
              } catch (e) {
                throw e instanceof RangeError ? "Unable to grow wasm table. Set ALLOW_TABLE_GROWTH." : e;
              }
              return wasmTable.length - 1;
            }
            __name(getEmptyTableSlot, "getEmptyTableSlot");
            function setWasmTableEntry(e, t) {
              wasmTable.set(e, t), wasmTableMirror[e] = wasmTable.get(e);
            }
            __name(setWasmTableEntry, "setWasmTableEntry");
            function addFunction(e, t) {
              if (functionsInTableMap || (functionsInTableMap = new WeakMap(), updateTableMap(0, wasmTable.length)), functionsInTableMap.has(e)) return functionsInTableMap.get(e);
              var r = getEmptyTableSlot();
              try {
                setWasmTableEntry(r, e);
              } catch (_) {
                if (!(_ instanceof TypeError)) throw _;
                setWasmTableEntry(r, convertJsFunctionToWasm(e, t));
              }
              return functionsInTableMap.set(e, r), r;
            }
            __name(addFunction, "addFunction");
            function updateGOT(e, t) {
              for (var r in e) if (!isInternalSym(r)) {
                var _ = e[r];
                r.startsWith("orig$") && (r = r.split("$")[1], t = !0), GOT[r] || (GOT[r] = new WebAssembly.Global({
                  value: "i32",
                  mutable: !0
                })), (t || GOT[r].value == 0) && (typeof _ == "function" ? GOT[r].value = addFunction(_) : typeof _ == "number" ? GOT[r].value = _ : err("unhandled export type for `" + r + "`: " + typeof _));
              }
            }
            __name(updateGOT, "updateGOT");
            function relocateExports(e, t, r) {
              var _ = {};
              for (var n in e) {
                var s = e[n];
                typeof s == "object" && (s = s.value), typeof s == "number" && (s += t), _[n] = s;
              }
              return updateGOT(_, r), _;
            }
            __name(relocateExports, "relocateExports");
            function resolveGlobalSymbol(e, t) {
              var r;
              return t && (r = asmLibraryArg["orig$" + e]), r || (r = asmLibraryArg[e]) && r.stub && (r = void 0), r || (r = Module[asmjsMangle(e)]), !r && e.startsWith("invoke_") && (r = createInvokeFunction(e.split("_")[1])), r;
            }
            __name(resolveGlobalSymbol, "resolveGlobalSymbol");
            function alignMemory(e, t) {
              return Math.ceil(e / t) * t;
            }
            __name(alignMemory, "alignMemory");
            function loadWebAssemblyModule(binary, flags, handle) {
              var metadata = getDylinkMetadata(binary);
              function loadModule() {
                var firstLoad = !handle || !HEAP8[handle + 12 >> 0];
                if (firstLoad) {
                  var memAlign = Math.pow(2, metadata.memoryAlign);
                  memAlign = Math.max(memAlign, STACK_ALIGN);
                  var memoryBase = metadata.memorySize ? alignMemory(getMemory(metadata.memorySize + memAlign), memAlign) : 0,
                    tableBase = metadata.tableSize ? wasmTable.length : 0;
                  handle && (HEAP8[handle + 12 >> 0] = 1, HEAPU32[handle + 16 >> 2] = memoryBase, HEAP32[handle + 20 >> 2] = metadata.memorySize, HEAPU32[handle + 24 >> 2] = tableBase, HEAP32[handle + 28 >> 2] = metadata.tableSize);
                } else memoryBase = HEAPU32[handle + 16 >> 2], tableBase = HEAPU32[handle + 24 >> 2];
                var tableGrowthNeeded = tableBase + metadata.tableSize - wasmTable.length,
                  moduleExports;
                function resolveSymbol(e) {
                  var t = resolveGlobalSymbol(e, !1);
                  return t || (t = moduleExports[e]), t;
                }
                __name(resolveSymbol, "resolveSymbol"), tableGrowthNeeded > 0 && wasmTable.grow(tableGrowthNeeded);
                var proxyHandler = {
                    get: __name(function (e, t) {
                      switch (t) {
                        case "__memory_base":
                          return memoryBase;
                        case "__table_base":
                          return tableBase;
                      }
                      if (t in asmLibraryArg) return asmLibraryArg[t];
                      var r;
                      return t in e || (e[t] = function () {
                        return r || (r = resolveSymbol(t)), r.apply(null, arguments);
                      }), e[t];
                    }, "get")
                  },
                  proxy = new Proxy({}, proxyHandler),
                  info = {
                    "GOT.mem": new Proxy({}, GOTHandler),
                    "GOT.func": new Proxy({}, GOTHandler),
                    env: proxy,
                    wasi_snapshot_preview1: proxy
                  };
                function postInstantiation(instance) {
                  function addEmAsm(addr, body) {
                    for (var args = [], arity = 0; arity < 16 && body.indexOf("$" + arity) != -1; arity++) args.push("$" + arity);
                    args = args.join(",");
                    var func = "(" + args + " ) => { " + body + "};";
                    ASM_CONSTS[start] = eval(func);
                  }
                  if (__name(addEmAsm, "addEmAsm"), updateTableMap(tableBase, metadata.tableSize), moduleExports = relocateExports(instance.exports, memoryBase), flags.allowUndefined || reportUndefinedSymbols(), "__start_em_asm" in moduleExports) for (var start = moduleExports.__start_em_asm, stop = moduleExports.__stop_em_asm; start < stop;) {
                    var jsString = UTF8ToString(start);
                    addEmAsm(start, jsString), start = HEAPU8.indexOf(0, start) + 1;
                  }
                  var applyRelocs = moduleExports.__wasm_apply_data_relocs;
                  applyRelocs && (runtimeInitialized ? applyRelocs() : __RELOC_FUNCS__.push(applyRelocs));
                  var init = moduleExports.__wasm_call_ctors;
                  return init && (runtimeInitialized ? init() : __ATINIT__.push(init)), moduleExports;
                }
                if (__name(postInstantiation, "postInstantiation"), flags.loadAsync) {
                  if (binary instanceof WebAssembly.Module) {
                    var instance = new WebAssembly.Instance(binary, info);
                    return Promise.resolve(postInstantiation(instance));
                  }
                  return WebAssembly.instantiate(binary, info).then(function (e) {
                    return postInstantiation(e.instance);
                  });
                }
                var module = binary instanceof WebAssembly.Module ? binary : new WebAssembly.Module(binary),
                  instance = new WebAssembly.Instance(module, info);
                return postInstantiation(instance);
              }
              return __name(loadModule, "loadModule"), CurrentModuleWeakSymbols = metadata.weakImports, flags.loadAsync ? metadata.neededDynlibs.reduce(function (e, t) {
                return e.then(function () {
                  return loadDynamicLibrary(t, flags);
                });
              }, Promise.resolve()).then(function () {
                return loadModule();
              }) : (metadata.neededDynlibs.forEach(function (e) {
                loadDynamicLibrary(e, flags);
              }), loadModule());
            }
            __name(loadWebAssemblyModule, "loadWebAssemblyModule");
            function loadDynamicLibrary(e, t, r) {
              t = t || {
                global: !0,
                nodelete: !0
              };
              var _ = LDSO.loadedLibsByName[e];
              if (_) return t.global && !_.global && (_.global = !0, _.module !== "loading" && mergeLibSymbols(_.module, e)), t.nodelete && _.refcount !== 1 / 0 && (_.refcount = 1 / 0), _.refcount++, r && (LDSO.loadedLibsByHandle[r] = _), !t.loadAsync || Promise.resolve(!0);
              function n(e) {
                if (t.fs && t.fs.findObject(e)) {
                  var r = t.fs.readFile(e, {
                    encoding: "binary"
                  });
                  return r instanceof Uint8Array || (r = new Uint8Array(r)), t.loadAsync ? Promise.resolve(r) : r;
                }
                if (e = locateFile(e), t.loadAsync) return new Promise(function (t, r) {
                  readAsync(e, e => t(new Uint8Array(e)), r);
                });
                if (!readBinary) throw new Error(e + ": file not found, and synchronous loading of external files is not available");
                return readBinary(e);
              }
              __name(n, "n");
              function s() {
                if (typeof preloadedWasm < "u" && preloadedWasm[e]) {
                  var _ = preloadedWasm[e];
                  return t.loadAsync ? Promise.resolve(_) : _;
                }
                return t.loadAsync ? n(e).then(function (e) {
                  return loadWebAssemblyModule(e, t, r);
                }) : loadWebAssemblyModule(n(e), t, r);
              }
              __name(s, "s");
              function a(t) {
                _.global && mergeLibSymbols(t, e), _.module = t;
              }
              return __name(a, "a"), _ = {
                refcount: t.nodelete ? 1 / 0 : 1,
                name: e,
                module: "loading",
                global: t.global
              }, LDSO.loadedLibsByName[e] = _, r && (LDSO.loadedLibsByHandle[r] = _), t.loadAsync ? s().then(function (e) {
                return a(e), !0;
              }) : (a(s()), !0);
            }
            __name(loadDynamicLibrary, "loadDynamicLibrary");
            function reportUndefinedSymbols() {
              for (var e in GOT) if (GOT[e].value == 0) {
                var t = resolveGlobalSymbol(e, !0);
                if (!t && !GOT[e].required) continue;
                if (typeof t == "function") GOT[e].value = addFunction(t, t.sig);else {
                  if (typeof t != "number") throw new Error("bad export type for `" + e + "`: " + typeof t);
                  GOT[e].value = t;
                }
              }
            }
            __name(reportUndefinedSymbols, "reportUndefinedSymbols");
            function preloadDylibs() {
              dynamicLibraries.length ? (addRunDependency("preloadDylibs"), dynamicLibraries.reduce(function (e, t) {
                return e.then(function () {
                  return loadDynamicLibrary(t, {
                    loadAsync: !0,
                    global: !0,
                    nodelete: !0,
                    allowUndefined: !0
                  });
                });
              }, Promise.resolve()).then(function () {
                reportUndefinedSymbols(), removeRunDependency("preloadDylibs");
              })) : reportUndefinedSymbols();
            }
            __name(preloadDylibs, "preloadDylibs");
            function setValue(e, t, r = "i8") {
              switch (r.endsWith("*") && (r = "*"), r) {
                case "i1":
                case "i8":
                  HEAP8[e >> 0] = t;
                  break;
                case "i16":
                  HEAP16[e >> 1] = t;
                  break;
                case "i32":
                  HEAP32[e >> 2] = t;
                  break;
                case "i64":
                  tempI64 = [t >>> 0, (tempDouble = t, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? (0 | Math.min(+Math.floor(tempDouble / 4294967296), 4294967295)) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[e >> 2] = tempI64[0], HEAP32[e + 4 >> 2] = tempI64[1];
                  break;
                case "float":
                  HEAPF32[e >> 2] = t;
                  break;
                case "double":
                  HEAPF64[e >> 3] = t;
                  break;
                case "*":
                  HEAPU32[e >> 2] = t;
                  break;
                default:
                  abort("invalid type for setValue: " + r);
              }
            }
            __name(setValue, "setValue");
            var ___memory_base = new WebAssembly.Global({
                value: "i32",
                mutable: !1
              }, 1024),
              ___stack_pointer = new WebAssembly.Global({
                value: "i32",
                mutable: !0
              }, 78144),
              ___table_base = new WebAssembly.Global({
                value: "i32",
                mutable: !1
              }, 1),
              nowIsMonotonic = !0,
              _emscripten_get_now;
            function __emscripten_get_now_is_monotonic() {
              return nowIsMonotonic;
            }
            __name(__emscripten_get_now_is_monotonic, "__emscripten_get_now_is_monotonic");
            function _abort() {
              abort("");
            }
            __name(_abort, "_abort");
            function _emscripten_date_now() {
              return Date.now();
            }
            __name(_emscripten_date_now, "_emscripten_date_now");
            function _emscripten_memcpy_big(e, t, r) {
              HEAPU8.copyWithin(e, t, t + r);
            }
            __name(_emscripten_memcpy_big, "_emscripten_memcpy_big");
            function getHeapMax() {
              return 2147483648;
            }
            __name(getHeapMax, "getHeapMax");
            function emscripten_realloc_buffer(e) {
              try {
                return wasmMemory.grow(e - buffer.byteLength + 65535 >>> 16), updateGlobalBufferAndViews(wasmMemory.buffer), 1;
              } catch {}
            }
            __name(emscripten_realloc_buffer, "emscripten_realloc_buffer");
            function _emscripten_resize_heap(e) {
              var t = HEAPU8.length;
              e >>>= 0;
              var r = getHeapMax();
              if (e > r) return !1;
              for (var _ = 1; _ <= 4; _ *= 2) {
                var n = t * (1 + .2 / _);
                if (n = Math.min(n, e + 100663296), emscripten_realloc_buffer(Math.min(r, (s = Math.max(e, n)) + ((a = 65536) - s % a) % a))) return !0;
              }
              var s, a;
              return !1;
            }
            __name(_emscripten_resize_heap, "_emscripten_resize_heap"), __emscripten_get_now_is_monotonic.sig = "i", Module._abort = _abort, _abort.sig = "v", _emscripten_date_now.sig = "d", _emscripten_get_now = ENVIRONMENT_IS_NODE ? () => {
              var e = process.hrtime();
              return 1e3 * e[0] + e[1] / 1e6;
            } : () => performance.now(), _emscripten_get_now.sig = "d", _emscripten_memcpy_big.sig = "vppp", _emscripten_resize_heap.sig = "ip";
            var SYSCALLS = {
              DEFAULT_POLLMASK: 5,
              calculateAt: __name(function (e, t, r) {
                if (PATH.isAbs(t)) return t;
                var _;
                if (e === -100 ? _ = FS.cwd() : _ = SYSCALLS.getStreamFromFD(e).path, t.length == 0) {
                  if (!r) throw new FS.ErrnoError(44);
                  return _;
                }
                return PATH.join2(_, t);
              }, "calculateAt"),
              doStat: __name(function (e, t, r) {
                try {
                  var _ = e(t);
                } catch (e) {
                  if (e && e.node && PATH.normalize(t) !== PATH.normalize(FS.getPath(e.node))) return -54;
                  throw e;
                }
                HEAP32[r >> 2] = _.dev, HEAP32[r + 8 >> 2] = _.ino, HEAP32[r + 12 >> 2] = _.mode, HEAPU32[r + 16 >> 2] = _.nlink, HEAP32[r + 20 >> 2] = _.uid, HEAP32[r + 24 >> 2] = _.gid, HEAP32[r + 28 >> 2] = _.rdev, tempI64 = [_.size >>> 0, (tempDouble = _.size, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? (0 | Math.min(+Math.floor(tempDouble / 4294967296), 4294967295)) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[r + 40 >> 2] = tempI64[0], HEAP32[r + 44 >> 2] = tempI64[1], HEAP32[r + 48 >> 2] = 4096, HEAP32[r + 52 >> 2] = _.blocks;
                var n = _.atime.getTime(),
                  s = _.mtime.getTime(),
                  a = _.ctime.getTime();
                return tempI64 = [Math.floor(n / 1e3) >>> 0, (tempDouble = Math.floor(n / 1e3), +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? (0 | Math.min(+Math.floor(tempDouble / 4294967296), 4294967295)) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[r + 56 >> 2] = tempI64[0], HEAP32[r + 60 >> 2] = tempI64[1], HEAPU32[r + 64 >> 2] = n % 1e3 * 1e3, tempI64 = [Math.floor(s / 1e3) >>> 0, (tempDouble = Math.floor(s / 1e3), +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? (0 | Math.min(+Math.floor(tempDouble / 4294967296), 4294967295)) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[r + 72 >> 2] = tempI64[0], HEAP32[r + 76 >> 2] = tempI64[1], HEAPU32[r + 80 >> 2] = s % 1e3 * 1e3, tempI64 = [Math.floor(a / 1e3) >>> 0, (tempDouble = Math.floor(a / 1e3), +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? (0 | Math.min(+Math.floor(tempDouble / 4294967296), 4294967295)) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[r + 88 >> 2] = tempI64[0], HEAP32[r + 92 >> 2] = tempI64[1], HEAPU32[r + 96 >> 2] = a % 1e3 * 1e3, tempI64 = [_.ino >>> 0, (tempDouble = _.ino, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? (0 | Math.min(+Math.floor(tempDouble / 4294967296), 4294967295)) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[r + 104 >> 2] = tempI64[0], HEAP32[r + 108 >> 2] = tempI64[1], 0;
              }, "doStat"),
              doMsync: __name(function (e, t, r, _, n) {
                if (!FS.isFile(t.node.mode)) throw new FS.ErrnoError(43);
                if (2 & _) return 0;
                var s = HEAPU8.slice(e, e + r);
                FS.msync(t, s, n, r, _);
              }, "doMsync"),
              varargs: void 0,
              get: __name(function () {
                return SYSCALLS.varargs += 4, HEAP32[SYSCALLS.varargs - 4 >> 2];
              }, "get"),
              getStr: __name(function (e) {
                return UTF8ToString(e);
              }, "getStr"),
              getStreamFromFD: __name(function (e) {
                var t = FS.getStream(e);
                if (!t) throw new FS.ErrnoError(8);
                return t;
              }, "getStreamFromFD")
            };
            function _proc_exit(e) {
              EXITSTATUS = e, keepRuntimeAlive() || (Module.onExit && Module.onExit(e), ABORT = !0), quit_(e, new ExitStatus(e));
            }
            __name(_proc_exit, "_proc_exit");
            function exitJS(e, t) {
              EXITSTATUS = e, _proc_exit(e);
            }
            __name(exitJS, "exitJS"), _proc_exit.sig = "vi";
            var _exit = exitJS;
            function _fd_close(e) {
              try {
                var t = SYSCALLS.getStreamFromFD(e);
                return FS.close(t), 0;
              } catch (e) {
                if (typeof FS > "u" || !(e instanceof FS.ErrnoError)) throw e;
                return e.errno;
              }
            }
            __name(_fd_close, "_fd_close");
            function convertI32PairToI53Checked(e, t) {
              return t + 2097152 >>> 0 < 4194305 - !!e ? (e >>> 0) + 4294967296 * t : NaN;
            }
            __name(convertI32PairToI53Checked, "convertI32PairToI53Checked");
            function _fd_seek(e, t, r, _, n) {
              try {
                var s = convertI32PairToI53Checked(t, r);
                if (isNaN(s)) return 61;
                var a = SYSCALLS.getStreamFromFD(e);
                return FS.llseek(a, s, _), tempI64 = [a.position >>> 0, (tempDouble = a.position, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? (0 | Math.min(+Math.floor(tempDouble / 4294967296), 4294967295)) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[n >> 2] = tempI64[0], HEAP32[n + 4 >> 2] = tempI64[1], a.getdents && s === 0 && _ === 0 && (a.getdents = null), 0;
              } catch (e) {
                if (typeof FS > "u" || !(e instanceof FS.ErrnoError)) throw e;
                return e.errno;
              }
            }
            __name(_fd_seek, "_fd_seek");
            function doWritev(e, t, r, _) {
              for (var n = 0, s = 0; s < r; s++) {
                var a = HEAPU32[t >> 2],
                  o = HEAPU32[t + 4 >> 2];
                t += 8;
                var i = FS.write(e, HEAP8, a, o, _);
                if (i < 0) return -1;
                n += i, _ !== void 0 && (_ += i);
              }
              return n;
            }
            __name(doWritev, "doWritev");
            function _fd_write(e, t, r, _) {
              try {
                var n = doWritev(SYSCALLS.getStreamFromFD(e), t, r);
                return HEAPU32[_ >> 2] = n, 0;
              } catch (e) {
                if (typeof FS > "u" || !(e instanceof FS.ErrnoError)) throw e;
                return e.errno;
              }
            }
            __name(_fd_write, "_fd_write");
            function _tree_sitter_log_callback(e, t) {
              if (currentLogCallback) {
                let r = UTF8ToString(t);
                currentLogCallback(r, e !== 0);
              }
            }
            __name(_tree_sitter_log_callback, "_tree_sitter_log_callback");
            function _tree_sitter_parse_callback(e, t, r, _, n) {
              var s = currentParseCallback(t, {
                row: r,
                column: _
              });
              typeof s == "string" ? (setValue(n, s.length, "i32"), stringToUTF16(s, e, 10240)) : setValue(n, 0, "i32");
            }
            __name(_tree_sitter_parse_callback, "_tree_sitter_parse_callback");
            function handleException(e) {
              if (e instanceof ExitStatus || e == "unwind") return EXITSTATUS;
              quit_(1, e);
            }
            __name(handleException, "handleException");
            function allocateUTF8OnStack(e) {
              var t = lengthBytesUTF8(e) + 1,
                r = stackAlloc(t);
              return stringToUTF8Array(e, HEAP8, r, t), r;
            }
            __name(allocateUTF8OnStack, "allocateUTF8OnStack");
            function stringToUTF16(e, t, r) {
              if (r === void 0 && (r = 2147483647), r < 2) return 0;
              for (var _ = t, n = (r -= 2) < 2 * e.length ? r / 2 : e.length, s = 0; s < n; ++s) {
                var a = e.charCodeAt(s);
                HEAP16[t >> 1] = a, t += 2;
              }
              return HEAP16[t >> 1] = 0, t - _;
            }
            __name(stringToUTF16, "stringToUTF16");
            function AsciiToString(e) {
              for (var t = "";;) {
                var r = HEAPU8[e++ >> 0];
                if (!r) return t;
                t += String.fromCharCode(r);
              }
            }
            __name(AsciiToString, "AsciiToString"), _exit.sig = "vi", _fd_close.sig = "ii", _fd_seek.sig = "iijip", _fd_write.sig = "iippp";
            var asmLibraryArg = {
                __heap_base: ___heap_base,
                __indirect_function_table: wasmTable,
                __memory_base: ___memory_base,
                __stack_pointer: ___stack_pointer,
                __table_base: ___table_base,
                _emscripten_get_now_is_monotonic: __emscripten_get_now_is_monotonic,
                abort: _abort,
                emscripten_get_now: _emscripten_get_now,
                emscripten_memcpy_big: _emscripten_memcpy_big,
                emscripten_resize_heap: _emscripten_resize_heap,
                exit: _exit,
                fd_close: _fd_close,
                fd_seek: _fd_seek,
                fd_write: _fd_write,
                memory: wasmMemory,
                tree_sitter_log_callback: _tree_sitter_log_callback,
                tree_sitter_parse_callback: _tree_sitter_parse_callback
              },
              asm = createWasm(),
              ___wasm_call_ctors = Module.___wasm_call_ctors = function () {
                return (___wasm_call_ctors = Module.___wasm_call_ctors = Module.asm.__wasm_call_ctors).apply(null, arguments);
              },
              ___wasm_apply_data_relocs = Module.___wasm_apply_data_relocs = function () {
                return (___wasm_apply_data_relocs = Module.___wasm_apply_data_relocs = Module.asm.__wasm_apply_data_relocs).apply(null, arguments);
              },
              _malloc = Module._malloc = function () {
                return (_malloc = Module._malloc = Module.asm.malloc).apply(null, arguments);
              },
              _calloc = Module._calloc = function () {
                return (_calloc = Module._calloc = Module.asm.calloc).apply(null, arguments);
              },
              _realloc = Module._realloc = function () {
                return (_realloc = Module._realloc = Module.asm.realloc).apply(null, arguments);
              },
              _free = Module._free = function () {
                return (_free = Module._free = Module.asm.free).apply(null, arguments);
              },
              _ts_language_symbol_count = Module._ts_language_symbol_count = function () {
                return (_ts_language_symbol_count = Module._ts_language_symbol_count = Module.asm.ts_language_symbol_count).apply(null, arguments);
              },
              _ts_language_version = Module._ts_language_version = function () {
                return (_ts_language_version = Module._ts_language_version = Module.asm.ts_language_version).apply(null, arguments);
              },
              _ts_language_field_count = Module._ts_language_field_count = function () {
                return (_ts_language_field_count = Module._ts_language_field_count = Module.asm.ts_language_field_count).apply(null, arguments);
              },
              _ts_language_symbol_name = Module._ts_language_symbol_name = function () {
                return (_ts_language_symbol_name = Module._ts_language_symbol_name = Module.asm.ts_language_symbol_name).apply(null, arguments);
              },
              _ts_language_symbol_for_name = Module._ts_language_symbol_for_name = function () {
                return (_ts_language_symbol_for_name = Module._ts_language_symbol_for_name = Module.asm.ts_language_symbol_for_name).apply(null, arguments);
              },
              _ts_language_symbol_type = Module._ts_language_symbol_type = function () {
                return (_ts_language_symbol_type = Module._ts_language_symbol_type = Module.asm.ts_language_symbol_type).apply(null, arguments);
              },
              _ts_language_field_name_for_id = Module._ts_language_field_name_for_id = function () {
                return (_ts_language_field_name_for_id = Module._ts_language_field_name_for_id = Module.asm.ts_language_field_name_for_id).apply(null, arguments);
              },
              _memset = Module._memset = function () {
                return (_memset = Module._memset = Module.asm.memset).apply(null, arguments);
              },
              _memcpy = Module._memcpy = function () {
                return (_memcpy = Module._memcpy = Module.asm.memcpy).apply(null, arguments);
              },
              _ts_parser_delete = Module._ts_parser_delete = function () {
                return (_ts_parser_delete = Module._ts_parser_delete = Module.asm.ts_parser_delete).apply(null, arguments);
              },
              _ts_parser_reset = Module._ts_parser_reset = function () {
                return (_ts_parser_reset = Module._ts_parser_reset = Module.asm.ts_parser_reset).apply(null, arguments);
              },
              _ts_parser_set_language = Module._ts_parser_set_language = function () {
                return (_ts_parser_set_language = Module._ts_parser_set_language = Module.asm.ts_parser_set_language).apply(null, arguments);
              },
              _ts_parser_timeout_micros = Module._ts_parser_timeout_micros = function () {
                return (_ts_parser_timeout_micros = Module._ts_parser_timeout_micros = Module.asm.ts_parser_timeout_micros).apply(null, arguments);
              },
              _ts_parser_set_timeout_micros = Module._ts_parser_set_timeout_micros = function () {
                return (_ts_parser_set_timeout_micros = Module._ts_parser_set_timeout_micros = Module.asm.ts_parser_set_timeout_micros).apply(null, arguments);
              },
              _memmove = Module._memmove = function () {
                return (_memmove = Module._memmove = Module.asm.memmove).apply(null, arguments);
              },
              _memcmp = Module._memcmp = function () {
                return (_memcmp = Module._memcmp = Module.asm.memcmp).apply(null, arguments);
              },
              _ts_query_new = Module._ts_query_new = function () {
                return (_ts_query_new = Module._ts_query_new = Module.asm.ts_query_new).apply(null, arguments);
              },
              _ts_query_delete = Module._ts_query_delete = function () {
                return (_ts_query_delete = Module._ts_query_delete = Module.asm.ts_query_delete).apply(null, arguments);
              },
              _iswspace = Module._iswspace = function () {
                return (_iswspace = Module._iswspace = Module.asm.iswspace).apply(null, arguments);
              },
              _iswalnum = Module._iswalnum = function () {
                return (_iswalnum = Module._iswalnum = Module.asm.iswalnum).apply(null, arguments);
              },
              _ts_query_pattern_count = Module._ts_query_pattern_count = function () {
                return (_ts_query_pattern_count = Module._ts_query_pattern_count = Module.asm.ts_query_pattern_count).apply(null, arguments);
              },
              _ts_query_capture_count = Module._ts_query_capture_count = function () {
                return (_ts_query_capture_count = Module._ts_query_capture_count = Module.asm.ts_query_capture_count).apply(null, arguments);
              },
              _ts_query_string_count = Module._ts_query_string_count = function () {
                return (_ts_query_string_count = Module._ts_query_string_count = Module.asm.ts_query_string_count).apply(null, arguments);
              },
              _ts_query_capture_name_for_id = Module._ts_query_capture_name_for_id = function () {
                return (_ts_query_capture_name_for_id = Module._ts_query_capture_name_for_id = Module.asm.ts_query_capture_name_for_id).apply(null, arguments);
              },
              _ts_query_string_value_for_id = Module._ts_query_string_value_for_id = function () {
                return (_ts_query_string_value_for_id = Module._ts_query_string_value_for_id = Module.asm.ts_query_string_value_for_id).apply(null, arguments);
              },
              _ts_query_predicates_for_pattern = Module._ts_query_predicates_for_pattern = function () {
                return (_ts_query_predicates_for_pattern = Module._ts_query_predicates_for_pattern = Module.asm.ts_query_predicates_for_pattern).apply(null, arguments);
              },
              _ts_tree_copy = Module._ts_tree_copy = function () {
                return (_ts_tree_copy = Module._ts_tree_copy = Module.asm.ts_tree_copy).apply(null, arguments);
              },
              _ts_tree_delete = Module._ts_tree_delete = function () {
                return (_ts_tree_delete = Module._ts_tree_delete = Module.asm.ts_tree_delete).apply(null, arguments);
              },
              _ts_init = Module._ts_init = function () {
                return (_ts_init = Module._ts_init = Module.asm.ts_init).apply(null, arguments);
              },
              _ts_parser_new_wasm = Module._ts_parser_new_wasm = function () {
                return (_ts_parser_new_wasm = Module._ts_parser_new_wasm = Module.asm.ts_parser_new_wasm).apply(null, arguments);
              },
              _ts_parser_enable_logger_wasm = Module._ts_parser_enable_logger_wasm = function () {
                return (_ts_parser_enable_logger_wasm = Module._ts_parser_enable_logger_wasm = Module.asm.ts_parser_enable_logger_wasm).apply(null, arguments);
              },
              _ts_parser_parse_wasm = Module._ts_parser_parse_wasm = function () {
                return (_ts_parser_parse_wasm = Module._ts_parser_parse_wasm = Module.asm.ts_parser_parse_wasm).apply(null, arguments);
              },
              _ts_language_type_is_named_wasm = Module._ts_language_type_is_named_wasm = function () {
                return (_ts_language_type_is_named_wasm = Module._ts_language_type_is_named_wasm = Module.asm.ts_language_type_is_named_wasm).apply(null, arguments);
              },
              _ts_language_type_is_visible_wasm = Module._ts_language_type_is_visible_wasm = function () {
                return (_ts_language_type_is_visible_wasm = Module._ts_language_type_is_visible_wasm = Module.asm.ts_language_type_is_visible_wasm).apply(null, arguments);
              },
              _ts_tree_root_node_wasm = Module._ts_tree_root_node_wasm = function () {
                return (_ts_tree_root_node_wasm = Module._ts_tree_root_node_wasm = Module.asm.ts_tree_root_node_wasm).apply(null, arguments);
              },
              _ts_tree_edit_wasm = Module._ts_tree_edit_wasm = function () {
                return (_ts_tree_edit_wasm = Module._ts_tree_edit_wasm = Module.asm.ts_tree_edit_wasm).apply(null, arguments);
              },
              _ts_tree_get_changed_ranges_wasm = Module._ts_tree_get_changed_ranges_wasm = function () {
                return (_ts_tree_get_changed_ranges_wasm = Module._ts_tree_get_changed_ranges_wasm = Module.asm.ts_tree_get_changed_ranges_wasm).apply(null, arguments);
              },
              _ts_tree_cursor_new_wasm = Module._ts_tree_cursor_new_wasm = function () {
                return (_ts_tree_cursor_new_wasm = Module._ts_tree_cursor_new_wasm = Module.asm.ts_tree_cursor_new_wasm).apply(null, arguments);
              },
              _ts_tree_cursor_delete_wasm = Module._ts_tree_cursor_delete_wasm = function () {
                return (_ts_tree_cursor_delete_wasm = Module._ts_tree_cursor_delete_wasm = Module.asm.ts_tree_cursor_delete_wasm).apply(null, arguments);
              },
              _ts_tree_cursor_reset_wasm = Module._ts_tree_cursor_reset_wasm = function () {
                return (_ts_tree_cursor_reset_wasm = Module._ts_tree_cursor_reset_wasm = Module.asm.ts_tree_cursor_reset_wasm).apply(null, arguments);
              },
              _ts_tree_cursor_goto_first_child_wasm = Module._ts_tree_cursor_goto_first_child_wasm = function () {
                return (_ts_tree_cursor_goto_first_child_wasm = Module._ts_tree_cursor_goto_first_child_wasm = Module.asm.ts_tree_cursor_goto_first_child_wasm).apply(null, arguments);
              },
              _ts_tree_cursor_goto_next_sibling_wasm = Module._ts_tree_cursor_goto_next_sibling_wasm = function () {
                return (_ts_tree_cursor_goto_next_sibling_wasm = Module._ts_tree_cursor_goto_next_sibling_wasm = Module.asm.ts_tree_cursor_goto_next_sibling_wasm).apply(null, arguments);
              },
              _ts_tree_cursor_goto_parent_wasm = Module._ts_tree_cursor_goto_parent_wasm = function () {
                return (_ts_tree_cursor_goto_parent_wasm = Module._ts_tree_cursor_goto_parent_wasm = Module.asm.ts_tree_cursor_goto_parent_wasm).apply(null, arguments);
              },
              _ts_tree_cursor_current_node_type_id_wasm = Module._ts_tree_cursor_current_node_type_id_wasm = function () {
                return (_ts_tree_cursor_current_node_type_id_wasm = Module._ts_tree_cursor_current_node_type_id_wasm = Module.asm.ts_tree_cursor_current_node_type_id_wasm).apply(null, arguments);
              },
              _ts_tree_cursor_current_node_is_named_wasm = Module._ts_tree_cursor_current_node_is_named_wasm = function () {
                return (_ts_tree_cursor_current_node_is_named_wasm = Module._ts_tree_cursor_current_node_is_named_wasm = Module.asm.ts_tree_cursor_current_node_is_named_wasm).apply(null, arguments);
              },
              _ts_tree_cursor_current_node_is_missing_wasm = Module._ts_tree_cursor_current_node_is_missing_wasm = function () {
                return (_ts_tree_cursor_current_node_is_missing_wasm = Module._ts_tree_cursor_current_node_is_missing_wasm = Module.asm.ts_tree_cursor_current_node_is_missing_wasm).apply(null, arguments);
              },
              _ts_tree_cursor_current_node_id_wasm = Module._ts_tree_cursor_current_node_id_wasm = function () {
                return (_ts_tree_cursor_current_node_id_wasm = Module._ts_tree_cursor_current_node_id_wasm = Module.asm.ts_tree_cursor_current_node_id_wasm).apply(null, arguments);
              },
              _ts_tree_cursor_start_position_wasm = Module._ts_tree_cursor_start_position_wasm = function () {
                return (_ts_tree_cursor_start_position_wasm = Module._ts_tree_cursor_start_position_wasm = Module.asm.ts_tree_cursor_start_position_wasm).apply(null, arguments);
              },
              _ts_tree_cursor_end_position_wasm = Module._ts_tree_cursor_end_position_wasm = function () {
                return (_ts_tree_cursor_end_position_wasm = Module._ts_tree_cursor_end_position_wasm = Module.asm.ts_tree_cursor_end_position_wasm).apply(null, arguments);
              },
              _ts_tree_cursor_start_index_wasm = Module._ts_tree_cursor_start_index_wasm = function () {
                return (_ts_tree_cursor_start_index_wasm = Module._ts_tree_cursor_start_index_wasm = Module.asm.ts_tree_cursor_start_index_wasm).apply(null, arguments);
              },
              _ts_tree_cursor_end_index_wasm = Module._ts_tree_cursor_end_index_wasm = function () {
                return (_ts_tree_cursor_end_index_wasm = Module._ts_tree_cursor_end_index_wasm = Module.asm.ts_tree_cursor_end_index_wasm).apply(null, arguments);
              },
              _ts_tree_cursor_current_field_id_wasm = Module._ts_tree_cursor_current_field_id_wasm = function () {
                return (_ts_tree_cursor_current_field_id_wasm = Module._ts_tree_cursor_current_field_id_wasm = Module.asm.ts_tree_cursor_current_field_id_wasm).apply(null, arguments);
              },
              _ts_tree_cursor_current_node_wasm = Module._ts_tree_cursor_current_node_wasm = function () {
                return (_ts_tree_cursor_current_node_wasm = Module._ts_tree_cursor_current_node_wasm = Module.asm.ts_tree_cursor_current_node_wasm).apply(null, arguments);
              },
              _ts_node_symbol_wasm = Module._ts_node_symbol_wasm = function () {
                return (_ts_node_symbol_wasm = Module._ts_node_symbol_wasm = Module.asm.ts_node_symbol_wasm).apply(null, arguments);
              },
              _ts_node_child_count_wasm = Module._ts_node_child_count_wasm = function () {
                return (_ts_node_child_count_wasm = Module._ts_node_child_count_wasm = Module.asm.ts_node_child_count_wasm).apply(null, arguments);
              },
              _ts_node_named_child_count_wasm = Module._ts_node_named_child_count_wasm = function () {
                return (_ts_node_named_child_count_wasm = Module._ts_node_named_child_count_wasm = Module.asm.ts_node_named_child_count_wasm).apply(null, arguments);
              },
              _ts_node_child_wasm = Module._ts_node_child_wasm = function () {
                return (_ts_node_child_wasm = Module._ts_node_child_wasm = Module.asm.ts_node_child_wasm).apply(null, arguments);
              },
              _ts_node_named_child_wasm = Module._ts_node_named_child_wasm = function () {
                return (_ts_node_named_child_wasm = Module._ts_node_named_child_wasm = Module.asm.ts_node_named_child_wasm).apply(null, arguments);
              },
              _ts_node_child_by_field_id_wasm = Module._ts_node_child_by_field_id_wasm = function () {
                return (_ts_node_child_by_field_id_wasm = Module._ts_node_child_by_field_id_wasm = Module.asm.ts_node_child_by_field_id_wasm).apply(null, arguments);
              },
              _ts_node_next_sibling_wasm = Module._ts_node_next_sibling_wasm = function () {
                return (_ts_node_next_sibling_wasm = Module._ts_node_next_sibling_wasm = Module.asm.ts_node_next_sibling_wasm).apply(null, arguments);
              },
              _ts_node_prev_sibling_wasm = Module._ts_node_prev_sibling_wasm = function () {
                return (_ts_node_prev_sibling_wasm = Module._ts_node_prev_sibling_wasm = Module.asm.ts_node_prev_sibling_wasm).apply(null, arguments);
              },
              _ts_node_next_named_sibling_wasm = Module._ts_node_next_named_sibling_wasm = function () {
                return (_ts_node_next_named_sibling_wasm = Module._ts_node_next_named_sibling_wasm = Module.asm.ts_node_next_named_sibling_wasm).apply(null, arguments);
              },
              _ts_node_prev_named_sibling_wasm = Module._ts_node_prev_named_sibling_wasm = function () {
                return (_ts_node_prev_named_sibling_wasm = Module._ts_node_prev_named_sibling_wasm = Module.asm.ts_node_prev_named_sibling_wasm).apply(null, arguments);
              },
              _ts_node_parent_wasm = Module._ts_node_parent_wasm = function () {
                return (_ts_node_parent_wasm = Module._ts_node_parent_wasm = Module.asm.ts_node_parent_wasm).apply(null, arguments);
              },
              _ts_node_descendant_for_index_wasm = Module._ts_node_descendant_for_index_wasm = function () {
                return (_ts_node_descendant_for_index_wasm = Module._ts_node_descendant_for_index_wasm = Module.asm.ts_node_descendant_for_index_wasm).apply(null, arguments);
              },
              _ts_node_named_descendant_for_index_wasm = Module._ts_node_named_descendant_for_index_wasm = function () {
                return (_ts_node_named_descendant_for_index_wasm = Module._ts_node_named_descendant_for_index_wasm = Module.asm.ts_node_named_descendant_for_index_wasm).apply(null, arguments);
              },
              _ts_node_descendant_for_position_wasm = Module._ts_node_descendant_for_position_wasm = function () {
                return (_ts_node_descendant_for_position_wasm = Module._ts_node_descendant_for_position_wasm = Module.asm.ts_node_descendant_for_position_wasm).apply(null, arguments);
              },
              _ts_node_named_descendant_for_position_wasm = Module._ts_node_named_descendant_for_position_wasm = function () {
                return (_ts_node_named_descendant_for_position_wasm = Module._ts_node_named_descendant_for_position_wasm = Module.asm.ts_node_named_descendant_for_position_wasm).apply(null, arguments);
              },
              _ts_node_start_point_wasm = Module._ts_node_start_point_wasm = function () {
                return (_ts_node_start_point_wasm = Module._ts_node_start_point_wasm = Module.asm.ts_node_start_point_wasm).apply(null, arguments);
              },
              _ts_node_end_point_wasm = Module._ts_node_end_point_wasm = function () {
                return (_ts_node_end_point_wasm = Module._ts_node_end_point_wasm = Module.asm.ts_node_end_point_wasm).apply(null, arguments);
              },
              _ts_node_start_index_wasm = Module._ts_node_start_index_wasm = function () {
                return (_ts_node_start_index_wasm = Module._ts_node_start_index_wasm = Module.asm.ts_node_start_index_wasm).apply(null, arguments);
              },
              _ts_node_end_index_wasm = Module._ts_node_end_index_wasm = function () {
                return (_ts_node_end_index_wasm = Module._ts_node_end_index_wasm = Module.asm.ts_node_end_index_wasm).apply(null, arguments);
              },
              _ts_node_to_string_wasm = Module._ts_node_to_string_wasm = function () {
                return (_ts_node_to_string_wasm = Module._ts_node_to_string_wasm = Module.asm.ts_node_to_string_wasm).apply(null, arguments);
              },
              _ts_node_children_wasm = Module._ts_node_children_wasm = function () {
                return (_ts_node_children_wasm = Module._ts_node_children_wasm = Module.asm.ts_node_children_wasm).apply(null, arguments);
              },
              _ts_node_named_children_wasm = Module._ts_node_named_children_wasm = function () {
                return (_ts_node_named_children_wasm = Module._ts_node_named_children_wasm = Module.asm.ts_node_named_children_wasm).apply(null, arguments);
              },
              _ts_node_descendants_of_type_wasm = Module._ts_node_descendants_of_type_wasm = function () {
                return (_ts_node_descendants_of_type_wasm = Module._ts_node_descendants_of_type_wasm = Module.asm.ts_node_descendants_of_type_wasm).apply(null, arguments);
              },
              _ts_node_is_named_wasm = Module._ts_node_is_named_wasm = function () {
                return (_ts_node_is_named_wasm = Module._ts_node_is_named_wasm = Module.asm.ts_node_is_named_wasm).apply(null, arguments);
              },
              _ts_node_has_changes_wasm = Module._ts_node_has_changes_wasm = function () {
                return (_ts_node_has_changes_wasm = Module._ts_node_has_changes_wasm = Module.asm.ts_node_has_changes_wasm).apply(null, arguments);
              },
              _ts_node_has_error_wasm = Module._ts_node_has_error_wasm = function () {
                return (_ts_node_has_error_wasm = Module._ts_node_has_error_wasm = Module.asm.ts_node_has_error_wasm).apply(null, arguments);
              },
              _ts_node_is_missing_wasm = Module._ts_node_is_missing_wasm = function () {
                return (_ts_node_is_missing_wasm = Module._ts_node_is_missing_wasm = Module.asm.ts_node_is_missing_wasm).apply(null, arguments);
              },
              _ts_query_matches_wasm = Module._ts_query_matches_wasm = function () {
                return (_ts_query_matches_wasm = Module._ts_query_matches_wasm = Module.asm.ts_query_matches_wasm).apply(null, arguments);
              },
              _ts_query_captures_wasm = Module._ts_query_captures_wasm = function () {
                return (_ts_query_captures_wasm = Module._ts_query_captures_wasm = Module.asm.ts_query_captures_wasm).apply(null, arguments);
              },
              ___cxa_atexit = Module.___cxa_atexit = function () {
                return (___cxa_atexit = Module.___cxa_atexit = Module.asm.__cxa_atexit).apply(null, arguments);
              },
              _iswdigit = Module._iswdigit = function () {
                return (_iswdigit = Module._iswdigit = Module.asm.iswdigit).apply(null, arguments);
              },
              _iswalpha = Module._iswalpha = function () {
                return (_iswalpha = Module._iswalpha = Module.asm.iswalpha).apply(null, arguments);
              },
              _iswlower = Module._iswlower = function () {
                return (_iswlower = Module._iswlower = Module.asm.iswlower).apply(null, arguments);
              },
              _memchr = Module._memchr = function () {
                return (_memchr = Module._memchr = Module.asm.memchr).apply(null, arguments);
              },
              _strlen = Module._strlen = function () {
                return (_strlen = Module._strlen = Module.asm.strlen).apply(null, arguments);
              },
              _towupper = Module._towupper = function () {
                return (_towupper = Module._towupper = Module.asm.towupper).apply(null, arguments);
              },
              _setThrew = Module._setThrew = function () {
                return (_setThrew = Module._setThrew = Module.asm.setThrew).apply(null, arguments);
              },
              stackSave = Module.stackSave = function () {
                return (stackSave = Module.stackSave = Module.asm.stackSave).apply(null, arguments);
              },
              stackRestore = Module.stackRestore = function () {
                return (stackRestore = Module.stackRestore = Module.asm.stackRestore).apply(null, arguments);
              },
              stackAlloc = Module.stackAlloc = function () {
                return (stackAlloc = Module.stackAlloc = Module.asm.stackAlloc).apply(null, arguments);
              },
              __Znwm = Module.__Znwm = function () {
                return (__Znwm = Module.__Znwm = Module.asm._Znwm).apply(null, arguments);
              },
              __ZdlPv = Module.__ZdlPv = function () {
                return (__ZdlPv = Module.__ZdlPv = Module.asm._ZdlPv).apply(null, arguments);
              },
              __ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEED2Ev = Module.__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEED2Ev = function () {
                return (__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEED2Ev = Module.__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEED2Ev = Module.asm._ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEED2Ev).apply(null, arguments);
              },
              __ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE9__grow_byEmmmmmm = Module.__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE9__grow_byEmmmmmm = function () {
                return (__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE9__grow_byEmmmmmm = Module.__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE9__grow_byEmmmmmm = Module.asm._ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE9__grow_byEmmmmmm).apply(null, arguments);
              },
              __ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE6__initEPKcm = Module.__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE6__initEPKcm = function () {
                return (__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE6__initEPKcm = Module.__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE6__initEPKcm = Module.asm._ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE6__initEPKcm).apply(null, arguments);
              },
              __ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE7reserveEm = Module.__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE7reserveEm = function () {
                return (__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE7reserveEm = Module.__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE7reserveEm = Module.asm._ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE7reserveEm).apply(null, arguments);
              },
              __ZNKSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE4copyEPcmm = Module.__ZNKSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE4copyEPcmm = function () {
                return (__ZNKSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE4copyEPcmm = Module.__ZNKSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE4copyEPcmm = Module.asm._ZNKSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE4copyEPcmm).apply(null, arguments);
              },
              __ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE9push_backEc = Module.__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE9push_backEc = function () {
                return (__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE9push_backEc = Module.__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE9push_backEc = Module.asm._ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE9push_backEc).apply(null, arguments);
              },
              __ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEED2Ev = Module.__ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEED2Ev = function () {
                return (__ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEED2Ev = Module.__ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEED2Ev = Module.asm._ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEED2Ev).apply(null, arguments);
              },
              __ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEE9push_backEw = Module.__ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEE9push_backEw = function () {
                return (__ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEE9push_backEw = Module.__ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEE9push_backEw = Module.asm._ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEE9push_backEw).apply(null, arguments);
              },
              __ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEE6resizeEmw = Module.__ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEE6resizeEmw = function () {
                return (__ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEE6resizeEmw = Module.__ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEE6resizeEmw = Module.asm._ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEE6resizeEmw).apply(null, arguments);
              },
              dynCall_jiji = Module.dynCall_jiji = function () {
                return (dynCall_jiji = Module.dynCall_jiji = Module.asm.dynCall_jiji).apply(null, arguments);
              },
              _orig$ts_parser_timeout_micros = Module._orig$ts_parser_timeout_micros = function () {
                return (_orig$ts_parser_timeout_micros = Module._orig$ts_parser_timeout_micros = Module.asm.orig$ts_parser_timeout_micros).apply(null, arguments);
              },
              _orig$ts_parser_set_timeout_micros = Module._orig$ts_parser_set_timeout_micros = function () {
                return (_orig$ts_parser_set_timeout_micros = Module._orig$ts_parser_set_timeout_micros = Module.asm.orig$ts_parser_set_timeout_micros).apply(null, arguments);
              },
              calledRun;
            function callMain(e) {
              var t = Module._main;
              if (t) {
                (e = e || []).unshift(thisProgram);
                var r = e.length,
                  _ = stackAlloc(4 * (r + 1)),
                  n = _ >> 2;
                e.forEach(e => {
                  HEAP32[n++] = allocateUTF8OnStack(e);
                }), HEAP32[n] = 0;
                try {
                  var s = t(r, _);
                  return exitJS(s, !0), s;
                } catch (e) {
                  return handleException(e);
                }
              }
            }
            __name(callMain, "callMain"), Module.AsciiToString = AsciiToString, Module.stringToUTF16 = stringToUTF16, dependenciesFulfilled = __name(function e() {
              calledRun || run(), calledRun || (dependenciesFulfilled = e);
            }, "e");
            var dylibsLoaded = !1;
            function run(e) {
              function t() {
                calledRun || (calledRun = !0, Module.calledRun = !0, ABORT || (initRuntime(), preMain(), Module.onRuntimeInitialized && Module.onRuntimeInitialized(), shouldRunNow && callMain(e), postRun()));
              }
              __name(t, "t"), e = e || arguments_, runDependencies > 0 || !dylibsLoaded && (preloadDylibs(), dylibsLoaded = !0, runDependencies > 0) || (preRun(), runDependencies > 0 || (Module.setStatus ? (Module.setStatus("Running..."), setTimeout(function () {
                setTimeout(function () {
                  Module.setStatus("");
                }, 1), t();
              }, 1)) : t()));
            }
            if (__name(run, "run"), Module.preInit) for (typeof Module.preInit == "function" && (Module.preInit = [Module.preInit]); Module.preInit.length > 0;) Module.preInit.pop()();
            var shouldRunNow = !0;
            Module.noInitialRun && (shouldRunNow = !1), run();
            let C = Module,
              INTERNAL = {},
              SIZE_OF_INT = 4,
              SIZE_OF_NODE = 5 * SIZE_OF_INT,
              SIZE_OF_POINT = 2 * SIZE_OF_INT,
              SIZE_OF_RANGE = 2 * SIZE_OF_INT + 2 * SIZE_OF_POINT,
              ZERO_POINT = {
                row: 0,
                column: 0
              },
              QUERY_WORD_REGEX = /[\w-.]*/g,
              PREDICATE_STEP_TYPE_CAPTURE = 1,
              PREDICATE_STEP_TYPE_STRING = 2,
              LANGUAGE_FUNCTION_REGEX = /^_?tree_sitter_\w+/;
            var VERSION, MIN_COMPATIBLE_VERSION, TRANSFER_BUFFER, currentParseCallback, currentLogCallback;
            let _ParserImpl = class _ParserImpl {
              static init() {
                TRANSFER_BUFFER = C._ts_init(), VERSION = getValue(TRANSFER_BUFFER, "i32"), MIN_COMPATIBLE_VERSION = getValue(TRANSFER_BUFFER + SIZE_OF_INT, "i32");
              }
              initialize() {
                C._ts_parser_new_wasm(), this[0] = getValue(TRANSFER_BUFFER, "i32"), this[1] = getValue(TRANSFER_BUFFER + SIZE_OF_INT, "i32");
              }
              delete() {
                C._ts_parser_delete(this[0]), C._free(this[1]), this[0] = 0, this[1] = 0;
              }
              setLanguage(e) {
                let t;
                if (e) {
                  if (e.constructor !== Language) throw new Error("Argument must be a Language");
                  {
                    t = e[0];
                    let r = C._ts_language_version(t);
                    if (r < MIN_COMPATIBLE_VERSION || VERSION < r) throw new Error(`Incompatible language version ${r}. Compatibility range ${MIN_COMPATIBLE_VERSION} through ${VERSION}.`);
                  }
                } else t = 0, e = null;
                return this.language = e, C._ts_parser_set_language(this[0], t), this;
              }
              getLanguage() {
                return this.language;
              }
              parse(e, t, r) {
                if (typeof e == "string") currentParseCallback = __name((t, r, _) => e.slice(t, _), "currentParseCallback");else {
                  if (typeof e != "function") throw new Error("Argument must be a string or a function");
                  currentParseCallback = e;
                }
                this.logCallback ? (currentLogCallback = this.logCallback, C._ts_parser_enable_logger_wasm(this[0], 1)) : (currentLogCallback = null, C._ts_parser_enable_logger_wasm(this[0], 0));
                let _ = 0,
                  n = 0;
                if (r && r.includedRanges) {
                  _ = r.includedRanges.length, n = C._calloc(_, SIZE_OF_RANGE);
                  let e = n;
                  for (let t = 0; t < _; t++) marshalRange(e, r.includedRanges[t]), e += SIZE_OF_RANGE;
                }
                let s = C._ts_parser_parse_wasm(this[0], this[1], t ? t[0] : 0, n, _);
                if (!s) throw currentParseCallback = null, currentLogCallback = null, new Error("Parsing failed");
                let a = new Tree(INTERNAL, s, this.language, currentParseCallback);
                return currentParseCallback = null, currentLogCallback = null, a;
              }
              reset() {
                C._ts_parser_reset(this[0]);
              }
              setTimeoutMicros(e) {
                C._ts_parser_set_timeout_micros(this[0], e);
              }
              getTimeoutMicros() {
                return C._ts_parser_timeout_micros(this[0]);
              }
              setLogger(e) {
                if (e) {
                  if (typeof e != "function") throw new Error("Logger callback must be a function");
                } else e = null;
                return this.logCallback = e, this;
              }
              getLogger() {
                return this.logCallback;
              }
            };
            __name(_ParserImpl, "ParserImpl");
            let ParserImpl = _ParserImpl,
              _Tree = class _Tree {
                constructor(e, t, r, _) {
                  assertInternal(e), this[0] = t, this.language = r, this.textCallback = _;
                }
                copy() {
                  let e = C._ts_tree_copy(this[0]);
                  return new _Tree(INTERNAL, e, this.language, this.textCallback);
                }
                delete() {
                  C._ts_tree_delete(this[0]), this[0] = 0;
                }
                edit(e) {
                  marshalEdit(e), C._ts_tree_edit_wasm(this[0]);
                }
                get rootNode() {
                  return C._ts_tree_root_node_wasm(this[0]), unmarshalNode(this);
                }
                getLanguage() {
                  return this.language;
                }
                walk() {
                  return this.rootNode.walk();
                }
                getChangedRanges(e) {
                  if (e.constructor !== _Tree) throw new TypeError("Argument must be a Tree");
                  C._ts_tree_get_changed_ranges_wasm(this[0], e[0]);
                  let t = getValue(TRANSFER_BUFFER, "i32"),
                    r = getValue(TRANSFER_BUFFER + SIZE_OF_INT, "i32"),
                    _ = new Array(t);
                  if (t > 0) {
                    let e = r;
                    for (let r = 0; r < t; r++) _[r] = unmarshalRange(e), e += SIZE_OF_RANGE;
                    C._free(r);
                  }
                  return _;
                }
              };
            __name(_Tree, "Tree");
            let Tree = _Tree,
              _Node = class _Node {
                constructor(e, t) {
                  assertInternal(e), this.tree = t;
                }
                get typeId() {
                  return marshalNode(this), C._ts_node_symbol_wasm(this.tree[0]);
                }
                get type() {
                  return this.tree.language.types[this.typeId] || "ERROR";
                }
                get endPosition() {
                  return marshalNode(this), C._ts_node_end_point_wasm(this.tree[0]), unmarshalPoint(TRANSFER_BUFFER);
                }
                get endIndex() {
                  return marshalNode(this), C._ts_node_end_index_wasm(this.tree[0]);
                }
                get text() {
                  return getText(this.tree, this.startIndex, this.endIndex);
                }
                isNamed() {
                  return marshalNode(this), C._ts_node_is_named_wasm(this.tree[0]) === 1;
                }
                hasError() {
                  return marshalNode(this), C._ts_node_has_error_wasm(this.tree[0]) === 1;
                }
                hasChanges() {
                  return marshalNode(this), C._ts_node_has_changes_wasm(this.tree[0]) === 1;
                }
                isMissing() {
                  return marshalNode(this), C._ts_node_is_missing_wasm(this.tree[0]) === 1;
                }
                equals(e) {
                  return this.id === e.id;
                }
                child(e) {
                  return marshalNode(this), C._ts_node_child_wasm(this.tree[0], e), unmarshalNode(this.tree);
                }
                namedChild(e) {
                  return marshalNode(this), C._ts_node_named_child_wasm(this.tree[0], e), unmarshalNode(this.tree);
                }
                childForFieldId(e) {
                  return marshalNode(this), C._ts_node_child_by_field_id_wasm(this.tree[0], e), unmarshalNode(this.tree);
                }
                childForFieldName(e) {
                  let t = this.tree.language.fields.indexOf(e);
                  if (t !== -1) return this.childForFieldId(t);
                }
                get childCount() {
                  return marshalNode(this), C._ts_node_child_count_wasm(this.tree[0]);
                }
                get namedChildCount() {
                  return marshalNode(this), C._ts_node_named_child_count_wasm(this.tree[0]);
                }
                get firstChild() {
                  return this.child(0);
                }
                get firstNamedChild() {
                  return this.namedChild(0);
                }
                get lastChild() {
                  return this.child(this.childCount - 1);
                }
                get lastNamedChild() {
                  return this.namedChild(this.namedChildCount - 1);
                }
                get children() {
                  if (!this._children) {
                    marshalNode(this), C._ts_node_children_wasm(this.tree[0]);
                    let e = getValue(TRANSFER_BUFFER, "i32"),
                      t = getValue(TRANSFER_BUFFER + SIZE_OF_INT, "i32");
                    if (this._children = new Array(e), e > 0) {
                      let r = t;
                      for (let t = 0; t < e; t++) this._children[t] = unmarshalNode(this.tree, r), r += SIZE_OF_NODE;
                      C._free(t);
                    }
                  }
                  return this._children;
                }
                get namedChildren() {
                  if (!this._namedChildren) {
                    marshalNode(this), C._ts_node_named_children_wasm(this.tree[0]);
                    let e = getValue(TRANSFER_BUFFER, "i32"),
                      t = getValue(TRANSFER_BUFFER + SIZE_OF_INT, "i32");
                    if (this._namedChildren = new Array(e), e > 0) {
                      let r = t;
                      for (let t = 0; t < e; t++) this._namedChildren[t] = unmarshalNode(this.tree, r), r += SIZE_OF_NODE;
                      C._free(t);
                    }
                  }
                  return this._namedChildren;
                }
                descendantsOfType(e, t, r) {
                  Array.isArray(e) || (e = [e]), t || (t = ZERO_POINT), r || (r = ZERO_POINT);
                  let _ = [],
                    n = this.tree.language.types;
                  for (let t = 0, r = n.length; t < r; t++) e.includes(n[t]) && _.push(t);
                  let s = C._malloc(SIZE_OF_INT * _.length);
                  for (let e = 0, t = _.length; e < t; e++) setValue(s + e * SIZE_OF_INT, _[e], "i32");
                  marshalNode(this), C._ts_node_descendants_of_type_wasm(this.tree[0], s, _.length, t.row, t.column, r.row, r.column);
                  let a = getValue(TRANSFER_BUFFER, "i32"),
                    o = getValue(TRANSFER_BUFFER + SIZE_OF_INT, "i32"),
                    i = new Array(a);
                  if (a > 0) {
                    let e = o;
                    for (let t = 0; t < a; t++) i[t] = unmarshalNode(this.tree, e), e += SIZE_OF_NODE;
                  }
                  return C._free(o), C._free(s), i;
                }
                get nextSibling() {
                  return marshalNode(this), C._ts_node_next_sibling_wasm(this.tree[0]), unmarshalNode(this.tree);
                }
                get previousSibling() {
                  return marshalNode(this), C._ts_node_prev_sibling_wasm(this.tree[0]), unmarshalNode(this.tree);
                }
                get nextNamedSibling() {
                  return marshalNode(this), C._ts_node_next_named_sibling_wasm(this.tree[0]), unmarshalNode(this.tree);
                }
                get previousNamedSibling() {
                  return marshalNode(this), C._ts_node_prev_named_sibling_wasm(this.tree[0]), unmarshalNode(this.tree);
                }
                get parent() {
                  return marshalNode(this), C._ts_node_parent_wasm(this.tree[0]), unmarshalNode(this.tree);
                }
                descendantForIndex(e, t = e) {
                  if (typeof e != "number" || typeof t != "number") throw new Error("Arguments must be numbers");
                  marshalNode(this);
                  let r = TRANSFER_BUFFER + SIZE_OF_NODE;
                  return setValue(r, e, "i32"), setValue(r + SIZE_OF_INT, t, "i32"), C._ts_node_descendant_for_index_wasm(this.tree[0]), unmarshalNode(this.tree);
                }
                namedDescendantForIndex(e, t = e) {
                  if (typeof e != "number" || typeof t != "number") throw new Error("Arguments must be numbers");
                  marshalNode(this);
                  let r = TRANSFER_BUFFER + SIZE_OF_NODE;
                  return setValue(r, e, "i32"), setValue(r + SIZE_OF_INT, t, "i32"), C._ts_node_named_descendant_for_index_wasm(this.tree[0]), unmarshalNode(this.tree);
                }
                descendantForPosition(e, t = e) {
                  if (!isPoint(e) || !isPoint(t)) throw new Error("Arguments must be {row, column} objects");
                  marshalNode(this);
                  let r = TRANSFER_BUFFER + SIZE_OF_NODE;
                  return marshalPoint(r, e), marshalPoint(r + SIZE_OF_POINT, t), C._ts_node_descendant_for_position_wasm(this.tree[0]), unmarshalNode(this.tree);
                }
                namedDescendantForPosition(e, t = e) {
                  if (!isPoint(e) || !isPoint(t)) throw new Error("Arguments must be {row, column} objects");
                  marshalNode(this);
                  let r = TRANSFER_BUFFER + SIZE_OF_NODE;
                  return marshalPoint(r, e), marshalPoint(r + SIZE_OF_POINT, t), C._ts_node_named_descendant_for_position_wasm(this.tree[0]), unmarshalNode(this.tree);
                }
                walk() {
                  return marshalNode(this), C._ts_tree_cursor_new_wasm(this.tree[0]), new TreeCursor(INTERNAL, this.tree);
                }
                toString() {
                  marshalNode(this);
                  let e = C._ts_node_to_string_wasm(this.tree[0]),
                    t = AsciiToString(e);
                  return C._free(e), t;
                }
              };
            __name(_Node, "Node");
            let Node = _Node,
              _TreeCursor = class _TreeCursor {
                constructor(e, t) {
                  assertInternal(e), this.tree = t, unmarshalTreeCursor(this);
                }
                delete() {
                  marshalTreeCursor(this), C._ts_tree_cursor_delete_wasm(this.tree[0]), this[0] = this[1] = this[2] = 0;
                }
                reset(e) {
                  marshalNode(e), marshalTreeCursor(this, TRANSFER_BUFFER + SIZE_OF_NODE), C._ts_tree_cursor_reset_wasm(this.tree[0]), unmarshalTreeCursor(this);
                }
                get nodeType() {
                  return this.tree.language.types[this.nodeTypeId] || "ERROR";
                }
                get nodeTypeId() {
                  return marshalTreeCursor(this), C._ts_tree_cursor_current_node_type_id_wasm(this.tree[0]);
                }
                get nodeId() {
                  return marshalTreeCursor(this), C._ts_tree_cursor_current_node_id_wasm(this.tree[0]);
                }
                get nodeIsNamed() {
                  return marshalTreeCursor(this), C._ts_tree_cursor_current_node_is_named_wasm(this.tree[0]) === 1;
                }
                get nodeIsMissing() {
                  return marshalTreeCursor(this), C._ts_tree_cursor_current_node_is_missing_wasm(this.tree[0]) === 1;
                }
                get nodeText() {
                  marshalTreeCursor(this);
                  let e = C._ts_tree_cursor_start_index_wasm(this.tree[0]),
                    t = C._ts_tree_cursor_end_index_wasm(this.tree[0]);
                  return getText(this.tree, e, t);
                }
                get startPosition() {
                  return marshalTreeCursor(this), C._ts_tree_cursor_start_position_wasm(this.tree[0]), unmarshalPoint(TRANSFER_BUFFER);
                }
                get endPosition() {
                  return marshalTreeCursor(this), C._ts_tree_cursor_end_position_wasm(this.tree[0]), unmarshalPoint(TRANSFER_BUFFER);
                }
                get startIndex() {
                  return marshalTreeCursor(this), C._ts_tree_cursor_start_index_wasm(this.tree[0]);
                }
                get endIndex() {
                  return marshalTreeCursor(this), C._ts_tree_cursor_end_index_wasm(this.tree[0]);
                }
                currentNode() {
                  return marshalTreeCursor(this), C._ts_tree_cursor_current_node_wasm(this.tree[0]), unmarshalNode(this.tree);
                }
                currentFieldId() {
                  return marshalTreeCursor(this), C._ts_tree_cursor_current_field_id_wasm(this.tree[0]);
                }
                currentFieldName() {
                  return this.tree.language.fields[this.currentFieldId()];
                }
                gotoFirstChild() {
                  marshalTreeCursor(this);
                  let e = C._ts_tree_cursor_goto_first_child_wasm(this.tree[0]);
                  return unmarshalTreeCursor(this), e === 1;
                }
                gotoNextSibling() {
                  marshalTreeCursor(this);
                  let e = C._ts_tree_cursor_goto_next_sibling_wasm(this.tree[0]);
                  return unmarshalTreeCursor(this), e === 1;
                }
                gotoParent() {
                  marshalTreeCursor(this);
                  let e = C._ts_tree_cursor_goto_parent_wasm(this.tree[0]);
                  return unmarshalTreeCursor(this), e === 1;
                }
              };
            __name(_TreeCursor, "TreeCursor");
            let TreeCursor = _TreeCursor,
              _Language = class _Language {
                constructor(e, t) {
                  assertInternal(e), this[0] = t, this.types = new Array(C._ts_language_symbol_count(this[0]));
                  for (let e = 0, t = this.types.length; e < t; e++) C._ts_language_symbol_type(this[0], e) < 2 && (this.types[e] = UTF8ToString(C._ts_language_symbol_name(this[0], e)));
                  this.fields = new Array(C._ts_language_field_count(this[0]) + 1);
                  for (let e = 0, t = this.fields.length; e < t; e++) {
                    let t = C._ts_language_field_name_for_id(this[0], e);
                    this.fields[e] = t !== 0 ? UTF8ToString(t) : null;
                  }
                }
                get version() {
                  return C._ts_language_version(this[0]);
                }
                get fieldCount() {
                  return this.fields.length - 1;
                }
                fieldIdForName(e) {
                  let t = this.fields.indexOf(e);
                  return t !== -1 ? t : null;
                }
                fieldNameForId(e) {
                  return this.fields[e] || null;
                }
                idForNodeType(e, t) {
                  let r = lengthBytesUTF8(e),
                    _ = C._malloc(r + 1);
                  stringToUTF8(e, _, r + 1);
                  let n = C._ts_language_symbol_for_name(this[0], _, r, t);
                  return C._free(_), n || null;
                }
                get nodeTypeCount() {
                  return C._ts_language_symbol_count(this[0]);
                }
                nodeTypeForId(e) {
                  let t = C._ts_language_symbol_name(this[0], e);
                  return t ? UTF8ToString(t) : null;
                }
                nodeTypeIsNamed(e) {
                  return !!C._ts_language_type_is_named_wasm(this[0], e);
                }
                nodeTypeIsVisible(e) {
                  return !!C._ts_language_type_is_visible_wasm(this[0], e);
                }
                query(e) {
                  let t = lengthBytesUTF8(e),
                    r = C._malloc(t + 1);
                  stringToUTF8(e, r, t + 1);
                  let _ = C._ts_query_new(this[0], r, t, TRANSFER_BUFFER, TRANSFER_BUFFER + SIZE_OF_INT);
                  if (!_) {
                    let t = getValue(TRANSFER_BUFFER + SIZE_OF_INT, "i32"),
                      _ = UTF8ToString(r, getValue(TRANSFER_BUFFER, "i32")).length,
                      n = e.substr(_, 100).split(`
`)[0],
                      s,
                      a = n.match(QUERY_WORD_REGEX)[0];
                    switch (t) {
                      case 2:
                        s = new RangeError(`Bad node name '${a}'`);
                        break;
                      case 3:
                        s = new RangeError(`Bad field name '${a}'`);
                        break;
                      case 4:
                        s = new RangeError(`Bad capture name @${a}`);
                        break;
                      case 5:
                        s = new TypeError(`Bad pattern structure at offset ${_}: '${n}'...`), a = "";
                        break;
                      default:
                        s = new SyntaxError(`Bad syntax at offset ${_}: '${n}'...`), a = "";
                    }
                    throw s.index = _, s.length = a.length, C._free(r), s;
                  }
                  let n = C._ts_query_string_count(_),
                    s = C._ts_query_capture_count(_),
                    a = C._ts_query_pattern_count(_),
                    o = new Array(s),
                    i = new Array(n);
                  for (let e = 0; e < s; e++) {
                    let t = C._ts_query_capture_name_for_id(_, e, TRANSFER_BUFFER),
                      r = getValue(TRANSFER_BUFFER, "i32");
                    o[e] = UTF8ToString(t, r);
                  }
                  for (let e = 0; e < n; e++) {
                    let t = C._ts_query_string_value_for_id(_, e, TRANSFER_BUFFER),
                      r = getValue(TRANSFER_BUFFER, "i32");
                    i[e] = UTF8ToString(t, r);
                  }
                  let l = new Array(a),
                    u = new Array(a),
                    d = new Array(a),
                    c = new Array(a),
                    m = new Array(a);
                  for (let e = 0; e < a; e++) {
                    let t = C._ts_query_predicates_for_pattern(_, e, TRANSFER_BUFFER),
                      r = getValue(TRANSFER_BUFFER, "i32");
                    c[e] = [], m[e] = [];
                    let n = [],
                      s = t;
                    for (let t = 0; t < r; t++) {
                      let t = getValue(s, "i32");
                      s += SIZE_OF_INT;
                      let r = getValue(s, "i32");
                      if (s += SIZE_OF_INT, t === PREDICATE_STEP_TYPE_CAPTURE) n.push({
                        type: "capture",
                        name: o[r]
                      });else if (t === PREDICATE_STEP_TYPE_STRING) n.push({
                        type: "string",
                        value: i[r]
                      });else if (n.length > 0) {
                        if (n[0].type !== "string") throw new Error("Predicates must begin with a literal value");
                        let t = n[0].value,
                          r = !0;
                        switch (t) {
                          case "not-eq?":
                            r = !1;
                          case "eq?":
                            if (n.length !== 3) throw new Error("Wrong number of arguments to `#eq?` predicate. Expected 2, got " + (n.length - 1));
                            if (n[1].type !== "capture") throw new Error(`First argument of \`#eq?\` predicate must be a capture. Got "${n[1].value}"`);
                            if (n[2].type === "capture") {
                              let t = n[1].name,
                                _ = n[2].name;
                              m[e].push(function (e) {
                                let n, s;
                                for (let r of e) r.name === t && (n = r.node), r.name === _ && (s = r.node);
                                return n === void 0 || s === void 0 || n.text === s.text === r;
                              });
                            } else {
                              let t = n[1].name,
                                _ = n[2].value;
                              m[e].push(function (e) {
                                for (let n of e) if (n.name === t) return n.node.text === _ === r;
                                return !0;
                              });
                            }
                            break;
                          case "not-match?":
                            r = !1;
                          case "match?":
                            if (n.length !== 3) throw new Error(`Wrong number of arguments to \`#match?\` predicate. Expected 2, got ${n.length - 1}.`);
                            if (n[1].type !== "capture") throw new Error(`First argument of \`#match?\` predicate must be a capture. Got "${n[1].value}".`);
                            if (n[2].type !== "string") throw new Error(`Second argument of \`#match?\` predicate must be a string. Got @${n[2].value}.`);
                            let _ = n[1].name,
                              s = new RegExp(n[2].value);
                            m[e].push(function (e) {
                              for (let t of e) if (t.name === _) return s.test(t.node.text) === r;
                              return !0;
                            });
                            break;
                          case "set!":
                            if (n.length < 2 || n.length > 3) throw new Error(`Wrong number of arguments to \`#set!\` predicate. Expected 1 or 2. Got ${n.length - 1}.`);
                            if (n.some(e => e.type !== "string")) throw new Error('Arguments to `#set!` predicate must be a strings.".');
                            l[e] || (l[e] = {}), l[e][n[1].value] = n[2] ? n[2].value : null;
                            break;
                          case "is?":
                          case "is-not?":
                            if (n.length < 2 || n.length > 3) throw new Error(`Wrong number of arguments to \`#${t}\` predicate. Expected 1 or 2. Got ${n.length - 1}.`);
                            if (n.some(e => e.type !== "string")) throw new Error(`Arguments to \`#${t}\` predicate must be a strings.".`);
                            let a = t === "is?" ? u : d;
                            a[e] || (a[e] = {}), a[e][n[1].value] = n[2] ? n[2].value : null;
                            break;
                          default:
                            c[e].push({
                              operator: t,
                              operands: n.slice(1)
                            });
                        }
                        n.length = 0;
                      }
                    }
                    Object.freeze(l[e]), Object.freeze(u[e]), Object.freeze(d[e]);
                  }
                  return C._free(r), new Query(INTERNAL, _, o, m, c, Object.freeze(l), Object.freeze(u), Object.freeze(d));
                }
                static load(e) {
                  let t;
                  if (e instanceof Uint8Array) t = Promise.resolve(e);else {
                    let r = e;
                    if (typeof process < "u" && process.versions && process.versions.node) {
                      let e = require("fs");
                      t = Promise.resolve(e.readFileSync(r));
                    } else t = fetch(r).then(e => e.arrayBuffer().then(t => {
                      if (e.ok) return new Uint8Array(t);
                      {
                        let r = new TextDecoder("utf-8").decode(t);
                        throw new Error(`Language.load failed with status ${e.status}.

${r}`);
                      }
                    }));
                  }
                  let r = typeof loadSideModule == "function" ? loadSideModule : loadWebAssemblyModule;
                  return t.then(e => r(e, {
                    loadAsync: !0
                  })).then(e => {
                    let t = Object.keys(e),
                      r = t.find(e => LANGUAGE_FUNCTION_REGEX.test(e) && !e.includes("external_scanner_"));
                    r || console.log(`Couldn't find language function in WASM file. Symbols:
${JSON.stringify(t, null, 2)}`);
                    let _ = e[r]();
                    return new _Language(INTERNAL, _);
                  });
                }
              };
            __name(_Language, "Language");
            let Language = _Language,
              _Query = class _Query {
                constructor(e, t, r, _, n, s, a, o) {
                  assertInternal(e), this[0] = t, this.captureNames = r, this.textPredicates = _, this.predicates = n, this.setProperties = s, this.assertedProperties = a, this.refutedProperties = o, this.exceededMatchLimit = !1;
                }
                delete() {
                  C._ts_query_delete(this[0]), this[0] = 0;
                }
                matches(e, t, r, _) {
                  t || (t = ZERO_POINT), r || (r = ZERO_POINT), _ || (_ = {});
                  let n = _.matchLimit;
                  if (n === void 0) n = 0;else if (typeof n != "number") throw new Error("Arguments must be numbers");
                  marshalNode(e), C._ts_query_matches_wasm(this[0], e.tree[0], t.row, t.column, r.row, r.column, n);
                  let s = getValue(TRANSFER_BUFFER, "i32"),
                    a = getValue(TRANSFER_BUFFER + SIZE_OF_INT, "i32"),
                    o = getValue(TRANSFER_BUFFER + 2 * SIZE_OF_INT, "i32"),
                    i = new Array(s);
                  this.exceededMatchLimit = !!o;
                  let l = 0,
                    u = a;
                  for (let t = 0; t < s; t++) {
                    let r = getValue(u, "i32");
                    u += SIZE_OF_INT;
                    let _ = getValue(u, "i32");
                    u += SIZE_OF_INT;
                    let n = new Array(_);
                    if (u = unmarshalCaptures(this, e.tree, u, n), this.textPredicates[r].every(e => e(n))) {
                      i[l++] = {
                        pattern: r,
                        captures: n
                      };
                      let e = this.setProperties[r];
                      e && (i[t].setProperties = e);
                      let _ = this.assertedProperties[r];
                      _ && (i[t].assertedProperties = _);
                      let s = this.refutedProperties[r];
                      s && (i[t].refutedProperties = s);
                    }
                  }
                  return i.length = l, C._free(a), i;
                }
                captures(e, t, r, _) {
                  t || (t = ZERO_POINT), r || (r = ZERO_POINT), _ || (_ = {});
                  let n = _.matchLimit;
                  if (n === void 0) n = 0;else if (typeof n != "number") throw new Error("Arguments must be numbers");
                  marshalNode(e), C._ts_query_captures_wasm(this[0], e.tree[0], t.row, t.column, r.row, r.column, n);
                  let s = getValue(TRANSFER_BUFFER, "i32"),
                    a = getValue(TRANSFER_BUFFER + SIZE_OF_INT, "i32"),
                    o = getValue(TRANSFER_BUFFER + 2 * SIZE_OF_INT, "i32"),
                    i = [];
                  this.exceededMatchLimit = !!o;
                  let l = [],
                    u = a;
                  for (let t = 0; t < s; t++) {
                    let t = getValue(u, "i32");
                    u += SIZE_OF_INT;
                    let r = getValue(u, "i32");
                    u += SIZE_OF_INT;
                    let _ = getValue(u, "i32");
                    if (u += SIZE_OF_INT, l.length = r, u = unmarshalCaptures(this, e.tree, u, l), this.textPredicates[t].every(e => e(l))) {
                      let e = l[_],
                        r = this.setProperties[t];
                      r && (e.setProperties = r);
                      let n = this.assertedProperties[t];
                      n && (e.assertedProperties = n);
                      let s = this.refutedProperties[t];
                      s && (e.refutedProperties = s), i.push(e);
                    }
                  }
                  return C._free(a), i;
                }
                predicatesForPattern(e) {
                  return this.predicates[e];
                }
                didExceedMatchLimit() {
                  return this.exceededMatchLimit;
                }
              };
            __name(_Query, "Query");
            let Query = _Query;
            function getText(e, t, r) {
              let _ = r - t,
                n = e.textCallback(t, null, r);
              for (t += n.length; t < r;) {
                let _ = e.textCallback(t, null, r);
                if (!(_ && _.length > 0)) break;
                t += _.length, n += _;
              }
              return t > r && (n = n.slice(0, _)), n;
            }
            __name(getText, "getText");
            function unmarshalCaptures(e, t, r, _) {
              for (let n = 0, s = _.length; n < s; n++) {
                let s = getValue(r, "i32"),
                  a = unmarshalNode(t, r += SIZE_OF_INT);
                r += SIZE_OF_NODE, _[n] = {
                  name: e.captureNames[s],
                  node: a
                };
              }
              return r;
            }
            __name(unmarshalCaptures, "unmarshalCaptures");
            function assertInternal(e) {
              if (e !== INTERNAL) throw new Error("Illegal constructor");
            }
            __name(assertInternal, "assertInternal");
            function isPoint(e) {
              return e && typeof e.row == "number" && typeof e.column == "number";
            }
            __name(isPoint, "isPoint");
            function marshalNode(e) {
              let t = TRANSFER_BUFFER;
              setValue(t, e.id, "i32"), t += SIZE_OF_INT, setValue(t, e.startIndex, "i32"), t += SIZE_OF_INT, setValue(t, e.startPosition.row, "i32"), t += SIZE_OF_INT, setValue(t, e.startPosition.column, "i32"), t += SIZE_OF_INT, setValue(t, e[0], "i32");
            }
            __name(marshalNode, "marshalNode");
            function unmarshalNode(e, t = TRANSFER_BUFFER) {
              let r = getValue(t, "i32");
              if (r === 0) return null;
              let _ = getValue(t += SIZE_OF_INT, "i32"),
                n = getValue(t += SIZE_OF_INT, "i32"),
                s = getValue(t += SIZE_OF_INT, "i32"),
                a = getValue(t += SIZE_OF_INT, "i32"),
                o = new Node(INTERNAL, e);
              return o.id = r, o.startIndex = _, o.startPosition = {
                row: n,
                column: s
              }, o[0] = a, o;
            }
            __name(unmarshalNode, "unmarshalNode");
            function marshalTreeCursor(e, t = TRANSFER_BUFFER) {
              setValue(t + 0 * SIZE_OF_INT, e[0], "i32"), setValue(t + 1 * SIZE_OF_INT, e[1], "i32"), setValue(t + 2 * SIZE_OF_INT, e[2], "i32");
            }
            __name(marshalTreeCursor, "marshalTreeCursor");
            function unmarshalTreeCursor(e) {
              e[0] = getValue(TRANSFER_BUFFER + 0 * SIZE_OF_INT, "i32"), e[1] = getValue(TRANSFER_BUFFER + 1 * SIZE_OF_INT, "i32"), e[2] = getValue(TRANSFER_BUFFER + 2 * SIZE_OF_INT, "i32");
            }
            __name(unmarshalTreeCursor, "unmarshalTreeCursor");
            function marshalPoint(e, t) {
              setValue(e, t.row, "i32"), setValue(e + SIZE_OF_INT, t.column, "i32");
            }
            __name(marshalPoint, "marshalPoint");
            function unmarshalPoint(e) {
              return {
                row: getValue(e, "i32"),
                column: getValue(e + SIZE_OF_INT, "i32")
              };
            }
            __name(unmarshalPoint, "unmarshalPoint");
            function marshalRange(e, t) {
              marshalPoint(e, t.startPosition), marshalPoint(e += SIZE_OF_POINT, t.endPosition), setValue(e += SIZE_OF_POINT, t.startIndex, "i32"), setValue(e += SIZE_OF_INT, t.endIndex, "i32"), e += SIZE_OF_INT;
            }
            __name(marshalRange, "marshalRange");
            function unmarshalRange(e) {
              let t = {};
              return t.startPosition = unmarshalPoint(e), e += SIZE_OF_POINT, t.endPosition = unmarshalPoint(e), e += SIZE_OF_POINT, t.startIndex = getValue(e, "i32"), e += SIZE_OF_INT, t.endIndex = getValue(e, "i32"), t;
            }
            __name(unmarshalRange, "unmarshalRange");
            function marshalEdit(e) {
              let t = TRANSFER_BUFFER;
              marshalPoint(t, e.startPosition), t += SIZE_OF_POINT, marshalPoint(t, e.oldEndPosition), t += SIZE_OF_POINT, marshalPoint(t, e.newEndPosition), t += SIZE_OF_POINT, setValue(t, e.startIndex, "i32"), t += SIZE_OF_INT, setValue(t, e.oldEndIndex, "i32"), t += SIZE_OF_INT, setValue(t, e.newEndIndex, "i32"), t += SIZE_OF_INT;
            }
            __name(marshalEdit, "marshalEdit");
            for (let e of Object.getOwnPropertyNames(ParserImpl.prototype)) Object.defineProperty(_Parser.prototype, e, {
              value: ParserImpl.prototype[e],
              enumerable: !1,
              writable: !1
            });
            _Parser.Language = Language, Module.onRuntimeInitialized = () => {
              ParserImpl.init(), resolveInitPromise();
            };
          }));
        }
      };
      __name(_Parser, "Parser");
      let Parser = _Parser;
      return Parser;
    }();
  typeof exports == "object" && (module.exports = TreeSitter);
});,var ZIe = j((iL, GIe) => {
  (function (e, t) {
    typeof iL == "object" && typeof GIe < "u" ? t(iL) : typeof define == "function" && define.amd ? define(["exports"], t) : (e = typeof globalThis < "u" ? globalThis : e || self, t((e.Microsoft = e.Microsoft || {}, e.Microsoft.ApplicationInsights = e.Microsoft.ApplicationInsights || {})));
  })(iL, function (e) {
    "use strict";

    function _pureAssign(func1, func2) {
      return func1 || func2;
    }
    __name(_pureAssign, "_pureAssign");
    function _pureRef(value, name) {
      return value[name];
    }
    __name(_pureRef, "_pureRef");
    var UNDEF_VALUE = void 0,
      NULL_VALUE = null,
      EMPTY = "",
      FUNCTION = "function",
      OBJECT = "object",
      PROTOTYPE = "prototype",
      __PROTO__ = "__proto__",
      UNDEFINED = "undefined",
      CONSTRUCTOR = "constructor",
      SYMBOL = "Symbol",
      POLYFILL_TAG = "_polyfill",
      LENGTH = "length",
      NAME = "name",
      CALL = "call",
      TO_STRING = "toString",
      ObjClass = _pureAssign(Object),
      ObjProto = _pureRef(ObjClass, PROTOTYPE),
      StrCls = _pureAssign(String),
      StrProto = _pureRef(StrCls, PROTOTYPE),
      MathCls = _pureAssign(Math),
      ArrCls = _pureAssign(Array),
      ArrProto = _pureRef(ArrCls, PROTOTYPE),
      ArrSlice = _pureRef(ArrProto, "slice");
    function safe(func, argArray) {
      try {
        return {
          v: func.apply(this, argArray)
        };
      } catch (e) {
        return {
          e: e
        };
      }
    }
    __name(safe, "safe");
    function _createIs(theType) {
      return function (value) {
        return typeof value === theType;
      };
    }
    __name(_createIs, "_createIs");
    function _createObjIs(theName) {
      var theType = "[object " + theName + "]";
      return function (value) {
        return !!(value && objToString(value) === theType);
      };
    }
    __name(_createObjIs, "_createObjIs");
    function objToString(value) {
      return ObjProto[TO_STRING].call(value);
    }
    __name(objToString, "objToString");
    function isUndefined(value) {
      return typeof value === UNDEFINED || value === UNDEFINED;
    }
    __name(isUndefined, "isUndefined");
    function isStrictUndefined(arg) {
      return !isDefined(arg);
    }
    __name(isStrictUndefined, "isStrictUndefined");
    function isNullOrUndefined(value) {
      return value === NULL_VALUE || isUndefined(value);
    }
    __name(isNullOrUndefined, "isNullOrUndefined");
    function isDefined(arg) {
      return !!arg || arg !== UNDEF_VALUE;
    }
    __name(isDefined, "isDefined");
    var isString = _createIs("string"),
      isFunction = _createIs(FUNCTION);
    function isObject(value) {
      return !value && isNullOrUndefined(value) ? !1 : !!value && typeof value === OBJECT;
    }
    __name(isObject, "isObject");
    var isArray = _pureRef(ArrCls, "isArray"),
      isError = _createObjIs("Error"),
      objGetOwnPropertyDescriptor = _pureRef(ObjClass, "getOwnPropertyDescriptor");
    function objHasOwnProperty(obj, prop) {
      return !!obj && ObjProto.hasOwnProperty[CALL](obj, prop);
    }
    __name(objHasOwnProperty, "objHasOwnProperty");
    var objHasOwn = _pureAssign(_pureRef(ObjClass, "hasOwn"), polyObjHasOwn);
    function polyObjHasOwn(obj, prop) {
      return objHasOwnProperty(obj, prop) || !!objGetOwnPropertyDescriptor(obj, prop);
    }
    __name(polyObjHasOwn, "polyObjHasOwn");
    function objForEachKey(theObject, callbackfn, thisArg) {
      if (theObject && isObject(theObject)) {
        for (var prop in theObject) if (objHasOwn(theObject, prop) && callbackfn[CALL](thisArg || theObject, prop, theObject[prop]) === -1) break;
      }
    }
    __name(objForEachKey, "objForEachKey");
    var propMap = {
      e: "enumerable",
      c: "configurable",
      v: "value",
      w: "writable",
      g: "get",
      s: "set"
    };
    function _createProp(value) {
      var prop = {};
      if (prop[propMap.c] = !0, prop[propMap.e] = !0, value.l) {
        prop.get = function () {
          return value.l.v;
        };
        var desc = objGetOwnPropertyDescriptor(value.l, "v");
        desc && desc.set && (prop.set = function (newValue) {
          value.l.v = newValue;
        });
      }
      return objForEachKey(value, function (key, value) {
        prop[propMap[key]] = isStrictUndefined(value) ? prop[propMap[key]] : value;
      }), prop;
    }
    __name(_createProp, "_createProp");
    var objDefineProp = _pureRef(ObjClass, "defineProperty");
    function objDefine(target, key, propDesc) {
      return objDefineProp(target, key, _createProp(propDesc));
    }
    __name(objDefine, "objDefine");
    function _createKeyValueMap(values, keyType, valueType, completeFn, writable) {
      var theMap = {};
      return objForEachKey(values, function (key, value) {
        _assignMapValue(theMap, key, keyType ? value : key), _assignMapValue(theMap, value, valueType ? value : key);
      }), completeFn ? completeFn(theMap) : theMap;
    }
    __name(_createKeyValueMap, "_createKeyValueMap");
    function _assignMapValue(theMap, key, value, writable) {
      objDefineProp(theMap, key, {
        value: value,
        enumerable: !0,
        writable: !1
      });
    }
    __name(_assignMapValue, "_assignMapValue");
    var asString = _pureAssign(StrCls),
      ERROR_TYPE = "[object Error]";
    function dumpObj(object, format) {
      var propertyValueDump = EMPTY,
        objType = ObjProto[TO_STRING][CALL](object);
      objType === ERROR_TYPE && (object = {
        stack: asString(object.stack),
        message: asString(object.message),
        name: asString(object.name)
      });
      try {
        propertyValueDump = JSON.stringify(object, NULL_VALUE, format ? typeof format == "number" ? format : 4 : UNDEF_VALUE), propertyValueDump = (propertyValueDump ? propertyValueDump.replace(/"(\w+)"\s*:\s{0,1}/g, "$1: ") : NULL_VALUE) || asString(object);
      } catch (e) {
        propertyValueDump = " - " + dumpObj(e, format);
      }
      return objType + ": " + propertyValueDump;
    }
    __name(dumpObj, "dumpObj");
    function throwError(message) {
      throw new Error(message);
    }
    __name(throwError, "throwError");
    function throwTypeError(message) {
      throw new TypeError(message);
    }
    __name(throwTypeError, "throwTypeError");
    var _objFreeze = _pureRef(ObjClass, "freeze");
    function _doNothing(value) {
      return value;
    }
    __name(_doNothing, "_doNothing");
    function _getProto(value) {
      return value[__PROTO__] || NULL_VALUE;
    }
    __name(_getProto, "_getProto");
    var objAssign = _pureRef(ObjClass, "assign"),
      objKeys = _pureRef(ObjClass, "keys"),
      objFreeze = _pureAssign(_objFreeze, _doNothing),
      objGetPrototypeOf = _pureAssign(_pureRef(ObjClass, "getPrototypeOf"), _getProto);
    function createEnum(values) {
      return _createKeyValueMap(values, 1, 0, objFreeze);
    }
    __name(createEnum, "createEnum");
    function createSimpleMap(values) {
      var mapClass = {};
      return objForEachKey(values, function (key, value) {
        _assignMapValue(mapClass, key, value[1]), _assignMapValue(mapClass, value[0], value[1]);
      }), objFreeze(mapClass);
    }
    __name(createSimpleMap, "createSimpleMap");
    function createTypeMap(values) {
      return createSimpleMap(values);
    }
    __name(createTypeMap, "createTypeMap");
    var GLOBAL_CONFIG_KEY = "__tsUtils$gblCfg",
      _globalCfg;
    function _getGlobalValue() {
      var result;
      return typeof globalThis !== UNDEFINED && (result = globalThis), !result && typeof self !== UNDEFINED && (result = self), !result && typeof window !== UNDEFINED && (result = window), !result && typeof global !== UNDEFINED && (result = global), result;
    }
    __name(_getGlobalValue, "_getGlobalValue");
    function _getGlobalConfig() {
      if (!_globalCfg) {
        var gbl = safe(_getGlobalValue).v || {};
        _globalCfg = gbl[GLOBAL_CONFIG_KEY] = gbl[GLOBAL_CONFIG_KEY] || {};
      }
      return _globalCfg;
    }
    __name(_getGlobalConfig, "_getGlobalConfig");
    var _unwrapFunction = _unwrapFunctionWithPoly;
    function _unwrapFunctionWithPoly(funcName, clsProto, polyFunc) {
      var clsFn = clsProto ? clsProto[funcName] : NULL_VALUE;
      return function (thisArg) {
        var theFunc = (thisArg ? thisArg[funcName] : NULL_VALUE) || clsFn;
        if (theFunc || polyFunc) {
          var theArgs = arguments;
          return (theFunc || polyFunc).apply(thisArg, theFunc ? ArrSlice[CALL](theArgs, 1) : theArgs);
        }
        throwTypeError('"' + asString(funcName) + '" not defined for ' + dumpObj(thisArg));
      };
    }
    __name(_unwrapFunctionWithPoly, "_unwrapFunctionWithPoly");
    var mathMin = _pureRef(MathCls, "min"),
      mathMax = _pureRef(MathCls, "max"),
      strSlice = _unwrapFunction("slice", StrProto),
      strSubstring = _unwrapFunction("substring", StrProto),
      strSubstr = _unwrapFunctionWithPoly("substr", StrProto, polyStrSubstr);
    function polyStrSubstr(value, start, length) {
      return isNullOrUndefined(value) && throwTypeError("Invalid " + dumpObj(value)), length < 0 ? EMPTY : (start = start || 0, start < 0 && (start = mathMax(start + value[LENGTH], 0)), isUndefined(length) ? strSlice(value, start) : strSlice(value, start, start + length));
    }
    __name(polyStrSubstr, "polyStrSubstr");
    function strLeft(value, count) {
      return strSubstring(value, 0, count);
    }
    __name(strLeft, "strLeft");
    var UNIQUE_REGISTRY_ID = "_urid",
      _polySymbols;
    function _globalSymbolRegistry() {
      if (!_polySymbols) {
        var gblCfg = _getGlobalConfig();
        _polySymbols = gblCfg.gblSym = gblCfg.gblSym || {
          k: {},
          s: {}
        };
      }
      return _polySymbols;
    }
    __name(_globalSymbolRegistry, "_globalSymbolRegistry");
    function polyNewSymbol(description) {
      var theSymbol = {
        description: asString(description),
        toString: __name(function () {
          return SYMBOL + "(" + description + ")";
        }, "toString")
      };
      return theSymbol[POLYFILL_TAG] = !0, theSymbol;
    }
    __name(polyNewSymbol, "polyNewSymbol");
    function polySymbolFor(key) {
      var registry = _globalSymbolRegistry();
      if (!objHasOwn(registry.k, key)) {
        var newSymbol_1 = polyNewSymbol(key),
          regId_1 = objKeys(registry.s).length;
        newSymbol_1[UNIQUE_REGISTRY_ID] = function () {
          return regId_1 + "_" + newSymbol_1[TO_STRING]();
        }, registry.k[key] = newSymbol_1, registry.s[newSymbol_1[UNIQUE_REGISTRY_ID]()] = asString(key);
      }
      return registry.k[key];
    }
    __name(polySymbolFor, "polySymbolFor");
    var _globalLazyTestHooks;
    function _initTestHooks() {
      _globalLazyTestHooks = _getGlobalConfig();
    }
    __name(_initTestHooks, "_initTestHooks");
    function createCachedValue(value) {
      return objDefineProp({
        toJSON: __name(function () {
          return value;
        }, "toJSON")
      }, "v", {
        value: value
      });
    }
    __name(createCachedValue, "createCachedValue");
    var WINDOW = "window",
      _cachedGlobal;
    function _getGlobalInstFn(getFn, theArgs) {
      var cachedValue;
      return function () {
        return !_globalLazyTestHooks && _initTestHooks(), (!cachedValue || _globalLazyTestHooks.lzy) && (cachedValue = createCachedValue(safe(getFn, theArgs).v)), cachedValue.v;
      };
    }
    __name(_getGlobalInstFn, "_getGlobalInstFn");
    function getGlobal(useCached) {
      return !_globalLazyTestHooks && _initTestHooks(), (!_cachedGlobal || useCached === !1 || _globalLazyTestHooks.lzy) && (_cachedGlobal = createCachedValue(safe(_getGlobalValue).v || NULL_VALUE)), _cachedGlobal.v;
    }
    __name(getGlobal, "getGlobal");
    function getInst(name, useCached) {
      var gbl;
      if (!_cachedGlobal || useCached === !1 ? gbl = getGlobal(useCached) : gbl = _cachedGlobal.v, gbl && gbl[name]) return gbl[name];
      if (name === WINDOW) try {
        return window;
      } catch {}
      return NULL_VALUE;
    }
    __name(getInst, "getInst");
    var getDocument = _getGlobalInstFn(getInst, ["document"]);
    function hasWindow() {
      return !!getWindow();
    }
    __name(hasWindow, "hasWindow");
    var getWindow = _getGlobalInstFn(getInst, [WINDOW]);
    function hasNavigator() {
      return !!getNavigator();
    }
    __name(hasNavigator, "hasNavigator");
    var getNavigator = _getGlobalInstFn(getInst, ["navigator"]),
      _symbol,
      _symbolFor;
    function _initSymbol() {
      return _symbol = createCachedValue(safe(getInst, [SYMBOL]).v), _symbol;
    }
    __name(_initSymbol, "_initSymbol");
    function _getSymbolKey(key) {
      var gblSym = (_globalLazyTestHooks.lzy ? 0 : _symbol) || _initSymbol();
      return gblSym.v ? gblSym.v[key] : UNDEF_VALUE;
    }
    __name(_getSymbolKey, "_getSymbolKey");
    function newSymbol(description, noPoly) {
      !_globalLazyTestHooks && _initTestHooks();
      var sym = (_globalLazyTestHooks.lzy ? 0 : _symbol) || _initSymbol();
      return sym.v ? sym.v(description) : noPoly ? NULL_VALUE : polyNewSymbol(description);
    }
    __name(newSymbol, "newSymbol");
    function symbolFor(key) {
      return !_globalLazyTestHooks && _initTestHooks(), _symbolFor = (_globalLazyTestHooks.lzy ? 0 : _symbolFor) || createCachedValue(safe(_getSymbolKey, ["for"]).v), (_symbolFor.v || polySymbolFor)(key);
    }
    __name(symbolFor, "symbolFor");
    function fnApply(fn, thisArg, argArray) {
      return fn.apply(thisArg, argArray);
    }
    __name(fnApply, "fnApply");
    function arrForEach(theArray, callbackfn, thisArg) {
      if (theArray) for (var len = theArray[LENGTH] >>> 0, idx = 0; idx < len && !(idx in theArray && callbackfn[CALL](thisArg || theArray, theArray[idx], idx, theArray) === -1); idx++);
    }
    __name(arrForEach, "arrForEach");
    var arrIndexOf = _unwrapFunction("indexOf", ArrProto),
      arrMap = _unwrapFunction("map", ArrProto),
      arrReduce = _unwrapFunction("reduce", ArrProto),
      objCreate = _pureAssign(_pureRef(ObjClass, "create"), polyObjCreate);
    function polyObjCreate(obj) {
      if (!obj) return {};
      var type = typeof obj;
      type !== OBJECT && type !== FUNCTION && throwTypeError("Prototype must be an Object or function: " + dumpObj(obj));
      function tempFunc() {}
      return __name(tempFunc, "tempFunc"), tempFunc[PROTOTYPE] = obj, new tempFunc();
    }
    __name(polyObjCreate, "polyObjCreate");
    var _isProtoArray;
    function objSetPrototypeOf(obj, proto) {
      var fn = ObjClass.setPrototypeOf || function (d, b) {
        var ke;
        !_isProtoArray && (_isProtoArray = createCachedValue((_a = {}, _a[__PROTO__] = [], _a instanceof Array))), _isProtoArray.v ? d[__PROTO__] = b : objForEachKey(b, function (key, value) {
          return d[key] = value;
        });
      };
      return fn(obj, proto);
    }
    __name(objSetPrototypeOf, "objSetPrototypeOf");
    function _createCustomError(name, d, b) {
      safe(objDefine, [d, NAME, {
        v: name,
        c: !0,
        e: !1
      }]), d = objSetPrototypeOf(d, b);
      function __() {
        this[CONSTRUCTOR] = d, safe(objDefine, [this, NAME, {
          v: name,
          c: !0,
          e: !1
        }]);
      }
      return __name(__, "__"), d[PROTOTYPE] = b === NULL_VALUE ? objCreate(b) : (__[PROTOTYPE] = b[PROTOTYPE], new __()), d;
    }
    __name(_createCustomError, "_createCustomError");
    function _setName(baseClass, name) {
      name && (baseClass[NAME] = name);
    }
    __name(_setName, "_setName");
    function createCustomError(name, constructCb, errorBase) {
      var theBaseClass = errorBase || Error,
        orgName = theBaseClass[PROTOTYPE][NAME],
        captureFn = Error.captureStackTrace;
      return _createCustomError(name, function () {
        var _this = this,
          theArgs = arguments;
        try {
          safe(_setName, [theBaseClass, name]);
          var _self = fnApply(theBaseClass, _this, ArrSlice[CALL](theArgs)) || _this;
          if (_self !== _this) {
            var orgProto = objGetPrototypeOf(_this);
            orgProto !== objGetPrototypeOf(_self) && objSetPrototypeOf(_self, orgProto);
          }
          return captureFn && captureFn(_self, _this[CONSTRUCTOR]), constructCb && constructCb(_self, theArgs), _self;
        } finally {
          safe(_setName, [theBaseClass, orgName]);
        }
      }, theBaseClass);
    }
    __name(createCustomError, "createCustomError");
    function utcNow() {
      return (Date.now || polyUtcNow)();
    }
    __name(utcNow, "utcNow");
    function polyUtcNow() {
      return new Date().getTime();
    }
    __name(polyUtcNow, "polyUtcNow");
    function _createTrimFn(exp) {
      return __name(function (value) {
        return isNullOrUndefined(value) && throwTypeError("strTrim called [" + dumpObj(value) + "]"), value && value.replace && (value = value.replace(exp, EMPTY)), value;
      }, "_doTrim");
    }
    __name(_createTrimFn, "_createTrimFn");
    var polyStrTrim = _createTrimFn(/^\s+|(?=\s)\s+$/g),
      strTrim = _unwrapFunctionWithPoly("trim", StrProto, polyStrTrim),
      mathFloor = _pureRef(MathCls, "floor"),
      _fnToString,
      _objCtrFnString,
      _gblWindow;
    function isPlainObject(value) {
      if (!value || typeof value !== OBJECT) return !1;
      _gblWindow || (_gblWindow = hasWindow() ? getWindow() : !0);
      var result = !1;
      if (value !== _gblWindow) {
        _objCtrFnString || (_fnToString = Function[PROTOTYPE][TO_STRING], _objCtrFnString = _fnToString[CALL](ObjClass));
        try {
          var proto = objGetPrototypeOf(value);
          result = !proto, result || (objHasOwnProperty(proto, CONSTRUCTOR) && (proto = proto[CONSTRUCTOR]), result = !!(proto && typeof proto === FUNCTION && _fnToString[CALL](proto) === _objCtrFnString));
        } catch {}
      }
      return result;
    }
    __name(isPlainObject, "isPlainObject");
    var _perf;
    function getPerformance() {
      return !_globalLazyTestHooks && _initTestHooks(), (!_perf || _globalLazyTestHooks.lzy) && (_perf = createCachedValue(safe(getInst, ["performance"]).v)), _perf.v;
    }
    __name(getPerformance, "getPerformance");
    var mathRound = _pureRef(MathCls, "round"),
      strEndsWith = _unwrapFunctionWithPoly("endsWith", StrProto, polyStrEndsWith);
    function polyStrEndsWith(value, searchString, length) {
      isString(value) || throwTypeError("'" + dumpObj(value) + "' is not a string");
      var searchValue = isString(searchString) ? searchString : asString(searchString),
        end = !isUndefined(length) && length < value[LENGTH] ? length : value[LENGTH];
      return strSubstring(value, end - searchValue[LENGTH], end) === searchValue;
    }
    __name(polyStrEndsWith, "polyStrEndsWith");
    var strIndexOf = _unwrapFunction("indexOf", StrProto),
      REF = "ref",
      UNREF = "unref",
      HAS_REF = "hasRef",
      ENABLED = "enabled";
    function _createTimerHandler(startTimer, refreshFn, cancelFn) {
      var ref = !0,
        timerId = startTimer ? refreshFn(NULL_VALUE) : NULL_VALUE,
        theTimerHandler;
      function _unref() {
        return ref = !1, timerId && timerId[UNREF] && timerId[UNREF](), theTimerHandler;
      }
      __name(_unref, "_unref");
      function _cancel() {
        timerId && cancelFn(timerId), timerId = NULL_VALUE;
      }
      __name(_cancel, "_cancel");
      function _refresh() {
        return timerId = refreshFn(timerId), ref || _unref(), theTimerHandler;
      }
      __name(_refresh, "_refresh");
      function _setEnabled(value) {
        !value && timerId && _cancel(), value && !timerId && _refresh();
      }
      return __name(_setEnabled, "_setEnabled"), theTimerHandler = {
        cancel: _cancel,
        refresh: _refresh
      }, theTimerHandler[HAS_REF] = function () {
        return timerId && timerId[HAS_REF] ? timerId[HAS_REF]() : ref;
      }, theTimerHandler[REF] = function () {
        return ref = !0, timerId && timerId[REF] && timerId[REF](), theTimerHandler;
      }, theTimerHandler[UNREF] = _unref, theTimerHandler = objDefineProp(theTimerHandler, ENABLED, {
        get: __name(function () {
          return !!timerId;
        }, "get"),
        set: _setEnabled
      }), {
        h: theTimerHandler,
        dn: __name(function () {
          timerId = NULL_VALUE;
        }, "dn")
      };
    }
    __name(_createTimerHandler, "_createTimerHandler");
    function _createTimeoutWith(startTimer, overrideFn, theArgs) {
      var isArr = isArray(overrideFn),
        len = isArr ? overrideFn.length : 0,
        setFn = (len > 0 ? overrideFn[0] : isArr ? UNDEF_VALUE : overrideFn) || setTimeout,
        clearFn = (len > 1 ? overrideFn[1] : UNDEF_VALUE) || clearTimeout,
        timerFn = theArgs[0];
      theArgs[0] = function () {
        handler.dn(), fnApply(timerFn, UNDEF_VALUE, ArrSlice[CALL](arguments));
      };
      var handler = _createTimerHandler(startTimer, function (timerId) {
        if (timerId) {
          if (timerId.refresh) return timerId.refresh(), timerId;
          fnApply(clearFn, UNDEF_VALUE, [timerId]);
        }
        return fnApply(setFn, UNDEF_VALUE, theArgs);
      }, function (timerId) {
        fnApply(clearFn, UNDEF_VALUE, [timerId]);
      });
      return handler.h;
    }
    __name(_createTimeoutWith, "_createTimeoutWith");
    function scheduleTimeout(callback, timeout) {
      return _createTimeoutWith(!0, UNDEF_VALUE, ArrSlice[CALL](arguments));
    }
    __name(scheduleTimeout, "scheduleTimeout");
    var createEnumStyle = createEnum,
      createValueMap = createTypeMap,
      _DYN_TO_LOWER_CASE = "toLowerCase",
      _DYN_LENGTH = "length",
      _DYN_WARN_TO_CONSOLE = "warnToConsole",
      _DYN_THROW_INTERNAL = "throwInternal",
      _DYN_WATCH = "watch",
      _DYN_APPLY = "apply",
      _DYN_PUSH = "push",
      _DYN_SPLICE = "splice",
      _DYN_LOGGER = "logger",
      _DYN_CANCEL = "cancel",
      _DYN_NAME = "name",
      _DYN_UNLOAD = "unload",
      _DYN_VERSION = "version",
      _DYN_LOGGING_LEVEL_CONSOL4 = "loggingLevelConsole",
      _DYN_MESSAGE_ID = "messageId",
      _DYN_MESSAGE = "message",
      _DYN_DIAG_LOG = "diagLog",
      _DYN_USER_AGENT = "userAgent",
      _DYN_SPLIT = "split",
      _DYN_REPLACE = "replace",
      _DYN_TYPE = "type",
      _DYN_EVT_NAME = "evtName",
      _DYN_TRACE_FLAGS = "traceFlags",
      _DYN_GET_ATTRIBUTE = "getAttribute",
      aggregationErrorType;
    function throwAggregationError(message, sourceErrors) {
      aggregationErrorType || (aggregationErrorType = createCustomError("AggregationError", function (self, args) {
        args[_DYN_LENGTH] > 1 && (self.errors = args[1]);
      }));
      var theMessage = message || "One or more errors occurred.";
      throw arrForEach(sourceErrors, function (srcError, idx) {
        theMessage += `
`.concat(idx, " > ").concat(dumpObj(srcError));
      }), new aggregationErrorType(theMessage, sourceErrors || []);
    }
    __name(throwAggregationError, "throwAggregationError");
    var strShimFunction = "function",
      strShimObject = "object",
      strShimUndefined = "undefined",
      strShimPrototype = "prototype",
      ObjClass = Object,
      ObjProto = ObjClass[strShimPrototype];
    (getGlobal() || {}).Symbol, (getGlobal() || {}).Reflect;
    var strHasOwnProperty = "hasOwnProperty",
      __objAssignFnImpl = __name(function (t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) ObjProto[strHasOwnProperty].call(s, p) && (t[p] = s[p]);
        }
        return t;
      }, "__objAssignFnImpl"),
      __assignFn = objAssign || __objAssignFnImpl,
      extendStaticsFn = __name(function (d, b) {
        return extendStaticsFn = ObjClass.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function (d, b) {
          d.__proto__ = b;
        } || function (d, b) {
          for (var p in b) b[strHasOwnProperty](p) && (d[p] = b[p]);
        }, extendStaticsFn(d, b);
      }, "extendStaticsFn");
    function __extendsFn(d, b) {
      typeof b !== strShimFunction && b !== null && throwTypeError("Class extends value " + String(b) + " is not a constructor or null"), extendStaticsFn(d, b);
      function __() {
        this.constructor = d;
      }
      __name(__, "__"), d[strShimPrototype] = b === null ? objCreate(b) : (__[strShimPrototype] = b[strShimPrototype], new __());
    }
    __name(__extendsFn, "__extendsFn");
    var cE,
      Constructor = "constructor",
      Prototype = "prototype",
      strFunction = "function",
      DynInstFuncTable = "_dynInstFuncs",
      DynProxyTag = "_isDynProxy",
      DynClassName = "_dynClass",
      DynClassNamePrefix = "_dynCls$",
      DynInstChkTag = "_dynInstChk",
      DynAllowInstChkTag = DynInstChkTag,
      DynProtoDefaultOptions = "_dfOpts",
      UnknownValue = "_unknown_",
      str__Proto = "__proto__",
      DynProtoBaseProto = "_dyn" + str__Proto,
      DynProtoGlobalSettings = "__dynProto$Gbl",
      DynProtoCurrent = "_dynInstProto",
      strUseBaseInst = "useBaseInst",
      strSetInstFuncs = "setInstFuncs",
      Obj = Object,
      _objGetPrototypeOf = Obj.getPrototypeOf,
      _objGetOwnProps = Obj.getOwnPropertyNames,
      _gbl = getGlobal(),
      _gblInst = _gbl[DynProtoGlobalSettings] || (_gbl[DynProtoGlobalSettings] = {
        o: (_a = {}, _a[strSetInstFuncs] = !0, _a[strUseBaseInst] = !0, _a),
        n: 1e3
      });
    function _isObjectOrArrayPrototype(target) {
      return target && (target === Obj[Prototype] || target === Array[Prototype]);
    }
    __name(_isObjectOrArrayPrototype, "_isObjectOrArrayPrototype");
    function _isObjectArrayOrFunctionPrototype(target) {
      return _isObjectOrArrayPrototype(target) || target === Function[Prototype];
    }
    __name(_isObjectArrayOrFunctionPrototype, "_isObjectArrayOrFunctionPrototype");
    function _getObjProto(target) {
      var newProto;
      if (target) {
        if (_objGetPrototypeOf) return _objGetPrototypeOf(target);
        var curProto = target[str__Proto] || target[Prototype] || (target[Constructor] ? target[Constructor][Prototype] : null);
        newProto = target[DynProtoBaseProto] || curProto, objHasOwnProperty(target, DynProtoBaseProto) || (delete target[DynProtoCurrent], newProto = target[DynProtoBaseProto] = target[DynProtoCurrent] || target[DynProtoBaseProto], target[DynProtoCurrent] = curProto);
      }
      return newProto;
    }
    __name(_getObjProto, "_getObjProto");
    function _forEachProp(target, func) {
      var props = [];
      if (_objGetOwnProps) props = _objGetOwnProps(target);else for (var name_1 in target) typeof name_1 == "string" && objHasOwnProperty(target, name_1) && props.push(name_1);
      if (props && props.length > 0) for (var lp = 0; lp < props.length; lp++) func(props[lp]);
    }
    __name(_forEachProp, "_forEachProp");
    function _isDynamicCandidate(target, funcName, skipOwn) {
      return funcName !== Constructor && typeof target[funcName] === strFunction && (skipOwn || objHasOwnProperty(target, funcName)) && funcName !== str__Proto && funcName !== Prototype;
    }
    __name(_isDynamicCandidate, "_isDynamicCandidate");
    function _throwTypeError(message) {
      throwTypeError("DynamicProto: " + message);
    }
    __name(_throwTypeError, "_throwTypeError");
    function _getInstanceFuncs(thisTarget) {
      var instFuncs = objCreate(null);
      return _forEachProp(thisTarget, function (name) {
        !instFuncs[name] && _isDynamicCandidate(thisTarget, name, !1) && (instFuncs[name] = thisTarget[name]);
      }), instFuncs;
    }
    __name(_getInstanceFuncs, "_getInstanceFuncs");
    function _hasVisited(values, value) {
      for (var lp = values.length - 1; lp >= 0; lp--) if (values[lp] === value) return !0;
      return !1;
    }
    __name(_hasVisited, "_hasVisited");
    function _getBaseFuncs(classProto, thisTarget, instFuncs, useBaseInst) {
      function _instFuncProxy(target, funcHost, funcName) {
        var theFunc = funcHost[funcName];
        if (theFunc[DynProxyTag] && useBaseInst) {
          var instFuncTable = target[DynInstFuncTable] || {};
          instFuncTable[DynAllowInstChkTag] !== !1 && (theFunc = (instFuncTable[funcHost[DynClassName]] || {})[funcName] || theFunc);
        }
        return function () {
          return theFunc.apply(target, arguments);
        };
      }
      __name(_instFuncProxy, "_instFuncProxy");
      var baseFuncs = objCreate(null);
      _forEachProp(instFuncs, function (name) {
        baseFuncs[name] = _instFuncProxy(thisTarget, instFuncs, name);
      });
      for (var baseProto = _getObjProto(classProto), visited = []; baseProto && !_isObjectArrayOrFunctionPrototype(baseProto) && !_hasVisited(visited, baseProto);) _forEachProp(baseProto, function (name) {
        !baseFuncs[name] && _isDynamicCandidate(baseProto, name, !_objGetPrototypeOf) && (baseFuncs[name] = _instFuncProxy(thisTarget, baseProto, name));
      }), visited.push(baseProto), baseProto = _getObjProto(baseProto);
      return baseFuncs;
    }
    __name(_getBaseFuncs, "_getBaseFuncs");
    function _getInstFunc(target, funcName, proto, currentDynProtoProxy) {
      var instFunc = null;
      if (target && objHasOwnProperty(proto, DynClassName)) {
        var instFuncTable = target[DynInstFuncTable] || objCreate(null);
        if (instFunc = (instFuncTable[proto[DynClassName]] || objCreate(null))[funcName], instFunc || _throwTypeError("Missing [" + funcName + "] " + strFunction), !instFunc[DynInstChkTag] && instFuncTable[DynAllowInstChkTag] !== !1) {
          for (var canAddInst = !objHasOwnProperty(target, funcName), objProto = _getObjProto(target), visited = []; canAddInst && objProto && !_isObjectArrayOrFunctionPrototype(objProto) && !_hasVisited(visited, objProto);) {
            var protoFunc = objProto[funcName];
            if (protoFunc) {
              canAddInst = protoFunc === currentDynProtoProxy;
              break;
            }
            visited.push(objProto), objProto = _getObjProto(objProto);
          }
          try {
            canAddInst && (target[funcName] = instFunc), instFunc[DynInstChkTag] = 1;
          } catch {
            instFuncTable[DynAllowInstChkTag] = !1;
          }
        }
      }
      return instFunc;
    }
    __name(_getInstFunc, "_getInstFunc");
    function _getProtoFunc(funcName, proto, currentDynProtoProxy) {
      var protoFunc = proto[funcName];
      return protoFunc === currentDynProtoProxy && (protoFunc = _getObjProto(proto)[funcName]), typeof protoFunc !== strFunction && _throwTypeError("[" + funcName + "] is not a " + strFunction), protoFunc;
    }
    __name(_getProtoFunc, "_getProtoFunc");
    function _populatePrototype(proto, className, target, baseInstFuncs, setInstanceFunc) {
      function _createDynamicPrototype(proto, funcName) {
        var dynProtoProxy = __name(function () {
          var instFunc = _getInstFunc(this, funcName, proto, dynProtoProxy) || _getProtoFunc(funcName, proto, dynProtoProxy);
          return instFunc.apply(this, arguments);
        }, "dynProtoProxy");
        return dynProtoProxy[DynProxyTag] = 1, dynProtoProxy;
      }
      if (__name(_createDynamicPrototype, "_createDynamicPrototype"), !_isObjectOrArrayPrototype(proto)) {
        var instFuncTable = target[DynInstFuncTable] = target[DynInstFuncTable] || objCreate(null);
        if (!_isObjectOrArrayPrototype(instFuncTable)) {
          var instFuncs_1 = instFuncTable[className] = instFuncTable[className] || objCreate(null);
          instFuncTable[DynAllowInstChkTag] !== !1 && (instFuncTable[DynAllowInstChkTag] = !!setInstanceFunc), _isObjectOrArrayPrototype(instFuncs_1) || _forEachProp(target, function (name) {
            _isDynamicCandidate(target, name, !1) && target[name] !== baseInstFuncs[name] && (instFuncs_1[name] = target[name], delete target[name], (!objHasOwnProperty(proto, name) || proto[name] && !proto[name][DynProxyTag]) && (proto[name] = _createDynamicPrototype(proto, name)));
          });
        }
      }
    }
    __name(_populatePrototype, "_populatePrototype");
    function _checkPrototype(classProto, thisTarget) {
      if (_objGetPrototypeOf) {
        for (var visited = [], thisProto = _getObjProto(thisTarget); thisProto && !_isObjectArrayOrFunctionPrototype(thisProto) && !_hasVisited(visited, thisProto);) {
          if (thisProto === classProto) return !0;
          visited.push(thisProto), thisProto = _getObjProto(thisProto);
        }
        return !1;
      }
      return !0;
    }
    __name(_checkPrototype, "_checkPrototype");
    function _getObjName(target, unknownValue) {
      return objHasOwnProperty(target, Prototype) ? target.name || unknownValue || UnknownValue : ((target || {})[Constructor] || {}).name || unknownValue || UnknownValue;
    }
    __name(_getObjName, "_getObjName");
    function dynamicProto(theClass, target, delegateFunc, options) {
      objHasOwnProperty(theClass, Prototype) || _throwTypeError("theClass is an invalid class definition.");
      var classProto = theClass[Prototype];
      _checkPrototype(classProto, target) || _throwTypeError("[" + _getObjName(theClass) + "] not in hierarchy of [" + _getObjName(target) + "]");
      var className = null;
      objHasOwnProperty(classProto, DynClassName) ? className = classProto[DynClassName] : (className = DynClassNamePrefix + _getObjName(theClass, "_") + "$" + _gblInst.n, _gblInst.n++, classProto[DynClassName] = className);
      var perfOptions = dynamicProto[DynProtoDefaultOptions],
        useBaseInst = !!perfOptions[strUseBaseInst];
      useBaseInst && options && options[strUseBaseInst] !== void 0 && (useBaseInst = !!options[strUseBaseInst]);
      var instFuncs = _getInstanceFuncs(target),
        baseFuncs = _getBaseFuncs(classProto, target, instFuncs, useBaseInst);
      delegateFunc(target, baseFuncs);
      var setInstanceFunc = !!_objGetPrototypeOf && !!perfOptions[strSetInstFuncs];
      setInstanceFunc && options && (setInstanceFunc = !!options[strSetInstFuncs]), _populatePrototype(classProto, className, target, instFuncs, setInstanceFunc !== !1);
    }
    __name(dynamicProto, "dynamicProto"), dynamicProto[DynProtoDefaultOptions] = _gblInst.o;
    var UNDEFINED_VALUE = void 0,
      STR_EMPTY = "",
      STR_NOT_DYNAMIC_ERROR = "Not dynamic - ",
      rCamelCase = /-([a-z])/g,
      rNormalizeInvalid = /([^\w\d_$])/g,
      rLeadingNumeric = /^(\d+[\w\d_$])/;
    function isNotNullOrUndefined(value) {
      return !isNullOrUndefined(value);
    }
    __name(isNotNullOrUndefined, "isNotNullOrUndefined");
    function normalizeJsName(name) {
      var value = name;
      return value && isString(value) && (value = value[_DYN_REPLACE](rCamelCase, function (_all, letter) {
        return letter.toUpperCase();
      }), value = value[_DYN_REPLACE](rNormalizeInvalid, "_"), value = value[_DYN_REPLACE](rLeadingNumeric, function (_all, match) {
        return "_" + match;
      })), value;
    }
    __name(normalizeJsName, "normalizeJsName");
    function strContains(value, search) {
      return value && search ? strIndexOf(value, search) !== -1 : !1;
    }
    __name(strContains, "strContains");
    function toISOString(date) {
      return date && date.toISOString() || "";
    }
    __name(toISOString, "toISOString");
    function getExceptionName(object) {
      return isError(object) ? object[_DYN_NAME] : STR_EMPTY;
    }
    __name(getExceptionName, "getExceptionName");
    function createClassFromInterface(defaults) {
      return function () {
        function class_1() {
          var _this = this;
          defaults && objForEachKey(defaults, function (field, value) {
            _this[field] = value;
          });
        }
        return __name(class_1, "class_1"), class_1;
      }();
    }
    __name(createClassFromInterface, "createClassFromInterface");
    var strConsole = "console",
      strJSON = "JSON",
      strCrypto = "crypto",
      strMsCrypto = "msCrypto",
      strMsie = "msie",
      strTrident = "trident/",
      _isTrident = null,
      _navUserAgentCheck = null,
      _beaconsSupported = null;
    function getConsole() {
      return typeof console !== strShimUndefined ? console : getInst(strConsole);
    }
    __name(getConsole, "getConsole");
    function hasJSON() {
      return !!(typeof JSON === strShimObject && JSON || getInst(strJSON) !== null);
    }
    __name(hasJSON, "hasJSON");
    function getJSON() {
      return hasJSON() ? JSON || getInst(strJSON) : null;
    }
    __name(getJSON, "getJSON");
    function getCrypto() {
      return getInst(strCrypto);
    }
    __name(getCrypto, "getCrypto");
    function getMsCrypto() {
      return getInst(strMsCrypto);
    }
    __name(getMsCrypto, "getMsCrypto");
    function isIE() {
      var nav = getNavigator();
      if (nav && (nav[_DYN_USER_AGENT] !== _navUserAgentCheck || _isTrident === null)) {
        _navUserAgentCheck = nav[_DYN_USER_AGENT];
        var userAgent = (_navUserAgentCheck || STR_EMPTY)[_DYN_TO_LOWER_CASE]();
        _isTrident = strContains(userAgent, strMsie) || strContains(userAgent, strTrident);
      }
      return _isTrident;
    }
    __name(isIE, "isIE");
    function isBeaconsSupported(useCached) {
      return (_beaconsSupported === null || useCached === !1) && (_beaconsSupported = hasNavigator() && !!getNavigator().sendBeacon), _beaconsSupported;
    }
    __name(isBeaconsSupported, "isBeaconsSupported");
    function _getNamedValue(values, name) {
      if (values) for (var i = 0; i < values[_DYN_LENGTH]; i++) {
        var value = values[i];
        if (value[_DYN_NAME] && value[_DYN_NAME] === name) return value;
      }
      return {};
    }
    __name(_getNamedValue, "_getNamedValue");
    function findMetaTag(name) {
      var doc = getDocument();
      return doc && name ? _getNamedValue(doc.querySelectorAll("meta"), name).content : null;
    }
    __name(findMetaTag, "findMetaTag");
    function findNamedServerTiming(name) {
      var value,
        perf = getPerformance();
      if (perf) {
        var navPerf = perf.getEntriesByType("navigation") || [];
        value = _getNamedValue((navPerf[_DYN_LENGTH] > 0 ? navPerf[0] : {}).serverTiming, name).description;
      }
      return value;
    }
    __name(findNamedServerTiming, "findNamedServerTiming");
    var UInt32Mask = 4294967296,
      MaxUInt32 = 4294967295,
      SEED1 = 123456789,
      SEED2 = 987654321,
      _mwcSeeded = !1,
      _mwcW = SEED1,
      _mwcZ = SEED2;
    function _mwcSeed(seedValue) {
      seedValue < 0 && (seedValue >>>= 0), _mwcW = SEED1 + seedValue & MaxUInt32, _mwcZ = SEED2 - seedValue & MaxUInt32, _mwcSeeded = !0;
    }
    __name(_mwcSeed, "_mwcSeed");
    function _autoSeedMwc() {
      try {
        var now = utcNow() & 2147483647;
        _mwcSeed((Math.random() * UInt32Mask ^ now) + now);
      } catch {}
    }
    __name(_autoSeedMwc, "_autoSeedMwc");
    function randomValue(maxValue) {
      return maxValue > 0 ? mathFloor(random32() / MaxUInt32 * (maxValue + 1)) >>> 0 : 0;
    }
    __name(randomValue, "randomValue");
    function random32(signed) {
      var value = 0,
        c = getCrypto() || getMsCrypto();
      return c && c.getRandomValues && (value = c.getRandomValues(new Uint32Array(1))[0] & MaxUInt32), value === 0 && isIE() && (_mwcSeeded || _autoSeedMwc(), value = mwcRandom32() & MaxUInt32), value === 0 && (value = mathFloor(UInt32Mask * Math.random() | 0)), signed || (value >>>= 0), value;
    }
    __name(random32, "random32");
    function mwcRandom32(signed) {
      _mwcZ = 36969 * (_mwcZ & 65535) + (_mwcZ >> 16) & MaxUInt32, _mwcW = 18e3 * (_mwcW & 65535) + (_mwcW >> 16) & MaxUInt32;
      var value = (_mwcZ << 16) + (_mwcW & 65535) >>> 0 & MaxUInt32 | 0;
      return signed || (value >>>= 0), value;
    }
    __name(mwcRandom32, "mwcRandom32");
    function newId(maxLength) {
      maxLength === void 0 && (maxLength = 22);
      for (var base64chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", number = random32() >>> 0, chars = 0, result = STR_EMPTY; result[_DYN_LENGTH] < maxLength;) chars++, result += base64chars.charAt(number & 63), number >>>= 6, chars === 5 && (number = (random32() << 2 & 4294967295 | number & 3) >>> 0, chars = 0);
      return result;
    }
    __name(newId, "newId");
    var version = "3.3.6",
      instanceName = "." + newId(6),
      _dataUid = 0;
    function _canAcceptData(target) {
      return target.nodeType === 1 || target.nodeType === 9 || !+target.nodeType;
    }
    __name(_canAcceptData, "_canAcceptData");
    function _getCache(data, target) {
      var theCache = target[data.id];
      if (!theCache) {
        theCache = {};
        try {
          _canAcceptData(target) && objDefine(target, data.id, {
            e: !1,
            v: theCache
          });
        } catch {}
      }
      return theCache;
    }
    __name(_getCache, "_getCache");
    function createUniqueNamespace(name, includeVersion) {
      return includeVersion === void 0 && (includeVersion = !1), normalizeJsName(name + _dataUid++ + (includeVersion ? "." + version : STR_EMPTY) + instanceName);
    }
    __name(createUniqueNamespace, "createUniqueNamespace");
    function createElmNodeData(name) {
      var data = {
        id: createUniqueNamespace("_aiData-" + (name || STR_EMPTY) + "." + version),
        accept: __name(function (target) {
          return _canAcceptData(target);
        }, "accept"),
        get: __name(function (target, name, defValue, addDefault) {
          var theCache = target[data.id];
          return theCache ? theCache[normalizeJsName(name)] : (addDefault && (theCache = _getCache(data, target), theCache[normalizeJsName(name)] = defValue), defValue);
        }, "get"),
        kill: __name(function (target, name) {
          if (target && target[name]) try {
            delete target[name];
          } catch {}
        }, "kill")
      };
      return data;
    }
    __name(createElmNodeData, "createElmNodeData");
    function _isConfigDefaults(value) {
      return value && isObject(value) && (value.isVal || value.fb || objHasOwn(value, "v") || objHasOwn(value, "mrg") || objHasOwn(value, "ref") || value.set);
    }
    __name(_isConfigDefaults, "_isConfigDefaults");
    function _getDefault(dynamicHandler, theConfig, cfgDefaults) {
      var defValue,
        isDefaultValid = cfgDefaults.dfVal || isDefined;
      if (theConfig && cfgDefaults.fb) {
        var fallbacks = cfgDefaults.fb;
        isArray(fallbacks) || (fallbacks = [fallbacks]);
        for (var lp = 0; lp < fallbacks[_DYN_LENGTH]; lp++) {
          var fallback = fallbacks[lp],
            fbValue = theConfig[fallback];
          if (isDefaultValid(fbValue) ? defValue = fbValue : dynamicHandler && (fbValue = dynamicHandler.cfg[fallback], isDefaultValid(fbValue) && (defValue = fbValue), dynamicHandler.set(dynamicHandler.cfg, asString(fallback), fbValue)), isDefaultValid(defValue)) break;
        }
      }
      return !isDefaultValid(defValue) && isDefaultValid(cfgDefaults.v) && (defValue = cfgDefaults.v), defValue;
    }
    __name(_getDefault, "_getDefault");
    function _resolveDefaultValue(dynamicHandler, theConfig, cfgDefaults) {
      var theValue = cfgDefaults;
      if (cfgDefaults && _isConfigDefaults(cfgDefaults) && (theValue = _getDefault(dynamicHandler, theConfig, cfgDefaults)), theValue) {
        _isConfigDefaults(theValue) && (theValue = _resolveDefaultValue(dynamicHandler, theConfig, theValue));
        var newValue_1;
        isArray(theValue) ? (newValue_1 = [], newValue_1[_DYN_LENGTH] = theValue[_DYN_LENGTH]) : isPlainObject(theValue) && (newValue_1 = {}), newValue_1 && (objForEachKey(theValue, function (key, value) {
          value && _isConfigDefaults(value) && (value = _resolveDefaultValue(dynamicHandler, theConfig, value)), newValue_1[key] = value;
        }), theValue = newValue_1);
      }
      return theValue;
    }
    __name(_resolveDefaultValue, "_resolveDefaultValue");
    function _applyDefaultValue(dynamicHandler, theConfig, name, defaultValue) {
      var isValid,
        setFn,
        defValue,
        cfgDefaults = defaultValue,
        mergeDf,
        reference,
        readOnly,
        blkDynamicValue;
      _isConfigDefaults(cfgDefaults) ? (isValid = cfgDefaults.isVal, setFn = cfgDefaults.set, readOnly = cfgDefaults.rdOnly, blkDynamicValue = cfgDefaults.blkVal, mergeDf = cfgDefaults.mrg, reference = cfgDefaults.ref, !reference && isUndefined(reference) && (reference = !!mergeDf), defValue = _getDefault(dynamicHandler, theConfig, cfgDefaults)) : defValue = defaultValue, blkDynamicValue && dynamicHandler.blkVal(theConfig, name);
      var theValue,
        usingDefault = !0,
        cfgValue = theConfig[name];
      (cfgValue || !isNullOrUndefined(cfgValue)) && (theValue = cfgValue, usingDefault = !1, isValid && theValue !== defValue && !isValid(theValue) && (theValue = defValue, usingDefault = !0), setFn && (theValue = setFn(theValue, defValue, theConfig), usingDefault = theValue === defValue)), usingDefault ? defValue ? theValue = _resolveDefaultValue(dynamicHandler, theConfig, defValue) : theValue = defValue : (isPlainObject(theValue) || isArray(defValue)) && mergeDf && defValue && (isPlainObject(defValue) || isArray(defValue)) && objForEachKey(defValue, function (dfName, dfValue) {
        _applyDefaultValue(dynamicHandler, theValue, dfName, dfValue);
      }), dynamicHandler.set(theConfig, name, theValue), reference && dynamicHandler.ref(theConfig, name), readOnly && dynamicHandler.rdOnly(theConfig, name);
    }
    __name(_applyDefaultValue, "_applyDefaultValue");
    var CFG_HANDLER_LINK = symbolFor("[[ai_dynCfg_1]]"),
      BLOCK_DYNAMIC = symbolFor("[[ai_blkDynCfg_1]]"),
      FORCE_DYNAMIC = symbolFor("[[ai_frcDynCfg_1]]");
    function _cfgDeepCopy(source) {
      if (source) {
        var target_1;
        if (isArray(source) ? (target_1 = [], target_1[_DYN_LENGTH] = source[_DYN_LENGTH]) : isPlainObject(source) && (target_1 = {}), target_1) return objForEachKey(source, function (key, value) {
          target_1[key] = _cfgDeepCopy(value);
        }), target_1;
      }
      return source;
    }
    __name(_cfgDeepCopy, "_cfgDeepCopy");
    function getDynamicConfigHandler(value) {
      if (value) {
        var handler = value[CFG_HANDLER_LINK] || value;
        if (handler.cfg && (handler.cfg === value || handler.cfg[CFG_HANDLER_LINK] === handler)) return handler;
      }
      return null;
    }
    __name(getDynamicConfigHandler, "getDynamicConfigHandler");
    function blockDynamicConversion(value) {
      if (value && (isPlainObject(value) || isArray(value))) try {
        value[BLOCK_DYNAMIC] = !0;
      } catch {}
      return value;
    }
    __name(blockDynamicConversion, "blockDynamicConversion");
    function _canMakeDynamic(getFunc, state, value) {
      var result = !1;
      return value && !getFunc[state.blkVal] && (result = value[FORCE_DYNAMIC], !result && !value[BLOCK_DYNAMIC] && (result = isPlainObject(value) || isArray(value))), result;
    }
    __name(_canMakeDynamic, "_canMakeDynamic");
    function throwInvalidAccess(message) {
      throwTypeError("InvalidAccess:" + message);
    }
    __name(throwInvalidAccess, "throwInvalidAccess");
    var arrayMethodsToPatch = ["push", "pop", "shift", "unshift", "splice"],
      _throwDynamicError = __name(function (logger, name, desc, e) {
        logger && logger[_DYN_THROW_INTERNAL](3, 108, "".concat(desc, " [").concat(name, "] failed - ") + dumpObj(e));
      }, "_throwDynamicError");
    function _patchArray(state, target, name) {
      isArray(target) && arrForEach(arrayMethodsToPatch, function (method) {
        var orgMethod = target[method];
        target[method] = function () {
          for (var args = [], _i = 0; _i < arguments.length; _i++) args[_i] = arguments[_i];
          var result = orgMethod[_DYN_APPLY](this, args);
          return _makeDynamicObject(state, target, name, "Patching"), result;
        };
      });
    }
    __name(_patchArray, "_patchArray");
    function _getOwnPropGetter(target, name) {
      var propDesc = objGetOwnPropertyDescriptor(target, name);
      return propDesc && propDesc.get;
    }
    __name(_getOwnPropGetter, "_getOwnPropGetter");
    function _createDynamicProperty(state, theConfig, name, value) {
      var detail = {
          n: name,
          h: [],
          trk: __name(function (handler) {
            handler && handler.fn && (arrIndexOf(detail.h, handler) === -1 && detail.h[_DYN_PUSH](handler), state.trk(handler, detail));
          }, "trk"),
          clr: __name(function (handler) {
            var idx = arrIndexOf(detail.h, handler);
            idx !== -1 && detail.h[_DYN_SPLICE](idx, 1);
          }, "clr")
        },
        checkDynamic = !0,
        isObjectOrArray = !1;
      function _getProperty() {
        checkDynamic && (isObjectOrArray = isObjectOrArray || _canMakeDynamic(_getProperty, state, value), value && !value[CFG_HANDLER_LINK] && isObjectOrArray && (value = _makeDynamicObject(state, value, name, "Converting")), checkDynamic = !1);
        var activeHandler = state.act;
        return activeHandler && detail.trk(activeHandler), value;
      }
      __name(_getProperty, "_getProperty"), _getProperty[state.prop] = {
        chng: __name(function () {
          state.add(detail);
        }, "chng")
      };
      function _setProperty(newValue) {
        if (value !== newValue) {
          _getProperty[state.ro] && !state.upd && throwInvalidAccess("[" + name + "] is read-only:" + dumpObj(theConfig)), checkDynamic && (isObjectOrArray = isObjectOrArray || _canMakeDynamic(_getProperty, state, value), checkDynamic = !1);
          var isReferenced = isObjectOrArray && _getProperty[state.rf];
          if (isObjectOrArray) if (isReferenced) {
            objForEachKey(value, function (key) {
              value[key] = newValue ? newValue[key] : UNDEFINED_VALUE;
            });
            try {
              objForEachKey(newValue, function (key, theValue) {
                _setDynamicProperty(state, value, key, theValue);
              }), newValue = value;
            } catch (e) {
              _throwDynamicError((state.hdlr || {})[_DYN_LOGGER], name, "Assigning", e), isObjectOrArray = !1;
            }
          } else value && value[CFG_HANDLER_LINK] && objForEachKey(value, function (key) {
            var getter = _getOwnPropGetter(value, key);
            if (getter) {
              var valueState = getter[state.prop];
              valueState && valueState.chng();
            }
          });
          if (newValue !== value) {
            var newIsObjectOrArray = newValue && _canMakeDynamic(_getProperty, state, newValue);
            !isReferenced && newIsObjectOrArray && (newValue = _makeDynamicObject(state, newValue, name, "Converting")), value = newValue, isObjectOrArray = newIsObjectOrArray;
          }
          state.add(detail);
        }
      }
      __name(_setProperty, "_setProperty"), objDefine(theConfig, detail.n, {
        g: _getProperty,
        s: _setProperty
      });
    }
    __name(_createDynamicProperty, "_createDynamicProperty");
    function _setDynamicProperty(state, target, name, value) {
      if (target) {
        var getter = _getOwnPropGetter(target, name),
          isDynamic = getter && !!getter[state.prop];
        isDynamic ? target[name] = value : _createDynamicProperty(state, target, name, value);
      }
      return target;
    }
    __name(_setDynamicProperty, "_setDynamicProperty");
    function _setDynamicPropertyState(state, target, name, flags) {
      if (target) {
        var getter = _getOwnPropGetter(target, name),
          isDynamic = getter && !!getter[state.prop],
          inPlace = flags && flags[0],
          rdOnly = flags && flags[1],
          blkProp = flags && flags[2];
        if (!isDynamic) {
          if (blkProp) try {
            blockDynamicConversion(target);
          } catch (e) {
            _throwDynamicError((state.hdlr || {})[_DYN_LOGGER], name, "Blocking", e);
          }
          try {
            _setDynamicProperty(state, target, name, target[name]), getter = _getOwnPropGetter(target, name);
          } catch (e) {
            _throwDynamicError((state.hdlr || {})[_DYN_LOGGER], name, "State", e);
          }
        }
        inPlace && (getter[state.rf] = inPlace), rdOnly && (getter[state.ro] = rdOnly), blkProp && (getter[state.blkVal] = !0);
      }
      return target;
    }
    __name(_setDynamicPropertyState, "_setDynamicPropertyState");
    function _makeDynamicObject(state, target, name, desc) {
      try {
        objForEachKey(target, function (key, value) {
          _setDynamicProperty(state, target, key, value);
        }), target[CFG_HANDLER_LINK] || (objDefineProp(target, CFG_HANDLER_LINK, {
          get: __name(function () {
            return state.hdlr;
          }, "get")
        }), _patchArray(state, target, name));
      } catch (e) {
        _throwDynamicError((state.hdlr || {})[_DYN_LOGGER], name, desc, e);
      }
      return target;
    }
    __name(_makeDynamicObject, "_makeDynamicObject");
    var symPrefix = "[[ai_",
      symPostfix = "]]";
    function _createState(cfgHandler) {
      var dynamicPropertySymbol = newSymbol(symPrefix + "get" + cfgHandler.uid + symPostfix),
        dynamicPropertyReadOnly = newSymbol(symPrefix + "ro" + cfgHandler.uid + symPostfix),
        dynamicPropertyReferenced = newSymbol(symPrefix + "rf" + cfgHandler.uid + symPostfix),
        dynamicPropertyBlockValue = newSymbol(symPrefix + "blkVal" + cfgHandler.uid + symPostfix),
        dynamicPropertyDetail = newSymbol(symPrefix + "dtl" + cfgHandler.uid + symPostfix),
        _waitingHandlers = null,
        _watcherTimer = null,
        theState;
      function _useHandler(activeHandler, callback) {
        var prevWatcher = theState.act;
        try {
          theState.act = activeHandler, activeHandler && activeHandler[dynamicPropertyDetail] && (arrForEach(activeHandler[dynamicPropertyDetail], function (detail) {
            detail.clr(activeHandler);
          }), activeHandler[dynamicPropertyDetail] = []), callback({
            cfg: cfgHandler.cfg,
            set: cfgHandler.set.bind(cfgHandler),
            setDf: cfgHandler.setDf.bind(cfgHandler),
            ref: cfgHandler.ref.bind(cfgHandler),
            rdOnly: cfgHandler.rdOnly.bind(cfgHandler)
          });
        } catch (e) {
          var logger = cfgHandler[_DYN_LOGGER];
          throw logger && logger[_DYN_THROW_INTERNAL](1, 107, dumpObj(e)), e;
        } finally {
          theState.act = prevWatcher || null;
        }
      }
      __name(_useHandler, "_useHandler");
      function _notifyWatchers() {
        if (_waitingHandlers) {
          var notifyHandlers = _waitingHandlers;
          _waitingHandlers = null, _watcherTimer && _watcherTimer[_DYN_CANCEL](), _watcherTimer = null;
          var watcherFailures_1 = [];
          if (arrForEach(notifyHandlers, function (handler) {
            if (handler && (handler[dynamicPropertyDetail] && (arrForEach(handler[dynamicPropertyDetail], function (detail) {
              detail.clr(handler);
            }), handler[dynamicPropertyDetail] = null), handler.fn)) try {
              _useHandler(handler, handler.fn);
            } catch (e) {
              watcherFailures_1[_DYN_PUSH](e);
            }
          }), _waitingHandlers) try {
            _notifyWatchers();
          } catch (e) {
            watcherFailures_1[_DYN_PUSH](e);
          }
          watcherFailures_1[_DYN_LENGTH] > 0 && throwAggregationError("Watcher error(s): ", watcherFailures_1);
        }
      }
      __name(_notifyWatchers, "_notifyWatchers");
      function _addWatcher(detail) {
        if (detail && detail.h[_DYN_LENGTH] > 0) {
          _waitingHandlers || (_waitingHandlers = []), _watcherTimer || (_watcherTimer = scheduleTimeout(function () {
            _watcherTimer = null, _notifyWatchers();
          }, 0));
          for (var idx = 0; idx < detail.h[_DYN_LENGTH]; idx++) {
            var handler = detail.h[idx];
            handler && arrIndexOf(_waitingHandlers, handler) === -1 && _waitingHandlers[_DYN_PUSH](handler);
          }
        }
      }
      __name(_addWatcher, "_addWatcher");
      function _trackHandler(handler, detail) {
        if (handler) {
          var details = handler[dynamicPropertyDetail] = handler[dynamicPropertyDetail] || [];
          arrIndexOf(details, detail) === -1 && details[_DYN_PUSH](detail);
        }
      }
      return __name(_trackHandler, "_trackHandler"), theState = {
        prop: dynamicPropertySymbol,
        ro: dynamicPropertyReadOnly,
        rf: dynamicPropertyReferenced,
        blkVal: dynamicPropertyBlockValue,
        hdlr: cfgHandler,
        add: _addWatcher,
        notify: _notifyWatchers,
        use: _useHandler,
        trk: _trackHandler
      }, theState;
    }
    __name(_createState, "_createState");
    function _createAndUseHandler(state, configHandler) {
      var handler = {
        fn: configHandler,
        rm: __name(function () {
          handler.fn = null, state = null, configHandler = null;
        }, "rm")
      };
      return objDefine(handler, "toJSON", {
        v: __name(function () {
          return "WatcherHandler" + (handler.fn ? "" : "[X]");
        }, "v")
      }), state.use(handler, configHandler), handler;
    }
    __name(_createAndUseHandler, "_createAndUseHandler");
    function _createDynamicHandler(logger, target, inPlace) {
      var dynamicHandler = getDynamicConfigHandler(target);
      if (dynamicHandler) return dynamicHandler;
      var uid = createUniqueNamespace("dyncfg", !0),
        newTarget = target && inPlace !== !1 ? target : _cfgDeepCopy(target),
        theState;
      function _notifyWatchers() {
        theState.notify();
      }
      __name(_notifyWatchers, "_notifyWatchers");
      function _setValue(target, name, value) {
        try {
          target = _setDynamicProperty(theState, target, name, value);
        } catch (e) {
          _throwDynamicError(logger, name, "Setting value", e);
        }
        return target[name];
      }
      __name(_setValue, "_setValue");
      function _watch(configHandler) {
        return _createAndUseHandler(theState, configHandler);
      }
      __name(_watch, "_watch");
      function _block(configHandler, allowUpdate) {
        theState.use(null, function (details) {
          var prevUpd = theState.upd;
          try {
            isUndefined(allowUpdate) || (theState.upd = allowUpdate), configHandler(details);
          } finally {
            theState.upd = prevUpd;
          }
        });
      }
      __name(_block, "_block");
      function _ref(target, name) {
        var _a;
        return _setDynamicPropertyState(theState, target, name, (_a = {}, _a[0] = !0, _a))[name];
      }
      __name(_ref, "_ref");
      function _rdOnly(target, name) {
        var _a;
        return _setDynamicPropertyState(theState, target, name, (_a = {}, _a[1] = !0, _a))[name];
      }
      __name(_rdOnly, "_rdOnly");
      function _blkPropValue(target, name) {
        var _a;
        return _setDynamicPropertyState(theState, target, name, (_a = {}, _a[2] = !0, _a))[name];
      }
      __name(_blkPropValue, "_blkPropValue");
      function _applyDefaults(theConfig, defaultValues) {
        return defaultValues && objForEachKey(defaultValues, function (name, value) {
          _applyDefaultValue(cfgHandler, theConfig, name, value);
        }), theConfig;
      }
      __name(_applyDefaults, "_applyDefaults");
      var cfgHandler = {
        uid: null,
        cfg: newTarget,
        logger: logger,
        notify: _notifyWatchers,
        set: _setValue,
        setDf: _applyDefaults,
        watch: _watch,
        ref: _ref,
        rdOnly: _rdOnly,
        blkVal: _blkPropValue,
        _block: _block
      };
      return objDefine(cfgHandler, "uid", {
        c: !1,
        e: !1,
        w: !1,
        v: uid
      }), theState = _createState(cfgHandler), _makeDynamicObject(theState, newTarget, "config", "Creating"), cfgHandler;
    }
    __name(_createDynamicHandler, "_createDynamicHandler");
    function _logInvalidAccess(logger, message) {
      logger ? (logger[_DYN_WARN_TO_CONSOLE](message), logger[_DYN_THROW_INTERNAL](2, 108, message)) : throwInvalidAccess(message);
    }
    __name(_logInvalidAccess, "_logInvalidAccess");
    function createDynamicConfig(config, defaultConfig, logger, inPlace) {
      var dynamicHandler = _createDynamicHandler(logger, config || {}, inPlace);
      return defaultConfig && dynamicHandler.setDf(dynamicHandler.cfg, defaultConfig), dynamicHandler;
    }
    __name(createDynamicConfig, "createDynamicConfig");
    function onConfigChange(config, configHandler, logger) {
      var handler = config[CFG_HANDLER_LINK] || config;
      return handler.cfg && (handler.cfg === config || handler.cfg[CFG_HANDLER_LINK] === handler) ? handler[_DYN_WATCH](configHandler) : (_logInvalidAccess(logger, STR_NOT_DYNAMIC_ERROR + dumpObj(config)), createDynamicConfig(config, null, logger)[_DYN_WATCH](configHandler));
    }
    __name(onConfigChange, "onConfigChange");
    var _aiNamespace = null;
    function _getExtensionNamespace() {
      var target = getInst("Microsoft");
      return target && (_aiNamespace = target.ApplicationInsights), _aiNamespace;
    }
    __name(_getExtensionNamespace, "_getExtensionNamespace");
    function getDebugExt(config) {
      var ns = _aiNamespace;
      return !ns && config.disableDbgExt !== !0 && (ns = _aiNamespace || _getExtensionNamespace()), ns ? ns.ChromeDbgExt : null;
    }
    __name(getDebugExt, "getDebugExt");
    var _a,
      STR_WARN_TO_CONSOLE = "warnToConsole",
      AiNonUserActionablePrefix = "AI (Internal): ",
      AiUserActionablePrefix = "AI: ",
      AIInternalMessagePrefix = "AITR_",
      defaultValues = {
        loggingLevelConsole: 0,
        loggingLevelTelemetry: 1,
        maxMessageLimit: 25,
        enableDebug: !1
      },
      _logFuncs = (_a = {}, _a[0] = null, _a[1] = "errorToConsole", _a[2] = STR_WARN_TO_CONSOLE, _a[3] = "debugToConsole", _a);
    function _sanitizeDiagnosticText(text) {
      return text ? '"' + text[_DYN_REPLACE](/\"/g, STR_EMPTY) + '"' : STR_EMPTY;
    }
    __name(_sanitizeDiagnosticText, "_sanitizeDiagnosticText");
    function _logToConsole(func, message) {
      var theConsole = getConsole();
      if (theConsole) {
        var logFunc = "log";
        theConsole[func] && (logFunc = func), isFunction(theConsole[logFunc]) && theConsole[logFunc](message);
      }
    }
    __name(_logToConsole, "_logToConsole");
    var _InternalLogMessage = function () {
      function _InternalLogMessage(msgId, msg, isUserAct, properties) {
        isUserAct === void 0 && (isUserAct = !1);
        var _self = this;
        _self[_DYN_MESSAGE_ID] = msgId, _self[_DYN_MESSAGE] = (isUserAct ? AiUserActionablePrefix : AiNonUserActionablePrefix) + msgId;
        var strProps = STR_EMPTY;
        hasJSON() && (strProps = getJSON().stringify(properties));
        var diagnosticText = (msg ? " message:" + _sanitizeDiagnosticText(msg) : STR_EMPTY) + (properties ? " props:" + _sanitizeDiagnosticText(strProps) : STR_EMPTY);
        _self[_DYN_MESSAGE] += diagnosticText;
      }
      return __name(_InternalLogMessage, "_InternalLogMessage"), _InternalLogMessage.dataType = "MessageData", _InternalLogMessage;
    }();
    function safeGetLogger(core, config) {
      return (core || {})[_DYN_LOGGER] || new DiagnosticLogger(config);
    }
    __name(safeGetLogger, "safeGetLogger");
    var DiagnosticLogger = function () {
      function DiagnosticLogger(config) {
        this.identifier = "DiagnosticLogger", this.queue = [];
        var _messageCount = 0,
          _messageLogged = {},
          _loggingLevelConsole,
          _loggingLevelTelemetry,
          _maxInternalMessageLimit,
          _enableDebug,
          _unloadHandler;
        dynamicProto(DiagnosticLogger, this, function (_self) {
          _unloadHandler = _setDefaultsFromConfig(config || {}), _self.consoleLoggingLevel = function () {
            return _loggingLevelConsole;
          }, _self[_DYN_THROW_INTERNAL] = function (severity, msgId, msg, properties, isUserAct) {
            isUserAct === void 0 && (isUserAct = !1);
            var message = new _InternalLogMessage(msgId, msg, isUserAct, properties);
            if (_enableDebug) throw dumpObj(message);
            var logFunc = _logFuncs[severity] || STR_WARN_TO_CONSOLE;
            if (isUndefined(message[_DYN_MESSAGE])) _debugExtMsg("throw" + (severity === 1 ? "Critical" : "Warning"), message);else {
              if (isUserAct) {
                var messageKey = +message[_DYN_MESSAGE_ID];
                !_messageLogged[messageKey] && _loggingLevelConsole >= severity && (_self[logFunc](message[_DYN_MESSAGE]), _messageLogged[messageKey] = !0);
              } else _loggingLevelConsole >= severity && _self[logFunc](message[_DYN_MESSAGE]);
              _logInternalMessage(severity, message);
            }
          }, _self.debugToConsole = function (message) {
            _logToConsole("debug", message), _debugExtMsg("warning", message);
          }, _self[_DYN_WARN_TO_CONSOLE] = function (message) {
            _logToConsole("warn", message), _debugExtMsg("warning", message);
          }, _self.errorToConsole = function (message) {
            _logToConsole("error", message), _debugExtMsg("error", message);
          }, _self.resetInternalMessageCount = function () {
            _messageCount = 0, _messageLogged = {};
          }, _self.logInternalMessage = _logInternalMessage, _self[_DYN_UNLOAD] = function (isAsync) {
            _unloadHandler && _unloadHandler.rm(), _unloadHandler = null;
          };
          function _logInternalMessage(severity, message) {
            if (!_areInternalMessagesThrottled()) {
              var logMessage = !0,
                messageKey = AIInternalMessagePrefix + message[_DYN_MESSAGE_ID];
              if (_messageLogged[messageKey] ? logMessage = !1 : _messageLogged[messageKey] = !0, logMessage && (severity <= _loggingLevelTelemetry && (_self.queue[_DYN_PUSH](message), _messageCount++, _debugExtMsg(severity === 1 ? "error" : "warn", message)), _messageCount === _maxInternalMessageLimit)) {
                var throttleLimitMessage = "Internal events throttle limit per PageView reached for this app.",
                  throttleMessage = new _InternalLogMessage(23, throttleLimitMessage, !1);
                _self.queue[_DYN_PUSH](throttleMessage), severity === 1 ? _self.errorToConsole(throttleLimitMessage) : _self[_DYN_WARN_TO_CONSOLE](throttleLimitMessage);
              }
            }
          }
          __name(_logInternalMessage, "_logInternalMessage");
          function _setDefaultsFromConfig(config) {
            return onConfigChange(createDynamicConfig(config, defaultValues, _self).cfg, function (details) {
              var config = details.cfg;
              _loggingLevelConsole = config[_DYN_LOGGING_LEVEL_CONSOL4], _loggingLevelTelemetry = config.loggingLevelTelemetry, _maxInternalMessageLimit = config.maxMessageLimit, _enableDebug = config.enableDebug;
            });
          }
          __name(_setDefaultsFromConfig, "_setDefaultsFromConfig");
          function _areInternalMessagesThrottled() {
            return _messageCount >= _maxInternalMessageLimit;
          }
          __name(_areInternalMessagesThrottled, "_areInternalMessagesThrottled");
          function _debugExtMsg(name, data) {
            var dbgExt = getDebugExt(config || {});
            dbgExt && dbgExt[_DYN_DIAG_LOG] && dbgExt[_DYN_DIAG_LOG](name, data);
          }
          __name(_debugExtMsg, "_debugExtMsg");
        });
      }
      return __name(DiagnosticLogger, "DiagnosticLogger"), x.__ieDyn = 1, DiagnosticLogger;
    }();
    function _getLogger(logger) {
      return logger || new DiagnosticLogger();
    }
    __name(_getLogger, "_getLogger");
    function _throwInternal(logger, severity, msgId, msg, properties, isUserAct) {
      isUserAct === void 0 && (isUserAct = !1), _getLogger(logger)[_DYN_THROW_INTERNAL](severity, msgId, msg, properties, isUserAct);
    }
    __name(_throwInternal, "_throwInternal");
    function generateW3CId() {
      for (var hexValues = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"], oct = STR_EMPTY, tmp, a = 0; a < 4; a++) tmp = random32(), oct += hexValues[tmp & 15] + hexValues[tmp >> 4 & 15] + hexValues[tmp >> 8 & 15] + hexValues[tmp >> 12 & 15] + hexValues[tmp >> 16 & 15] + hexValues[tmp >> 20 & 15] + hexValues[tmp >> 24 & 15] + hexValues[tmp >> 28 & 15];
      var clockSequenceHi = hexValues[8 + (random32() & 3) | 0];
      return strSubstr(oct, 0, 8) + strSubstr(oct, 9, 4) + "4" + strSubstr(oct, 13, 3) + clockSequenceHi + strSubstr(oct, 16, 3) + strSubstr(oct, 19, 12);
    }
    __name(generateW3CId, "generateW3CId");
    var TRACE_PARENT_REGEX = /^([\da-f]{2})-([\da-f]{32})-([\da-f]{16})-([\da-f]{2})(-[^\s]{1,64})?$/i,
      DEFAULT_VERSION = "00",
      INVALID_VERSION = "ff",
      INVALID_TRACE_ID = "00000000000000000000000000000000",
      INVALID_SPAN_ID = "0000000000000000",
      SAMPLED_FLAG = 1;
    function _isValid(value, len, invalidValue) {
      return value && value[_DYN_LENGTH] === len && value !== invalidValue ? !!value.match(/^[\da-f]*$/i) : !1;
    }
    __name(_isValid, "_isValid");
    function _formatValue(value, len, defValue) {
      return _isValid(value, len) ? value : defValue;
    }
    __name(_formatValue, "_formatValue");
    function _formatFlags(value) {
      (isNaN(value) || value < 0 || value > 255) && (value = 1);
      for (var result = value.toString(16); result[_DYN_LENGTH] < 2;) result = "0" + result;
      return result;
    }
    __name(_formatFlags, "_formatFlags");
    function createTraceParent(traceId, spanId, flags, version) {
      return {
        version: _isValid(version, 2, INVALID_VERSION) ? version : DEFAULT_VERSION,
        traceId: isValidTraceId(traceId) ? traceId : generateW3CId(),
        spanId: isValidSpanId(spanId) ? spanId : strLeft(generateW3CId(), 16),
        traceFlags: flags >= 0 && flags <= 255 ? flags : 1
      };
    }
    __name(createTraceParent, "createTraceParent");
    function parseTraceParent(value, selectIdx) {
      if (!value || (isArray(value) && (value = value[0] || ""), !value || !isString(value) || value[_DYN_LENGTH] > 8192)) return null;
      if (value.indexOf(",") !== -1) {
        var values = value[_DYN_SPLIT](",");
        value = values[selectIdx > 0 && values[_DYN_LENGTH] > selectIdx ? selectIdx : 0];
      }
      var match = TRACE_PARENT_REGEX.exec(strTrim(value));
      return !match || match[1] === INVALID_VERSION || match[2] === INVALID_TRACE_ID || match[3] === INVALID_SPAN_ID ? null : {
        version: (match[1] || STR_EMPTY)[_DYN_TO_LOWER_CASE](),
        traceId: (match[2] || STR_EMPTY)[_DYN_TO_LOWER_CASE](),
        spanId: (match[3] || STR_EMPTY)[_DYN_TO_LOWER_CASE](),
        traceFlags: parseInt(match[4], 16)
      };
    }
    __name(parseTraceParent, "parseTraceParent");
    function isValidTraceId(value) {
      return _isValid(value, 32, INVALID_TRACE_ID);
    }
    __name(isValidTraceId, "isValidTraceId");
    function isValidSpanId(value) {
      return _isValid(value, 16, INVALID_SPAN_ID);
    }
    __name(isValidSpanId, "isValidSpanId");
    function isValidTraceParent(value) {
      return !(!value || !_isValid(value[_DYN_VERSION], 2, INVALID_VERSION) || !_isValid(value.traceId, 32, INVALID_TRACE_ID) || !_isValid(value.spanId, 16, INVALID_SPAN_ID) || !_isValid(_formatFlags(value[_DYN_TRACE_FLAGS]), 2));
    }
    __name(isValidTraceParent, "isValidTraceParent");
    function isSampledFlag(value) {
      return isValidTraceParent(value) ? (value[_DYN_TRACE_FLAGS] & SAMPLED_FLAG) === SAMPLED_FLAG : !1;
    }
    __name(isSampledFlag, "isSampledFlag");
    function formatTraceParent(value) {
      if (value) {
        var flags = _formatFlags(value[_DYN_TRACE_FLAGS]);
        _isValid(flags, 2) || (flags = "01");
        var version = value[_DYN_VERSION] || DEFAULT_VERSION;
        return version !== "00" && version !== "ff" && (version = DEFAULT_VERSION), "".concat(version.toLowerCase(), "-").concat(_formatValue(value.traceId, 32, INVALID_TRACE_ID).toLowerCase(), "-").concat(_formatValue(value.spanId, 16, INVALID_SPAN_ID).toLowerCase(), "-").concat(flags.toLowerCase());
      }
      return "";
    }
    __name(formatTraceParent, "formatTraceParent");
    function findW3cTraceParent(selectIdx) {
      var name = "traceparent",
        traceParent = parseTraceParent(findMetaTag(name), selectIdx);
      return traceParent || (traceParent = parseTraceParent(findNamedServerTiming(name), selectIdx)), traceParent;
    }
    __name(findW3cTraceParent, "findW3cTraceParent");
    function findAllScripts(doc) {
      var scripts = doc.getElementsByTagName("script"),
        result = [];
      return arrForEach(scripts, function (script) {
        var src = script[_DYN_GET_ATTRIBUTE]("src");
        if (src) {
          var crossOrigin = script[_DYN_GET_ATTRIBUTE]("crossorigin"),
            async = script.hasAttribute("async") === !0,
            defer = script.hasAttribute("defer") === !0,
            referrerPolicy = script[_DYN_GET_ATTRIBUTE]("referrerpolicy"),
            info = {
              url: src
            };
          crossOrigin && (info.crossOrigin = crossOrigin), async && (info.async = async), defer && (info.defer = defer), referrerPolicy && (info.referrerPolicy = referrerPolicy), result[_DYN_PUSH](info);
        }
      }), result;
    }
    __name(findAllScripts, "findAllScripts");
    var strOnPrefix = "on",
      strAttachEvent = "attachEvent",
      strAddEventHelper = "addEventListener",
      strDetachEvent = "detachEvent",
      strRemoveEventListener = "removeEventListener",
      strEvents = "events";
    createUniqueNamespace("aiEvtPageHide"), createUniqueNamespace("aiEvtPageShow");
    var rRemoveEmptyNs = /\.[\.]+/g,
      rRemoveTrailingEmptyNs = /[\.]+$/,
      _guid = 1,
      elmNodeData = createElmNodeData("events"),
      eventNamespace = /^([^.]*)(?:\.(.+)|)/;
    function _normalizeNamespace(name) {
      return name && name[_DYN_REPLACE] ? name[_DYN_REPLACE](/^[\s\.]+|(?=[\s\.])[\.\s]+$/g, STR_EMPTY) : name;
    }
    __name(_normalizeNamespace, "_normalizeNamespace");
    function _getEvtNamespace(eventName, evtNamespace) {
      if (evtNamespace) {
        var theNamespace_1 = STR_EMPTY;
        isArray(evtNamespace) ? (theNamespace_1 = STR_EMPTY, arrForEach(evtNamespace, function (name) {
          name = _normalizeNamespace(name), name && (name[0] !== "." && (name = "." + name), theNamespace_1 += name);
        })) : theNamespace_1 = _normalizeNamespace(evtNamespace), theNamespace_1 && (theNamespace_1[0] !== "." && (theNamespace_1 = "." + theNamespace_1), eventName = (eventName || STR_EMPTY) + theNamespace_1);
      }
      var parsedEvent = eventNamespace.exec(eventName || STR_EMPTY) || [];
      return {
        type: parsedEvent[1],
        ns: (parsedEvent[2] || STR_EMPTY).replace(rRemoveEmptyNs, ".").replace(rRemoveTrailingEmptyNs, STR_EMPTY)[_DYN_SPLIT](".").sort().join(".")
      };
    }
    __name(_getEvtNamespace, "_getEvtNamespace");
    function _getRegisteredEvents(target, evtName, addDefault) {
      addDefault === void 0 && (addDefault = !0);
      var aiEvts = elmNodeData.get(target, strEvents, {}, addDefault),
        registeredEvents = aiEvts[evtName];
      return registeredEvents || (registeredEvents = aiEvts[evtName] = []), registeredEvents;
    }
    __name(_getRegisteredEvents, "_getRegisteredEvents");
    function _doDetach(obj, evtName, handlerRef, useCapture) {
      obj && evtName && evtName[_DYN_TYPE] && (obj[strRemoveEventListener] ? obj[strRemoveEventListener](evtName[_DYN_TYPE], handlerRef, useCapture) : obj[strDetachEvent] && obj[strDetachEvent](strOnPrefix + evtName[_DYN_TYPE], handlerRef));
    }
    __name(_doDetach, "_doDetach");
    function _doAttach(obj, evtName, handlerRef, useCapture) {
      var result = !1;
      return obj && evtName && evtName[_DYN_TYPE] && handlerRef && (obj[strAddEventHelper] ? (obj[strAddEventHelper](evtName[_DYN_TYPE], handlerRef, useCapture), result = !0) : obj[strAttachEvent] && (obj[strAttachEvent](strOnPrefix + evtName[_DYN_TYPE], handlerRef), result = !0)), result;
    }
    __name(_doAttach, "_doAttach");
    function _doUnregister(target, events, evtName, unRegFn) {
      for (var idx = events[_DYN_LENGTH]; idx--;) {
        var theEvent = events[idx];
        theEvent && (!evtName.ns || evtName.ns === theEvent[_DYN_EVT_NAME].ns) && (!unRegFn || unRegFn(theEvent)) && (_doDetach(target, theEvent[_DYN_EVT_NAME], theEvent.handler, theEvent.capture), events[_DYN_SPLICE](idx, 1));
      }
    }
    __name(_doUnregister, "_doUnregister");
    function _unregisterEvents(target, evtName, unRegFn) {
      if (evtName[_DYN_TYPE]) _doUnregister(target, _getRegisteredEvents(target, evtName[_DYN_TYPE]), evtName, unRegFn);else {
        var eventCache = elmNodeData.get(target, strEvents, {});
        objForEachKey(eventCache, function (evtType, events) {
          _doUnregister(target, events, evtName, unRegFn);
        }), objKeys(eventCache)[_DYN_LENGTH] === 0 && elmNodeData.kill(target, strEvents);
      }
    }
    __name(_unregisterEvents, "_unregisterEvents");
    function mergeEvtNamespace(theNamespace, namespaces) {
      var newNamespaces;
      return namespaces ? (isArray(namespaces) ? newNamespaces = [theNamespace].concat(namespaces) : newNamespaces = [theNamespace, namespaces], newNamespaces = _getEvtNamespace("xx", newNamespaces).ns[_DYN_SPLIT](".")) : newNamespaces = theNamespace, newNamespaces;
    }
    __name(mergeEvtNamespace, "mergeEvtNamespace");
    function eventOn(target, eventName, handlerRef, evtNamespace, useCapture) {
      useCapture === void 0 && (useCapture = !1);
      var result = !1;
      if (target) try {
        var evtName = _getEvtNamespace(eventName, evtNamespace);
        if (result = _doAttach(target, evtName, handlerRef, useCapture), result && elmNodeData.accept(target)) {
          var registeredEvent = {
            guid: _guid++,
            evtName: evtName,
            handler: handlerRef,
            capture: useCapture
          };
          _getRegisteredEvents(target, evtName.type)[_DYN_PUSH](registeredEvent);
        }
      } catch {}
      return result;
    }
    __name(eventOn, "eventOn");
    function eventOff(target, eventName, handlerRef, evtNamespace, useCapture) {
      if (useCapture === void 0 && (useCapture = !1), target) try {
        var evtName_1 = _getEvtNamespace(eventName, evtNamespace),
          found_1 = !1;
        _unregisterEvents(target, evtName_1, function (regEvent) {
          return evtName_1.ns && !handlerRef || regEvent.handler === handlerRef ? (found_1 = !0, !0) : !1;
        }), found_1 || _doDetach(target, evtName_1, handlerRef, useCapture);
      } catch {}
    }
    __name(eventOff, "eventOff");
    var DisabledPropertyName = "Microsoft_ApplicationInsights_BypassAjaxInstrumentation",
      SampleRate = "sampleRate",
      ProcessLegacy = "ProcessLegacy",
      HttpMethod = "http.method",
      DEFAULT_BREEZE_ENDPOINT = "https://dc.services.visualstudio.com",
      DEFAULT_BREEZE_PATH = "/v2/track",
      strNotSpecified = "not_specified",
      strIkey = "iKey",
      RequestHeaders = createValueMap({
        requestContextHeader: [0, "Request-Context"],
        requestContextTargetKey: [1, "appId"],
        requestContextAppIdFormat: [2, "appId=cid-v1:"],
        requestIdHeader: [3, "Request-Id"],
        traceParentHeader: [4, "traceparent"],
        traceStateHeader: [5, "tracestate"],
        sdkContextHeader: [6, "Sdk-Context"],
        sdkContextHeaderAppIdRequest: [7, "appId"],
        requestContextHeaderLowerCase: [8, "request-context"]
      }),
      _DYN_SPLIT = "split",
      _DYN_LENGTH = "length",
      _DYN_TO_LOWER_CASE = "toLowerCase",
      _DYN_INGESTIONENDPOINT = "ingestionendpoint",
      _DYN_TO_STRING = "toString",
      _DYN_REMOVE_ITEM = "removeItem",
      _DYN_MESSAGE = "message",
      _DYN_COUNT = "count",
      _DYN_PRE_TRIGGER_DATE = "preTriggerDate",
      _DYN_GET_UTCDATE = "getUTCDate",
      _DYN_STRINGIFY = "stringify",
      _DYN_PATHNAME = "pathname",
      _DYN_MATCH = "match",
      _DYN_CORRELATION_HEADER_E0 = "correlationHeaderExcludePatterns",
      _DYN_NAME = "name",
      _DYN_EXTENSION_CONFIG = "extensionConfig",
      _DYN_PROPERTIES = "properties",
      _DYN_MEASUREMENTS = "measurements",
      _DYN_SIZE_IN_BYTES = "sizeInBytes",
      _DYN_TYPE_NAME = "typeName",
      _DYN_EXCEPTIONS = "exceptions",
      _DYN_SEVERITY_LEVEL = "severityLevel",
      _DYN_PROBLEM_GROUP = "problemGroup",
      _DYN_PARSED_STACK = "parsedStack",
      _DYN_HAS_FULL_STACK = "hasFullStack",
      _DYN_ASSEMBLY = "assembly",
      _DYN_FILE_NAME = "fileName",
      _DYN_LINE = "line",
      _DYN_AI_DATA_CONTRACT = "aiDataContract",
      _DYN_DURATION = "duration";
    function dataSanitizeKeyAndAddUniqueness(logger, key, map) {
      var origLength = key[_DYN_LENGTH],
        field = dataSanitizeKey(logger, key);
      if (field[_DYN_LENGTH] !== origLength) {
        for (var i = 0, uniqueField = field; map[uniqueField] !== void 0;) i++, uniqueField = strSubstring(field, 0, 147) + dsPadNumber(i);
        field = uniqueField;
      }
      return field;
    }
    __name(dataSanitizeKeyAndAddUniqueness, "dataSanitizeKeyAndAddUniqueness");
    function dataSanitizeKey(logger, name) {
      var nameTrunc;
      return name && (name = strTrim(asString(name)), name[_DYN_LENGTH] > 150 && (nameTrunc = strSubstring(name, 0, 150), _throwInternal(logger, 2, 57, "name is too long.  It has been truncated to 150 characters.", {
        name: name
      }, !0))), nameTrunc || name;
    }
    __name(dataSanitizeKey, "dataSanitizeKey");
    function dataSanitizeString(logger, value, maxLength) {
      maxLength === void 0 && (maxLength = 1024);
      var valueTrunc;
      return value && (maxLength = maxLength || 1024, value = strTrim(asString(value)), value[_DYN_LENGTH] > maxLength && (valueTrunc = strSubstring(value, 0, maxLength), _throwInternal(logger, 2, 61, "string value is too long. It has been truncated to " + maxLength + " characters.", {
        value: value
      }, !0))), valueTrunc || value;
    }
    __name(dataSanitizeString, "dataSanitizeString");
    function dataSanitizeUrl(logger, url) {
      return dataSanitizeInput(logger, url, 2048, 66);
    }
    __name(dataSanitizeUrl, "dataSanitizeUrl");
    function dataSanitizeMessage(logger, message) {
      var messageTrunc;
      return message && message[_DYN_LENGTH] > 32768 && (messageTrunc = strSubstring(message, 0, 32768), _throwInternal(logger, 2, 56, "message is too long, it has been truncated to 32768 characters.", {
        message: message
      }, !0)), messageTrunc || message;
    }
    __name(dataSanitizeMessage, "dataSanitizeMessage");
    function dataSanitizeException(logger, exception) {
      var exceptionTrunc;
      if (exception) {
        var value = "" + exception;
        value[_DYN_LENGTH] > 32768 && (exceptionTrunc = strSubstring(value, 0, 32768), _throwInternal(logger, 2, 52, "exception is too long, it has been truncated to 32768 characters.", {
          exception: exception
        }, !0));
      }
      return exceptionTrunc || exception;
    }
    __name(dataSanitizeException, "dataSanitizeException");
    function dataSanitizeProperties(logger, properties) {
      if (properties) {
        var tempProps_1 = {};
        objForEachKey(properties, function (prop, value) {
          if (isObject(value) && hasJSON()) try {
            value = getJSON()[_DYN_STRINGIFY](value);
          } catch (e) {
            _throwInternal(logger, 2, 49, "custom property is not valid", {
              exception: e
            }, !0);
          }
          value = dataSanitizeString(logger, value, 8192), prop = dataSanitizeKeyAndAddUniqueness(logger, prop, tempProps_1), tempProps_1[prop] = value;
        }), properties = tempProps_1;
      }
      return properties;
    }
    __name(dataSanitizeProperties, "dataSanitizeProperties");
    function dataSanitizeMeasurements(logger, measurements) {
      if (measurements) {
        var tempMeasurements_1 = {};
        objForEachKey(measurements, function (measure, value) {
          measure = dataSanitizeKeyAndAddUniqueness(logger, measure, tempMeasurements_1), tempMeasurements_1[measure] = value;
        }), measurements = tempMeasurements_1;
      }
      return measurements;
    }
    __name(dataSanitizeMeasurements, "dataSanitizeMeasurements");
    function dataSanitizeId(logger, id) {
      return id && dataSanitizeInput(logger, id, 128, 69)[_DYN_TO_STRING]();
    }
    __name(dataSanitizeId, "dataSanitizeId");
    function dataSanitizeInput(logger, input, maxLength, _msgId) {
      var inputTrunc;
      return input && (input = strTrim(asString(input)), input[_DYN_LENGTH] > maxLength && (inputTrunc = strSubstring(input, 0, maxLength), _throwInternal(logger, 2, _msgId, "input is too long, it has been truncated to " + maxLength + " characters.", {
        data: input
      }, !0))), inputTrunc || input;
    }
    __name(dataSanitizeInput, "dataSanitizeInput");
    function dsPadNumber(num) {
      var s = "00" + num;
      return strSubstr(s, s[_DYN_LENGTH] - 3);
    }
    __name(dsPadNumber, "dsPadNumber");
    var _document = getDocument() || {},
      _htmlAnchorIdx = 0,
      _htmlAnchorElement = [null, null, null, null, null];
    function urlParseUrl(url) {
      var anchorIdx = _htmlAnchorIdx,
        anchorCache = _htmlAnchorElement,
        tempAnchor = anchorCache[anchorIdx];
      return _document.createElement ? anchorCache[anchorIdx] || (tempAnchor = anchorCache[anchorIdx] = _document.createElement("a")) : tempAnchor = {
        host: urlParseHost(url, !0)
      }, tempAnchor.href = url, anchorIdx++, anchorIdx >= anchorCache[_DYN_LENGTH] && (anchorIdx = 0), _htmlAnchorIdx = anchorIdx, tempAnchor;
    }
    __name(urlParseUrl, "urlParseUrl");
    function urlGetAbsoluteUrl(url) {
      var result,
        a = urlParseUrl(url);
      return a && (result = a.href), result;
    }
    __name(urlGetAbsoluteUrl, "urlGetAbsoluteUrl");
    function urlGetPathName(url) {
      var result,
        a = urlParseUrl(url);
      return a && (result = a[_DYN_PATHNAME]), result;
    }
    __name(urlGetPathName, "urlGetPathName");
    function urlGetCompleteUrl(method, absoluteUrl) {
      return method ? method.toUpperCase() + " " + absoluteUrl : absoluteUrl;
    }
    __name(urlGetCompleteUrl, "urlGetCompleteUrl");
    function urlParseHost(url, inclPort) {
      var fullHost = urlParseFullHost(url, inclPort) || "";
      if (fullHost) {
        var match = fullHost[_DYN_MATCH](/(www\d{0,5}\.)?([^\/:]{1,256})(:\d{1,20})?/i);
        if (match != null && match[_DYN_LENGTH] > 3 && isString(match[2]) && match[2][_DYN_LENGTH] > 0) return match[2] + (match[3] || "");
      }
      return fullHost;
    }
    __name(urlParseHost, "urlParseHost");
    function urlParseFullHost(url, inclPort) {
      var result = null;
      if (url) {
        var match = url[_DYN_MATCH](/(\w{1,150}):\/\/([^\/:]{1,256})(:\d{1,20})?/i);
        if (match != null && match[_DYN_LENGTH] > 2 && isString(match[2]) && match[2][_DYN_LENGTH] > 0 && (result = match[2] || "", inclPort && match[_DYN_LENGTH] > 2)) {
          var protocol = (match[1] || "")[_DYN_TO_LOWER_CASE](),
            port = match[3] || "";
          (protocol === "http" && port === ":80" || protocol === "https" && port === ":443") && (port = ""), result += port;
        }
      }
      return result;
    }
    __name(urlParseFullHost, "urlParseFullHost");
    var _internalEndpoints = [DEFAULT_BREEZE_ENDPOINT + DEFAULT_BREEZE_PATH, "https://breeze.aimon.applicationinsights.io" + DEFAULT_BREEZE_PATH, "https://dc-int.services.visualstudio.com" + DEFAULT_BREEZE_PATH],
      _correlationIdPrefix = "cid-v1:";
    function isInternalApplicationInsightsEndpoint(endpointUrl) {
      return arrIndexOf(_internalEndpoints, endpointUrl[_DYN_TO_LOWER_CASE]()) !== -1;
    }
    __name(isInternalApplicationInsightsEndpoint, "isInternalApplicationInsightsEndpoint");
    function correlationIdSetPrefix(prefix) {
      _correlationIdPrefix = prefix;
    }
    __name(correlationIdSetPrefix, "correlationIdSetPrefix");
    function correlationIdGetPrefix() {
      return _correlationIdPrefix;
    }
    __name(correlationIdGetPrefix, "correlationIdGetPrefix");
    function correlationIdCanIncludeCorrelationHeader(config, requestUrl, currentHost) {
      if (!requestUrl || config && config.disableCorrelationHeaders) return !1;
      if (config && config[_DYN_CORRELATION_HEADER_E0]) {
        for (var i = 0; i < config.correlationHeaderExcludePatterns[_DYN_LENGTH]; i++) if (config[_DYN_CORRELATION_HEADER_E0][i].test(requestUrl)) return !1;
      }
      var requestHost = urlParseUrl(requestUrl).host[_DYN_TO_LOWER_CASE]();
      if (requestHost && (strIndexOf(requestHost, ":443") !== -1 || strIndexOf(requestHost, ":80") !== -1) && (requestHost = (urlParseFullHost(requestUrl, !0) || "")[_DYN_TO_LOWER_CASE]()), (!config || !config.enableCorsCorrelation) && requestHost && requestHost !== currentHost) return !1;
      var includedDomains = config && config.correlationHeaderDomains;
      if (includedDomains) {
        var matchExists_1;
        if (arrForEach(includedDomains, function (domain) {
          var regex = new RegExp(domain.toLowerCase().replace(/\\/g, "\\\\").replace(/\./g, "\\.").replace(/\*/g, ".*"));
          matchExists_1 = matchExists_1 || regex.test(requestHost);
        }), !matchExists_1) return !1;
      }
      var excludedDomains = config && config.correlationHeaderExcludedDomains;
      if (!excludedDomains || excludedDomains[_DYN_LENGTH] === 0) return !0;
      for (var i = 0; i < excludedDomains[_DYN_LENGTH]; i++) {
        var regex = new RegExp(excludedDomains[i].toLowerCase().replace(/\\/g, "\\\\").replace(/\./g, "\\.").replace(/\*/g, ".*"));
        if (regex.test(requestHost)) return !1;
      }
      return requestHost && requestHost[_DYN_LENGTH] > 0;
    }
    __name(correlationIdCanIncludeCorrelationHeader, "correlationIdCanIncludeCorrelationHeader");
    function correlationIdGetCorrelationContext(responseHeader) {
      if (responseHeader) {
        var correlationId = correlationIdGetCorrelationContextValue(responseHeader, RequestHeaders[1]);
        if (correlationId && correlationId !== _correlationIdPrefix) return correlationId;
      }
    }
    __name(correlationIdGetCorrelationContext, "correlationIdGetCorrelationContext");
    function correlationIdGetCorrelationContextValue(responseHeader, key) {
      if (responseHeader) for (var keyValues = responseHeader[_DYN_SPLIT](","), i = 0; i < keyValues[_DYN_LENGTH]; ++i) {
        var keyValue = keyValues[i][_DYN_SPLIT]("=");
        if (keyValue[_DYN_LENGTH] === 2 && keyValue[0] === key) return keyValue[1];
      }
    }
    __name(correlationIdGetCorrelationContextValue, "correlationIdGetCorrelationContextValue");
    function AjaxHelperParseDependencyPath(logger, absoluteUrl, method, commandName) {
      var target,
        name = commandName,
        data = commandName;
      if (absoluteUrl && absoluteUrl[_DYN_LENGTH] > 0) {
        var parsedUrl = urlParseUrl(absoluteUrl);
        if (target = parsedUrl.host, !name) if (parsedUrl[_DYN_PATHNAME] != null) {
          var pathName = parsedUrl.pathname[_DYN_LENGTH] === 0 ? "/" : parsedUrl[_DYN_PATHNAME];
          pathName.charAt(0) !== "/" && (pathName = "/" + pathName), data = parsedUrl[_DYN_PATHNAME], name = dataSanitizeString(logger, method ? method + " " + pathName : pathName);
        } else name = dataSanitizeString(logger, absoluteUrl);
      } else target = commandName, name = commandName;
      return {
        target: target,
        name: name,
        data: data
      };
    }
    __name(AjaxHelperParseDependencyPath, "AjaxHelperParseDependencyPath");
    function dateTimeUtilsNow() {
      var perf = getPerformance();
      if (perf && perf.now && perf.timing) {
        var now = perf.now() + perf.timing.navigationStart;
        if (now > 0) return now;
      }
      return dateNow();
    }
    __name(dateTimeUtilsNow, "dateTimeUtilsNow");
    function dateTimeUtilsDuration(start, end) {
      var result = null;
      return start !== 0 && end !== 0 && !isNullOrUndefined(start) && !isNullOrUndefined(end) && (result = end - start), result;
    }
    __name(dateTimeUtilsDuration, "dateTimeUtilsDuration");
    function createDistributedTraceContextFromTrace(telemetryTrace, parentCtx) {
      var trace = telemetryTrace || {};
      return {
        getName: __name(function () {
          return trace[_DYN_NAME];
        }, "getName"),
        setName: __name(function (newValue) {
          parentCtx && parentCtx.setName(newValue), trace[_DYN_NAME] = newValue;
        }, "setName"),
        getTraceId: __name(function () {
          return trace.traceID;
        }, "getTraceId"),
        setTraceId: __name(function (newValue) {
          parentCtx && parentCtx.setTraceId(newValue), isValidTraceId(newValue) && (trace.traceID = newValue);
        }, "setTraceId"),
        getSpanId: __name(function () {
          return trace.parentID;
        }, "getSpanId"),
        setSpanId: __name(function (newValue) {
          parentCtx && parentCtx.setSpanId(newValue), isValidSpanId(newValue) && (trace.parentID = newValue);
        }, "setSpanId"),
        getTraceFlags: __name(function () {
          return trace.traceFlags;
        }, "getTraceFlags"),
        setTraceFlags: __name(function (newTraceFlags) {
          parentCtx && parentCtx.setTraceFlags(newTraceFlags), trace.traceFlags = newTraceFlags;
        }, "setTraceFlags")
      };
    }
    __name(createDistributedTraceContextFromTrace, "createDistributedTraceContextFromTrace");
    var StorageType = createEnumStyle({
        LocalStorage: 0,
        SessionStorage: 1
      }),
      DistributedTracingModes = createEnumStyle({
        AI: 0,
        AI_AND_W3C: 1,
        W3C: 2
      }),
      EventPersistence = createEnumStyle({
        Normal: 1,
        Critical: 2
      }),
      _canUseLocalStorage = void 0,
      _canUseSessionStorage = void 0,
      _storagePrefix = "";
    function _getLocalStorageObject() {
      return utlCanUseLocalStorage() ? _getVerifiedStorageObject(StorageType.LocalStorage) : null;
    }
    __name(_getLocalStorageObject, "_getLocalStorageObject");
    function _getVerifiedStorageObject(storageType) {
      try {
        if (isNullOrUndefined(getGlobal())) return null;
        var uid = new Date()[_DYN_TO_STRING](),
          storage = getGlobalInst(storageType === StorageType.LocalStorage ? "localStorage" : "sessionStorage"),
          name_1 = _storagePrefix + uid;
        storage.setItem(name_1, uid);
        var fail = storage.getItem(name_1) !== uid;
        if (storage[_DYN_REMOVE_ITEM](name_1), !fail) return storage;
      } catch {}
      return null;
    }
    __name(_getVerifiedStorageObject, "_getVerifiedStorageObject");
    function _getSessionStorageObject() {
      return utlCanUseSessionStorage() ? _getVerifiedStorageObject(StorageType.SessionStorage) : null;
    }
    __name(_getSessionStorageObject, "_getSessionStorageObject");
    function utlDisableStorage() {
      _canUseLocalStorage = !1, _canUseSessionStorage = !1;
    }
    __name(utlDisableStorage, "utlDisableStorage");
    function utlSetStoragePrefix(storagePrefix) {
      _storagePrefix = storagePrefix || "";
    }
    __name(utlSetStoragePrefix, "utlSetStoragePrefix");
    function utlEnableStorage() {
      _canUseLocalStorage = utlCanUseLocalStorage(!0), _canUseSessionStorage = utlCanUseSessionStorage(!0);
    }
    __name(utlEnableStorage, "utlEnableStorage");
    function utlCanUseLocalStorage(reset) {
      return (reset || _canUseLocalStorage === void 0) && (_canUseLocalStorage = !!_getVerifiedStorageObject(StorageType.LocalStorage)), _canUseLocalStorage;
    }
    __name(utlCanUseLocalStorage, "utlCanUseLocalStorage");
    function utlGetLocalStorage(logger, name) {
      var storage = _getLocalStorageObject();
      if (storage !== null) try {
        return storage.getItem(name);
      } catch (e) {
        _canUseLocalStorage = !1, _throwInternal(logger, 2, 1, "Browser failed read of local storage. " + getExceptionName(e), {
          exception: dumpObj(e)
        });
      }
      return null;
    }
    __name(utlGetLocalStorage, "utlGetLocalStorage");
    function utlSetLocalStorage(logger, name, data) {
      var storage = _getLocalStorageObject();
      if (storage !== null) try {
        return storage.setItem(name, data), !0;
      } catch (e) {
        _canUseLocalStorage = !1, _throwInternal(logger, 2, 3, "Browser failed write to local storage. " + getExceptionName(e), {
          exception: dumpObj(e)
        });
      }
      return !1;
    }
    __name(utlSetLocalStorage, "utlSetLocalStorage");
    function utlRemoveStorage(logger, name) {
      var storage = _getLocalStorageObject();
      if (storage !== null) try {
        return storage[_DYN_REMOVE_ITEM](name), !0;
      } catch (e) {
        _canUseLocalStorage = !1, _throwInternal(logger, 2, 5, "Browser failed removal of local storage item. " + getExceptionName(e), {
          exception: dumpObj(e)
        });
      }
      return !1;
    }
    __name(utlRemoveStorage, "utlRemoveStorage");
    function utlCanUseSessionStorage(reset) {
      return (reset || _canUseSessionStorage === void 0) && (_canUseSessionStorage = !!_getVerifiedStorageObject(StorageType.SessionStorage)), _canUseSessionStorage;
    }
    __name(utlCanUseSessionStorage, "utlCanUseSessionStorage");
    function utlGetSessionStorageKeys() {
      var keys = [];
      return utlCanUseSessionStorage() && objForEachKey(getGlobalInst("sessionStorage"), function (key) {
        keys.push(key);
      }), keys;
    }
    __name(utlGetSessionStorageKeys, "utlGetSessionStorageKeys");
    function utlGetSessionStorage(logger, name) {
      var storage = _getSessionStorageObject();
      if (storage !== null) try {
        return storage.getItem(name);
      } catch (e) {
        _canUseSessionStorage = !1, _throwInternal(logger, 2, 2, "Browser failed read of session storage. " + getExceptionName(e), {
          exception: dumpObj(e)
        });
      }
      return null;
    }
    __name(utlGetSessionStorage, "utlGetSessionStorage");
    function utlSetSessionStorage(logger, name, data) {
      var storage = _getSessionStorageObject();
      if (storage !== null) try {
        return storage.setItem(name, data), !0;
      } catch (e) {
        _canUseSessionStorage = !1, _throwInternal(logger, 2, 4, "Browser failed write to session storage. " + getExceptionName(e), {
          exception: dumpObj(e)
        });
      }
      return !1;
    }
    __name(utlSetSessionStorage, "utlSetSessionStorage");
    function utlRemoveSessionStorage(logger, name) {
      var storage = _getSessionStorageObject();
      if (storage !== null) try {
        return storage[_DYN_REMOVE_ITEM](name), !0;
      } catch (e) {
        _canUseSessionStorage = !1, _throwInternal(logger, 2, 6, "Browser failed removal of session storage item. " + getExceptionName(e), {
          exception: dumpObj(e)
        });
      }
      return !1;
    }
    __name(utlRemoveSessionStorage, "utlRemoveSessionStorage");
    var THROTTLE_STORAGE_PREFIX = "appInsightsThrottle",
      ThrottleMgr = function () {
        function ThrottleMgr(core, namePrefix) {
          var _self = this,
            _canUseLocalStorage,
            _logger,
            _config,
            _localStorageObj,
            _isTriggered,
            _namePrefix,
            _queue,
            _isReady = !1,
            _isSpecificDaysGiven = !1;
          _initConfig(), _self._getDbgPlgTargets = function () {
            return [_queue];
          }, _self.getConfig = function () {
            return _config;
          }, _self.canThrottle = function (msgId) {
            var localObj = _getLocalStorageObjByKey(msgId),
              cfg = _getCfgByKey(msgId);
            return _canThrottle(cfg, _canUseLocalStorage, localObj);
          }, _self.isTriggered = function (msgId) {
            return _isTrigger(msgId);
          }, _self.isReady = function () {
            return _isReady;
          }, _self.flush = function (msgId) {
            try {
              var queue = _getQueueByKey(msgId);
              if (queue && queue[_DYN_LENGTH] > 0) {
                var items = queue.slice(0);
                return _queue[msgId] = [], arrForEach(items, function (item) {
                  _flushMessage(item.msgID, item[_DYN_MESSAGE], item.severity, !1);
                }), !0;
              }
            } catch {}
            return !1;
          }, _self.flushAll = function () {
            try {
              if (_queue) {
                var result_1 = !0;
                return objForEachKey(_queue, function (key) {
                  var isFlushed = _self.flush(parseInt(key));
                  result_1 = result_1 && isFlushed;
                }), result_1;
              }
            } catch {}
            return !1;
          }, _self.onReadyState = function (isReady, flushAll) {
            return flushAll === void 0 && (flushAll = !0), _isReady = isNullOrUndefined(isReady) ? !0 : isReady, _isReady && flushAll ? _self.flushAll() : null;
          }, _self.sendMessage = function (msgID, message, severity) {
            return _flushMessage(msgID, message, severity, !0);
          };
          function _flushMessage(msgID, message, severity, saveUnsentMsg) {
            if (_isReady) {
              var isSampledIn = _canSampledIn(msgID);
              if (!isSampledIn) return;
              var cfg = _getCfgByKey(msgID),
                localStorageObj = _getLocalStorageObjByKey(msgID),
                canThrottle = _canThrottle(cfg, _canUseLocalStorage, localStorageObj),
                throttled = !1,
                number = 0,
                isTriggered = _isTrigger(msgID);
              try {
                canThrottle && !isTriggered ? (number = mathMin(cfg.limit.maxSendNumber, localStorageObj[_DYN_COUNT] + 1), localStorageObj[_DYN_COUNT] = 0, throttled = !0, _isTriggered[msgID] = !0, localStorageObj[_DYN_PRE_TRIGGER_DATE] = new Date()) : (_isTriggered[msgID] = canThrottle, localStorageObj[_DYN_COUNT] += 1);
                var localStorageName = _getLocalStorageName(msgID);
                _resetLocalStorage(_logger, localStorageName, localStorageObj);
                for (var i = 0; i < number; i++) _sendMessage(msgID, _logger, message, severity);
              } catch {}
              return {
                isThrottled: throttled,
                throttleNum: number
              };
            } else if (saveUnsentMsg) {
              var queue = _getQueueByKey(msgID);
              queue.push({
                msgID: msgID,
                message: message,
                severity: severity
              });
            }
            return null;
          }
          __name(_flushMessage, "_flushMessage");
          function _initConfig() {
            _logger = safeGetLogger(core), _isTriggered = {}, _localStorageObj = {}, _queue = {}, _config = {}, _setCfgByKey(109), _namePrefix = isNotNullOrUndefined(namePrefix) ? namePrefix : "", core.addUnloadHook(onConfigChange(core.config, function (details) {
              var coreConfig = details.cfg;
              _canUseLocalStorage = utlCanUseLocalStorage();
              var configMgr = coreConfig.throttleMgrCfg || {};
              objForEachKey(configMgr, function (key, cfg) {
                _setCfgByKey(parseInt(key), cfg);
              });
            }));
          }
          __name(_initConfig, "_initConfig");
          function _getCfgByKey(msgID) {
            return _config[msgID] || _config[109];
          }
          __name(_getCfgByKey, "_getCfgByKey");
          function _setCfgByKey(msgID, config) {
            var _a, _b;
            try {
              var cfg = config || {},
                curCfg = {};
              curCfg.disabled = !!cfg.disabled;
              var configInterval = cfg.interval || {};
              _isSpecificDaysGiven = (configInterval == null ? void 0 : configInterval.daysOfMonth) && (configInterval == null ? void 0 : configInterval.daysOfMonth[_DYN_LENGTH]) > 0, curCfg.interval = _getIntervalConfig(configInterval);
              var limit = {
                samplingRate: ((_a = cfg.limit) === null || _a === void 0 ? void 0 : _a.samplingRate) || 100,
                maxSendNumber: ((_b = cfg.limit) === null || _b === void 0 ? void 0 : _b.maxSendNumber) || 1
              };
              curCfg.limit = limit, _config[msgID] = curCfg;
            } catch {}
          }
          __name(_setCfgByKey, "_setCfgByKey");
          function _getIntervalConfig(interval) {
            interval = interval || {};
            var monthInterval = interval == null ? void 0 : interval.monthInterval,
              dayInterval = interval == null ? void 0 : interval.dayInterval;
            return isNullOrUndefined(monthInterval) && isNullOrUndefined(dayInterval) && (interval.monthInterval = 3, _isSpecificDaysGiven || (interval.daysOfMonth = [28], _isSpecificDaysGiven = !0)), interval = {
              monthInterval: interval == null ? void 0 : interval.monthInterval,
              dayInterval: interval == null ? void 0 : interval.dayInterval,
              daysOfMonth: interval == null ? void 0 : interval.daysOfMonth
            }, interval;
          }
          __name(_getIntervalConfig, "_getIntervalConfig");
          function _canThrottle(config, canUseLocalStorage, localStorageObj) {
            if (config && !config.disabled && canUseLocalStorage && isNotNullOrUndefined(localStorageObj)) {
              var curDate = _getThrottleDate(),
                date = localStorageObj.date,
                interval = config.interval,
                monthCheck = 1;
              if (interval != null && interval.monthInterval) {
                var monthExpand = (curDate.getUTCFullYear() - date.getUTCFullYear()) * 12 + curDate.getUTCMonth() - date.getUTCMonth();
                monthCheck = _checkInterval(interval.monthInterval, 0, monthExpand);
              }
              var dayCheck = 1;
              if (_isSpecificDaysGiven) dayCheck = arrIndexOf(interval.daysOfMonth, curDate[_DYN_GET_UTCDATE]());else if (interval != null && interval.dayInterval) {
                var daySpan = mathFloor((curDate.getTime() - date.getTime()) / 864e5);
                dayCheck = _checkInterval(interval.dayInterval, 0, daySpan);
              }
              return monthCheck >= 0 && dayCheck >= 0;
            }
            return !1;
          }
          __name(_canThrottle, "_canThrottle");
          function _getLocalStorageName(msgKey, prefix) {
            var fix = isNotNullOrUndefined(prefix) ? prefix : "";
            return msgKey ? THROTTLE_STORAGE_PREFIX + fix + "-" + msgKey : null;
          }
          __name(_getLocalStorageName, "_getLocalStorageName");
          function _isTriggeredOnCurDate(preTriggerDate) {
            try {
              if (preTriggerDate) {
                var curDate = new Date();
                return preTriggerDate.getUTCFullYear() === curDate.getUTCFullYear() && preTriggerDate.getUTCMonth() === curDate.getUTCMonth() && preTriggerDate[_DYN_GET_UTCDATE]() === curDate[_DYN_GET_UTCDATE]();
              }
            } catch {}
            return !1;
          }
          __name(_isTriggeredOnCurDate, "_isTriggeredOnCurDate");
          function _getLocalStorageObj(value, logger, storageName) {
            try {
              var storageObj = {
                date: _getThrottleDate(),
                count: 0
              };
              if (value) {
                var obj = JSON.parse(value),
                  curObj = {
                    date: _getThrottleDate(obj.date) || storageObj.date,
                    count: obj[_DYN_COUNT] || storageObj[_DYN_COUNT],
                    preTriggerDate: obj.preTriggerDate ? _getThrottleDate(obj[_DYN_PRE_TRIGGER_DATE]) : void 0
                  };
                return curObj;
              } else return _resetLocalStorage(logger, storageName, storageObj), storageObj;
            } catch {}
            return null;
          }
          __name(_getLocalStorageObj, "_getLocalStorageObj");
          function _getThrottleDate(dateStr) {
            try {
              if (dateStr) {
                var date = new Date(dateStr);
                if (!isNaN(date.getDate())) return date;
              } else return new Date();
            } catch {}
            return null;
          }
          __name(_getThrottleDate, "_getThrottleDate");
          function _resetLocalStorage(logger, storageName, obj) {
            try {
              return utlSetLocalStorage(logger, storageName, strTrim(JSON[_DYN_STRINGIFY](obj)));
            } catch {}
            return !1;
          }
          __name(_resetLocalStorage, "_resetLocalStorage");
          function _checkInterval(interval, start, current) {
            return interval <= 0 ? 1 : current >= start && (current - start) % interval == 0 ? mathFloor((current - start) / interval) + 1 : -1;
          }
          __name(_checkInterval, "_checkInterval");
          function _sendMessage(msgID, logger, message, severity) {
            _throwInternal(logger, severity || 1, msgID, message);
          }
          __name(_sendMessage, "_sendMessage");
          function _canSampledIn(msgID) {
            try {
              var cfg = _getCfgByKey(msgID);
              return randomValue(1e6) <= cfg.limit.samplingRate;
            } catch {}
            return !1;
          }
          __name(_canSampledIn, "_canSampledIn");
          function _getLocalStorageObjByKey(key) {
            try {
              var curObj = _localStorageObj[key];
              if (!curObj) {
                var localStorageName = _getLocalStorageName(key, _namePrefix);
                curObj = _getLocalStorageObj(utlGetLocalStorage(_logger, localStorageName), _logger, localStorageName), _localStorageObj[key] = curObj;
              }
              return _localStorageObj[key];
            } catch {}
            return null;
          }
          __name(_getLocalStorageObjByKey, "_getLocalStorageObjByKey");
          function _isTrigger(key) {
            var isTrigger = _isTriggered[key];
            if (isNullOrUndefined(isTrigger)) {
              isTrigger = !1;
              var localStorageObj = _getLocalStorageObjByKey(key);
              localStorageObj && (isTrigger = _isTriggeredOnCurDate(localStorageObj[_DYN_PRE_TRIGGER_DATE])), _isTriggered[key] = isTrigger;
            }
            return _isTriggered[key];
          }
          __name(_isTrigger, "_isTrigger");
          function _getQueueByKey(key) {
            return _queue = _queue || {}, isNullOrUndefined(_queue[key]) && (_queue[key] = []), _queue[key];
          }
          __name(_getQueueByKey, "_getQueueByKey");
        }
        return __name(ThrottleMgr, "ThrottleMgr"), ThrottleMgr;
      }(),
      _FIELDS_SEPARATOR = ";",
      _FIELD_KEY_VALUE_SEPARATOR = "=";
    function parseConnectionString(connectionString) {
      if (!connectionString) return {};
      var kvPairs = connectionString[_DYN_SPLIT](_FIELDS_SEPARATOR),
        result = arrReduce(kvPairs, function (fields, kv) {
          var kvParts = kv[_DYN_SPLIT](_FIELD_KEY_VALUE_SEPARATOR);
          if (kvParts[_DYN_LENGTH] === 2) {
            var key = kvParts[0][_DYN_TO_LOWER_CASE](),
              value = kvParts[1];
            fields[key] = value;
          }
          return fields;
        }, {});
      if (objKeys(result)[_DYN_LENGTH] > 0) {
        if (result.endpointsuffix) {
          var locationPrefix = result.location ? result.location + "." : "";
          result[_DYN_INGESTIONENDPOINT] = result[_DYN_INGESTIONENDPOINT] || "https://" + locationPrefix + "dc." + result.endpointsuffix;
        }
        result[_DYN_INGESTIONENDPOINT] = result[_DYN_INGESTIONENDPOINT] || DEFAULT_BREEZE_ENDPOINT, strEndsWith(result[_DYN_INGESTIONENDPOINT], "/") && (result[_DYN_INGESTIONENDPOINT] = result[_DYN_INGESTIONENDPOINT].slice(0, -1));
      }
      return result;
    }
    __name(parseConnectionString, "parseConnectionString");
    var ConnectionStringParser = {
        parse: parseConnectionString
      },
      Envelope = function () {
        function Envelope(logger, data, name) {
          var _this = this,
            _self = this;
          _self.ver = 1, _self.sampleRate = 100, _self.tags = {}, _self[_DYN_NAME] = dataSanitizeString(logger, name) || strNotSpecified, _self.data = data, _self.time = toISOString(new Date()), _self[_DYN_AI_DATA_CONTRACT] = {
            time: 1,
            iKey: 1,
            name: 1,
            sampleRate: __name(function () {
              return _this.sampleRate === 100 ? 4 : 1;
            }, "sampleRate"),
            tags: 1,
            data: 1
          };
        }
        return __name(Envelope, "Envelope"), Envelope;
      }(),
      Event = function () {
        function Event(logger, name, properties, measurements) {
          this.aiDataContract = {
            ver: 1,
            name: 1,
            properties: 0,
            measurements: 0
          };
          var _self = this;
          _self.ver = 2, _self[_DYN_NAME] = dataSanitizeString(logger, name) || strNotSpecified, _self[_DYN_PROPERTIES] = dataSanitizeProperties(logger, properties), _self[_DYN_MEASUREMENTS] = dataSanitizeMeasurements(logger, measurements);
        }
        return __name(Event, "Event"), Event.envelopeType = "Microsoft.ApplicationInsights.{0}.Event", Event.dataType = "EventData", Event;
      }(),
      STACKFRAME_BASE_SIZE = 58,
      IS_FRAME = /^\s{0,50}(from\s|at\s|Line\s{1,5}\d{1,10}\s{1,5}of|\w{1,50}@\w{1,80}|[^\(\s\n]+:[0-9\?]+(?::[0-9\?]+)?)/,
      FULL_STACK_FRAME_1 = /^(?:\s{0,50}at)?\s{0,50}([^\@\()\s]+)?\s{0,50}(?:\s|\@|\()\s{0,5}([^\(\s\n\]]+):([0-9\?]+):([0-9\?]+)\)?$/,
      FULL_STACK_FRAME_2 = /^(?:\s{0,50}at)?\s{0,50}([^\@\()\s]+)?\s{0,50}(?:\s|\@|\()\s{0,5}([^\(\s\n\]]+):([0-9\?]+)\)?$/,
      FULL_STACK_FRAME_3 = /^(?:\s{0,50}at)?\s{0,50}([^\@\()\s]+)?\s{0,50}(?:\s|\@|\()\s{0,5}([^\(\s\n\)\]]+)\)?$/,
      EXTRACT_FILENAME = /(?:^|\(|\s{0,10}[\w\)]+\@)?([^\(\n\s\]\)]+)(?:\:([0-9]+)(?:\:([0-9]+))?)?\)?(?:,|$)/,
      PARSE_FILENAME_LINE_COL = /([^\(\s\n]+):([0-9]+):([0-9]+)$/,
      PARSE_FILENAME_LINE_ONLY = /([^\(\s\n]+):([0-9]+)$/,
      NoMethod = "<no_method>",
      strError = "error",
      strStack = "stack",
      strStackDetails = "stackDetails",
      strErrorSrc = "errorSrc",
      strMessage = "message",
      strDescription = "description",
      _parseSequence = [{
        re: FULL_STACK_FRAME_1,
        len: 5,
        m: 1,
        fn: 2,
        ln: 3,
        col: 4
      }, {
        chk: _ignoreNative,
        pre: _scrubAnonymous,
        re: FULL_STACK_FRAME_2,
        len: 4,
        m: 1,
        fn: 2,
        ln: 3
      }, {
        re: FULL_STACK_FRAME_3,
        len: 3,
        m: 1,
        fn: 2,
        hdl: _handleFilename
      }, {
        re: EXTRACT_FILENAME,
        len: 2,
        fn: 1,
        hdl: _handleFilename
      }];
    function _scrubAnonymous(frame) {
      return frame.replace(/(\(anonymous\))/, "<anonymous>");
    }
    __name(_scrubAnonymous, "_scrubAnonymous");
    function _ignoreNative(frame) {
      return strIndexOf(frame, "[native") < 0;
    }
    __name(_ignoreNative, "_ignoreNative");
    function _stringify(value, convertToString) {
      var result = value;
      return result && !isString(result) && (JSON && JSON[_DYN_STRINGIFY] ? (result = JSON[_DYN_STRINGIFY](value), convertToString && (!result || result === "{}") && (isFunction(value[_DYN_TO_STRING]) ? result = value[_DYN_TO_STRING]() : result = "" + value)) : result = "" + value + " - (Missing JSON.stringify)"), result || "";
    }
    __name(_stringify, "_stringify");
    function _formatMessage(theEvent, errorType) {
      var evtMessage = theEvent;
      return theEvent && (evtMessage && !isString(evtMessage) && (evtMessage = theEvent[strMessage] || theEvent[strDescription] || evtMessage), evtMessage && !isString(evtMessage) && (evtMessage = _stringify(evtMessage, !0)), theEvent.filename && (evtMessage = evtMessage + " @" + (theEvent.filename || "") + ":" + (theEvent.lineno || "?") + ":" + (theEvent.colno || "?"))), errorType && errorType !== "String" && errorType !== "Object" && errorType !== "Error" && strIndexOf(evtMessage || "", errorType) === -1 && (evtMessage = errorType + ": " + evtMessage), evtMessage || "";
    }
    __name(_formatMessage, "_formatMessage");
    function _isExceptionDetailsInternal(value) {
      try {
        if (isObject(value)) return "hasFullStack" in value && "typeName" in value;
      } catch {}
      return !1;
    }
    __name(_isExceptionDetailsInternal, "_isExceptionDetailsInternal");
    function _isExceptionInternal(value) {
      try {
        if (isObject(value)) return "ver" in value && "exceptions" in value && "properties" in value;
      } catch {}
      return !1;
    }
    __name(_isExceptionInternal, "_isExceptionInternal");
    function _isStackDetails(details) {
      return details && details.src && isString(details.src) && details.obj && isArray(details.obj);
    }
    __name(_isStackDetails, "_isStackDetails");
    function _convertStackObj(errorStack) {
      var src = errorStack || "";
      isString(src) || (isString(src[strStack]) ? src = src[strStack] : src = "" + src);
      var items = src[_DYN_SPLIT](`
`);
      return {
        src: src,
        obj: items
      };
    }
    __name(_convertStackObj, "_convertStackObj");
    function _getOperaStack(errorMessage) {
      for (var stack = [], lines = errorMessage[_DYN_SPLIT](`
`), lp = 0; lp < lines[_DYN_LENGTH]; lp++) {
        var entry = lines[lp];
        lines[lp + 1] && (entry += "@" + lines[lp + 1], lp++), stack.push(entry);
      }
      return {
        src: errorMessage,
        obj: stack
      };
    }
    __name(_getOperaStack, "_getOperaStack");
    function _getStackFromErrorObj(errorObj) {
      var details = null;
      if (errorObj) try {
        if (errorObj[strStack]) details = _convertStackObj(errorObj[strStack]);else if (errorObj[strError] && errorObj[strError][strStack]) details = _convertStackObj(errorObj[strError][strStack]);else if (errorObj.exception && errorObj.exception[strStack]) details = _convertStackObj(errorObj.exception[strStack]);else if (_isStackDetails(errorObj)) details = errorObj;else if (_isStackDetails(errorObj[strStackDetails])) details = errorObj[strStackDetails];else if (getWindow() && getWindow().opera && errorObj[strMessage]) details = _getOperaStack(errorObj[_DYN_MESSAGE]);else if (errorObj.reason && errorObj.reason[strStack]) details = _convertStackObj(errorObj.reason[strStack]);else if (isString(errorObj)) details = _convertStackObj(errorObj);else {
          var evtMessage = errorObj[strMessage] || errorObj[strDescription] || "";
          isString(errorObj[strErrorSrc]) && (evtMessage && (evtMessage += `
`), evtMessage += " from " + errorObj[strErrorSrc]), evtMessage && (details = _convertStackObj(evtMessage));
        }
      } catch (e) {
        details = _convertStackObj(e);
      }
      return details || {
        src: "",
        obj: null
      };
    }
    __name(_getStackFromErrorObj, "_getStackFromErrorObj");
    function _formatStackTrace(stackDetails) {
      var stack = "";
      return stackDetails && (stackDetails.obj ? stack = stackDetails.obj.join(`
`) : stack = stackDetails.src || ""), stack;
    }
    __name(_formatStackTrace, "_formatStackTrace");
    function _parseStack(stack) {
      var parsedStack,
        frames = stack.obj;
      if (frames && frames[_DYN_LENGTH] > 0) {
        parsedStack = [];
        var level_1 = 0,
          foundStackStart_1 = !1,
          totalSizeInBytes_1 = 0;
        arrForEach(frames, function (frame) {
          if (foundStackStart_1 || _isStackFrame(frame)) {
            var theFrame = asString(frame);
            foundStackStart_1 = !0;
            var parsedFrame = _extractStackFrame(theFrame, level_1);
            parsedFrame && (totalSizeInBytes_1 += parsedFrame[_DYN_SIZE_IN_BYTES], parsedStack.push(parsedFrame), level_1++);
          }
        });
        var exceptionParsedStackThreshold = 32 * 1024;
        if (totalSizeInBytes_1 > exceptionParsedStackThreshold) for (var left = 0, right = parsedStack[_DYN_LENGTH] - 1, size = 0, acceptedLeft = left, acceptedRight = right; left < right;) {
          var lSize = parsedStack[left][_DYN_SIZE_IN_BYTES],
            rSize = parsedStack[right][_DYN_SIZE_IN_BYTES];
          if (size += lSize + rSize, size > exceptionParsedStackThreshold) {
            var howMany = acceptedRight - acceptedLeft + 1;
            parsedStack.splice(acceptedLeft, howMany);
            break;
          }
          acceptedLeft = left, acceptedRight = right, left++, right--;
        }
      }
      return parsedStack;
    }
    __name(_parseStack, "_parseStack");
    function _getErrorType(errorType) {
      var typeName = "";
      if (errorType && (typeName = errorType.typeName || errorType[_DYN_NAME] || "", !typeName)) try {
        var funcNameRegex = /function (.{1,200})\(/,
          results = funcNameRegex.exec(errorType.constructor[_DYN_TO_STRING]());
        typeName = results && results[_DYN_LENGTH] > 1 ? results[1] : "";
      } catch {}
      return typeName;
    }
    __name(_getErrorType, "_getErrorType");
    function _formatErrorCode(errorObj) {
      if (errorObj) try {
        if (!isString(errorObj)) {
          var errorType = _getErrorType(errorObj),
            result = _stringify(errorObj, !1);
          return (!result || result === "{}") && (errorObj[strError] && (errorObj = errorObj[strError], errorType = _getErrorType(errorObj)), result = _stringify(errorObj, !0)), strIndexOf(result, errorType) !== 0 && errorType !== "String" ? errorType + ":" + result : result;
        }
      } catch {}
      return "" + (errorObj || "");
    }
    __name(_formatErrorCode, "_formatErrorCode");
    var Exception = function () {
        function Exception(logger, exception, properties, measurements, severityLevel, id) {
          this.aiDataContract = {
            ver: 1,
            exceptions: 1,
            severityLevel: 0,
            properties: 0,
            measurements: 0
          };
          var _self = this;
          _self.ver = 2, _isExceptionInternal(exception) ? (_self[_DYN_EXCEPTIONS] = exception[_DYN_EXCEPTIONS] || [], _self[_DYN_PROPERTIES] = exception[_DYN_PROPERTIES], _self[_DYN_MEASUREMENTS] = exception[_DYN_MEASUREMENTS], exception[_DYN_SEVERITY_LEVEL] && (_self[_DYN_SEVERITY_LEVEL] = exception[_DYN_SEVERITY_LEVEL]), exception.id && (_self.id = exception.id, exception[_DYN_PROPERTIES].id = exception.id), exception[_DYN_PROBLEM_GROUP] && (_self[_DYN_PROBLEM_GROUP] = exception[_DYN_PROBLEM_GROUP]), isNullOrUndefined(exception.isManual) || (_self.isManual = exception.isManual)) : (properties || (properties = {}), id && (properties.id = id), _self[_DYN_EXCEPTIONS] = [_createExceptionDetails(logger, exception, properties)], _self[_DYN_PROPERTIES] = dataSanitizeProperties(logger, properties), _self[_DYN_MEASUREMENTS] = dataSanitizeMeasurements(logger, measurements), severityLevel && (_self[_DYN_SEVERITY_LEVEL] = severityLevel), id && (_self.id = id));
        }
        return __name(Exception, "Exception"), Exception.CreateAutoException = function (message, url, lineNumber, columnNumber, error, evt, stack, errorSrc) {
          var errorType = _getErrorType(error || evt || message);
          return {
            message: _formatMessage(message, errorType),
            url: url,
            lineNumber: lineNumber,
            columnNumber: columnNumber,
            error: _formatErrorCode(error || evt || message),
            evt: _formatErrorCode(evt || message),
            typeName: errorType,
            stackDetails: _getStackFromErrorObj(stack || error || evt),
            errorSrc: errorSrc
          };
        }, Exception.CreateFromInterface = function (logger, exception, properties, measurements) {
          var exceptions = exception[_DYN_EXCEPTIONS] && arrMap(exception[_DYN_EXCEPTIONS], function (ex) {
              return _createExDetailsFromInterface(logger, ex);
            }),
            exceptionData = new Exception(logger, __assign(__assign({}, exception), {
              exceptions: exceptions
            }), properties, measurements);
          return exceptionData;
        }, Exception.prototype.toInterface = function () {
          var _a = this,
            exceptions = _a.exceptions,
            properties = _a.properties,
            measurements = _a.measurements,
            severityLevel = _a.severityLevel,
            problemGroup = _a.problemGroup,
            id = _a.id,
            isManual = _a.isManual,
            exceptionDetailsInterface = exceptions instanceof Array && arrMap(exceptions, function (exception) {
              return exception.toInterface();
            }) || void 0;
          return {
            ver: "4.0",
            exceptions: exceptionDetailsInterface,
            severityLevel: severityLevel,
            properties: properties,
            measurements: measurements,
            problemGroup: problemGroup,
            id: id,
            isManual: isManual
          };
        }, Exception.CreateSimpleException = function (message, typeName, assembly, fileName, details, line) {
          var _a;
          return {
            exceptions: [(_a = {}, _a[_DYN_HAS_FULL_STACK] = !0, _a.message = message, _a.stack = details, _a.typeName = typeName, _a)]
          };
        }, Exception.envelopeType = "Microsoft.ApplicationInsights.{0}.Exception", Exception.dataType = "ExceptionData", Exception.formatError = _formatErrorCode, Exception;
      }(),
      exDetailsAiDataContract = objFreeze({
        id: 0,
        outerId: 0,
        typeName: 1,
        message: 1,
        hasFullStack: 0,
        stack: 0,
        parsedStack: 2
      });
    function _toInterface() {
      var _self = this,
        parsedStack = isArray(_self[_DYN_PARSED_STACK]) && arrMap(_self[_DYN_PARSED_STACK], function (frame) {
          return _parsedFrameToInterface(frame);
        }),
        exceptionDetailsInterface = {
          id: _self.id,
          outerId: _self.outerId,
          typeName: _self[_DYN_TYPE_NAME],
          message: _self[_DYN_MESSAGE],
          hasFullStack: _self[_DYN_HAS_FULL_STACK],
          stack: _self[strStack],
          parsedStack: parsedStack || void 0
        };
      return exceptionDetailsInterface;
    }
    __name(_toInterface, "_toInterface");
    function _createExceptionDetails(logger, exception, properties) {
      var _a, id, outerId, typeName, message, hasFullStack, theStack, parsedStack;
      if (_isExceptionDetailsInternal(exception)) typeName = exception[_DYN_TYPE_NAME], message = exception[_DYN_MESSAGE], theStack = exception[strStack], parsedStack = exception[_DYN_PARSED_STACK] || [], hasFullStack = exception[_DYN_HAS_FULL_STACK];else {
        var error = exception,
          evt = error && error.evt;
        isError(error) || (error = error[strError] || evt || error), typeName = dataSanitizeString(logger, _getErrorType(error)) || strNotSpecified, message = dataSanitizeMessage(logger, _formatMessage(exception || error, typeName)) || strNotSpecified;
        var stack = exception[strStackDetails] || _getStackFromErrorObj(exception);
        parsedStack = _parseStack(stack), isArray(parsedStack) && arrMap(parsedStack, function (frame) {
          frame[_DYN_ASSEMBLY] = dataSanitizeString(logger, frame[_DYN_ASSEMBLY]), frame[_DYN_FILE_NAME] = dataSanitizeString(logger, frame[_DYN_FILE_NAME]);
        }), theStack = dataSanitizeException(logger, _formatStackTrace(stack)), hasFullStack = isArray(parsedStack) && parsedStack[_DYN_LENGTH] > 0, properties && (properties[_DYN_TYPE_NAME] = properties[_DYN_TYPE_NAME] || typeName);
      }
      return _a = {}, _a[_DYN_AI_DATA_CONTRACT] = exDetailsAiDataContract, _a.id = id, _a.outerId = outerId, _a.typeName = typeName, _a.message = message, _a[_DYN_HAS_FULL_STACK] = hasFullStack, _a.stack = theStack, _a.parsedStack = parsedStack, _a.toInterface = _toInterface, _a;
    }
    __name(_createExceptionDetails, "_createExceptionDetails");
    function _createExDetailsFromInterface(logger, exception) {
      var parsedStack = isArray(exception[_DYN_PARSED_STACK]) && arrMap(exception[_DYN_PARSED_STACK], function (frame) {
          return _stackFrameFromInterface(frame);
        }) || exception[_DYN_PARSED_STACK],
        exceptionDetails = _createExceptionDetails(logger, __assign(__assign({}, exception), {
          parsedStack: parsedStack
        }));
      return exceptionDetails;
    }
    __name(_createExDetailsFromInterface, "_createExDetailsFromInterface");
    function _parseFilename(theFrame, fileName) {
      var lineCol = fileName[_DYN_MATCH](PARSE_FILENAME_LINE_COL);
      if (lineCol && lineCol[_DYN_LENGTH] >= 4) theFrame[_DYN_FILE_NAME] = lineCol[1], theFrame[_DYN_LINE] = parseInt(lineCol[2]);else {
        var lineNo = fileName[_DYN_MATCH](PARSE_FILENAME_LINE_ONLY);
        lineNo && lineNo[_DYN_LENGTH] >= 3 ? (theFrame[_DYN_FILE_NAME] = lineNo[1], theFrame[_DYN_LINE] = parseInt(lineNo[2])) : theFrame[_DYN_FILE_NAME] = fileName;
      }
    }
    __name(_parseFilename, "_parseFilename");
    function _handleFilename(theFrame, sequence, matches) {
      var filename = theFrame[_DYN_FILE_NAME];
      sequence.fn && matches && matches[_DYN_LENGTH] > sequence.fn && (sequence.ln && matches[_DYN_LENGTH] > sequence.ln ? (filename = strTrim(matches[sequence.fn] || ""), theFrame[_DYN_LINE] = parseInt(strTrim(matches[sequence.ln] || "")) || 0) : filename = strTrim(matches[sequence.fn] || "")), filename && _parseFilename(theFrame, filename);
    }
    __name(_handleFilename, "_handleFilename");
    function _isStackFrame(frame) {
      var result = !1;
      if (frame && isString(frame)) {
        var trimmedFrame = strTrim(frame);
        trimmedFrame && (result = IS_FRAME.test(trimmedFrame));
      }
      return result;
    }
    __name(_isStackFrame, "_isStackFrame");
    var stackFrameAiDataContract = objFreeze({
      level: 1,
      method: 1,
      assembly: 0,
      fileName: 0,
      line: 0
    });
    function _extractStackFrame(frame, level) {
      var _a, theFrame;
      if (frame && isString(frame) && strTrim(frame)) {
        theFrame = (_a = {}, _a[_DYN_AI_DATA_CONTRACT] = stackFrameAiDataContract, _a.level = level, _a.assembly = strTrim(frame), _a.method = NoMethod, _a.fileName = "", _a.line = 0, _a.sizeInBytes = 0, _a);
        for (var idx = 0; idx < _parseSequence[_DYN_LENGTH];) {
          var sequence = _parseSequence[idx];
          if (sequence.chk && !sequence.chk(frame)) break;
          sequence.pre && (frame = sequence.pre(frame));
          var matches = frame[_DYN_MATCH](sequence.re);
          if (matches && matches[_DYN_LENGTH] >= sequence.len) {
            sequence.m && (theFrame.method = strTrim(matches[sequence.m] || NoMethod)), sequence.hdl ? sequence.hdl(theFrame, sequence, matches) : sequence.fn && (sequence.ln ? (theFrame[_DYN_FILE_NAME] = strTrim(matches[sequence.fn] || ""), theFrame[_DYN_LINE] = parseInt(strTrim(matches[sequence.ln] || "")) || 0) : _parseFilename(theFrame, matches[sequence.fn] || ""));
            break;
          }
          idx++;
        }
      }
      return _populateFrameSizeInBytes(theFrame);
    }
    __name(_extractStackFrame, "_extractStackFrame");
    function _stackFrameFromInterface(frame) {
      var _a,
        parsedFrame = (_a = {}, _a[_DYN_AI_DATA_CONTRACT] = stackFrameAiDataContract, _a.level = frame.level, _a.method = frame.method, _a.assembly = frame[_DYN_ASSEMBLY], _a.fileName = frame[_DYN_FILE_NAME], _a.line = frame[_DYN_LINE], _a.sizeInBytes = 0, _a);
      return _populateFrameSizeInBytes(parsedFrame);
    }
    __name(_stackFrameFromInterface, "_stackFrameFromInterface");
    function _populateFrameSizeInBytes(frame) {
      var sizeInBytes = STACKFRAME_BASE_SIZE;
      return frame && (sizeInBytes += frame.method[_DYN_LENGTH], sizeInBytes += frame.assembly[_DYN_LENGTH], sizeInBytes += frame.fileName[_DYN_LENGTH], sizeInBytes += frame.level.toString()[_DYN_LENGTH], sizeInBytes += frame.line.toString()[_DYN_LENGTH], frame[_DYN_SIZE_IN_BYTES] = sizeInBytes), frame;
    }
    __name(_populateFrameSizeInBytes, "_populateFrameSizeInBytes");
    function _parsedFrameToInterface(frame) {
      return {
        level: frame.level,
        method: frame.method,
        assembly: frame[_DYN_ASSEMBLY],
        fileName: frame[_DYN_FILE_NAME],
        line: frame[_DYN_LINE]
      };
    }
    __name(_parsedFrameToInterface, "_parsedFrameToInterface");
    var DataPoint = function () {
        function DataPoint() {
          this.aiDataContract = {
            name: 1,
            kind: 0,
            value: 1,
            count: 0,
            min: 0,
            max: 0,
            stdDev: 0
          }, this.kind = 0;
        }
        return __name(DataPoint, "DataPoint"), DataPoint;
      }(),
      Metric = function () {
        function Metric(logger, name, value, count, min, max, stdDev, properties, measurements) {
          this.aiDataContract = {
            ver: 1,
            metrics: 1,
            properties: 0
          };
          var _self = this;
          _self.ver = 2;
          var dataPoint = new DataPoint();
          dataPoint[_DYN_COUNT] = count > 0 ? count : void 0, dataPoint.max = isNaN(max) || max === null ? void 0 : max, dataPoint.min = isNaN(min) || min === null ? void 0 : min, dataPoint[_DYN_NAME] = dataSanitizeString(logger, name) || strNotSpecified, dataPoint.value = value, dataPoint.stdDev = isNaN(stdDev) || stdDev === null ? void 0 : stdDev, _self.metrics = [dataPoint], _self[_DYN_PROPERTIES] = dataSanitizeProperties(logger, properties), _self[_DYN_MEASUREMENTS] = dataSanitizeMeasurements(logger, measurements);
        }
        return __name(Metric, "Metric"), Metric.envelopeType = "Microsoft.ApplicationInsights.{0}.Metric", Metric.dataType = "MetricData", Metric;
      }(),
      strEmpty = "";
    function stringToBoolOrDefault(str, defaultValue) {
      return defaultValue === void 0 && (defaultValue = !1), str == null ? defaultValue : str.toString()[_DYN_TO_LOWER_CASE]() === "true";
    }
    __name(stringToBoolOrDefault, "stringToBoolOrDefault");
    function msToTimeSpan(totalms) {
      (isNaN(totalms) || totalms < 0) && (totalms = 0), totalms = mathRound(totalms);
      var ms = strEmpty + totalms % 1e3,
        sec = strEmpty + mathFloor(totalms / 1e3) % 60,
        min = strEmpty + mathFloor(totalms / (1e3 * 60)) % 60,
        hour = strEmpty + mathFloor(totalms / (1e3 * 60 * 60)) % 24,
        days = mathFloor(totalms / (1e3 * 60 * 60 * 24));
      return ms = ms[_DYN_LENGTH] === 1 ? "00" + ms : ms[_DYN_LENGTH] === 2 ? "0" + ms : ms, sec = sec[_DYN_LENGTH] < 2 ? "0" + sec : sec, min = min[_DYN_LENGTH] < 2 ? "0" + min : min, hour = hour[_DYN_LENGTH] < 2 ? "0" + hour : hour, (days > 0 ? days + "." : strEmpty) + hour + ":" + min + ":" + sec + "." + ms;
    }
    __name(msToTimeSpan, "msToTimeSpan");
    function getExtensionByName(extensions, identifier) {
      var extension = null;
      return arrForEach(extensions, function (value) {
        if (value.identifier === identifier) return extension = value, -1;
      }), extension;
    }
    __name(getExtensionByName, "getExtensionByName");
    function isCrossOriginError(message, url, lineNumber, columnNumber, error) {
      return !error && isString(message) && (message === "Script error." || message === "Script error");
    }
    __name(isCrossOriginError, "isCrossOriginError");
    var PageView = function () {
        function PageView(logger, name, url, durationMs, properties, measurements, id) {
          this.aiDataContract = {
            ver: 1,
            name: 0,
            url: 0,
            duration: 0,
            properties: 0,
            measurements: 0,
            id: 0
          };
          var _self = this;
          _self.ver = 2, _self.id = dataSanitizeId(logger, id), _self.url = dataSanitizeUrl(logger, url), _self[_DYN_NAME] = dataSanitizeString(logger, name) || strNotSpecified, isNaN(durationMs) || (_self[_DYN_DURATION] = msToTimeSpan(durationMs)), _self[_DYN_PROPERTIES] = dataSanitizeProperties(logger, properties), _self[_DYN_MEASUREMENTS] = dataSanitizeMeasurements(logger, measurements);
        }
        return __name(PageView, "PageView"), PageView.envelopeType = "Microsoft.ApplicationInsights.{0}.Pageview", PageView.dataType = "PageviewData", PageView;
      }(),
      RemoteDependencyData = function () {
        function RemoteDependencyData(logger, id, absoluteUrl, commandName, value, success, resultCode, method, requestAPI, correlationContext, properties, measurements) {
          requestAPI === void 0 && (requestAPI = "Ajax"), this.aiDataContract = {
            id: 1,
            ver: 1,
            name: 0,
            resultCode: 0,
            duration: 0,
            success: 0,
            data: 0,
            target: 0,
            type: 0,
            properties: 0,
            measurements: 0,
            kind: 0,
            value: 0,
            count: 0,
            min: 0,
            max: 0,
            stdDev: 0,
            dependencyKind: 0,
            dependencySource: 0,
            commandName: 0,
            dependencyTypeName: 0
          };
          var _self = this;
          _self.ver = 2, _self.id = id, _self[_DYN_DURATION] = msToTimeSpan(value), _self.success = success, _self.resultCode = resultCode + "", _self.type = dataSanitizeString(logger, requestAPI);
          var dependencyFields = AjaxHelperParseDependencyPath(logger, absoluteUrl, method, commandName);
          _self.data = dataSanitizeUrl(logger, commandName) || dependencyFields.data, _self.target = dataSanitizeString(logger, dependencyFields.target), correlationContext && (_self.target = "".concat(_self.target, " | ").concat(correlationContext)), _self[_DYN_NAME] = dataSanitizeString(logger, dependencyFields[_DYN_NAME]), _self[_DYN_PROPERTIES] = dataSanitizeProperties(logger, properties), _self[_DYN_MEASUREMENTS] = dataSanitizeMeasurements(logger, measurements);
        }
        return __name(RemoteDependencyData, "RemoteDependencyData"), RemoteDependencyData.envelopeType = "Microsoft.ApplicationInsights.{0}.RemoteDependency", RemoteDependencyData.dataType = "RemoteDependencyData", RemoteDependencyData;
      }(),
      Trace = function () {
        function Trace(logger, message, severityLevel, properties, measurements) {
          this.aiDataContract = {
            ver: 1,
            message: 1,
            severityLevel: 0,
            properties: 0
          };
          var _self = this;
          _self.ver = 2, message = message || strNotSpecified, _self[_DYN_MESSAGE] = dataSanitizeMessage(logger, message), _self[_DYN_PROPERTIES] = dataSanitizeProperties(logger, properties), _self[_DYN_MEASUREMENTS] = dataSanitizeMeasurements(logger, measurements), severityLevel && (_self[_DYN_SEVERITY_LEVEL] = severityLevel);
        }
        return __name(Trace, "Trace"), Trace.envelopeType = "Microsoft.ApplicationInsights.{0}.Message", Trace.dataType = "MessageData", Trace;
      }(),
      PageViewPerformance = function () {
        function PageViewPerformance(logger, name, url, unused, properties, measurements, cs4BaseData) {
          this.aiDataContract = {
            ver: 1,
            name: 0,
            url: 0,
            duration: 0,
            perfTotal: 0,
            networkConnect: 0,
            sentRequest: 0,
            receivedResponse: 0,
            domProcessing: 0,
            properties: 0,
            measurements: 0
          };
          var _self = this;
          _self.ver = 2, _self.url = dataSanitizeUrl(logger, url), _self[_DYN_NAME] = dataSanitizeString(logger, name) || strNotSpecified, _self[_DYN_PROPERTIES] = dataSanitizeProperties(logger, properties), _self[_DYN_MEASUREMENTS] = dataSanitizeMeasurements(logger, measurements), cs4BaseData && (_self.domProcessing = cs4BaseData.domProcessing, _self[_DYN_DURATION] = cs4BaseData[_DYN_DURATION], _self.networkConnect = cs4BaseData.networkConnect, _self.perfTotal = cs4BaseData.perfTotal, _self.receivedResponse = cs4BaseData.receivedResponse, _self.sentRequest = cs4BaseData.sentRequest);
        }
        return __name(PageViewPerformance, "PageViewPerformance"), PageViewPerformance.envelopeType = "Microsoft.ApplicationInsights.{0}.PageviewPerformance", PageViewPerformance.dataType = "PageviewPerformanceData", PageViewPerformance;
      }(),
      Data = function () {
        function Data(baseType, data) {
          this.aiDataContract = {
            baseType: 1,
            baseData: 1
          }, this.baseType = baseType, this.baseData = data;
        }
        return __name(Data, "Data"), Data;
      }(),
      SeverityLevel = createEnumStyle({
        Verbose: 0,
        Information: 1,
        Warning: 2,
        Error: 3,
        Critical: 4
      }),
      ConfigurationManager = function () {
        function ConfigurationManager() {}
        return __name(ConfigurationManager, "ConfigurationManager"), ConfigurationManager.getConfig = function (config, field, identifier, defaultValue) {
          defaultValue === void 0 && (defaultValue = !1);
          var configValue;
          return identifier && config[_DYN_EXTENSION_CONFIG] && config[_DYN_EXTENSION_CONFIG][identifier] && !isNullOrUndefined(config[_DYN_EXTENSION_CONFIG][identifier][field]) ? configValue = config[_DYN_EXTENSION_CONFIG][identifier][field] : configValue = config[field], isNullOrUndefined(configValue) ? defaultValue : configValue;
        }, ConfigurationManager;
      }();
    function _aiNameFunc(baseName) {
      var aiName = "ai." + baseName + ".";
      return function (name) {
        return aiName + name;
      };
    }
    __name(_aiNameFunc, "_aiNameFunc");
    var _aiApplication = _aiNameFunc("application"),
      _aiDevice = _aiNameFunc("device"),
      _aiLocation = _aiNameFunc("location"),
      _aiOperation = _aiNameFunc("operation"),
      _aiSession = _aiNameFunc("session"),
      _aiUser = _aiNameFunc("user"),
      _aiCloud = _aiNameFunc("cloud"),
      _aiInternal = _aiNameFunc("internal"),
      ContextTagKeys = function (_super) {
        __extends(ContextTagKeys, _super);
        function ContextTagKeys() {
          return _super.call(this) || this;
        }
        return __name(ContextTagKeys, "ContextTagKeys"), ContextTagKeys;
      }(createClassFromInterface({
        applicationVersion: _aiApplication("ver"),
        applicationBuild: _aiApplication("build"),
        applicationTypeId: _aiApplication("typeId"),
        applicationId: _aiApplication("applicationId"),
        applicationLayer: _aiApplication("layer"),
        deviceId: _aiDevice("id"),
        deviceIp: _aiDevice("ip"),
        deviceLanguage: _aiDevice("language"),
        deviceLocale: _aiDevice("locale"),
        deviceModel: _aiDevice("model"),
        deviceFriendlyName: _aiDevice("friendlyName"),
        deviceNetwork: _aiDevice("network"),
        deviceNetworkName: _aiDevice("networkName"),
        deviceOEMName: _aiDevice("oemName"),
        deviceOS: _aiDevice("os"),
        deviceOSVersion: _aiDevice("osVersion"),
        deviceRoleInstance: _aiDevice("roleInstance"),
        deviceRoleName: _aiDevice("roleName"),
        deviceScreenResolution: _aiDevice("screenResolution"),
        deviceType: _aiDevice("type"),
        deviceMachineName: _aiDevice("machineName"),
        deviceVMName: _aiDevice("vmName"),
        deviceBrowser: _aiDevice("browser"),
        deviceBrowserVersion: _aiDevice("browserVersion"),
        locationIp: _aiLocation("ip"),
        locationCountry: _aiLocation("country"),
        locationProvince: _aiLocation("province"),
        locationCity: _aiLocation("city"),
        operationId: _aiOperation("id"),
        operationName: _aiOperation("name"),
        operationParentId: _aiOperation("parentId"),
        operationRootId: _aiOperation("rootId"),
        operationSyntheticSource: _aiOperation("syntheticSource"),
        operationCorrelationVector: _aiOperation("correlationVector"),
        sessionId: _aiSession("id"),
        sessionIsFirst: _aiSession("isFirst"),
        sessionIsNew: _aiSession("isNew"),
        userAccountAcquisitionDate: _aiUser("accountAcquisitionDate"),
        userAccountId: _aiUser("accountId"),
        userAgent: _aiUser("userAgent"),
        userId: _aiUser("id"),
        userStoreRegion: _aiUser("storeRegion"),
        userAuthUserId: _aiUser("authUserId"),
        userAnonymousUserAcquisitionDate: _aiUser("anonUserAcquisitionDate"),
        userAuthenticatedUserAcquisitionDate: _aiUser("authUserAcquisitionDate"),
        cloudName: _aiCloud("name"),
        cloudRole: _aiCloud("role"),
        cloudRoleVer: _aiCloud("roleVer"),
        cloudRoleInstance: _aiCloud("roleInstance"),
        cloudEnvironment: _aiCloud("environment"),
        cloudLocation: _aiCloud("location"),
        cloudDeploymentUnit: _aiCloud("deploymentUnit"),
        internalNodeName: _aiInternal("nodeName"),
        internalSdkVersion: _aiInternal("sdkVersion"),
        internalAgentVersion: _aiInternal("agentVersion"),
        internalSnippet: _aiInternal("snippet"),
        internalSdkSrc: _aiInternal("sdkSrc")
      }));
    function createTelemetryItem(item, baseType, envelopeName, logger, customProperties, systemProperties) {
      envelopeName = dataSanitizeString(logger, envelopeName) || strNotSpecified, (isNullOrUndefined(item) || isNullOrUndefined(baseType) || isNullOrUndefined(envelopeName)) && throwError("Input doesn't contain all required fields");
      var iKey = "";
      item[strIkey] && (iKey = item[strIkey], delete item[strIkey]);
      var telemetryItem = {
        name: envelopeName,
        time: toISOString(new Date()),
        iKey: iKey,
        ext: systemProperties || {},
        tags: [],
        data: {},
        baseType: baseType,
        baseData: item
      };
      return isNullOrUndefined(customProperties) || objForEachKey(customProperties, function (prop, value) {
        telemetryItem.data[prop] = value;
      }), telemetryItem;
    }
    __name(createTelemetryItem, "createTelemetryItem");
    var TelemetryItemCreator = function () {
        function TelemetryItemCreator() {}
        return __name(TelemetryItemCreator, "TelemetryItemCreator"), TelemetryItemCreator.create = createTelemetryItem, TelemetryItemCreator;
      }(),
      Extensions = {
        UserExt: "user",
        DeviceExt: "device",
        TraceExt: "trace",
        WebExt: "web",
        AppExt: "app",
        OSExt: "os",
        SessionExt: "ses",
        SDKExt: "sdk"
      },
      CtxTagKeys = new ContextTagKeys();
    function createDomEvent(eventName) {
      var event = null;
      if (isFunction(Event)) event = new Event(eventName);else {
        var doc = getDocument();
        doc && doc.createEvent && (event = doc.createEvent("Event"), event.initEvent(eventName, !0, !0));
      }
      return event;
    }
    __name(createDomEvent, "createDomEvent");
    function _disableEvents(target, evtNamespace) {
      eventOff(target, null, null, evtNamespace);
    }
    __name(_disableEvents, "_disableEvents");
    function createOfflineListener(parentEvtNamespace) {
      var _document = getDocument(),
        _navigator = getNavigator(),
        _isListening = !1,
        listenerList = [],
        rState = 1;
      _navigator && !isNullOrUndefined(_navigator.onLine) && !_navigator.onLine && (rState = 2);
      var uState = 0,
        _currentState = calCurrentState(),
        _evtNamespace = mergeEvtNamespace(createUniqueNamespace("OfflineListener"), parentEvtNamespace);
      try {
        if (_enableEvents(getWindow()) && (_isListening = !0), _document) {
          var target = _document.body || _document;
          target.ononline && _enableEvents(target) && (_isListening = !0);
        }
      } catch {
        _isListening = !1;
      }
      function _enableEvents(target) {
        var enabled = !1;
        return target && (enabled = eventOn(target, "online", _setOnline, _evtNamespace), enabled && eventOn(target, "offline", _setOffline, _evtNamespace)), enabled;
      }
      __name(_enableEvents, "_enableEvents");
      function _isOnline() {
        return _currentState;
      }
      __name(_isOnline, "_isOnline");
      function calCurrentState() {
        return !(uState === 2 || rState === 2);
      }
      __name(calCurrentState, "calCurrentState");
      function listnerNoticeCheck() {
        var newState = calCurrentState();
        _currentState !== newState && (_currentState = newState, arrForEach(listenerList, function (callback) {
          var offlineState = {
            isOnline: _currentState,
            rState: rState,
            uState: uState
          };
          try {
            callback(offlineState);
          } catch {}
        }));
      }
      __name(listnerNoticeCheck, "listnerNoticeCheck");
      function setOnlineState(newState) {
        uState = newState, listnerNoticeCheck();
      }
      __name(setOnlineState, "setOnlineState");
      function _setOnline() {
        rState = 1, listnerNoticeCheck();
      }
      __name(_setOnline, "_setOnline");
      function _setOffline() {
        rState = 2, listnerNoticeCheck();
      }
      __name(_setOffline, "_setOffline");
      function _unload() {
        var win = getWindow();
        if (win && _isListening) {
          if (_disableEvents(win, _evtNamespace), _document) {
            var target = _document.body || _document;
            isUndefined(target.ononline) || _disableEvents(target, _evtNamespace);
          }
          _isListening = !1;
        }
      }
      __name(_unload, "_unload");
      function addListener(callback) {
        return listenerList.push(callback), {
          rm: __name(function () {
            var index = listenerList.indexOf(callback);
            if (index > -1) return listenerList.splice(index, 1);
          }, "rm")
        };
      }
      return __name(addListener, "addListener"), {
        isOnline: _isOnline,
        isListening: __name(function () {
          return _isListening;
        }, "isListening"),
        unload: _unload,
        addListener: addListener,
        setOnlineState: setOnlineState
      };
    }
    __name(createOfflineListener, "createOfflineListener");
    var PropertiesPluginIdentifier = "AppInsightsPropertiesPlugin",
      BreezeChannelIdentifier = "AppInsightsChannelPlugin",
      AnalyticsPluginIdentifier = "ApplicationInsightsAnalytics";
    e.AnalyticsPluginIdentifier = W0, e.BreezeChannelIdentifier = dD, e.ConfigurationManager = WO, e.ConnectionStringParser = UE, e.ContextTagKeys = _g, e.CtxTagKeys = KO, e.DEFAULT_BREEZE_ENDPOINT = O2, e.DEFAULT_BREEZE_PATH = NC, e.Data = HO, e.DisabledPropertyName = NE, e.DistributedTracingModes = DO, e.Envelope = OE, e.Event = RO, e.EventPersistence = zC, e.Exception = bm, e.Extensions = YO, e.HttpMethod = MF, e.Metric = UO, e.PageView = ZO, e.PageViewPerformance = HC, e.ProcessLegacy = RE, e.PropertiesPluginIdentifier = JO, e.RemoteDependencyData = G0, e.RequestHeaders = zF, e.SampleRate = PF, e.SeverityLevel = JE, e.TelemetryItemCreator = mD, e.ThrottleMgr = NO, e.Trace = AD, e.correlationIdCanIncludeCorrelationHeader = hg, e.correlationIdGetCorrelationContext = ZF, e.correlationIdGetCorrelationContextValue = HF, e.correlationIdGetPrefix = tD, e.correlationIdSetPrefix = eD, e.createDistributedTraceContextFromTrace = nD, e.createDomEvent = p5, e.createOfflineListener = d5, e.createTelemetryItem = uD, e.createTraceParent = w0, e.dataSanitizeException = J2, e.dataSanitizeId = T0, e.dataSanitizeInput = V2, e.dataSanitizeKey = K2, e.dataSanitizeKeyAndAddUniqueness = Y2, e.dataSanitizeMeasurements = hA, e.dataSanitizeMessage = $E, e.dataSanitizeProperties = Mp, e.dataSanitizeString = Rs, e.dataSanitizeUrl = fm, e.dateTimeUtilsDuration = QO, e.dateTimeUtilsNow = IO, e.dsPadNumber = $F, e.findAllScripts = $2, e.findW3cTraceParent = z2, e.formatTraceParent = nh, e.getExtensionByName = GO, e.isBeaconApiSupported = cg, e.isCrossOriginError = wg, e.isInternalApplicationInsightsEndpoint = GF, e.isSampledFlag = QE, e.isValidSpanId = _0, e.isValidTraceId = C0, e.isValidTraceParent = x0, e.msToTimeSpan = lD, e.parseConnectionString = jE, e.parseTraceParent = gA, e.strNotSpecified = dm, e.stringToBoolOrDefault = OO, e.urlGetAbsoluteUrl = BO, e.urlGetCompleteUrl = jF, e.urlGetPathName = vO, e.urlParseFullHost = zp, e.urlParseHost = UF, e.urlParseUrl = N0, e.utlCanUseLocalStorage = qE, e.utlCanUseSessionStorage = $p, e.utlDisableStorage = $C, e.utlEnableStorage = SO, e.utlGetLocalStorage = KF, e.utlGetSessionStorage = VF, e.utlGetSessionStorageKeys = $0, e.utlRemoveSessionStorage = XF, e.utlRemoveStorage = bA, e.utlSetLocalStorage = JF, e.utlSetSessionStorage = FO, e.utlSetStoragePrefix = qC;
  });
});,var WIe = j((rL, HIe) => {
  (function (e, t) {
    typeof rL == "object" && typeof HIe < "u" ? t(rL) : typeof define == "function" && define.amd ? define(["exports"], t) : (e = typeof globalThis < "u" ? globalThis : e || self, t((e.Microsoft = e.Microsoft || {}, e.Microsoft.ApplicationInsights = e.Microsoft.ApplicationInsights || {})));
  })(rL, function (e) {
    "use strict";

    function _pureAssign(func1, func2) {
      return func1 || func2;
    }
    __name(_pureAssign, "_pureAssign");
    function _pureRef(value, name) {
      return value[name];
    }
    __name(_pureRef, "_pureRef");
    var UNDEF_VALUE = void 0,
      NULL_VALUE = null,
      EMPTY = "",
      FUNCTION = "function",
      OBJECT = "object",
      PROTOTYPE = "prototype",
      __PROTO__ = "__proto__",
      UNDEFINED = "undefined",
      CONSTRUCTOR = "constructor",
      SYMBOL = "Symbol",
      POLYFILL_TAG = "_polyfill",
      LENGTH = "length",
      NAME = "name",
      CALL = "call",
      TO_STRING = "toString",
      ObjClass = _pureAssign(Object),
      ObjProto = _pureRef(ObjClass, PROTOTYPE),
      StrCls = _pureAssign(String),
      StrProto = _pureRef(StrCls, PROTOTYPE),
      MathCls = _pureAssign(Math),
      ArrCls = _pureAssign(Array),
      ArrProto = _pureRef(ArrCls, PROTOTYPE),
      ArrSlice = _pureRef(ArrProto, "slice");
    function safe(func, argArray) {
      try {
        return {
          v: func.apply(this, argArray)
        };
      } catch (e) {
        return {
          e: e
        };
      }
    }
    __name(safe, "safe");
    function safeGet(cb, defValue) {
      var result = safe(cb);
      return result.e ? defValue : result.v;
    }
    __name(safeGet, "safeGet");
    var _primitiveTypes;
    function _createIs(theType) {
      return function (value) {
        return typeof value === theType;
      };
    }
    __name(_createIs, "_createIs");
    function _createObjIs(theName) {
      var theType = "[object " + theName + "]";
      return function (value) {
        return !!(value && objToString(value) === theType);
      };
    }
    __name(_createObjIs, "_createObjIs");
    function objToString(value) {
      return ObjProto[TO_STRING].call(value);
    }
    __name(objToString, "objToString");
    function isUndefined(value) {
      return typeof value === UNDEFINED || value === UNDEFINED;
    }
    __name(isUndefined, "isUndefined");
    function isStrictUndefined(arg) {
      return !isDefined(arg);
    }
    __name(isStrictUndefined, "isStrictUndefined");
    function isNullOrUndefined(value) {
      return value === NULL_VALUE || isUndefined(value);
    }
    __name(isNullOrUndefined, "isNullOrUndefined");
    function isStrictNullOrUndefined(value) {
      return value === NULL_VALUE || !isDefined(value);
    }
    __name(isStrictNullOrUndefined, "isStrictNullOrUndefined");
    function isDefined(arg) {
      return !!arg || arg !== UNDEF_VALUE;
    }
    __name(isDefined, "isDefined");
    function isPrimitiveType(theType) {
      return !_primitiveTypes && (_primitiveTypes = ["string", "number", "boolean", UNDEFINED, "symbol", "bigint"]), theType !== OBJECT && _primitiveTypes.indexOf(theType) !== -1;
    }
    __name(isPrimitiveType, "isPrimitiveType");
    var isString = _createIs("string"),
      isFunction = _createIs(FUNCTION);
    function isObject(value) {
      return !value && isNullOrUndefined(value) ? !1 : !!value && typeof value === OBJECT;
    }
    __name(isObject, "isObject");
    var isArray = _pureRef(ArrCls, "isArray"),
      isDate = _createObjIs("Date"),
      isNumber = _createIs("number"),
      isBoolean = _createIs("boolean"),
      isError = _createObjIs("Error");
    function isPromiseLike(value) {
      return !!(value && value.then && isFunction(value.then));
    }
    __name(isPromiseLike, "isPromiseLike");
    function isTruthy(value) {
      return !(!value || safeGet(function () {
        return !(value && 0 + value);
      }, !value));
    }
    __name(isTruthy, "isTruthy");
    var objGetOwnPropertyDescriptor = _pureRef(ObjClass, "getOwnPropertyDescriptor");
    function objHasOwnProperty(obj, prop) {
      return !!obj && ObjProto.hasOwnProperty[CALL](obj, prop);
    }
    __name(objHasOwnProperty, "objHasOwnProperty");
    var objHasOwn = _pureAssign(_pureRef(ObjClass, "hasOwn"), polyObjHasOwn);
    function polyObjHasOwn(obj, prop) {
      return objHasOwnProperty(obj, prop) || !!objGetOwnPropertyDescriptor(obj, prop);
    }
    __name(polyObjHasOwn, "polyObjHasOwn");
    function objForEachKey(theObject, callbackfn, thisArg) {
      if (theObject && isObject(theObject)) {
        for (var prop in theObject) if (objHasOwn(theObject, prop) && callbackfn[CALL](thisArg || theObject, prop, theObject[prop]) === -1) break;
      }
    }
    __name(objForEachKey, "objForEachKey");
    var propMap = {
      e: "enumerable",
      c: "configurable",
      v: "value",
      w: "writable",
      g: "get",
      s: "set"
    };
    function _createProp(value) {
      var prop = {};
      if (prop[propMap.c] = !0, prop[propMap.e] = !0, value.l) {
        prop.get = function () {
          return value.l.v;
        };
        var desc = objGetOwnPropertyDescriptor(value.l, "v");
        desc && desc.set && (prop.set = function (newValue) {
          value.l.v = newValue;
        });
      }
      return objForEachKey(value, function (key, value) {
        prop[propMap[key]] = isStrictUndefined(value) ? prop[propMap[key]] : value;
      }), prop;
    }
    __name(_createProp, "_createProp");
    var objDefineProp = _pureRef(ObjClass, "defineProperty");
    function objDefine(target, key, propDesc) {
      return objDefineProp(target, key, _createProp(propDesc));
    }
    __name(objDefine, "objDefine");
    function _createKeyValueMap(values, keyType, valueType, completeFn, writable) {
      var theMap = {};
      return objForEachKey(values, function (key, value) {
        _assignMapValue(theMap, key, keyType ? value : key), _assignMapValue(theMap, value, valueType ? value : key);
      }), completeFn ? completeFn(theMap) : theMap;
    }
    __name(_createKeyValueMap, "_createKeyValueMap");
    function _assignMapValue(theMap, key, value, writable) {
      objDefineProp(theMap, key, {
        value: value,
        enumerable: !0,
        writable: !1
      });
    }
    __name(_assignMapValue, "_assignMapValue");
    var asString = _pureAssign(StrCls),
      ERROR_TYPE = "[object Error]";
    function dumpObj(object, format) {
      var propertyValueDump = EMPTY,
        objType = ObjProto[TO_STRING][CALL](object);
      objType === ERROR_TYPE && (object = {
        stack: asString(object.stack),
        message: asString(object.message),
        name: asString(object.name)
      });
      try {
        propertyValueDump = JSON.stringify(object, NULL_VALUE, format ? typeof format == "number" ? format : 4 : UNDEF_VALUE), propertyValueDump = (propertyValueDump ? propertyValueDump.replace(/"(\w+)"\s*:\s{0,1}/g, "$1: ") : NULL_VALUE) || asString(object);
      } catch (e) {
        propertyValueDump = " - " + dumpObj(e, format);
      }
      return objType + ": " + propertyValueDump;
    }
    __name(dumpObj, "dumpObj");
    function throwError(message) {
      throw new Error(message);
    }
    __name(throwError, "throwError");
    function throwTypeError(message) {
      throw new TypeError(message);
    }
    __name(throwTypeError, "throwTypeError");
    var _objFreeze = _pureRef(ObjClass, "freeze");
    function _doNothing(value) {
      return value;
    }
    __name(_doNothing, "_doNothing");
    function _getProto(value) {
      return value[__PROTO__] || NULL_VALUE;
    }
    __name(_getProto, "_getProto");
    var objAssign = _pureRef(ObjClass, "assign"),
      objKeys = _pureRef(ObjClass, "keys");
    function objDeepFreeze(value) {
      return _objFreeze && objForEachKey(value, function (key, value) {
        (isArray(value) || isObject(value)) && objDeepFreeze(value);
      }), objFreeze(value);
    }
    __name(objDeepFreeze, "objDeepFreeze");
    var objFreeze = _pureAssign(_objFreeze, _doNothing),
      objGetPrototypeOf = _pureAssign(_pureRef(ObjClass, "getPrototypeOf"), _getProto);
    function createEnum(values) {
      return _createKeyValueMap(values, 1, 0, objFreeze);
    }
    __name(createEnum, "createEnum");
    function createEnumKeyMap(values) {
      return _createKeyValueMap(values, 0, 0, objFreeze);
    }
    __name(createEnumKeyMap, "createEnumKeyMap");
    function createSimpleMap(values) {
      var mapClass = {};
      return objForEachKey(values, function (key, value) {
        _assignMapValue(mapClass, key, value[1]), _assignMapValue(mapClass, value[0], value[1]);
      }), objFreeze(mapClass);
    }
    __name(createSimpleMap, "createSimpleMap");
    function createTypeMap(values) {
      return createSimpleMap(values);
    }
    __name(createTypeMap, "createTypeMap");
    var _wellKnownSymbolMap = createEnumKeyMap({
        asyncIterator: 0,
        hasInstance: 1,
        isConcatSpreadable: 2,
        iterator: 3,
        match: 4,
        matchAll: 5,
        replace: 6,
        search: 7,
        species: 8,
        split: 9,
        toPrimitive: 10,
        toStringTag: 11,
        unscopables: 12
      }),
      GLOBAL_CONFIG_KEY = "__tsUtils$gblCfg",
      _globalCfg;
    function _getGlobalValue() {
      var result;
      return typeof globalThis !== UNDEFINED && (result = globalThis), !result && typeof self !== UNDEFINED && (result = self), !result && typeof window !== UNDEFINED && (result = window), !result && typeof global !== UNDEFINED && (result = global), result;
    }
    __name(_getGlobalValue, "_getGlobalValue");
    function _getGlobalConfig() {
      if (!_globalCfg) {
        var gbl = safe(_getGlobalValue).v || {};
        _globalCfg = gbl[GLOBAL_CONFIG_KEY] = gbl[GLOBAL_CONFIG_KEY] || {};
      }
      return _globalCfg;
    }
    __name(_getGlobalConfig, "_getGlobalConfig");
    var _unwrapFunction = _unwrapFunctionWithPoly;
    function _unwrapFunctionWithPoly(funcName, clsProto, polyFunc) {
      var clsFn = clsProto ? clsProto[funcName] : NULL_VALUE;
      return function (thisArg) {
        var theFunc = (thisArg ? thisArg[funcName] : NULL_VALUE) || clsFn;
        if (theFunc || polyFunc) {
          var theArgs = arguments;
          return (theFunc || polyFunc).apply(thisArg, theFunc ? ArrSlice[CALL](theArgs, 1) : theArgs);
        }
        throwTypeError('"' + asString(funcName) + '" not defined for ' + dumpObj(thisArg));
      };
    }
    __name(_unwrapFunctionWithPoly, "_unwrapFunctionWithPoly");
    function _unwrapProp(propName) {
      return function (thisArg) {
        return thisArg[propName];
      };
    }
    __name(_unwrapProp, "_unwrapProp");
    var mathMin = _pureRef(MathCls, "min"),
      mathMax = _pureRef(MathCls, "max"),
      strSlice = _unwrapFunction("slice", StrProto),
      strSubstring = _unwrapFunction("substring", StrProto),
      strSubstr = _unwrapFunctionWithPoly("substr", StrProto, polyStrSubstr);
    function polyStrSubstr(value, start, length) {
      return isNullOrUndefined(value) && throwTypeError("Invalid " + dumpObj(value)), length < 0 ? EMPTY : (start = start || 0, start < 0 && (start = mathMax(start + value[LENGTH], 0)), isUndefined(length) ? strSlice(value, start) : strSlice(value, start, start + length));
    }
    __name(polyStrSubstr, "polyStrSubstr");
    function strLeft(value, count) {
      return strSubstring(value, 0, count);
    }
    __name(strLeft, "strLeft");
    var UNIQUE_REGISTRY_ID = "_urid",
      _polySymbols;
    function _globalSymbolRegistry() {
      if (!_polySymbols) {
        var gblCfg = _getGlobalConfig();
        _polySymbols = gblCfg.gblSym = gblCfg.gblSym || {
          k: {},
          s: {}
        };
      }
      return _polySymbols;
    }
    __name(_globalSymbolRegistry, "_globalSymbolRegistry");
    var _wellKnownSymbolCache;
    function polyNewSymbol(description) {
      var theSymbol = {
        description: asString(description),
        toString: __name(function () {
          return SYMBOL + "(" + description + ")";
        }, "toString")
      };
      return theSymbol[POLYFILL_TAG] = !0, theSymbol;
    }
    __name(polyNewSymbol, "polyNewSymbol");
    function polySymbolFor(key) {
      var registry = _globalSymbolRegistry();
      if (!objHasOwn(registry.k, key)) {
        var newSymbol_1 = polyNewSymbol(key),
          regId_1 = objKeys(registry.s).length;
        newSymbol_1[UNIQUE_REGISTRY_ID] = function () {
          return regId_1 + "_" + newSymbol_1[TO_STRING]();
        }, registry.k[key] = newSymbol_1, registry.s[newSymbol_1[UNIQUE_REGISTRY_ID]()] = asString(key);
      }
      return registry.k[key];
    }
    __name(polySymbolFor, "polySymbolFor");
    function polyGetKnownSymbol(name) {
      !_wellKnownSymbolCache && (_wellKnownSymbolCache = {});
      var result,
        knownName = _wellKnownSymbolMap[name];
      return knownName && (result = _wellKnownSymbolCache[knownName] = _wellKnownSymbolCache[knownName] || polyNewSymbol(SYMBOL + "." + knownName)), result;
    }
    __name(polyGetKnownSymbol, "polyGetKnownSymbol");
    var _globalLazyTestHooks;
    function _initTestHooks() {
      _globalLazyTestHooks = _getGlobalConfig();
    }
    __name(_initTestHooks, "_initTestHooks");
    function getLazy(cb) {
      var lazyValue = {};
      return !_globalLazyTestHooks && _initTestHooks(), lazyValue.b = _globalLazyTestHooks.lzy, objDefineProp(lazyValue, "v", {
        configurable: !0,
        get: __name(function () {
          var result = cb();
          return _globalLazyTestHooks.lzy || objDefineProp(lazyValue, "v", {
            value: result
          }), lazyValue.b = _globalLazyTestHooks.lzy, result;
        }, "get")
      }), lazyValue;
    }
    __name(getLazy, "getLazy");
    function createCachedValue(value) {
      return objDefineProp({
        toJSON: __name(function () {
          return value;
        }, "toJSON")
      }, "v", {
        value: value
      });
    }
    __name(createCachedValue, "createCachedValue");
    var WINDOW = "window",
      _cachedGlobal;
    function _getGlobalInstFn(getFn, theArgs) {
      var cachedValue;
      return function () {
        return !_globalLazyTestHooks && _initTestHooks(), (!cachedValue || _globalLazyTestHooks.lzy) && (cachedValue = createCachedValue(safe(getFn, theArgs).v)), cachedValue.v;
      };
    }
    __name(_getGlobalInstFn, "_getGlobalInstFn");
    function getGlobal(useCached) {
      return !_globalLazyTestHooks && _initTestHooks(), (!_cachedGlobal || useCached === !1 || _globalLazyTestHooks.lzy) && (_cachedGlobal = createCachedValue(safe(_getGlobalValue).v || NULL_VALUE)), _cachedGlobal.v;
    }
    __name(getGlobal, "getGlobal");
    function getInst(name, useCached) {
      var gbl;
      if (!_cachedGlobal || useCached === !1 ? gbl = getGlobal(useCached) : gbl = _cachedGlobal.v, gbl && gbl[name]) return gbl[name];
      if (name === WINDOW) try {
        return window;
      } catch {}
      return NULL_VALUE;
    }
    __name(getInst, "getInst");
    function hasDocument() {
      return !!getDocument();
    }
    __name(hasDocument, "hasDocument");
    var getDocument = _getGlobalInstFn(getInst, ["document"]);
    function hasWindow() {
      return !!getWindow();
    }
    __name(hasWindow, "hasWindow");
    var getWindow = _getGlobalInstFn(getInst, [WINDOW]);
    function hasNavigator() {
      return !!getNavigator();
    }
    __name(hasNavigator, "hasNavigator");
    var getNavigator = _getGlobalInstFn(getInst, ["navigator"]),
      isNode = _getGlobalInstFn(function () {
        return !!safe(function () {
          return process && (process.versions || {}).node;
        }).v;
      }),
      _symbol,
      _symbolFor;
    function _initSymbol() {
      return _symbol = createCachedValue(safe(getInst, [SYMBOL]).v), _symbol;
    }
    __name(_initSymbol, "_initSymbol");
    function _getSymbolKey(key) {
      var gblSym = (_globalLazyTestHooks.lzy ? 0 : _symbol) || _initSymbol();
      return gblSym.v ? gblSym.v[key] : UNDEF_VALUE;
    }
    __name(_getSymbolKey, "_getSymbolKey");
    function hasSymbol() {
      return !!getSymbol();
    }
    __name(hasSymbol, "hasSymbol");
    function getSymbol() {
      return !_globalLazyTestHooks && _initTestHooks(), ((_globalLazyTestHooks.lzy ? 0 : _symbol) || _initSymbol()).v;
    }
    __name(getSymbol, "getSymbol");
    function getKnownSymbol(name, noPoly) {
      var knownName = _wellKnownSymbolMap[name];
      !_globalLazyTestHooks && _initTestHooks();
      var sym = (_globalLazyTestHooks.lzy ? 0 : _symbol) || _initSymbol();
      return sym.v ? sym.v[knownName || name] : noPoly ? UNDEF_VALUE : polyGetKnownSymbol(name);
    }
    __name(getKnownSymbol, "getKnownSymbol");
    function newSymbol(description, noPoly) {
      !_globalLazyTestHooks && _initTestHooks();
      var sym = (_globalLazyTestHooks.lzy ? 0 : _symbol) || _initSymbol();
      return sym.v ? sym.v(description) : noPoly ? NULL_VALUE : polyNewSymbol(description);
    }
    __name(newSymbol, "newSymbol");
    function symbolFor(key) {
      return !_globalLazyTestHooks && _initTestHooks(), _symbolFor = (_globalLazyTestHooks.lzy ? 0 : _symbolFor) || createCachedValue(safe(_getSymbolKey, ["for"]).v), (_symbolFor.v || polySymbolFor)(key);
    }
    __name(symbolFor, "symbolFor");
    function isIterator(value) {
      return !!value && isFunction(value.next);
    }
    __name(isIterator, "isIterator");
    function isIterable(value) {
      return !isStrictNullOrUndefined(value) && isFunction(value[getKnownSymbol(3)]);
    }
    __name(isIterable, "isIterable");
    var _iterSymbol;
    function iterForOf(iter, callbackfn, thisArg) {
      if (iter && (isIterator(iter) || (!_iterSymbol && (_iterSymbol = createCachedValue(getKnownSymbol(3))), iter = iter[_iterSymbol.v] ? iter[_iterSymbol.v]() : NULL_VALUE), isIterator(iter))) {
        var err = UNDEF_VALUE,
          iterResult = UNDEF_VALUE;
        try {
          for (var count = 0; !(iterResult = iter.next()).done && callbackfn[CALL](thisArg || iter, iterResult.value, count, iter) !== -1;) count++;
        } catch (failed) {
          err = {
            e: failed
          }, iter.throw && (iterResult = NULL_VALUE, iter.throw(err));
        } finally {
          try {
            iterResult && !iterResult.done && iter.return && iter.return(iterResult);
          } finally {
            if (err) throw err.e;
          }
        }
      }
    }
    __name(iterForOf, "iterForOf");
    function fnApply(fn, thisArg, argArray) {
      return fn.apply(thisArg, argArray);
    }
    __name(fnApply, "fnApply");
    function arrAppend(target, elms) {
      return !isUndefined(elms) && target && (isArray(elms) ? fnApply(target.push, target, elms) : isIterator(elms) || isIterable(elms) ? iterForOf(elms, function (elm) {
        target.push(elm);
      }) : target.push(elms)), target;
    }
    __name(arrAppend, "arrAppend");
    function arrForEach(theArray, callbackfn, thisArg) {
      if (theArray) for (var len = theArray[LENGTH] >>> 0, idx = 0; idx < len && !(idx in theArray && callbackfn[CALL](thisArg || theArray, theArray[idx], idx, theArray) === -1); idx++);
    }
    __name(arrForEach, "arrForEach");
    var arrIndexOf = _unwrapFunction("indexOf", ArrProto),
      arrMap = _unwrapFunction("map", ArrProto);
    function arrSlice(theArray, start, end) {
      return ((theArray ? theArray.slice : NULL_VALUE) || ArrSlice).apply(theArray, ArrSlice[CALL](arguments, 1));
    }
    __name(arrSlice, "arrSlice");
    var arrReduce = _unwrapFunction("reduce", ArrProto),
      objCreate = _pureAssign(_pureRef(ObjClass, "create"), polyObjCreate);
    function polyObjCreate(obj) {
      if (!obj) return {};
      var type = typeof obj;
      type !== OBJECT && type !== FUNCTION && throwTypeError("Prototype must be an Object or function: " + dumpObj(obj));
      function tempFunc() {}
      return __name(tempFunc, "tempFunc"), tempFunc[PROTOTYPE] = obj, new tempFunc();
    }
    __name(polyObjCreate, "polyObjCreate");
    var _isProtoArray;
    function objSetPrototypeOf(obj, proto) {
      var fn = ObjClass.setPrototypeOf || function (d, b) {
        var N;
        !_isProtoArray && (_isProtoArray = createCachedValue((_a = {}, _a[__PROTO__] = [], _a instanceof Array))), _isProtoArray.v ? d[__PROTO__] = b : objForEachKey(b, function (key, value) {
          return d[key] = value;
        });
      };
      return fn(obj, proto);
    }
    __name(objSetPrototypeOf, "objSetPrototypeOf");
    function _createCustomError(name, d, b) {
      safe(objDefine, [d, NAME, {
        v: name,
        c: !0,
        e: !1
      }]), d = objSetPrototypeOf(d, b);
      function __() {
        this[CONSTRUCTOR] = d, safe(objDefine, [this, NAME, {
          v: name,
          c: !0,
          e: !1
        }]);
      }
      return __name(__, "__"), d[PROTOTYPE] = b === NULL_VALUE ? objCreate(b) : (__[PROTOTYPE] = b[PROTOTYPE], new __()), d;
    }
    __name(_createCustomError, "_createCustomError");
    function _setName(baseClass, name) {
      name && (baseClass[NAME] = name);
    }
    __name(_setName, "_setName");
    function createCustomError(name, constructCb, errorBase) {
      var theBaseClass = errorBase || Error,
        orgName = theBaseClass[PROTOTYPE][NAME],
        captureFn = Error.captureStackTrace;
      return _createCustomError(name, function () {
        var _this = this,
          theArgs = arguments;
        try {
          safe(_setName, [theBaseClass, name]);
          var _self = fnApply(theBaseClass, _this, ArrSlice[CALL](theArgs)) || _this;
          if (_self !== _this) {
            var orgProto = objGetPrototypeOf(_this);
            orgProto !== objGetPrototypeOf(_self) && objSetPrototypeOf(_self, orgProto);
          }
          return captureFn && captureFn(_self, _this[CONSTRUCTOR]), constructCb && constructCb(_self, theArgs), _self;
        } finally {
          safe(_setName, [theBaseClass, orgName]);
        }
      }, theBaseClass);
    }
    __name(createCustomError, "createCustomError");
    function utcNow() {
      return (Date.now || polyUtcNow)();
    }
    __name(utcNow, "utcNow");
    function polyUtcNow() {
      return new Date().getTime();
    }
    __name(polyUtcNow, "polyUtcNow");
    function _createTrimFn(exp) {
      return __name(function (value) {
        return isNullOrUndefined(value) && throwTypeError("strTrim called [" + dumpObj(value) + "]"), value && value.replace && (value = value.replace(exp, EMPTY)), value;
      }, "_doTrim");
    }
    __name(_createTrimFn, "_createTrimFn");
    var polyStrTrim = _createTrimFn(/^\s+|(?=\s)\s+$/g),
      strTrim = _unwrapFunctionWithPoly("trim", StrProto, polyStrTrim),
      mathFloor = _pureRef(MathCls, "floor"),
      _fnToString,
      _objCtrFnString,
      _gblWindow;
    function isPlainObject(value) {
      if (!value || typeof value !== OBJECT) return !1;
      _gblWindow || (_gblWindow = hasWindow() ? getWindow() : !0);
      var result = !1;
      if (value !== _gblWindow) {
        _objCtrFnString || (_fnToString = Function[PROTOTYPE][TO_STRING], _objCtrFnString = _fnToString[CALL](ObjClass));
        try {
          var proto = objGetPrototypeOf(value);
          result = !proto, result || (objHasOwnProperty(proto, CONSTRUCTOR) && (proto = proto[CONSTRUCTOR]), result = !!(proto && typeof proto === FUNCTION && _fnToString[CALL](proto) === _objCtrFnString));
        } catch {}
      }
      return result;
    }
    __name(isPlainObject, "isPlainObject");
    function _defaultDeepCopyHandler(details) {
      return details.value && plainObjDeepCopyHandler(details), !0;
    }
    __name(_defaultDeepCopyHandler, "_defaultDeepCopyHandler");
    var defaultDeepCopyHandlers = [arrayDeepCopyHandler, plainObjDeepCopyHandler, functionDeepCopyHandler, dateDeepCopyHandler];
    function _getSetVisited(visitMap, source, newPath, cb) {
      var theEntry;
      return arrForEach(visitMap, function (entry) {
        if (entry.k === source) return theEntry = entry, -1;
      }), theEntry || (theEntry = {
        k: source,
        v: source
      }, visitMap.push(theEntry), cb(theEntry)), theEntry.v;
    }
    __name(_getSetVisited, "_getSetVisited");
    function _deepCopy(visitMap, value, ctx, key) {
      var userHandler = ctx.handler,
        newPath = ctx.path ? key ? ctx.path.concat(key) : ctx.path : [],
        newCtx = {
          handler: ctx.handler,
          src: ctx.src,
          path: newPath
        },
        theType = typeof value,
        isPlain = !1,
        isPrim = value === NULL_VALUE;
      isPrim || (value && theType === OBJECT ? isPlain = isPlainObject(value) : isPrim = isPrimitiveType(theType));
      var details = {
        type: theType,
        isPrim: isPrim,
        isPlain: isPlain,
        value: value,
        result: value,
        path: newPath,
        origin: ctx.src,
        copy: __name(function (source, newKey) {
          return _deepCopy(visitMap, source, newKey ? newCtx : ctx, newKey);
        }, "copy"),
        copyTo: __name(function (target, source) {
          return _copyProps(visitMap, target, source, newCtx);
        }, "copyTo")
      };
      return details.isPrim ? userHandler && userHandler[CALL](ctx, details) ? details.result : value : _getSetVisited(visitMap, value, newPath, function (newEntry) {
        objDefine(details, "result", {
          g: __name(function () {
            return newEntry.v;
          }, "g"),
          s: __name(function (newValue) {
            newEntry.v = newValue;
          }, "s")
        });
        for (var idx = 0, handler = userHandler; !(handler || (idx < defaultDeepCopyHandlers.length ? defaultDeepCopyHandlers[idx++] : _defaultDeepCopyHandler))[CALL](ctx, details);) handler = NULL_VALUE;
      });
    }
    __name(_deepCopy, "_deepCopy");
    function _copyProps(visitMap, target, source, ctx) {
      if (!isNullOrUndefined(source)) for (var key in source) target[key] = _deepCopy(visitMap, source[key], ctx, key);
      return target;
    }
    __name(_copyProps, "_copyProps");
    function objCopyProps(target, source, handler) {
      var ctx = {
        handler: handler,
        src: source,
        path: []
      };
      return _copyProps([], target, source, ctx);
    }
    __name(objCopyProps, "objCopyProps");
    function objDeepCopy(source, handler) {
      var ctx = {
        handler: handler,
        src: source
      };
      return _deepCopy([], source, ctx);
    }
    __name(objDeepCopy, "objDeepCopy");
    function arrayDeepCopyHandler(details) {
      var value = details.value;
      if (isArray(value)) {
        var target = details.result = [];
        return target.length = value.length, details.copyTo(target, value), !0;
      }
      return !1;
    }
    __name(arrayDeepCopyHandler, "arrayDeepCopyHandler");
    function dateDeepCopyHandler(details) {
      var value = details.value;
      return isDate(value) ? (details.result = new Date(value.getTime()), !0) : !1;
    }
    __name(dateDeepCopyHandler, "dateDeepCopyHandler");
    function functionDeepCopyHandler(details) {
      return details.type === FUNCTION;
    }
    __name(functionDeepCopyHandler, "functionDeepCopyHandler");
    function plainObjDeepCopyHandler(details) {
      var value = details.value;
      if (value && details.isPlain) {
        var target = details.result = {};
        return details.copyTo(target, value), !0;
      }
      return !1;
    }
    __name(plainObjDeepCopyHandler, "plainObjDeepCopyHandler");
    function _doExtend(target, theArgs) {
      return arrForEach(theArgs, function (theArg) {
        objCopyProps(target, theArg);
      }), target;
    }
    __name(_doExtend, "_doExtend");
    function deepExtend(target, obj1, obj2, obj3, obj4, obj5, obj6) {
      return _doExtend(objDeepCopy(target) || {}, ArrSlice[CALL](arguments));
    }
    __name(deepExtend, "deepExtend");
    var getLength = _unwrapProp(LENGTH),
      mathRound = _pureRef(MathCls, "round"),
      strEndsWith = _unwrapFunctionWithPoly("endsWith", StrProto, polyStrEndsWith);
    function polyStrEndsWith(value, searchString, length) {
      isString(value) || throwTypeError("'" + dumpObj(value) + "' is not a string");
      var searchValue = isString(searchString) ? searchString : asString(searchString),
        end = !isUndefined(length) && length < value[LENGTH] ? length : value[LENGTH];
      return strSubstring(value, end - searchValue[LENGTH], end) === searchValue;
    }
    __name(polyStrEndsWith, "polyStrEndsWith");
    var strIndexOf = _unwrapFunction("indexOf", StrProto),
      REF = "ref",
      UNREF = "unref",
      HAS_REF = "hasRef",
      ENABLED = "enabled";
    function _createTimerHandler(startTimer, refreshFn, cancelFn) {
      var ref = !0,
        timerId = startTimer ? refreshFn(NULL_VALUE) : NULL_VALUE,
        theTimerHandler;
      function _unref() {
        return ref = !1, timerId && timerId[UNREF] && timerId[UNREF](), theTimerHandler;
      }
      __name(_unref, "_unref");
      function _cancel() {
        timerId && cancelFn(timerId), timerId = NULL_VALUE;
      }
      __name(_cancel, "_cancel");
      function _refresh() {
        return timerId = refreshFn(timerId), ref || _unref(), theTimerHandler;
      }
      __name(_refresh, "_refresh");
      function _setEnabled(value) {
        !value && timerId && _cancel(), value && !timerId && _refresh();
      }
      return __name(_setEnabled, "_setEnabled"), theTimerHandler = {
        cancel: _cancel,
        refresh: _refresh
      }, theTimerHandler[HAS_REF] = function () {
        return timerId && timerId[HAS_REF] ? timerId[HAS_REF]() : ref;
      }, theTimerHandler[REF] = function () {
        return ref = !0, timerId && timerId[REF] && timerId[REF](), theTimerHandler;
      }, theTimerHandler[UNREF] = _unref, theTimerHandler = objDefineProp(theTimerHandler, ENABLED, {
        get: __name(function () {
          return !!timerId;
        }, "get"),
        set: _setEnabled
      }), {
        h: theTimerHandler,
        dn: __name(function () {
          timerId = NULL_VALUE;
        }, "dn")
      };
    }
    __name(_createTimerHandler, "_createTimerHandler");
    function _createTimeoutWith(startTimer, overrideFn, theArgs) {
      var isArr = isArray(overrideFn),
        len = isArr ? overrideFn.length : 0,
        setFn = (len > 0 ? overrideFn[0] : isArr ? UNDEF_VALUE : overrideFn) || setTimeout,
        clearFn = (len > 1 ? overrideFn[1] : UNDEF_VALUE) || clearTimeout,
        timerFn = theArgs[0];
      theArgs[0] = function () {
        handler.dn(), fnApply(timerFn, UNDEF_VALUE, ArrSlice[CALL](arguments));
      };
      var handler = _createTimerHandler(startTimer, function (timerId) {
        if (timerId) {
          if (timerId.refresh) return timerId.refresh(), timerId;
          fnApply(clearFn, UNDEF_VALUE, [timerId]);
        }
        return fnApply(setFn, UNDEF_VALUE, theArgs);
      }, function (timerId) {
        fnApply(clearFn, UNDEF_VALUE, [timerId]);
      });
      return handler.h;
    }
    __name(_createTimeoutWith, "_createTimeoutWith");
    function scheduleTimeout(callback, timeout) {
      return _createTimeoutWith(!0, UNDEF_VALUE, ArrSlice[CALL](arguments));
    }
    __name(scheduleTimeout, "scheduleTimeout");
    function createTimeout(callback, timeout) {
      return _createTimeoutWith(!1, UNDEF_VALUE, ArrSlice[CALL](arguments));
    }
    __name(createTimeout, "createTimeout");
    var Gf,
      Constructor = "constructor",
      Prototype = "prototype",
      strFunction = "function",
      DynInstFuncTable = "_dynInstFuncs",
      DynProxyTag = "_isDynProxy",
      DynClassName = "_dynClass",
      DynClassNamePrefix = "_dynCls$",
      DynInstChkTag = "_dynInstChk",
      DynAllowInstChkTag = DynInstChkTag,
      DynProtoDefaultOptions = "_dfOpts",
      UnknownValue = "_unknown_",
      str__Proto = "__proto__",
      DynProtoBaseProto = "_dyn" + str__Proto,
      DynProtoGlobalSettings = "__dynProto$Gbl",
      DynProtoCurrent = "_dynInstProto",
      strUseBaseInst = "useBaseInst",
      strSetInstFuncs = "setInstFuncs",
      Obj = Object,
      _objGetPrototypeOf = Obj.getPrototypeOf,
      _objGetOwnProps = Obj.getOwnPropertyNames,
      _gbl = getGlobal(),
      _gblInst = _gbl[DynProtoGlobalSettings] || (_gbl[DynProtoGlobalSettings] = {
        o: (_a = {}, _a[strSetInstFuncs] = !0, _a[strUseBaseInst] = !0, _a),
        n: 1e3
      });
    function _isObjectOrArrayPrototype(target) {
      return target && (target === Obj[Prototype] || target === Array[Prototype]);
    }
    __name(_isObjectOrArrayPrototype, "_isObjectOrArrayPrototype");
    function _isObjectArrayOrFunctionPrototype(target) {
      return _isObjectOrArrayPrototype(target) || target === Function[Prototype];
    }
    __name(_isObjectArrayOrFunctionPrototype, "_isObjectArrayOrFunctionPrototype");
    function _getObjProto(target) {
      var newProto;
      if (target) {
        if (_objGetPrototypeOf) return _objGetPrototypeOf(target);
        var curProto = target[str__Proto] || target[Prototype] || (target[Constructor] ? target[Constructor][Prototype] : null);
        newProto = target[DynProtoBaseProto] || curProto, objHasOwnProperty(target, DynProtoBaseProto) || (delete target[DynProtoCurrent], newProto = target[DynProtoBaseProto] = target[DynProtoCurrent] || target[DynProtoBaseProto], target[DynProtoCurrent] = curProto);
      }
      return newProto;
    }
    __name(_getObjProto, "_getObjProto");
    function _forEachProp(target, func) {
      var props = [];
      if (_objGetOwnProps) props = _objGetOwnProps(target);else for (var name_1 in target) typeof name_1 == "string" && objHasOwnProperty(target, name_1) && props.push(name_1);
      if (props && props.length > 0) for (var lp = 0; lp < props.length; lp++) func(props[lp]);
    }
    __name(_forEachProp, "_forEachProp");
    function _isDynamicCandidate(target, funcName, skipOwn) {
      return funcName !== Constructor && typeof target[funcName] === strFunction && (skipOwn || objHasOwnProperty(target, funcName)) && funcName !== str__Proto && funcName !== Prototype;
    }
    __name(_isDynamicCandidate, "_isDynamicCandidate");
    function _throwTypeError(message) {
      throwTypeError("DynamicProto: " + message);
    }
    __name(_throwTypeError, "_throwTypeError");
    function _getInstanceFuncs(thisTarget) {
      var instFuncs = objCreate(null);
      return _forEachProp(thisTarget, function (name) {
        !instFuncs[name] && _isDynamicCandidate(thisTarget, name, !1) && (instFuncs[name] = thisTarget[name]);
      }), instFuncs;
    }
    __name(_getInstanceFuncs, "_getInstanceFuncs");
    function _hasVisited(values, value) {
      for (var lp = values.length - 1; lp >= 0; lp--) if (values[lp] === value) return !0;
      return !1;
    }
    __name(_hasVisited, "_hasVisited");
    function _getBaseFuncs(classProto, thisTarget, instFuncs, useBaseInst) {
      function _instFuncProxy(target, funcHost, funcName) {
        var theFunc = funcHost[funcName];
        if (theFunc[DynProxyTag] && useBaseInst) {
          var instFuncTable = target[DynInstFuncTable] || {};
          instFuncTable[DynAllowInstChkTag] !== !1 && (theFunc = (instFuncTable[funcHost[DynClassName]] || {})[funcName] || theFunc);
        }
        return function () {
          return theFunc.apply(target, arguments);
        };
      }
      __name(_instFuncProxy, "_instFuncProxy");
      var baseFuncs = objCreate(null);
      _forEachProp(instFuncs, function (name) {
        baseFuncs[name] = _instFuncProxy(thisTarget, instFuncs, name);
      });
      for (var baseProto = _getObjProto(classProto), visited = []; baseProto && !_isObjectArrayOrFunctionPrototype(baseProto) && !_hasVisited(visited, baseProto);) _forEachProp(baseProto, function (name) {
        !baseFuncs[name] && _isDynamicCandidate(baseProto, name, !_objGetPrototypeOf) && (baseFuncs[name] = _instFuncProxy(thisTarget, baseProto, name));
      }), visited.push(baseProto), baseProto = _getObjProto(baseProto);
      return baseFuncs;
    }
    __name(_getBaseFuncs, "_getBaseFuncs");
    function _getInstFunc(target, funcName, proto, currentDynProtoProxy) {
      var instFunc = null;
      if (target && objHasOwnProperty(proto, DynClassName)) {
        var instFuncTable = target[DynInstFuncTable] || objCreate(null);
        if (instFunc = (instFuncTable[proto[DynClassName]] || objCreate(null))[funcName], instFunc || _throwTypeError("Missing [" + funcName + "] " + strFunction), !instFunc[DynInstChkTag] && instFuncTable[DynAllowInstChkTag] !== !1) {
          for (var canAddInst = !objHasOwnProperty(target, funcName), objProto = _getObjProto(target), visited = []; canAddInst && objProto && !_isObjectArrayOrFunctionPrototype(objProto) && !_hasVisited(visited, objProto);) {
            var protoFunc = objProto[funcName];
            if (protoFunc) {
              canAddInst = protoFunc === currentDynProtoProxy;
              break;
            }
            visited.push(objProto), objProto = _getObjProto(objProto);
          }
          try {
            canAddInst && (target[funcName] = instFunc), instFunc[DynInstChkTag] = 1;
          } catch {
            instFuncTable[DynAllowInstChkTag] = !1;
          }
        }
      }
      return instFunc;
    }
    __name(_getInstFunc, "_getInstFunc");
    function _getProtoFunc(funcName, proto, currentDynProtoProxy) {
      var protoFunc = proto[funcName];
      return protoFunc === currentDynProtoProxy && (protoFunc = _getObjProto(proto)[funcName]), typeof protoFunc !== strFunction && _throwTypeError("[" + funcName + "] is not a " + strFunction), protoFunc;
    }
    __name(_getProtoFunc, "_getProtoFunc");
    function _populatePrototype(proto, className, target, baseInstFuncs, setInstanceFunc) {
      function _createDynamicPrototype(proto, funcName) {
        var dynProtoProxy = __name(function () {
          var instFunc = _getInstFunc(this, funcName, proto, dynProtoProxy) || _getProtoFunc(funcName, proto, dynProtoProxy);
          return instFunc.apply(this, arguments);
        }, "dynProtoProxy");
        return dynProtoProxy[DynProxyTag] = 1, dynProtoProxy;
      }
      if (__name(_createDynamicPrototype, "_createDynamicPrototype"), !_isObjectOrArrayPrototype(proto)) {
        var instFuncTable = target[DynInstFuncTable] = target[DynInstFuncTable] || objCreate(null);
        if (!_isObjectOrArrayPrototype(instFuncTable)) {
          var instFuncs_1 = instFuncTable[className] = instFuncTable[className] || objCreate(null);
          instFuncTable[DynAllowInstChkTag] !== !1 && (instFuncTable[DynAllowInstChkTag] = !!setInstanceFunc), _isObjectOrArrayPrototype(instFuncs_1) || _forEachProp(target, function (name) {
            _isDynamicCandidate(target, name, !1) && target[name] !== baseInstFuncs[name] && (instFuncs_1[name] = target[name], delete target[name], (!objHasOwnProperty(proto, name) || proto[name] && !proto[name][DynProxyTag]) && (proto[name] = _createDynamicPrototype(proto, name)));
          });
        }
      }
    }
    __name(_populatePrototype, "_populatePrototype");
    function _checkPrototype(classProto, thisTarget) {
      if (_objGetPrototypeOf) {
        for (var visited = [], thisProto = _getObjProto(thisTarget); thisProto && !_isObjectArrayOrFunctionPrototype(thisProto) && !_hasVisited(visited, thisProto);) {
          if (thisProto === classProto) return !0;
          visited.push(thisProto), thisProto = _getObjProto(thisProto);
        }
        return !1;
      }
      return !0;
    }
    __name(_checkPrototype, "_checkPrototype");
    function _getObjName(target, unknownValue) {
      return objHasOwnProperty(target, Prototype) ? target.name || unknownValue || UnknownValue : ((target || {})[Constructor] || {}).name || unknownValue || UnknownValue;
    }
    __name(_getObjName, "_getObjName");
    function dynamicProto(theClass, target, delegateFunc, options) {
      objHasOwnProperty(theClass, Prototype) || _throwTypeError("theClass is an invalid class definition.");
      var classProto = theClass[Prototype];
      _checkPrototype(classProto, target) || _throwTypeError("[" + _getObjName(theClass) + "] not in hierarchy of [" + _getObjName(target) + "]");
      var className = null;
      objHasOwnProperty(classProto, DynClassName) ? className = classProto[DynClassName] : (className = DynClassNamePrefix + _getObjName(theClass, "_") + "$" + _gblInst.n, _gblInst.n++, classProto[DynClassName] = className);
      var perfOptions = dynamicProto[DynProtoDefaultOptions],
        useBaseInst = !!perfOptions[strUseBaseInst];
      useBaseInst && options && options[strUseBaseInst] !== void 0 && (useBaseInst = !!options[strUseBaseInst]);
      var instFuncs = _getInstanceFuncs(target),
        baseFuncs = _getBaseFuncs(classProto, target, instFuncs, useBaseInst);
      delegateFunc(target, baseFuncs);
      var setInstanceFunc = !!_objGetPrototypeOf && !!perfOptions[strSetInstFuncs];
      setInstanceFunc && options && (setInstanceFunc = !!options[strSetInstFuncs]), _populatePrototype(classProto, className, target, instFuncs, setInstanceFunc !== !1);
    }
    __name(dynamicProto, "dynamicProto"), dynamicProto[DynProtoDefaultOptions] = _gblInst.o;
    var strShimFunction = "function",
      strShimObject = "object",
      strShimUndefined = "undefined",
      strShimPrototype = "prototype",
      ObjClass = Object,
      ObjProto = ObjClass[strShimPrototype];
    (getGlobal() || {}).Symbol, (getGlobal() || {}).Reflect;
    var strHasOwnProperty = "hasOwnProperty",
      __objAssignFnImpl = __name(function (t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) ObjProto[strHasOwnProperty].call(s, p) && (t[p] = s[p]);
        }
        return t;
      }, "__objAssignFnImpl"),
      __assignFn = objAssign || __objAssignFnImpl,
      extendStaticsFn = __name(function (d, b) {
        return extendStaticsFn = ObjClass.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function (d, b) {
          d.__proto__ = b;
        } || function (d, b) {
          for (var p in b) b[strHasOwnProperty](p) && (d[p] = b[p]);
        }, extendStaticsFn(d, b);
      }, "extendStaticsFn");
    function __extendsFn(d, b) {
      typeof b !== strShimFunction && b !== null && throwTypeError("Class extends value " + String(b) + " is not a constructor or null"), extendStaticsFn(d, b);
      function __() {
        this.constructor = d;
      }
      __name(__, "__"), d[strShimPrototype] = b === null ? objCreate(b) : (__[strShimPrototype] = b[strShimPrototype], new __());
    }
    __name(__extendsFn, "__extendsFn");
    function __spreadArrayFn(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++) to[j] = from[i];
      return to;
    }
    __name(__spreadArrayFn, "__spreadArrayFn");
    var createEnumStyle = createEnum,
      createValueMap = createTypeMap,
      ActiveStatus = createEnumStyle({
        NONE: 0,
        PENDING: 3,
        INACTIVE: 1,
        ACTIVE: 2
      }),
      _DYN_TO_LOWER_CASE = "toLowerCase",
      _DYN_LENGTH = "length",
      _DYN_WARN_TO_CONSOLE = "warnToConsole",
      _DYN_THROW_INTERNAL = "throwInternal",
      _DYN_WATCH = "watch",
      _DYN_APPLY = "apply",
      _DYN_PUSH = "push",
      _DYN_SPLICE = "splice",
      _DYN_LOGGER = "logger",
      _DYN_CANCEL = "cancel",
      _DYN_INITIALIZE = "initialize",
      _DYN_IDENTIFIER = "identifier",
      _DYN_REMOVE_NOTIFICATION_0 = "removeNotificationListener",
      _DYN_ADD_NOTIFICATION_LIS1 = "addNotificationListener",
      _DYN_IS_INITIALIZED = "isInitialized",
      _DYN_VALUE = "value",
      _DYN_GET_NOTIFY_MGR = "getNotifyMgr",
      _DYN_GET_PLUGIN = "getPlugin",
      _DYN_NAME = "name",
      _DYN_PROCESS_NEXT = "processNext",
      _DYN_GET_PROCESS_TEL_CONT2 = "getProcessTelContext",
      _DYN_ENABLED = "enabled",
      _DYN_STOP_POLLING_INTERNA3 = "stopPollingInternalLogs",
      _DYN_UNLOAD = "unload",
      _DYN_ON_COMPLETE = "onComplete",
      _DYN_VERSION = "version",
      _DYN_LOGGING_LEVEL_CONSOL4 = "loggingLevelConsole",
      _DYN_CREATE_NEW = "createNew",
      _DYN_TEARDOWN = "teardown",
      _DYN_MESSAGE_ID = "messageId",
      _DYN_MESSAGE = "message",
      _DYN_DIAG_LOG = "diagLog",
      _DYN__DO_TEARDOWN = "_doTeardown",
      _DYN_UPDATE = "update",
      _DYN_GET_NEXT = "getNext",
      _DYN_SET_NEXT_PLUGIN = "setNextPlugin",
      _DYN_USER_AGENT = "userAgent",
      _DYN_SPLIT = "split",
      _DYN_REPLACE = "replace",
      _DYN_TYPE = "type",
      _DYN_EVT_NAME = "evtName",
      _DYN_STATUS = "status",
      _DYN_GET_ALL_RESPONSE_HEA5 = "getAllResponseHeaders",
      _DYN_IS_CHILD_EVT = "isChildEvt",
      _DYN_DATA = "data",
      _DYN_GET_CTX = "getCtx",
      _DYN_SET_CTX = "setCtx",
      _DYN_ITEMS_RECEIVED = "itemsReceived",
      _DYN_URL_STRING = "urlString",
      _DYN_HEADERS = "headers",
      _DYN_TIMEOUT = "timeout",
      _DYN_TRACE_FLAGS = "traceFlags",
      aggregationErrorType;
    function throwAggregationError(message, sourceErrors) {
      aggregationErrorType || (aggregationErrorType = createCustomError("AggregationError", function (self, args) {
        args[_DYN_LENGTH] > 1 && (self.errors = args[1]);
      }));
      var theMessage = message || "One or more errors occurred.";
      throw arrForEach(sourceErrors, function (srcError, idx) {
        theMessage += `
`.concat(idx, " > ").concat(dumpObj(srcError));
      }), new aggregationErrorType(theMessage, sourceErrors || []);
    }
    __name(throwAggregationError, "throwAggregationError");
    var STR_PROMISE = "Promise",
      REJECTED = "rejected";
    function doAwaitResponse(value, cb) {
      return doAwait(value, function (value) {
        return cb ? cb({
          status: "fulfilled",
          rejected: !1,
          value: value
        }) : value;
      }, function (reason) {
        return cb ? cb({
          status: REJECTED,
          rejected: !0,
          reason: reason
        }) : reason;
      });
    }
    __name(doAwaitResponse, "doAwaitResponse");
    function doAwait(value, resolveFn, rejectFn, finallyFn) {
      var result = value;
      try {
        if (isPromiseLike(value)) (resolveFn || rejectFn) && (result = value.then(resolveFn, rejectFn));else try {
          resolveFn && (result = resolveFn(value));
        } catch (err) {
          if (rejectFn) result = rejectFn(err);else throw err;
        }
      } finally {
        finallyFn && doFinally(result, finallyFn);
      }
      return result;
    }
    __name(doAwait, "doAwait");
    function doFinally(value, finallyFn) {
      var result = value;
      return finallyFn && (isPromiseLike(value) ? value.finally ? result = value.finally(finallyFn) : result = value.then(function (value) {
        return finallyFn(), value;
      }, function (reason) {
        throw finallyFn(), reason;
      }) : finallyFn()), result;
    }
    __name(doFinally, "doFinally");
    var STRING_STATES = ["pending", "resolving", "resolved", REJECTED],
      DISPATCH_EVENT = "dispatchEvent",
      _hasInitEvent;
    function _hasInitEventFn(doc) {
      var evt;
      return doc && doc.createEvent && (evt = doc.createEvent("Event")), !!evt && evt.initEvent;
    }
    __name(_hasInitEventFn, "_hasInitEventFn");
    function emitEvent(target, evtName, populateEvent, useNewEvent) {
      var doc = getDocument();
      !_hasInitEvent && (_hasInitEvent = createCachedValue(!!safe(_hasInitEventFn, [doc]).v));
      var theEvt = _hasInitEvent.v ? doc.createEvent("Event") : useNewEvent ? new Event(evtName) : {};
      if (populateEvent && populateEvent(theEvt), _hasInitEvent.v && theEvt.initEvent(evtName, !1, !0), theEvt && target[DISPATCH_EVENT]) target[DISPATCH_EVENT](theEvt);else {
        var handler = target["on" + evtName];
        if (handler) handler(theEvt);else {
          var theConsole = getInst("console");
          theConsole && (theConsole.error || theConsole.log)(evtName, dumpObj(theEvt));
        }
      }
    }
    __name(emitEvent, "emitEvent");
    var NODE_UNHANDLED_REJECTION = "unhandledRejection",
      UNHANDLED_REJECTION = NODE_UNHANDLED_REJECTION.toLowerCase(),
      _unhandledRejectionTimeout = 10,
      _hasPromiseRejectionEvent;
    function dumpFnObj(value) {
      return isFunction(value) ? value.toString() : dumpObj(value);
    }
    __name(dumpFnObj, "dumpFnObj");
    function _createPromise(newPromise, processor, executor) {
      var additionalArgs = arrSlice(arguments, 3),
        _state = 0,
        _hasResolved = !1,
        _settledValue,
        _queue = [],
        _handled = !1,
        _unHandledRejectionHandler = null,
        _thePromise;
      function _then(onResolved, onRejected) {
        try {
          _handled = !0, _unHandledRejectionHandler && _unHandledRejectionHandler.cancel(), _unHandledRejectionHandler = null;
          var thenPromise = newPromise(function (resolve, reject) {
            _queue.push(function () {
              try {
                var handler = _state === 2 ? onResolved : onRejected,
                  value = isUndefined(handler) ? _settledValue : isFunction(handler) ? handler(_settledValue) : handler;
                isPromiseLike(value) ? value.then(resolve, reject) : handler ? resolve(value) : _state === 3 ? reject(value) : resolve(value);
              } catch (e) {
                reject(e);
              }
            }), _hasResolved && _processQueue();
          }, additionalArgs);
          return thenPromise;
        } finally {}
      }
      __name(_then, "_then");
      function _catch(onRejected) {
        return _then(void 0, onRejected);
      }
      __name(_catch, "_catch");
      function _finally(onFinally) {
        var thenFinally = onFinally,
          catchFinally = onFinally;
        return isFunction(onFinally) && (thenFinally = __name(function (value) {
          return onFinally && onFinally(), value;
        }, "thenFinally"), catchFinally = __name(function (reason) {
          throw onFinally && onFinally(), reason;
        }, "catchFinally")), _then(thenFinally, catchFinally);
      }
      __name(_finally, "_finally");
      function _strState() {
        return STRING_STATES[_state];
      }
      __name(_strState, "_strState");
      function _processQueue() {
        if (_queue.length > 0) {
          var pending = _queue.slice();
          _queue = [], _handled = !0, _unHandledRejectionHandler && _unHandledRejectionHandler.cancel(), _unHandledRejectionHandler = null, processor(pending);
        }
      }
      __name(_processQueue, "_processQueue");
      function _createSettleIfFn(newState, allowState) {
        return function (theValue) {
          if (_state === allowState) {
            if (newState === 2 && isPromiseLike(theValue)) {
              _state = 1, theValue.then(_createSettleIfFn(2, 1), _createSettleIfFn(3, 1));
              return;
            }
            _state = newState, _hasResolved = !0, _settledValue = theValue, _processQueue(), !_handled && newState === 3 && !_unHandledRejectionHandler && (_unHandledRejectionHandler = scheduleTimeout(_notifyUnhandledRejection, _unhandledRejectionTimeout));
          }
        };
      }
      __name(_createSettleIfFn, "_createSettleIfFn");
      function _notifyUnhandledRejection() {
        if (!_handled) if (_handled = !0, isNode()) process.emit(NODE_UNHANDLED_REJECTION, _settledValue, _thePromise);else {
          var gbl = getWindow() || getGlobal();
          !_hasPromiseRejectionEvent && (_hasPromiseRejectionEvent = createCachedValue(safe(getInst, [STR_PROMISE + "RejectionEvent"]).v)), emitEvent(gbl, UNHANDLED_REJECTION, function (theEvt) {
            return objDefine(theEvt, "promise", {
              g: __name(function () {
                return _thePromise;
              }, "g")
            }), theEvt.reason = _settledValue, theEvt;
          }, !!_hasPromiseRejectionEvent.v);
        }
      }
      __name(_notifyUnhandledRejection, "_notifyUnhandledRejection"), _thePromise = {
        then: _then,
        catch: _catch,
        finally: _finally
      }, objDefineProp(_thePromise, "state", {
        get: _strState
      }), hasSymbol() && (_thePromise[getKnownSymbol(11)] = "IPromise");
      function _toString() {
        return "IPromise " + _strState() + (_hasResolved ? " - " + dumpFnObj(_settledValue) : "");
      }
      return __name(_toString, "_toString"), _thePromise.toString = _toString, __name(function () {
        isFunction(executor) || throwTypeError(STR_PROMISE + ": executor is not a function - " + dumpFnObj(executor));
        var _rejectFn = _createSettleIfFn(3, 0);
        try {
          executor.call(_thePromise, _createSettleIfFn(2, 0), _rejectFn);
        } catch (e) {
          _rejectFn(e);
        }
      }, "_initialize")(), _thePromise;
    }
    __name(_createPromise, "_createPromise");
    function _createAllPromise(newPromise) {
      return function (input) {
        var additionalArgs = arrSlice(arguments, 1);
        return newPromise(function (resolve, reject) {
          try {
            var values_1 = [],
              pending_1 = 1;
            iterForOf(input, function (item, idx) {
              item && (pending_1++, doAwait(item, function (value) {
                values_1[idx] = value, --pending_1 === 0 && resolve(values_1);
              }, reject));
            }), pending_1--, pending_1 === 0 && resolve(values_1);
          } catch (e) {
            reject(e);
          }
        }, additionalArgs);
      };
    }
    __name(_createAllPromise, "_createAllPromise");
    function _createAllSettledPromise(newPromise) {
      return createCachedValue(function (input) {
        var additionalArgs = arrSlice(arguments, 1);
        return newPromise(function (resolve, reject) {
          var values = [],
            pending = 1;
          function processItem(item, idx) {
            pending++, doAwaitResponse(item, function (value) {
              value.rejected ? values[idx] = {
                status: REJECTED,
                reason: value.reason
              } : values[idx] = {
                status: "fulfilled",
                value: value.value
              }, --pending === 0 && resolve(values);
            });
          }
          __name(processItem, "processItem");
          try {
            isArray(input) ? arrForEach(input, processItem) : isIterable(input) ? iterForOf(input, processItem) : throwTypeError("Input is not an iterable"), pending--, pending === 0 && resolve(values);
          } catch (e) {
            reject(e);
          }
        }, additionalArgs);
      });
    }
    __name(_createAllSettledPromise, "_createAllSettledPromise");
    function syncItemProcessor(pending) {
      arrForEach(pending, function (fn) {
        try {
          fn();
        } catch {}
      });
    }
    __name(syncItemProcessor, "syncItemProcessor");
    function timeoutItemProcessor(timeout) {
      var callbackTimeout = isNumber(timeout) ? timeout : 0;
      return function (pending) {
        scheduleTimeout(function () {
          syncItemProcessor(pending);
        }, callbackTimeout);
      };
    }
    __name(timeoutItemProcessor, "timeoutItemProcessor");
    function createAsyncPromise(executor, timeout) {
      return _createPromise(createAsyncPromise, timeoutItemProcessor(timeout), executor, timeout);
    }
    __name(createAsyncPromise, "createAsyncPromise");
    var _promiseCls;
    function createNativePromise(executor, timeout) {
      !_promiseCls && (_promiseCls = createCachedValue(safe(getInst, [STR_PROMISE]).v || null));
      var PrmCls = _promiseCls.v;
      if (!PrmCls) return createAsyncPromise(executor);
      isFunction(executor) || throwTypeError(STR_PROMISE + ": executor is not a function - " + dumpObj(executor));
      var _state = 0;
      function _strState() {
        return STRING_STATES[_state];
      }
      __name(_strState, "_strState");
      var thePromise = new PrmCls(function (resolve, reject) {
        function _resolve(value) {
          _state = 2, resolve(value);
        }
        __name(_resolve, "_resolve");
        function _reject(reason) {
          _state = 3, reject(reason);
        }
        __name(_reject, "_reject"), executor(_resolve, _reject);
      });
      return objDefineProp(thePromise, "state", {
        get: _strState
      }), thePromise;
    }
    __name(createNativePromise, "createNativePromise");
    var _allSyncSettledCreator;
    function createSyncPromise(executor) {
      return _createPromise(createSyncPromise, syncItemProcessor, executor);
    }
    __name(createSyncPromise, "createSyncPromise");
    function createSyncAllSettledPromise(input, timeout) {
      return !_allSyncSettledCreator && (_allSyncSettledCreator = _createAllSettledPromise(createSyncPromise)), _allSyncSettledCreator.v(input, timeout);
    }
    __name(createSyncAllSettledPromise, "createSyncAllSettledPromise");
    var _promiseCreator;
    function createPromise(executor, timeout) {
      return !_promiseCreator && (_promiseCreator = createCachedValue(createNativePromise)), _promiseCreator.v.call(this, executor, timeout);
    }
    __name(createPromise, "createPromise");
    var createAllPromise = _createAllPromise(createPromise),
      UNDEFINED_VALUE = void 0,
      STR_EMPTY = "",
      STR_CHANNELS = "channels",
      STR_CORE = "core",
      STR_CREATE_PERF_MGR = "createPerfMgr",
      STR_DISABLED = "disabled",
      STR_EXTENSION_CONFIG = "extensionConfig",
      STR_EXTENSIONS = "extensions",
      STR_PROCESS_TELEMETRY = "processTelemetry",
      STR_PRIORITY = "priority",
      STR_EVENTS_SENT = "eventsSent",
      STR_EVENTS_DISCARDED = "eventsDiscarded",
      STR_EVENTS_SEND_REQUEST = "eventsSendRequest",
      STR_PERF_EVENT = "perfEvent",
      STR_OFFLINE_STORE = "offlineEventsStored",
      STR_OFFLINE_SENT = "offlineBatchSent",
      STR_OFFLINE_DROP = "offlineBatchDrop",
      STR_GET_PERF_MGR = "getPerfMgr",
      STR_DOMAIN = "domain",
      STR_PATH = "path",
      STR_NOT_DYNAMIC_ERROR = "Not dynamic - ",
      rCamelCase = /-([a-z])/g,
      rNormalizeInvalid = /([^\w\d_$])/g,
      rLeadingNumeric = /^(\d+[\w\d_$])/;
    function isNotNullOrUndefined(value) {
      return !isNullOrUndefined(value);
    }
    __name(isNotNullOrUndefined, "isNotNullOrUndefined");
    function normalizeJsName(name) {
      var value = name;
      return value && isString(value) && (value = value[_DYN_REPLACE](rCamelCase, function (_all, letter) {
        return letter.toUpperCase();
      }), value = value[_DYN_REPLACE](rNormalizeInvalid, "_"), value = value[_DYN_REPLACE](rLeadingNumeric, function (_all, match) {
        return "_" + match;
      })), value;
    }
    __name(normalizeJsName, "normalizeJsName");
    function strContains(value, search) {
      return value && search ? strIndexOf(value, search) !== -1 : !1;
    }
    __name(strContains, "strContains");
    function toISOString(date) {
      return date && date.toISOString() || "";
    }
    __name(toISOString, "toISOString");
    function getExceptionName(object) {
      return isError(object) ? object[_DYN_NAME] : STR_EMPTY;
    }
    __name(getExceptionName, "getExceptionName");
    function setValue(target, field, value, valChk, srcChk) {
      var theValue = value;
      return target && (theValue = target[field], theValue !== value && (!srcChk || srcChk(theValue)) && (!valChk || valChk(value)) && (theValue = value, target[field] = theValue)), theValue;
    }
    __name(setValue, "setValue");
    function getSetValue(target, field, defValue) {
      var theValue;
      return target ? (theValue = target[field], !theValue && isNullOrUndefined(theValue) && (theValue = isUndefined(defValue) ? {} : defValue, target[field] = theValue)) : theValue = isUndefined(defValue) ? {} : defValue, theValue;
    }
    __name(getSetValue, "getSetValue");
    function _createProxyFunction(source, funcName) {
      var srcFunc = null,
        src = null;
      return isFunction(source) ? srcFunc = source : src = source, function () {
        var originalArguments = arguments;
        if (srcFunc && (src = srcFunc()), src) return src[funcName][_DYN_APPLY](src, originalArguments);
      };
    }
    __name(_createProxyFunction, "_createProxyFunction");
    function proxyFunctionAs(target, name, source, theFunc, overwriteTarget) {
      target && name && source && (overwriteTarget !== !1 || isUndefined(target[name])) && (target[name] = _createProxyFunction(source, theFunc));
    }
    __name(proxyFunctionAs, "proxyFunctionAs");
    function proxyFunctions(target, source, functionsToProxy, overwriteTarget) {
      return target && source && isObject(target) && isArray(functionsToProxy) && arrForEach(functionsToProxy, function (theFuncName) {
        isString(theFuncName) && proxyFunctionAs(target, theFuncName, source, theFuncName, overwriteTarget);
      }), target;
    }
    __name(proxyFunctions, "proxyFunctions");
    function createClassFromInterface(defaults) {
      return function () {
        function class_1() {
          var _this = this;
          defaults && objForEachKey(defaults, function (field, value) {
            _this[field] = value;
          });
        }
        return __name(class_1, "class_1"), class_1;
      }();
    }
    __name(createClassFromInterface, "createClassFromInterface");
    function optimizeObject(theObject) {
      return theObject && ObjAssign && (theObject = ObjClass(ObjAssign({}, theObject))), theObject;
    }
    __name(optimizeObject, "optimizeObject");
    function objExtend(obj1, obj2, obj3, obj4, obj5, obj6) {
      var theArgs = arguments,
        extended = theArgs[0] || {},
        argLen = theArgs[_DYN_LENGTH],
        deep = !1,
        idx = 1;
      for (argLen > 0 && isBoolean(extended) && (deep = extended, extended = theArgs[idx] || {}, idx++), isObject(extended) || (extended = {}); idx < argLen; idx++) {
        var arg = theArgs[idx],
          isArgArray = isArray(arg),
          isArgObj = isObject(arg);
        for (var prop in arg) {
          var propOk = isArgArray && prop in arg || isArgObj && objHasOwn(arg, prop);
          if (propOk) {
            var newValue = arg[prop],
              isNewArray = void 0;
            if (deep && newValue && ((isNewArray = isArray(newValue)) || isPlainObject(newValue))) {
              var clone = extended[prop];
              isNewArray ? isArray(clone) || (clone = []) : isPlainObject(clone) || (clone = {}), newValue = objExtend(deep, clone, newValue);
            }
            newValue !== void 0 && (extended[prop] = newValue);
          }
        }
      }
      return extended;
    }
    __name(objExtend, "objExtend");
    function getResponseText(xhr) {
      try {
        return xhr.responseText;
      } catch {}
      return null;
    }
    __name(getResponseText, "getResponseText");
    function formatErrorMessageXdr(xdr, message) {
      return xdr ? "XDomainRequest,Response:" + getResponseText(xdr) || "" : message;
    }
    __name(formatErrorMessageXdr, "formatErrorMessageXdr");
    function formatErrorMessageXhr(xhr, message) {
      return xhr ? "XMLHttpRequest,Status:" + xhr[_DYN_STATUS] + ",Response:" + getResponseText(xhr) || xhr.response || "" : message;
    }
    __name(formatErrorMessageXhr, "formatErrorMessageXhr");
    function prependTransports(theTransports, newTransports) {
      return newTransports && (isNumber(newTransports) ? theTransports = [newTransports].concat(theTransports) : isArray(newTransports) && (theTransports = newTransports.concat(theTransports))), theTransports;
    }
    __name(prependTransports, "prependTransports");
    var strDisabledPropertyName = "Microsoft_ApplicationInsights_BypassAjaxInstrumentation",
      strWithCredentials = "withCredentials",
      strTimeout = "timeout";
    function openXhr(method, urlString, withCredentials, disabled, isSync, timeout) {
      disabled === void 0 && (disabled = !1), isSync === void 0 && (isSync = !1);
      function _wrapSetXhrProp(xhr, prop, value) {
        try {
          xhr[prop] = value;
        } catch {}
      }
      __name(_wrapSetXhrProp, "_wrapSetXhrProp");
      var xhr = new XMLHttpRequest();
      return disabled && _wrapSetXhrProp(xhr, strDisabledPropertyName, disabled), withCredentials && _wrapSetXhrProp(xhr, strWithCredentials, withCredentials), xhr.open(method, urlString, !isSync), withCredentials && _wrapSetXhrProp(xhr, strWithCredentials, withCredentials), !isSync && timeout && _wrapSetXhrProp(xhr, strTimeout, timeout), xhr;
    }
    __name(openXhr, "openXhr");
    function convertAllHeadersToMap(headersString) {
      var headers = {};
      if (isString(headersString)) {
        var headersArray = strTrim(headersString)[_DYN_SPLIT](/[\r\n]+/);
        arrForEach(headersArray, function (headerEntry) {
          if (headerEntry) {
            var idx = headerEntry.indexOf(": ");
            if (idx !== -1) {
              var header = strTrim(headerEntry.substring(0, idx))[_DYN_TO_LOWER_CASE](),
                value = strTrim(headerEntry.substring(idx + 1));
              headers[header] = value;
            } else headers[strTrim(headerEntry)] = 1;
          }
        });
      }
      return headers;
    }
    __name(convertAllHeadersToMap, "convertAllHeadersToMap");
    function _appendHeader(theHeaders, xhr, name) {
      if (!theHeaders[name] && xhr && xhr.getResponseHeader) {
        var value = xhr.getResponseHeader(name);
        value && (theHeaders[name] = strTrim(value));
      }
      return theHeaders;
    }
    __name(_appendHeader, "_appendHeader");
    var STR_KILL_DURATION_HEADER = "kill-duration",
      STR_KILL_DURATION_SECONDS_HEADER = "kill-duration-seconds",
      STR_TIME_DELTA_HEADER = "time-delta-millis";
    function _getAllResponseHeaders(xhr, isOneDs) {
      var theHeaders = {};
      return xhr[_DYN_GET_ALL_RESPONSE_HEA5] ? theHeaders = convertAllHeadersToMap(xhr[_DYN_GET_ALL_RESPONSE_HEA5]()) : isOneDs && (theHeaders = _appendHeader(theHeaders, xhr, STR_TIME_DELTA_HEADER), theHeaders = _appendHeader(theHeaders, xhr, STR_KILL_DURATION_HEADER), theHeaders = _appendHeader(theHeaders, xhr, STR_KILL_DURATION_SECONDS_HEADER)), theHeaders;
    }
    __name(_getAllResponseHeaders, "_getAllResponseHeaders");
    var strDocumentMode = "documentMode",
      strLocation = "location",
      strConsole = "console",
      strJSON = "JSON",
      strCrypto = "crypto",
      strMsCrypto = "msCrypto",
      strMsie = "msie",
      strTrident = "trident/",
      strXMLHttpRequest = "XMLHttpRequest",
      _isTrident = null,
      _navUserAgentCheck = null,
      _enableMocks = !1,
      _useXDomainRequest = null,
      _beaconsSupported = null;
    function _hasProperty(theClass, property) {
      var supported = !1;
      if (theClass) {
        try {
          if (supported = property in theClass, !supported) {
            var proto = theClass[strShimPrototype];
            proto && (supported = property in proto);
          }
        } catch {}
        if (!supported) try {
          var tmp = new theClass();
          supported = !isUndefined(tmp[property]);
        } catch {}
      }
      return supported;
    }
    __name(_hasProperty, "_hasProperty");
    function getLocation(checkForMock) {
      if (checkForMock && _enableMocks) {
        var mockLocation = getInst("__mockLocation");
        if (mockLocation) return mockLocation;
      }
      return typeof location === strShimObject && location ? location : getInst(strLocation);
    }
    __name(getLocation, "getLocation");
    function getConsole() {
      return typeof console !== strShimUndefined ? console : getInst(strConsole);
    }
    __name(getConsole, "getConsole");
    function hasJSON() {
      return !!(typeof JSON === strShimObject && JSON || getInst(strJSON) !== null);
    }
    __name(hasJSON, "hasJSON");
    function getJSON() {
      return hasJSON() ? JSON || getInst(strJSON) : null;
    }
    __name(getJSON, "getJSON");
    function getCrypto() {
      return getInst(strCrypto);
    }
    __name(getCrypto, "getCrypto");
    function getMsCrypto() {
      return getInst(strMsCrypto);
    }
    __name(getMsCrypto, "getMsCrypto");
    function isIE() {
      var nav = getNavigator();
      if (nav && (nav[_DYN_USER_AGENT] !== _navUserAgentCheck || _isTrident === null)) {
        _navUserAgentCheck = nav[_DYN_USER_AGENT];
        var userAgent = (_navUserAgentCheck || STR_EMPTY)[_DYN_TO_LOWER_CASE]();
        _isTrident = strContains(userAgent, strMsie) || strContains(userAgent, strTrident);
      }
      return _isTrident;
    }
    __name(isIE, "isIE");
    function getIEVersion(userAgentStr) {
      if (userAgentStr === void 0 && (userAgentStr = null), !userAgentStr) {
        var navigator_1 = getNavigator() || {};
        userAgentStr = navigator_1 ? (navigator_1.userAgent || STR_EMPTY)[_DYN_TO_LOWER_CASE]() : STR_EMPTY;
      }
      var ua = (userAgentStr || STR_EMPTY)[_DYN_TO_LOWER_CASE]();
      if (strContains(ua, strMsie)) {
        var doc = getDocument() || {};
        return mathMax(parseInt(ua[_DYN_SPLIT](strMsie)[1]), doc[strDocumentMode] || 0);
      } else if (strContains(ua, strTrident)) {
        var tridentVer = parseInt(ua[_DYN_SPLIT](strTrident)[1]);
        if (tridentVer) return tridentVer + 4;
      }
      return null;
    }
    __name(getIEVersion, "getIEVersion");
    function isBeaconsSupported(useCached) {
      return (_beaconsSupported === null || useCached === !1) && (_beaconsSupported = hasNavigator() && !!getNavigator().sendBeacon), _beaconsSupported;
    }
    __name(isBeaconsSupported, "isBeaconsSupported");
    function isFetchSupported(withKeepAlive) {
      var isSupported = !1;
      try {
        isSupported = !!getInst("fetch");
        var request = getInst("Request");
        isSupported && withKeepAlive && request && (isSupported = _hasProperty(request, "keepalive"));
      } catch {}
      return isSupported;
    }
    __name(isFetchSupported, "isFetchSupported");
    function useXDomainRequest() {
      return _useXDomainRequest === null && (_useXDomainRequest = typeof XDomainRequest !== strShimUndefined, _useXDomainRequest && isXhrSupported() && (_useXDomainRequest = _useXDomainRequest && !_hasProperty(getInst(strXMLHttpRequest), "withCredentials"))), _useXDomainRequest;
    }
    __name(useXDomainRequest, "useXDomainRequest");
    function isXhrSupported() {
      var isSupported = !1;
      try {
        var xmlHttpRequest = getInst(strXMLHttpRequest);
        isSupported = !!xmlHttpRequest;
      } catch {}
      return isSupported;
    }
    __name(isXhrSupported, "isXhrSupported");
    var UInt32Mask = 4294967296,
      MaxUInt32 = 4294967295,
      SEED1 = 123456789,
      SEED2 = 987654321,
      _mwcSeeded = !1,
      _mwcW = SEED1,
      _mwcZ = SEED2;
    function _mwcSeed(seedValue) {
      seedValue < 0 && (seedValue >>>= 0), _mwcW = SEED1 + seedValue & MaxUInt32, _mwcZ = SEED2 - seedValue & MaxUInt32, _mwcSeeded = !0;
    }
    __name(_mwcSeed, "_mwcSeed");
    function _autoSeedMwc() {
      try {
        var now = utcNow() & 2147483647;
        _mwcSeed((Math.random() * UInt32Mask ^ now) + now);
      } catch {}
    }
    __name(_autoSeedMwc, "_autoSeedMwc");
    function random32(signed) {
      var value = 0,
        c = getCrypto() || getMsCrypto();
      return c && c.getRandomValues && (value = c.getRandomValues(new Uint32Array(1))[0] & MaxUInt32), value === 0 && isIE() && (_mwcSeeded || _autoSeedMwc(), value = mwcRandom32() & MaxUInt32), value === 0 && (value = mathFloor(UInt32Mask * Math.random() | 0)), signed || (value >>>= 0), value;
    }
    __name(random32, "random32");
    function mwcRandom32(signed) {
      _mwcZ = 36969 * (_mwcZ & 65535) + (_mwcZ >> 16) & MaxUInt32, _mwcW = 18e3 * (_mwcW & 65535) + (_mwcW >> 16) & MaxUInt32;
      var value = (_mwcZ << 16) + (_mwcW & 65535) >>> 0 & MaxUInt32 | 0;
      return signed || (value >>>= 0), value;
    }
    __name(mwcRandom32, "mwcRandom32");
    function newId(maxLength) {
      maxLength === void 0 && (maxLength = 22);
      for (var base64chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", number = random32() >>> 0, chars = 0, result = STR_EMPTY; result[_DYN_LENGTH] < maxLength;) chars++, result += base64chars.charAt(number & 63), number >>>= 6, chars === 5 && (number = (random32() << 2 & 4294967295 | number & 3) >>> 0, chars = 0);
      return result;
    }
    __name(newId, "newId");
    var version = "3.3.6",
      instanceName = "." + newId(6),
      _dataUid = 0;
    function _canAcceptData(target) {
      return target.nodeType === 1 || target.nodeType === 9 || !+target.nodeType;
    }
    __name(_canAcceptData, "_canAcceptData");
    function _getCache(data, target) {
      var theCache = target[data.id];
      if (!theCache) {
        theCache = {};
        try {
          _canAcceptData(target) && objDefine(target, data.id, {
            e: !1,
            v: theCache
          });
        } catch {}
      }
      return theCache;
    }
    __name(_getCache, "_getCache");
    function createUniqueNamespace(name, includeVersion) {
      return includeVersion === void 0 && (includeVersion = !1), normalizeJsName(name + _dataUid++ + (includeVersion ? "." + version : STR_EMPTY) + instanceName);
    }
    __name(createUniqueNamespace, "createUniqueNamespace");
    function createElmNodeData(name) {
      var data = {
        id: createUniqueNamespace("_aiData-" + (name || STR_EMPTY) + "." + version),
        accept: __name(function (target) {
          return _canAcceptData(target);
        }, "accept"),
        get: __name(function (target, name, defValue, addDefault) {
          var theCache = target[data.id];
          return theCache ? theCache[normalizeJsName(name)] : (addDefault && (theCache = _getCache(data, target), theCache[normalizeJsName(name)] = defValue), defValue);
        }, "get"),
        kill: __name(function (target, name) {
          if (target && target[name]) try {
            delete target[name];
          } catch {}
        }, "kill")
      };
      return data;
    }
    __name(createElmNodeData, "createElmNodeData");
    function _isConfigDefaults(value) {
      return value && isObject(value) && (value.isVal || value.fb || objHasOwn(value, "v") || objHasOwn(value, "mrg") || objHasOwn(value, "ref") || value.set);
    }
    __name(_isConfigDefaults, "_isConfigDefaults");
    function _getDefault(dynamicHandler, theConfig, cfgDefaults) {
      var defValue,
        isDefaultValid = cfgDefaults.dfVal || isDefined;
      if (theConfig && cfgDefaults.fb) {
        var fallbacks = cfgDefaults.fb;
        isArray(fallbacks) || (fallbacks = [fallbacks]);
        for (var lp = 0; lp < fallbacks[_DYN_LENGTH]; lp++) {
          var fallback = fallbacks[lp],
            fbValue = theConfig[fallback];
          if (isDefaultValid(fbValue) ? defValue = fbValue : dynamicHandler && (fbValue = dynamicHandler.cfg[fallback], isDefaultValid(fbValue) && (defValue = fbValue), dynamicHandler.set(dynamicHandler.cfg, asString(fallback), fbValue)), isDefaultValid(defValue)) break;
        }
      }
      return !isDefaultValid(defValue) && isDefaultValid(cfgDefaults.v) && (defValue = cfgDefaults.v), defValue;
    }
    __name(_getDefault, "_getDefault");
    function _resolveDefaultValue(dynamicHandler, theConfig, cfgDefaults) {
      var theValue = cfgDefaults;
      if (cfgDefaults && _isConfigDefaults(cfgDefaults) && (theValue = _getDefault(dynamicHandler, theConfig, cfgDefaults)), theValue) {
        _isConfigDefaults(theValue) && (theValue = _resolveDefaultValue(dynamicHandler, theConfig, theValue));
        var newValue_1;
        isArray(theValue) ? (newValue_1 = [], newValue_1[_DYN_LENGTH] = theValue[_DYN_LENGTH]) : isPlainObject(theValue) && (newValue_1 = {}), newValue_1 && (objForEachKey(theValue, function (key, value) {
          value && _isConfigDefaults(value) && (value = _resolveDefaultValue(dynamicHandler, theConfig, value)), newValue_1[key] = value;
        }), theValue = newValue_1);
      }
      return theValue;
    }
    __name(_resolveDefaultValue, "_resolveDefaultValue");
    function _applyDefaultValue(dynamicHandler, theConfig, name, defaultValue) {
      var isValid,
        setFn,
        defValue,
        cfgDefaults = defaultValue,
        mergeDf,
        reference,
        readOnly,
        blkDynamicValue;
      _isConfigDefaults(cfgDefaults) ? (isValid = cfgDefaults.isVal, setFn = cfgDefaults.set, readOnly = cfgDefaults.rdOnly, blkDynamicValue = cfgDefaults.blkVal, mergeDf = cfgDefaults.mrg, reference = cfgDefaults.ref, !reference && isUndefined(reference) && (reference = !!mergeDf), defValue = _getDefault(dynamicHandler, theConfig, cfgDefaults)) : defValue = defaultValue, blkDynamicValue && dynamicHandler.blkVal(theConfig, name);
      var theValue,
        usingDefault = !0,
        cfgValue = theConfig[name];
      (cfgValue || !isNullOrUndefined(cfgValue)) && (theValue = cfgValue, usingDefault = !1, isValid && theValue !== defValue && !isValid(theValue) && (theValue = defValue, usingDefault = !0), setFn && (theValue = setFn(theValue, defValue, theConfig), usingDefault = theValue === defValue)), usingDefault ? defValue ? theValue = _resolveDefaultValue(dynamicHandler, theConfig, defValue) : theValue = defValue : (isPlainObject(theValue) || isArray(defValue)) && mergeDf && defValue && (isPlainObject(defValue) || isArray(defValue)) && objForEachKey(defValue, function (dfName, dfValue) {
        _applyDefaultValue(dynamicHandler, theValue, dfName, dfValue);
      }), dynamicHandler.set(theConfig, name, theValue), reference && dynamicHandler.ref(theConfig, name), readOnly && dynamicHandler.rdOnly(theConfig, name);
    }
    __name(_applyDefaultValue, "_applyDefaultValue");
    var CFG_HANDLER_LINK = symbolFor("[[ai_dynCfg_1]]"),
      BLOCK_DYNAMIC = symbolFor("[[ai_blkDynCfg_1]]"),
      FORCE_DYNAMIC = symbolFor("[[ai_frcDynCfg_1]]");
    function _cfgDeepCopy(source) {
      if (source) {
        var target_1;
        if (isArray(source) ? (target_1 = [], target_1[_DYN_LENGTH] = source[_DYN_LENGTH]) : isPlainObject(source) && (target_1 = {}), target_1) return objForEachKey(source, function (key, value) {
          target_1[key] = _cfgDeepCopy(value);
        }), target_1;
      }
      return source;
    }
    __name(_cfgDeepCopy, "_cfgDeepCopy");
    function getDynamicConfigHandler(value) {
      if (value) {
        var handler = value[CFG_HANDLER_LINK] || value;
        if (handler.cfg && (handler.cfg === value || handler.cfg[CFG_HANDLER_LINK] === handler)) return handler;
      }
      return null;
    }
    __name(getDynamicConfigHandler, "getDynamicConfigHandler");
    function blockDynamicConversion(value) {
      if (value && (isPlainObject(value) || isArray(value))) try {
        value[BLOCK_DYNAMIC] = !0;
      } catch {}
      return value;
    }
    __name(blockDynamicConversion, "blockDynamicConversion");
    function _canMakeDynamic(getFunc, state, value) {
      var result = !1;
      return value && !getFunc[state.blkVal] && (result = value[FORCE_DYNAMIC], !result && !value[BLOCK_DYNAMIC] && (result = isPlainObject(value) || isArray(value))), result;
    }
    __name(_canMakeDynamic, "_canMakeDynamic");
    function throwInvalidAccess(message) {
      throwTypeError("InvalidAccess:" + message);
    }
    __name(throwInvalidAccess, "throwInvalidAccess");
    var arrayMethodsToPatch = ["push", "pop", "shift", "unshift", "splice"],
      _throwDynamicError = __name(function (logger, name, desc, e) {
        logger && logger[_DYN_THROW_INTERNAL](3, 108, "".concat(desc, " [").concat(name, "] failed - ") + dumpObj(e));
      }, "_throwDynamicError");
    function _patchArray(state, target, name) {
      isArray(target) && arrForEach(arrayMethodsToPatch, function (method) {
        var orgMethod = target[method];
        target[method] = function () {
          for (var args = [], _i = 0; _i < arguments.length; _i++) args[_i] = arguments[_i];
          var result = orgMethod[_DYN_APPLY](this, args);
          return _makeDynamicObject(state, target, name, "Patching"), result;
        };
      });
    }
    __name(_patchArray, "_patchArray");
    function _getOwnPropGetter(target, name) {
      var propDesc = objGetOwnPropertyDescriptor(target, name);
      return propDesc && propDesc.get;
    }
    __name(_getOwnPropGetter, "_getOwnPropGetter");
    function _createDynamicProperty(state, theConfig, name, value) {
      var detail = {
          n: name,
          h: [],
          trk: __name(function (handler) {
            handler && handler.fn && (arrIndexOf(detail.h, handler) === -1 && detail.h[_DYN_PUSH](handler), state.trk(handler, detail));
          }, "trk"),
          clr: __name(function (handler) {
            var idx = arrIndexOf(detail.h, handler);
            idx !== -1 && detail.h[_DYN_SPLICE](idx, 1);
          }, "clr")
        },
        checkDynamic = !0,
        isObjectOrArray = !1;
      function _getProperty() {
        checkDynamic && (isObjectOrArray = isObjectOrArray || _canMakeDynamic(_getProperty, state, value), value && !value[CFG_HANDLER_LINK] && isObjectOrArray && (value = _makeDynamicObject(state, value, name, "Converting")), checkDynamic = !1);
        var activeHandler = state.act;
        return activeHandler && detail.trk(activeHandler), value;
      }
      __name(_getProperty, "_getProperty"), _getProperty[state.prop] = {
        chng: __name(function () {
          state.add(detail);
        }, "chng")
      };
      function _setProperty(newValue) {
        if (value !== newValue) {
          _getProperty[state.ro] && !state.upd && throwInvalidAccess("[" + name + "] is read-only:" + dumpObj(theConfig)), checkDynamic && (isObjectOrArray = isObjectOrArray || _canMakeDynamic(_getProperty, state, value), checkDynamic = !1);
          var isReferenced = isObjectOrArray && _getProperty[state.rf];
          if (isObjectOrArray) if (isReferenced) {
            objForEachKey(value, function (key) {
              value[key] = newValue ? newValue[key] : UNDEFINED_VALUE;
            });
            try {
              objForEachKey(newValue, function (key, theValue) {
                _setDynamicProperty(state, value, key, theValue);
              }), newValue = value;
            } catch (e) {
              _throwDynamicError((state.hdlr || {})[_DYN_LOGGER], name, "Assigning", e), isObjectOrArray = !1;
            }
          } else value && value[CFG_HANDLER_LINK] && objForEachKey(value, function (key) {
            var getter = _getOwnPropGetter(value, key);
            if (getter) {
              var valueState = getter[state.prop];
              valueState && valueState.chng();
            }
          });
          if (newValue !== value) {
            var newIsObjectOrArray = newValue && _canMakeDynamic(_getProperty, state, newValue);
            !isReferenced && newIsObjectOrArray && (newValue = _makeDynamicObject(state, newValue, name, "Converting")), value = newValue, isObjectOrArray = newIsObjectOrArray;
          }
          state.add(detail);
        }
      }
      __name(_setProperty, "_setProperty"), objDefine(theConfig, detail.n, {
        g: _getProperty,
        s: _setProperty
      });
    }
    __name(_createDynamicProperty, "_createDynamicProperty");
    function _setDynamicProperty(state, target, name, value) {
      if (target) {
        var getter = _getOwnPropGetter(target, name),
          isDynamic = getter && !!getter[state.prop];
        isDynamic ? target[name] = value : _createDynamicProperty(state, target, name, value);
      }
      return target;
    }
    __name(_setDynamicProperty, "_setDynamicProperty");
    function _setDynamicPropertyState(state, target, name, flags) {
      if (target) {
        var getter = _getOwnPropGetter(target, name),
          isDynamic = getter && !!getter[state.prop],
          inPlace = flags && flags[0],
          rdOnly = flags && flags[1],
          blkProp = flags && flags[2];
        if (!isDynamic) {
          if (blkProp) try {
            blockDynamicConversion(target);
          } catch (e) {
            _throwDynamicError((state.hdlr || {})[_DYN_LOGGER], name, "Blocking", e);
          }
          try {
            _setDynamicProperty(state, target, name, target[name]), getter = _getOwnPropGetter(target, name);
          } catch (e) {
            _throwDynamicError((state.hdlr || {})[_DYN_LOGGER], name, "State", e);
          }
        }
        inPlace && (getter[state.rf] = inPlace), rdOnly && (getter[state.ro] = rdOnly), blkProp && (getter[state.blkVal] = !0);
      }
      return target;
    }
    __name(_setDynamicPropertyState, "_setDynamicPropertyState");
    function _makeDynamicObject(state, target, name, desc) {
      try {
        objForEachKey(target, function (key, value) {
          _setDynamicProperty(state, target, key, value);
        }), target[CFG_HANDLER_LINK] || (objDefineProp(target, CFG_HANDLER_LINK, {
          get: __name(function () {
            return state.hdlr;
          }, "get")
        }), _patchArray(state, target, name));
      } catch (e) {
        _throwDynamicError((state.hdlr || {})[_DYN_LOGGER], name, desc, e);
      }
      return target;
    }
    __name(_makeDynamicObject, "_makeDynamicObject");
    var symPrefix = "[[ai_",
      symPostfix = "]]";
    function _createState(cfgHandler) {
      var dynamicPropertySymbol = newSymbol(symPrefix + "get" + cfgHandler.uid + symPostfix),
        dynamicPropertyReadOnly = newSymbol(symPrefix + "ro" + cfgHandler.uid + symPostfix),
        dynamicPropertyReferenced = newSymbol(symPrefix + "rf" + cfgHandler.uid + symPostfix),
        dynamicPropertyBlockValue = newSymbol(symPrefix + "blkVal" + cfgHandler.uid + symPostfix),
        dynamicPropertyDetail = newSymbol(symPrefix + "dtl" + cfgHandler.uid + symPostfix),
        _waitingHandlers = null,
        _watcherTimer = null,
        theState;
      function _useHandler(activeHandler, callback) {
        var prevWatcher = theState.act;
        try {
          theState.act = activeHandler, activeHandler && activeHandler[dynamicPropertyDetail] && (arrForEach(activeHandler[dynamicPropertyDetail], function (detail) {
            detail.clr(activeHandler);
          }), activeHandler[dynamicPropertyDetail] = []), callback({
            cfg: cfgHandler.cfg,
            set: cfgHandler.set.bind(cfgHandler),
            setDf: cfgHandler.setDf.bind(cfgHandler),
            ref: cfgHandler.ref.bind(cfgHandler),
            rdOnly: cfgHandler.rdOnly.bind(cfgHandler)
          });
        } catch (e) {
          var logger = cfgHandler[_DYN_LOGGER];
          throw logger && logger[_DYN_THROW_INTERNAL](1, 107, dumpObj(e)), e;
        } finally {
          theState.act = prevWatcher || null;
        }
      }
      __name(_useHandler, "_useHandler");
      function _notifyWatchers() {
        if (_waitingHandlers) {
          var notifyHandlers = _waitingHandlers;
          _waitingHandlers = null, _watcherTimer && _watcherTimer[_DYN_CANCEL](), _watcherTimer = null;
          var watcherFailures_1 = [];
          if (arrForEach(notifyHandlers, function (handler) {
            if (handler && (handler[dynamicPropertyDetail] && (arrForEach(handler[dynamicPropertyDetail], function (detail) {
              detail.clr(handler);
            }), handler[dynamicPropertyDetail] = null), handler.fn)) try {
              _useHandler(handler, handler.fn);
            } catch (e) {
              watcherFailures_1[_DYN_PUSH](e);
            }
          }), _waitingHandlers) try {
            _notifyWatchers();
          } catch (e) {
            watcherFailures_1[_DYN_PUSH](e);
          }
          watcherFailures_1[_DYN_LENGTH] > 0 && throwAggregationError("Watcher error(s): ", watcherFailures_1);
        }
      }
      __name(_notifyWatchers, "_notifyWatchers");
      function _addWatcher(detail) {
        if (detail && detail.h[_DYN_LENGTH] > 0) {
          _waitingHandlers || (_waitingHandlers = []), _watcherTimer || (_watcherTimer = scheduleTimeout(function () {
            _watcherTimer = null, _notifyWatchers();
          }, 0));
          for (var idx = 0; idx < detail.h[_DYN_LENGTH]; idx++) {
            var handler = detail.h[idx];
            handler && arrIndexOf(_waitingHandlers, handler) === -1 && _waitingHandlers[_DYN_PUSH](handler);
          }
        }
      }
      __name(_addWatcher, "_addWatcher");
      function _trackHandler(handler, detail) {
        if (handler) {
          var details = handler[dynamicPropertyDetail] = handler[dynamicPropertyDetail] || [];
          arrIndexOf(details, detail) === -1 && details[_DYN_PUSH](detail);
        }
      }
      return __name(_trackHandler, "_trackHandler"), theState = {
        prop: dynamicPropertySymbol,
        ro: dynamicPropertyReadOnly,
        rf: dynamicPropertyReferenced,
        blkVal: dynamicPropertyBlockValue,
        hdlr: cfgHandler,
        add: _addWatcher,
        notify: _notifyWatchers,
        use: _useHandler,
        trk: _trackHandler
      }, theState;
    }
    __name(_createState, "_createState");
    function _createAndUseHandler(state, configHandler) {
      var handler = {
        fn: configHandler,
        rm: __name(function () {
          handler.fn = null, state = null, configHandler = null;
        }, "rm")
      };
      return objDefine(handler, "toJSON", {
        v: __name(function () {
          return "WatcherHandler" + (handler.fn ? "" : "[X]");
        }, "v")
      }), state.use(handler, configHandler), handler;
    }
    __name(_createAndUseHandler, "_createAndUseHandler");
    function _createDynamicHandler(logger, target, inPlace) {
      var dynamicHandler = getDynamicConfigHandler(target);
      if (dynamicHandler) return dynamicHandler;
      var uid = createUniqueNamespace("dyncfg", !0),
        newTarget = target && inPlace !== !1 ? target : _cfgDeepCopy(target),
        theState;
      function _notifyWatchers() {
        theState.notify();
      }
      __name(_notifyWatchers, "_notifyWatchers");
      function _setValue(target, name, value) {
        try {
          target = _setDynamicProperty(theState, target, name, value);
        } catch (e) {
          _throwDynamicError(logger, name, "Setting value", e);
        }
        return target[name];
      }
      __name(_setValue, "_setValue");
      function _watch(configHandler) {
        return _createAndUseHandler(theState, configHandler);
      }
      __name(_watch, "_watch");
      function _block(configHandler, allowUpdate) {
        theState.use(null, function (details) {
          var prevUpd = theState.upd;
          try {
            isUndefined(allowUpdate) || (theState.upd = allowUpdate), configHandler(details);
          } finally {
            theState.upd = prevUpd;
          }
        });
      }
      __name(_block, "_block");
      function _ref(target, name) {
        var _a;
        return _setDynamicPropertyState(theState, target, name, (_a = {}, _a[0] = !0, _a))[name];
      }
      __name(_ref, "_ref");
      function _rdOnly(target, name) {
        var _a;
        return _setDynamicPropertyState(theState, target, name, (_a = {}, _a[1] = !0, _a))[name];
      }
      __name(_rdOnly, "_rdOnly");
      function _blkPropValue(target, name) {
        var _a;
        return _setDynamicPropertyState(theState, target, name, (_a = {}, _a[2] = !0, _a))[name];
      }
      __name(_blkPropValue, "_blkPropValue");
      function _applyDefaults(theConfig, defaultValues) {
        return defaultValues && objForEachKey(defaultValues, function (name, value) {
          _applyDefaultValue(cfgHandler, theConfig, name, value);
        }), theConfig;
      }
      __name(_applyDefaults, "_applyDefaults");
      var cfgHandler = {
        uid: null,
        cfg: newTarget,
        logger: logger,
        notify: _notifyWatchers,
        set: _setValue,
        setDf: _applyDefaults,
        watch: _watch,
        ref: _ref,
        rdOnly: _rdOnly,
        blkVal: _blkPropValue,
        _block: _block
      };
      return objDefine(cfgHandler, "uid", {
        c: !1,
        e: !1,
        w: !1,
        v: uid
      }), theState = _createState(cfgHandler), _makeDynamicObject(theState, newTarget, "config", "Creating"), cfgHandler;
    }
    __name(_createDynamicHandler, "_createDynamicHandler");
    function _logInvalidAccess(logger, message) {
      logger ? (logger[_DYN_WARN_TO_CONSOLE](message), logger[_DYN_THROW_INTERNAL](2, 108, message)) : throwInvalidAccess(message);
    }
    __name(_logInvalidAccess, "_logInvalidAccess");
    function createDynamicConfig(config, defaultConfig, logger, inPlace) {
      var dynamicHandler = _createDynamicHandler(logger, config || {}, inPlace);
      return defaultConfig && dynamicHandler.setDf(dynamicHandler.cfg, defaultConfig), dynamicHandler;
    }
    __name(createDynamicConfig, "createDynamicConfig");
    function onConfigChange(config, configHandler, logger) {
      var handler = config[CFG_HANDLER_LINK] || config;
      return handler.cfg && (handler.cfg === config || handler.cfg[CFG_HANDLER_LINK] === handler) ? handler[_DYN_WATCH](configHandler) : (_logInvalidAccess(logger, STR_NOT_DYNAMIC_ERROR + dumpObj(config)), createDynamicConfig(config, null, logger)[_DYN_WATCH](configHandler));
    }
    __name(onConfigChange, "onConfigChange");
    function runTargetUnload(target, isAsync) {
      if (target && target[_DYN_UNLOAD]) return target[_DYN_UNLOAD](isAsync);
    }
    __name(runTargetUnload, "runTargetUnload");
    function doUnloadAll(targets, isAsync, done) {
      var result;
      return done || (result = createPromise(function (resolved) {
        done = resolved;
      })), targets && getLength(targets) > 0 ? doAwaitResponse(runTargetUnload(targets[0], isAsync), function () {
        doUnloadAll(arrSlice(targets, 1), isAsync, done);
      }) : done(), result;
    }
    __name(doUnloadAll, "doUnloadAll");
    var ChannelControllerPriority = 500,
      DisabledPropertyName = "Microsoft_ApplicationInsights_BypassAjaxInstrumentation";
    function _stringToBoolOrDefault(theValue, defaultValue, theConfig) {
      return !theValue && isNullOrUndefined(theValue) ? defaultValue : isBoolean(theValue) ? theValue : asString(theValue)[_DYN_TO_LOWER_CASE]() === "true";
    }
    __name(_stringToBoolOrDefault, "_stringToBoolOrDefault");
    function cfgDfMerge(defaultValue) {
      return {
        mrg: !0,
        v: defaultValue
      };
    }
    __name(cfgDfMerge, "cfgDfMerge");
    function cfgDfValidate(validator, defaultValue, fallBackName) {
      return {
        fb: fallBackName,
        isVal: validator,
        v: defaultValue
      };
    }
    __name(cfgDfValidate, "cfgDfValidate");
    function cfgDfBoolean(defaultValue, fallBackName) {
      return {
        fb: fallBackName,
        set: _stringToBoolOrDefault,
        v: !!defaultValue
      };
    }
    __name(cfgDfBoolean, "cfgDfBoolean");
    var listenerFuncs = [STR_EVENTS_SENT, STR_EVENTS_DISCARDED, STR_EVENTS_SEND_REQUEST, STR_PERF_EVENT],
      _aiNamespace = null,
      _debugListener;
    function _listenerProxyFunc(name, config) {
      return function () {
        var args = arguments,
          dbgExt = getDebugExt(config);
        if (dbgExt) {
          var listener = dbgExt.listener;
          listener && listener[name] && listener[name][_DYN_APPLY](listener, args);
        }
      };
    }
    __name(_listenerProxyFunc, "_listenerProxyFunc");
    function _getExtensionNamespace() {
      var target = getInst("Microsoft");
      return target && (_aiNamespace = target.ApplicationInsights), _aiNamespace;
    }
    __name(_getExtensionNamespace, "_getExtensionNamespace");
    function getDebugExt(config) {
      var ns = _aiNamespace;
      return !ns && config.disableDbgExt !== !0 && (ns = _aiNamespace || _getExtensionNamespace()), ns ? ns.ChromeDbgExt : null;
    }
    __name(getDebugExt, "getDebugExt");
    function getDebugListener(config) {
      if (!_debugListener) {
        _debugListener = {};
        for (var lp = 0; lp < listenerFuncs[_DYN_LENGTH]; lp++) _debugListener[listenerFuncs[lp]] = _listenerProxyFunc(listenerFuncs[lp], config);
      }
      return _debugListener;
    }
    __name(getDebugListener, "getDebugListener");
    var _a,
      STR_WARN_TO_CONSOLE = "warnToConsole",
      AiNonUserActionablePrefix = "AI (Internal): ",
      AiUserActionablePrefix = "AI: ",
      AIInternalMessagePrefix = "AITR_",
      defaultValues = {
        loggingLevelConsole: 0,
        loggingLevelTelemetry: 1,
        maxMessageLimit: 25,
        enableDebug: !1
      },
      _logFuncs = (_a = {}, _a[0] = null, _a[1] = "errorToConsole", _a[2] = STR_WARN_TO_CONSOLE, _a[3] = "debugToConsole", _a);
    function _sanitizeDiagnosticText(text) {
      return text ? '"' + text[_DYN_REPLACE](/\"/g, STR_EMPTY) + '"' : STR_EMPTY;
    }
    __name(_sanitizeDiagnosticText, "_sanitizeDiagnosticText");
    function _logToConsole(func, message) {
      var theConsole = getConsole();
      if (theConsole) {
        var logFunc = "log";
        theConsole[func] && (logFunc = func), isFunction(theConsole[logFunc]) && theConsole[logFunc](message);
      }
    }
    __name(_logToConsole, "_logToConsole");
    var _InternalLogMessage = function () {
      function _InternalLogMessage(msgId, msg, isUserAct, properties) {
        isUserAct === void 0 && (isUserAct = !1);
        var _self = this;
        _self[_DYN_MESSAGE_ID] = msgId, _self[_DYN_MESSAGE] = (isUserAct ? AiUserActionablePrefix : AiNonUserActionablePrefix) + msgId;
        var strProps = STR_EMPTY;
        hasJSON() && (strProps = getJSON().stringify(properties));
        var diagnosticText = (msg ? " message:" + _sanitizeDiagnosticText(msg) : STR_EMPTY) + (properties ? " props:" + _sanitizeDiagnosticText(strProps) : STR_EMPTY);
        _self[_DYN_MESSAGE] += diagnosticText;
      }
      return __name(_InternalLogMessage, "_InternalLogMessage"), _InternalLogMessage.dataType = "MessageData", _InternalLogMessage;
    }();
    function safeGetLogger(core, config) {
      return (core || {})[_DYN_LOGGER] || new DiagnosticLogger(config);
    }
    __name(safeGetLogger, "safeGetLogger");
    var DiagnosticLogger = function () {
      function DiagnosticLogger(config) {
        this.identifier = "DiagnosticLogger", this.queue = [];
        var _messageCount = 0,
          _messageLogged = {},
          _loggingLevelConsole,
          _loggingLevelTelemetry,
          _maxInternalMessageLimit,
          _enableDebug,
          _unloadHandler;
        dynamicProto(DiagnosticLogger, this, function (_self) {
          _unloadHandler = _setDefaultsFromConfig(config || {}), _self.consoleLoggingLevel = function () {
            return _loggingLevelConsole;
          }, _self[_DYN_THROW_INTERNAL] = function (severity, msgId, msg, properties, isUserAct) {
            isUserAct === void 0 && (isUserAct = !1);
            var message = new _InternalLogMessage(msgId, msg, isUserAct, properties);
            if (_enableDebug) throw dumpObj(message);
            var logFunc = _logFuncs[severity] || STR_WARN_TO_CONSOLE;
            if (isUndefined(message[_DYN_MESSAGE])) _debugExtMsg("throw" + (severity === 1 ? "Critical" : "Warning"), message);else {
              if (isUserAct) {
                var messageKey = +message[_DYN_MESSAGE_ID];
                !_messageLogged[messageKey] && _loggingLevelConsole >= severity && (_self[logFunc](message[_DYN_MESSAGE]), _messageLogged[messageKey] = !0);
              } else _loggingLevelConsole >= severity && _self[logFunc](message[_DYN_MESSAGE]);
              _logInternalMessage(severity, message);
            }
          }, _self.debugToConsole = function (message) {
            _logToConsole("debug", message), _debugExtMsg("warning", message);
          }, _self[_DYN_WARN_TO_CONSOLE] = function (message) {
            _logToConsole("warn", message), _debugExtMsg("warning", message);
          }, _self.errorToConsole = function (message) {
            _logToConsole("error", message), _debugExtMsg("error", message);
          }, _self.resetInternalMessageCount = function () {
            _messageCount = 0, _messageLogged = {};
          }, _self.logInternalMessage = _logInternalMessage, _self[_DYN_UNLOAD] = function (isAsync) {
            _unloadHandler && _unloadHandler.rm(), _unloadHandler = null;
          };
          function _logInternalMessage(severity, message) {
            if (!_areInternalMessagesThrottled()) {
              var logMessage = !0,
                messageKey = AIInternalMessagePrefix + message[_DYN_MESSAGE_ID];
              if (_messageLogged[messageKey] ? logMessage = !1 : _messageLogged[messageKey] = !0, logMessage && (severity <= _loggingLevelTelemetry && (_self.queue[_DYN_PUSH](message), _messageCount++, _debugExtMsg(severity === 1 ? "error" : "warn", message)), _messageCount === _maxInternalMessageLimit)) {
                var throttleLimitMessage = "Internal events throttle limit per PageView reached for this app.",
                  throttleMessage = new _InternalLogMessage(23, throttleLimitMessage, !1);
                _self.queue[_DYN_PUSH](throttleMessage), severity === 1 ? _self.errorToConsole(throttleLimitMessage) : _self[_DYN_WARN_TO_CONSOLE](throttleLimitMessage);
              }
            }
          }
          __name(_logInternalMessage, "_logInternalMessage");
          function _setDefaultsFromConfig(config) {
            return onConfigChange(createDynamicConfig(config, defaultValues, _self).cfg, function (details) {
              var config = details.cfg;
              _loggingLevelConsole = config[_DYN_LOGGING_LEVEL_CONSOL4], _loggingLevelTelemetry = config.loggingLevelTelemetry, _maxInternalMessageLimit = config.maxMessageLimit, _enableDebug = config.enableDebug;
            });
          }
          __name(_setDefaultsFromConfig, "_setDefaultsFromConfig");
          function _areInternalMessagesThrottled() {
            return _messageCount >= _maxInternalMessageLimit;
          }
          __name(_areInternalMessagesThrottled, "_areInternalMessagesThrottled");
          function _debugExtMsg(name, data) {
            var dbgExt = getDebugExt(config || {});
            dbgExt && dbgExt[_DYN_DIAG_LOG] && dbgExt[_DYN_DIAG_LOG](name, data);
          }
          __name(_debugExtMsg, "_debugExtMsg");
        });
      }
      return __name(DiagnosticLogger, "DiagnosticLogger"), f.__ieDyn = 1, DiagnosticLogger;
    }();
    function _getLogger(logger) {
      return logger || new DiagnosticLogger();
    }
    __name(_getLogger, "_getLogger");
    function _throwInternal(logger, severity, msgId, msg, properties, isUserAct) {
      isUserAct === void 0 && (isUserAct = !1), _getLogger(logger)[_DYN_THROW_INTERNAL](severity, msgId, msg, properties, isUserAct);
    }
    __name(_throwInternal, "_throwInternal");
    function _warnToConsole(logger, message) {
      _getLogger(logger)[_DYN_WARN_TO_CONSOLE](message);
    }
    __name(_warnToConsole, "_warnToConsole");
    var _a,
      _b,
      strToGMTString = "toGMTString",
      strToUTCString = "toUTCString",
      strCookie = "cookie",
      strExpires = "expires",
      strIsCookieUseDisabled = "isCookieUseDisabled",
      strDisableCookiesUsage = "disableCookiesUsage",
      strConfigCookieMgr = "_ckMgr",
      _supportsCookies = null,
      _allowUaSameSite = null,
      _parsedCookieValue = null,
      _doc,
      _cookieCache = {},
      _globalCookieConfig = {},
      rootDefaultConfig = (_a = {
        cookieCfg: cfgDfMerge((_b = {}, _b[STR_DOMAIN] = {
          fb: "cookieDomain",
          dfVal: isNotNullOrUndefined
        }, _b.path = {
          fb: "cookiePath",
          dfVal: isNotNullOrUndefined
        }, _b.enabled = UNDEFINED_VALUE, _b.ignoreCookies = UNDEFINED_VALUE, _b.blockedCookies = UNDEFINED_VALUE, _b)),
        cookieDomain: UNDEFINED_VALUE,
        cookiePath: UNDEFINED_VALUE
      }, _a[strDisableCookiesUsage] = UNDEFINED_VALUE, _a);
    function _getDoc() {
      !_doc && (_doc = getLazy(function () {
        return getDocument();
      }));
    }
    __name(_getDoc, "_getDoc");
    function _isMgrEnabled(cookieMgr) {
      return cookieMgr ? cookieMgr.isEnabled() : !0;
    }
    __name(_isMgrEnabled, "_isMgrEnabled");
    function _isIgnoredCookie(cookieMgrCfg, name) {
      return name && cookieMgrCfg && isArray(cookieMgrCfg.ignoreCookies) ? arrIndexOf(cookieMgrCfg.ignoreCookies, name) !== -1 : !1;
    }
    __name(_isIgnoredCookie, "_isIgnoredCookie");
    function _isBlockedCookie(cookieMgrCfg, name) {
      return name && cookieMgrCfg && isArray(cookieMgrCfg.blockedCookies) && arrIndexOf(cookieMgrCfg.blockedCookies, name) !== -1 ? !0 : _isIgnoredCookie(cookieMgrCfg, name);
    }
    __name(_isBlockedCookie, "_isBlockedCookie");
    function _isCfgEnabled(rootConfig, cookieMgrConfig) {
      var isCfgEnabled = cookieMgrConfig[_DYN_ENABLED];
      if (isNullOrUndefined(isCfgEnabled)) {
        var cookieEnabled = void 0;
        isUndefined(rootConfig[strIsCookieUseDisabled]) || (cookieEnabled = !rootConfig[strIsCookieUseDisabled]), isUndefined(rootConfig[strDisableCookiesUsage]) || (cookieEnabled = !rootConfig[strDisableCookiesUsage]), isCfgEnabled = cookieEnabled;
      }
      return isCfgEnabled;
    }
    __name(_isCfgEnabled, "_isCfgEnabled");
    function createCookieMgr(rootConfig, logger) {
      var cookieMgrConfig, _path, _domain, unloadHandler, _enabled, _getCookieFn, _setCookieFn, _delCookieFn;
      rootConfig = createDynamicConfig(rootConfig || _globalCookieConfig, null, logger).cfg, unloadHandler = onConfigChange(rootConfig, function (details) {
        details.setDf(details.cfg, rootDefaultConfig), cookieMgrConfig = details.ref(details.cfg, "cookieCfg"), _path = cookieMgrConfig[STR_PATH] || "/", _domain = cookieMgrConfig[STR_DOMAIN], _enabled = _isCfgEnabled(rootConfig, cookieMgrConfig) !== !1, _getCookieFn = cookieMgrConfig.getCookie || _getCookieValue, _setCookieFn = cookieMgrConfig.setCookie || _setCookieValue, _delCookieFn = cookieMgrConfig.delCookie || _setCookieValue;
      }, logger);
      var cookieMgr = {
        isEnabled: __name(function () {
          var enabled = _isCfgEnabled(rootConfig, cookieMgrConfig) !== !1 && _enabled && areCookiesSupported(logger),
            gblManager = _globalCookieConfig[strConfigCookieMgr];
          return enabled && gblManager && cookieMgr !== gblManager && (enabled = _isMgrEnabled(gblManager)), enabled;
        }, "isEnabled"),
        setEnabled: __name(function (value) {
          _enabled = value !== !1, cookieMgrConfig[_DYN_ENABLED] = value;
        }, "setEnabled"),
        set: __name(function (name, value, maxAgeSec, domain, path) {
          var result = !1;
          if (_isMgrEnabled(cookieMgr) && !_isBlockedCookie(cookieMgrConfig, name)) {
            var values = {},
              theValue = strTrim(value || STR_EMPTY),
              idx = strIndexOf(theValue, ";");
            if (idx !== -1 && (theValue = strTrim(strLeft(value, idx)), values = _extractParts(strSubstring(value, idx + 1))), setValue(values, STR_DOMAIN, domain || _domain, isTruthy, isUndefined), !isNullOrUndefined(maxAgeSec)) {
              var _isIE = isIE();
              if (isUndefined(values[strExpires])) {
                var nowMs = utcNow(),
                  expireMs = nowMs + maxAgeSec * 1e3;
                if (expireMs > 0) {
                  var expiry = new Date();
                  expiry.setTime(expireMs), setValue(values, strExpires, _formatDate(expiry, _isIE ? strToGMTString : strToUTCString) || _formatDate(expiry, _isIE ? strToGMTString : strToUTCString) || STR_EMPTY, isTruthy);
                }
              }
              _isIE || setValue(values, "max-age", STR_EMPTY + maxAgeSec, null, isUndefined);
            }
            var location_1 = getLocation();
            location_1 && location_1.protocol === "https:" && (setValue(values, "secure", null, null, isUndefined), _allowUaSameSite === null && (_allowUaSameSite = !uaDisallowsSameSiteNone((getNavigator() || {})[_DYN_USER_AGENT])), _allowUaSameSite && setValue(values, "SameSite", "None", null, isUndefined)), setValue(values, STR_PATH, path || _path, null, isUndefined), _setCookieFn(name, _formatCookieValue(theValue, values)), result = !0;
          }
          return result;
        }, "set"),
        get: __name(function (name) {
          var value = STR_EMPTY;
          return _isMgrEnabled(cookieMgr) && !_isIgnoredCookie(cookieMgrConfig, name) && (value = _getCookieFn(name)), value;
        }, "get"),
        del: __name(function (name, path) {
          var result = !1;
          return _isMgrEnabled(cookieMgr) && (result = cookieMgr.purge(name, path)), result;
        }, "del"),
        purge: __name(function (name, path) {
          var _a,
            result = !1;
          if (areCookiesSupported(logger)) {
            var values = (_a = {}, _a[STR_PATH] = path || "/", _a[strExpires] = "Thu, 01 Jan 1970 00:00:01 GMT", _a);
            isIE() || (values["max-age"] = "0"), _delCookieFn(name, _formatCookieValue(STR_EMPTY, values)), result = !0;
          }
          return result;
        }, "purge"),
        unload: __name(function (isAsync) {
          unloadHandler && unloadHandler.rm(), unloadHandler = null;
        }, "unload")
      };
      return cookieMgr[strConfigCookieMgr] = cookieMgr, cookieMgr;
    }
    __name(createCookieMgr, "createCookieMgr");
    function areCookiesSupported(logger) {
      if (_supportsCookies === null) {
        _supportsCookies = !1, !_doc && _getDoc();
        try {
          var doc = _doc.v || {};
          _supportsCookies = doc[strCookie] !== void 0;
        } catch (e) {
          _throwInternal(logger, 2, 68, "Cannot access document.cookie - " + getExceptionName(e), {
            exception: dumpObj(e)
          });
        }
      }
      return _supportsCookies;
    }
    __name(areCookiesSupported, "areCookiesSupported");
    function _extractParts(theValue) {
      var values = {};
      if (theValue && theValue[_DYN_LENGTH]) {
        var parts = strTrim(theValue)[_DYN_SPLIT](";");
        arrForEach(parts, function (thePart) {
          if (thePart = strTrim(thePart || STR_EMPTY), thePart) {
            var idx = strIndexOf(thePart, "=");
            idx === -1 ? values[thePart] = null : values[strTrim(strLeft(thePart, idx))] = strTrim(strSubstring(thePart, idx + 1));
          }
        });
      }
      return values;
    }
    __name(_extractParts, "_extractParts");
    function _formatDate(theDate, func) {
      return isFunction(theDate[func]) ? theDate[func]() : null;
    }
    __name(_formatDate, "_formatDate");
    function _formatCookieValue(value, values) {
      var cookieValue = value || STR_EMPTY;
      return objForEachKey(values, function (name, theValue) {
        cookieValue += "; " + name + (isNullOrUndefined(theValue) ? STR_EMPTY : "=" + theValue);
      }), cookieValue;
    }
    __name(_formatCookieValue, "_formatCookieValue");
    function _getCookieValue(name) {
      var cookieValue = STR_EMPTY;
      if (!_doc && _getDoc(), _doc.v) {
        var theCookie = _doc.v[strCookie] || STR_EMPTY;
        _parsedCookieValue !== theCookie && (_cookieCache = _extractParts(theCookie), _parsedCookieValue = theCookie), cookieValue = strTrim(_cookieCache[name] || STR_EMPTY);
      }
      return cookieValue;
    }
    __name(_getCookieValue, "_getCookieValue");
    function _setCookieValue(name, cookieValue) {
      !_doc && _getDoc(), _doc.v && (_doc.v[strCookie] = name + "=" + cookieValue);
    }
    __name(_setCookieValue, "_setCookieValue");
    function uaDisallowsSameSiteNone(userAgent) {
      return isString(userAgent) ? !!(strContains(userAgent, "CPU iPhone OS 12") || strContains(userAgent, "iPad; CPU OS 12") || strContains(userAgent, "Macintosh; Intel Mac OS X 10_14") && strContains(userAgent, "Version/") && strContains(userAgent, "Safari") || strContains(userAgent, "Macintosh; Intel Mac OS X 10_14") && strEndsWith(userAgent, "AppleWebKit/605.1.15 (KHTML, like Gecko)") || strContains(userAgent, "Chrome/5") || strContains(userAgent, "Chrome/6") || strContains(userAgent, "UnrealEngine") && !strContains(userAgent, "Chrome") || strContains(userAgent, "UCBrowser/12") || strContains(userAgent, "UCBrowser/11")) : !1;
    }
    __name(uaDisallowsSameSiteNone, "uaDisallowsSameSiteNone");
    var defaultValues = {
      perfEvtsSendAll: !1
    };
    function _runScheduledListeners(asyncNotifications) {
      asyncNotifications.h = null;
      var callbacks = asyncNotifications.cb;
      asyncNotifications.cb = [], arrForEach(callbacks, function (cb) {
        safe(cb.fn, [cb.arg]);
      });
    }
    __name(_runScheduledListeners, "_runScheduledListeners");
    function _runListeners(listeners, name, asyncNotifications, callback) {
      arrForEach(listeners, function (listener) {
        listener && listener[name] && (asyncNotifications ? (asyncNotifications.cb[_DYN_PUSH]({
          fn: callback,
          arg: listener
        }), asyncNotifications.h = asyncNotifications.h || scheduleTimeout(_runScheduledListeners, 0, asyncNotifications)) : safe(callback, [listener]));
      });
    }
    __name(_runListeners, "_runListeners");
    var NotificationManager = function () {
        function NotificationManager(config) {
          this.listeners = [];
          var perfEvtsSendAll,
            unloadHandler,
            _listeners = [],
            _asyncNotifications = {
              h: null,
              cb: []
            },
            cfgHandler = createDynamicConfig(config, defaultValues);
          unloadHandler = cfgHandler[_DYN_WATCH](function (details) {
            perfEvtsSendAll = !!details.cfg.perfEvtsSendAll;
          }), dynamicProto(NotificationManager, this, function (_self) {
            objDefine(_self, "listeners", {
              g: __name(function () {
                return _listeners;
              }, "g")
            }), _self[_DYN_ADD_NOTIFICATION_LIS1] = function (listener) {
              _listeners[_DYN_PUSH](listener);
            }, _self[_DYN_REMOVE_NOTIFICATION_0] = function (listener) {
              for (var index = arrIndexOf(_listeners, listener); index > -1;) _listeners[_DYN_SPLICE](index, 1), index = arrIndexOf(_listeners, listener);
            }, _self[STR_EVENTS_SENT] = function (events) {
              _runListeners(_listeners, STR_EVENTS_SENT, _asyncNotifications, function (listener) {
                listener[STR_EVENTS_SENT](events);
              });
            }, _self[STR_EVENTS_DISCARDED] = function (events, reason) {
              _runListeners(_listeners, STR_EVENTS_DISCARDED, _asyncNotifications, function (listener) {
                listener[STR_EVENTS_DISCARDED](events, reason);
              });
            }, _self[STR_EVENTS_SEND_REQUEST] = function (sendReason, isAsync) {
              _runListeners(_listeners, STR_EVENTS_SEND_REQUEST, isAsync ? _asyncNotifications : null, function (listener) {
                listener[STR_EVENTS_SEND_REQUEST](sendReason, isAsync);
              });
            }, _self[STR_PERF_EVENT] = function (perfEvent) {
              perfEvent && (perfEvtsSendAll || !perfEvent[_DYN_IS_CHILD_EVT]()) && _runListeners(_listeners, STR_PERF_EVENT, null, function (listener) {
                perfEvent.isAsync ? scheduleTimeout(function () {
                  return listener[STR_PERF_EVENT](perfEvent);
                }, 0) : listener[STR_PERF_EVENT](perfEvent);
              });
            }, _self[STR_OFFLINE_STORE] = function (events) {
              events && events[_DYN_LENGTH] && _runListeners(_listeners, STR_OFFLINE_STORE, _asyncNotifications, function (listener) {
                listener[STR_OFFLINE_STORE](events);
              });
            }, _self[STR_OFFLINE_SENT] = function (batch) {
              batch && batch[_DYN_DATA] && _runListeners(_listeners, STR_OFFLINE_SENT, _asyncNotifications, function (listener) {
                listener[STR_OFFLINE_SENT](batch);
              });
            }, _self[STR_OFFLINE_DROP] = function (cnt, reason) {
              if (cnt > 0) {
                var rn_1 = reason || 0;
                _runListeners(_listeners, STR_OFFLINE_DROP, _asyncNotifications, function (listener) {
                  listener[STR_OFFLINE_DROP](cnt, rn_1);
                });
              }
            }, _self[_DYN_UNLOAD] = function (isAsync) {
              var _finishUnload = __name(function () {
                  unloadHandler && unloadHandler.rm(), unloadHandler = null, _listeners = [], _asyncNotifications.h && _asyncNotifications.h[_DYN_CANCEL](), _asyncNotifications.h = null, _asyncNotifications.cb = [];
                }, "_finishUnload"),
                waiting;
              if (_runListeners(_listeners, "unload", null, function (listener) {
                var asyncUnload = listener[_DYN_UNLOAD](isAsync);
                asyncUnload && (waiting || (waiting = []), waiting[_DYN_PUSH](asyncUnload));
              }), waiting) return createPromise(function (resolve) {
                return doAwaitResponse(createAllPromise(waiting), function () {
                  _finishUnload(), resolve();
                });
              });
              _finishUnload();
            };
          });
        }
        return __name(NotificationManager, "NotificationManager"), f.__ieDyn = 1, NotificationManager;
      }(),
      strExecutionContextKey = "ctx",
      strParentContextKey = "ParentContextKey",
      strChildrenContextKey = "ChildrenContextKey",
      _defaultPerfManager = null,
      PerfEvent = function () {
        function PerfEvent(name, payloadDetails, isAsync) {
          var _self = this;
          if (_self.start = utcNow(), _self[_DYN_NAME] = name, _self.isAsync = isAsync, _self[_DYN_IS_CHILD_EVT] = function () {
            return !1;
          }, isFunction(payloadDetails)) {
            var theDetails_1;
            objDefine(_self, "payload", {
              g: __name(function () {
                return !theDetails_1 && isFunction(payloadDetails) && (theDetails_1 = payloadDetails(), payloadDetails = null), theDetails_1;
              }, "g")
            });
          }
          _self[_DYN_GET_CTX] = function (key) {
            return key ? key === PerfEvent[strParentContextKey] || key === PerfEvent[strChildrenContextKey] ? _self[key] : (_self[strExecutionContextKey] || {})[key] : null;
          }, _self[_DYN_SET_CTX] = function (key, value) {
            if (key) if (key === PerfEvent[strParentContextKey]) _self[key] || (_self[_DYN_IS_CHILD_EVT] = function () {
              return !0;
            }), _self[key] = value;else if (key === PerfEvent[strChildrenContextKey]) _self[key] = value;else {
              var ctx = _self[strExecutionContextKey] = _self[strExecutionContextKey] || {};
              ctx[key] = value;
            }
          }, _self.complete = function () {
            var childTime = 0,
              childEvts = _self[_DYN_GET_CTX](PerfEvent[strChildrenContextKey]);
            if (isArray(childEvts)) for (var lp = 0; lp < childEvts[_DYN_LENGTH]; lp++) {
              var childEvt = childEvts[lp];
              childEvt && (childTime += childEvt.time);
            }
            _self.time = utcNow() - _self.start, _self.exTime = _self.time - childTime, _self.complete = function () {};
          };
        }
        return __name(PerfEvent, "PerfEvent"), PerfEvent.ParentContextKey = "parent", PerfEvent.ChildrenContextKey = "childEvts", PerfEvent;
      }(),
      PerfManager = function () {
        function PerfManager(manager) {
          this.ctx = {}, dynamicProto(PerfManager, this, function (_self) {
            _self.create = function (src, payloadDetails, isAsync) {
              return new PerfEvent(src, payloadDetails, isAsync);
            }, _self.fire = function (perfEvent) {
              perfEvent && (perfEvent.complete(), manager && isFunction(manager[STR_PERF_EVENT]) && manager[STR_PERF_EVENT](perfEvent));
            }, _self[_DYN_SET_CTX] = function (key, value) {
              if (key) {
                var ctx = _self[strExecutionContextKey] = _self[strExecutionContextKey] || {};
                ctx[key] = value;
              }
            }, _self[_DYN_GET_CTX] = function (key) {
              return (_self[strExecutionContextKey] || {})[key];
            };
          });
        }
        return __name(PerfManager, "PerfManager"), f.__ieDyn = 1, PerfManager;
      }(),
      doPerfActiveKey = "CoreUtils.doPerf";
    function doPerf(mgrSource, getSource, func, details, isAsync) {
      if (mgrSource) {
        var perfMgr = mgrSource;
        if (perfMgr[STR_GET_PERF_MGR] && (perfMgr = perfMgr[STR_GET_PERF_MGR]()), perfMgr) {
          var perfEvt = void 0,
            currentActive = perfMgr[_DYN_GET_CTX](doPerfActiveKey);
          try {
            if (perfEvt = perfMgr.create(getSource(), details, isAsync), perfEvt) {
              if (currentActive && perfEvt[_DYN_SET_CTX] && (perfEvt[_DYN_SET_CTX](PerfEvent[strParentContextKey], currentActive), currentActive[_DYN_GET_CTX] && currentActive[_DYN_SET_CTX])) {
                var children = currentActive[_DYN_GET_CTX](PerfEvent[strChildrenContextKey]);
                children || (children = [], currentActive[_DYN_SET_CTX](PerfEvent[strChildrenContextKey], children)), children[_DYN_PUSH](perfEvt);
              }
              return perfMgr[_DYN_SET_CTX](doPerfActiveKey, perfEvt), func(perfEvt);
            }
          } catch (ex) {
            perfEvt && perfEvt[_DYN_SET_CTX] && perfEvt[_DYN_SET_CTX]("exception", ex);
          } finally {
            perfEvt && perfMgr.fire(perfEvt), perfMgr[_DYN_SET_CTX](doPerfActiveKey, currentActive);
          }
        }
      }
      return func();
    }
    __name(doPerf, "doPerf");
    function getGblPerfMgr() {
      return _defaultPerfManager;
    }
    __name(getGblPerfMgr, "getGblPerfMgr");
    var INVALID_TRACE_ID = "00000000000000000000000000000000",
      INVALID_SPAN_ID = "0000000000000000";
    function _isValid(value, len, invalidValue) {
      return value && value[_DYN_LENGTH] === len && value !== invalidValue ? !!value.match(/^[\da-f]*$/i) : !1;
    }
    __name(_isValid, "_isValid");
    function isValidTraceId(value) {
      return _isValid(value, 32, INVALID_TRACE_ID);
    }
    __name(isValidTraceId, "isValidTraceId");
    function isValidSpanId(value) {
      return _isValid(value, 16, INVALID_SPAN_ID);
    }
    __name(isValidSpanId, "isValidSpanId");
    var pluginStateData = createElmNodeData("plugin");
    function _getPluginState(plugin) {
      return pluginStateData.get(plugin, "state", {}, !0);
    }
    __name(_getPluginState, "_getPluginState");
    function initializePlugins(processContext, extensions) {
      for (var initPlugins = [], lastPlugin = null, proxy = processContext[_DYN_GET_NEXT](), pluginState; proxy;) {
        var thePlugin = proxy[_DYN_GET_PLUGIN]();
        if (thePlugin) {
          lastPlugin && lastPlugin[_DYN_SET_NEXT_PLUGIN] && thePlugin[STR_PROCESS_TELEMETRY] && lastPlugin[_DYN_SET_NEXT_PLUGIN](thePlugin), pluginState = _getPluginState(thePlugin);
          var isInitialized = !!pluginState[_DYN_IS_INITIALIZED];
          thePlugin[_DYN_IS_INITIALIZED] && (isInitialized = thePlugin[_DYN_IS_INITIALIZED]()), isInitialized || initPlugins[_DYN_PUSH](thePlugin), lastPlugin = thePlugin, proxy = proxy[_DYN_GET_NEXT]();
        }
      }
      arrForEach(initPlugins, function (thePlugin) {
        var core = processContext[STR_CORE]();
        thePlugin[_DYN_INITIALIZE](processContext.getCfg(), core, extensions, processContext[_DYN_GET_NEXT]()), pluginState = _getPluginState(thePlugin), !thePlugin[STR_CORE] && !pluginState[STR_CORE] && (pluginState[STR_CORE] = core), pluginState[_DYN_IS_INITIALIZED] = !0, delete pluginState[_DYN_TEARDOWN];
      });
    }
    __name(initializePlugins, "initializePlugins");
    function sortPlugins(plugins) {
      return plugins.sort(function (extA, extB) {
        var result = 0;
        if (extB) {
          var bHasProcess = extB[STR_PROCESS_TELEMETRY];
          extA[STR_PROCESS_TELEMETRY] ? result = bHasProcess ? extA[STR_PRIORITY] - extB[STR_PRIORITY] : 1 : bHasProcess && (result = -1);
        } else result = extA ? 1 : -1;
        return result;
      });
    }
    __name(sortPlugins, "sortPlugins");
    function createDistributedTraceContext(parentCtx) {
      var trace = {};
      return {
        getName: __name(function () {
          return trace[_DYN_NAME];
        }, "getName"),
        setName: __name(function (newValue) {
          parentCtx && parentCtx.setName(newValue), trace[_DYN_NAME] = newValue;
        }, "setName"),
        getTraceId: __name(function () {
          return trace.traceId;
        }, "getTraceId"),
        setTraceId: __name(function (newValue) {
          parentCtx && parentCtx.setTraceId(newValue), isValidTraceId(newValue) && (trace.traceId = newValue);
        }, "setTraceId"),
        getSpanId: __name(function () {
          return trace.spanId;
        }, "getSpanId"),
        setSpanId: __name(function (newValue) {
          parentCtx && parentCtx.setSpanId(newValue), isValidSpanId(newValue) && (trace.spanId = newValue);
        }, "setSpanId"),
        getTraceFlags: __name(function () {
          return trace[_DYN_TRACE_FLAGS];
        }, "getTraceFlags"),
        setTraceFlags: __name(function (newTraceFlags) {
          parentCtx && parentCtx.setTraceFlags(newTraceFlags), trace[_DYN_TRACE_FLAGS] = newTraceFlags;
        }, "setTraceFlags")
      };
    }
    __name(createDistributedTraceContext, "createDistributedTraceContext");
    var strTelemetryPluginChain = "TelemetryPluginChain",
      strHasRunFlags = "_hasRun",
      strGetTelCtx = "_getTelCtx",
      _chainId = 0;
    function _getNextProxyStart(proxy, core, startAt) {
      for (; proxy;) {
        if (proxy[_DYN_GET_PLUGIN]() === startAt) return proxy;
        proxy = proxy[_DYN_GET_NEXT]();
      }
      return createTelemetryProxyChain([startAt], core.config || {}, core);
    }
    __name(_getNextProxyStart, "_getNextProxyStart");
    function _createInternalContext(telemetryChain, dynamicHandler, core, startAt) {
      var _nextProxy = null,
        _onComplete = [];
      dynamicHandler || (dynamicHandler = createDynamicConfig({}, null, core[_DYN_LOGGER])), startAt !== null && (_nextProxy = startAt ? _getNextProxyStart(telemetryChain, core, startAt) : telemetryChain);
      var context = {
        _next: _moveNext,
        ctx: {
          core: __name(function () {
            return core;
          }, "core"),
          diagLog: __name(function () {
            return safeGetLogger(core, dynamicHandler.cfg);
          }, "diagLog"),
          getCfg: __name(function () {
            return dynamicHandler.cfg;
          }, "getCfg"),
          getExtCfg: _resolveExtCfg,
          getConfig: _getConfig,
          hasNext: __name(function () {
            return !!_nextProxy;
          }, "hasNext"),
          getNext: __name(function () {
            return _nextProxy;
          }, "getNext"),
          setNext: __name(function (nextPlugin) {
            _nextProxy = nextPlugin;
          }, "setNext"),
          iterate: _iterateChain,
          onComplete: _addOnComplete
        }
      };
      function _addOnComplete(onComplete, that) {
        for (var args = [], _i = 2; _i < arguments.length; _i++) args[_i - 2] = arguments[_i];
        onComplete && _onComplete[_DYN_PUSH]({
          func: onComplete,
          self: isUndefined(that) ? context.ctx : that,
          args: args
        });
      }
      __name(_addOnComplete, "_addOnComplete");
      function _moveNext() {
        var nextProxy = _nextProxy;
        if (_nextProxy = nextProxy ? nextProxy[_DYN_GET_NEXT]() : null, !nextProxy) {
          var onComplete = _onComplete;
          onComplete && onComplete[_DYN_LENGTH] > 0 && (arrForEach(onComplete, function (completeDetails) {
            try {
              completeDetails.func.call(completeDetails.self, completeDetails.args);
            } catch (e) {
              _throwInternal(core[_DYN_LOGGER], 2, 73, "Unexpected Exception during onComplete - " + dumpObj(e));
            }
          }), _onComplete = []);
        }
        return nextProxy;
      }
      __name(_moveNext, "_moveNext");
      function _getExtCfg(identifier, createIfMissing) {
        var idCfg = null,
          cfg = dynamicHandler.cfg;
        if (cfg && identifier) {
          var extCfg = cfg[STR_EXTENSION_CONFIG];
          !extCfg && createIfMissing && (extCfg = {}), cfg[STR_EXTENSION_CONFIG] = extCfg, extCfg = dynamicHandler.ref(cfg, STR_EXTENSION_CONFIG), extCfg && (idCfg = extCfg[identifier], !idCfg && createIfMissing && (idCfg = {}), extCfg[identifier] = idCfg, idCfg = dynamicHandler.ref(extCfg, identifier));
        }
        return idCfg;
      }
      __name(_getExtCfg, "_getExtCfg");
      function _resolveExtCfg(identifier, defaultValues) {
        var newConfig = _getExtCfg(identifier, !0);
        return defaultValues && objForEachKey(defaultValues, function (field, defaultValue) {
          if (isNullOrUndefined(newConfig[field])) {
            var cfgValue = dynamicHandler.cfg[field];
            (cfgValue || !isNullOrUndefined(cfgValue)) && (newConfig[field] = cfgValue);
          }
          _applyDefaultValue(dynamicHandler, newConfig, field, defaultValue);
        }), dynamicHandler.setDf(newConfig, defaultValues);
      }
      __name(_resolveExtCfg, "_resolveExtCfg");
      function _getConfig(identifier, field, defaultValue) {
        defaultValue === void 0 && (defaultValue = !1);
        var theValue,
          extConfig = _getExtCfg(identifier, !1),
          rootConfig = dynamicHandler.cfg;
        return extConfig && (extConfig[field] || !isNullOrUndefined(extConfig[field])) ? theValue = extConfig[field] : (rootConfig[field] || !isNullOrUndefined(rootConfig[field])) && (theValue = rootConfig[field]), theValue || !isNullOrUndefined(theValue) ? theValue : defaultValue;
      }
      __name(_getConfig, "_getConfig");
      function _iterateChain(cb) {
        for (var nextPlugin; nextPlugin = context._next();) {
          var plugin = nextPlugin[_DYN_GET_PLUGIN]();
          plugin && cb(plugin);
        }
      }
      return __name(_iterateChain, "_iterateChain"), context;
    }
    __name(_createInternalContext, "_createInternalContext");
    function createProcessTelemetryContext(telemetryChain, cfg, core, startAt) {
      var config = createDynamicConfig(cfg),
        internalContext = _createInternalContext(telemetryChain, config, core, startAt),
        context = internalContext.ctx;
      function _processNext(env) {
        var nextPlugin = internalContext._next();
        return nextPlugin && nextPlugin[STR_PROCESS_TELEMETRY](env, context), !nextPlugin;
      }
      __name(_processNext, "_processNext");
      function _createNew(plugins, startAt) {
        return plugins === void 0 && (plugins = null), isArray(plugins) && (plugins = createTelemetryProxyChain(plugins, config.cfg, core, startAt)), createProcessTelemetryContext(plugins || context[_DYN_GET_NEXT](), config.cfg, core, startAt);
      }
      return __name(_createNew, "_createNew"), context[_DYN_PROCESS_NEXT] = _processNext, context[_DYN_CREATE_NEW] = _createNew, context;
    }
    __name(createProcessTelemetryContext, "createProcessTelemetryContext");
    function createProcessTelemetryUnloadContext(telemetryChain, core, startAt) {
      var config = createDynamicConfig(core.config),
        internalContext = _createInternalContext(telemetryChain, config, core, startAt),
        context = internalContext.ctx;
      function _processNext(unloadState) {
        var nextPlugin = internalContext._next();
        return nextPlugin && nextPlugin[_DYN_UNLOAD](context, unloadState), !nextPlugin;
      }
      __name(_processNext, "_processNext");
      function _createNew(plugins, startAt) {
        return plugins === void 0 && (plugins = null), isArray(plugins) && (plugins = createTelemetryProxyChain(plugins, config.cfg, core, startAt)), createProcessTelemetryUnloadContext(plugins || context[_DYN_GET_NEXT](), core, startAt);
      }
      return __name(_createNew, "_createNew"), context[_DYN_PROCESS_NEXT] = _processNext, context[_DYN_CREATE_NEW] = _createNew, context;
    }
    __name(createProcessTelemetryUnloadContext, "createProcessTelemetryUnloadContext");
    function createProcessTelemetryUpdateContext(telemetryChain, core, startAt) {
      var config = createDynamicConfig(core.config),
        internalContext = _createInternalContext(telemetryChain, config, core, startAt),
        context = internalContext.ctx;
      function _processNext(updateState) {
        return context.iterate(function (plugin) {
          isFunction(plugin[_DYN_UPDATE]) && plugin[_DYN_UPDATE](context, updateState);
        });
      }
      __name(_processNext, "_processNext");
      function _createNew(plugins, startAt) {
        return plugins === void 0 && (plugins = null), isArray(plugins) && (plugins = createTelemetryProxyChain(plugins, config.cfg, core, startAt)), createProcessTelemetryUpdateContext(plugins || context[_DYN_GET_NEXT](), core, startAt);
      }
      return __name(_createNew, "_createNew"), context[_DYN_PROCESS_NEXT] = _processNext, context[_DYN_CREATE_NEW] = _createNew, context;
    }
    __name(createProcessTelemetryUpdateContext, "createProcessTelemetryUpdateContext");
    function createTelemetryProxyChain(plugins, config, core, startAt) {
      var firstProxy = null,
        add = !startAt;
      if (isArray(plugins) && plugins[_DYN_LENGTH] > 0) {
        var lastProxy_1 = null;
        arrForEach(plugins, function (thePlugin) {
          if (!add && startAt === thePlugin && (add = !0), add && thePlugin && isFunction(thePlugin[STR_PROCESS_TELEMETRY])) {
            var newProxy = createTelemetryPluginProxy(thePlugin, config, core);
            firstProxy || (firstProxy = newProxy), lastProxy_1 && lastProxy_1._setNext(newProxy), lastProxy_1 = newProxy;
          }
        });
      }
      return startAt && !firstProxy ? createTelemetryProxyChain([startAt], config, core) : firstProxy;
    }
    __name(createTelemetryProxyChain, "createTelemetryProxyChain");
    function createTelemetryPluginProxy(plugin, config, core) {
      var nextProxy = null,
        hasProcessTelemetry = isFunction(plugin[STR_PROCESS_TELEMETRY]),
        hasSetNext = isFunction(plugin[_DYN_SET_NEXT_PLUGIN]),
        chainId;
      plugin ? chainId = plugin[_DYN_IDENTIFIER] + "-" + plugin[STR_PRIORITY] + "-" + _chainId++ : chainId = "Unknown-0-" + _chainId++;
      var proxyChain = {
        getPlugin: __name(function () {
          return plugin;
        }, "getPlugin"),
        getNext: __name(function () {
          return nextProxy;
        }, "getNext"),
        processTelemetry: _processTelemetry,
        unload: _unloadPlugin,
        update: _updatePlugin,
        _id: chainId,
        _setNext: __name(function (nextPlugin) {
          nextProxy = nextPlugin;
        }, "_setNext")
      };
      function _getTelCtx() {
        var itemCtx;
        return plugin && isFunction(plugin[strGetTelCtx]) && (itemCtx = plugin[strGetTelCtx]()), itemCtx || (itemCtx = createProcessTelemetryContext(proxyChain, config, core)), itemCtx;
      }
      __name(_getTelCtx, "_getTelCtx");
      function _processChain(itemCtx, processPluginFn, name, details, isAsync) {
        var hasRun = !1,
          identifier = plugin ? plugin[_DYN_IDENTIFIER] : strTelemetryPluginChain,
          hasRunContext = itemCtx[strHasRunFlags];
        return hasRunContext || (hasRunContext = itemCtx[strHasRunFlags] = {}), itemCtx.setNext(nextProxy), plugin && doPerf(itemCtx[STR_CORE](), function () {
          return identifier + ":" + name;
        }, function () {
          hasRunContext[chainId] = !0;
          try {
            var nextId = nextProxy ? nextProxy._id : STR_EMPTY;
            nextId && (hasRunContext[nextId] = !1), hasRun = processPluginFn(itemCtx);
          } catch (error) {
            var hasNextRun = nextProxy ? hasRunContext[nextProxy._id] : !0;
            hasNextRun && (hasRun = !0), (!nextProxy || !hasNextRun) && _throwInternal(itemCtx[_DYN_DIAG_LOG](), 1, 73, "Plugin [" + identifier + "] failed during " + name + " - " + dumpObj(error) + ", run flags: " + dumpObj(hasRunContext));
          }
        }, details, isAsync), hasRun;
      }
      __name(_processChain, "_processChain");
      function _processTelemetry(env, itemCtx) {
        itemCtx = itemCtx || _getTelCtx();
        function _callProcessTelemetry(itemCtx) {
          if (!plugin || !hasProcessTelemetry) return !1;
          var pluginState = _getPluginState(plugin);
          return pluginState[_DYN_TEARDOWN] || pluginState[STR_DISABLED] ? !1 : (hasSetNext && plugin[_DYN_SET_NEXT_PLUGIN](nextProxy), plugin[STR_PROCESS_TELEMETRY](env, itemCtx), !0);
        }
        __name(_callProcessTelemetry, "_callProcessTelemetry"), _processChain(itemCtx, _callProcessTelemetry, "processTelemetry", function () {
          return {
            item: env
          };
        }, !env.sync) || itemCtx[_DYN_PROCESS_NEXT](env);
      }
      __name(_processTelemetry, "_processTelemetry");
      function _unloadPlugin(unloadCtx, unloadState) {
        function _callTeardown() {
          var hasRun = !1;
          if (plugin) {
            var pluginState = _getPluginState(plugin),
              pluginCore = plugin[STR_CORE] || pluginState[STR_CORE];
            plugin && (!pluginCore || pluginCore === unloadCtx.core()) && !pluginState[_DYN_TEARDOWN] && (pluginState[STR_CORE] = null, pluginState[_DYN_TEARDOWN] = !0, pluginState[_DYN_IS_INITIALIZED] = !1, plugin[_DYN_TEARDOWN] && plugin[_DYN_TEARDOWN](unloadCtx, unloadState) === !0 && (hasRun = !0));
          }
          return hasRun;
        }
        __name(_callTeardown, "_callTeardown"), _processChain(unloadCtx, _callTeardown, "unload", function () {}, unloadState.isAsync) || unloadCtx[_DYN_PROCESS_NEXT](unloadState);
      }
      __name(_unloadPlugin, "_unloadPlugin");
      function _updatePlugin(updateCtx, updateState) {
        function _callUpdate() {
          var hasRun = !1;
          if (plugin) {
            var pluginState = _getPluginState(plugin),
              pluginCore = plugin[STR_CORE] || pluginState[STR_CORE];
            plugin && (!pluginCore || pluginCore === updateCtx.core()) && !pluginState[_DYN_TEARDOWN] && plugin[_DYN_UPDATE] && plugin[_DYN_UPDATE](updateCtx, updateState) === !0 && (hasRun = !0);
          }
          return hasRun;
        }
        __name(_callUpdate, "_callUpdate"), _processChain(updateCtx, _callUpdate, "update", function () {}, !1) || updateCtx[_DYN_PROCESS_NEXT](updateState);
      }
      return __name(_updatePlugin, "_updatePlugin"), objFreeze(proxyChain);
    }
    __name(createTelemetryPluginProxy, "createTelemetryPluginProxy");
    function createUnloadHandlerContainer() {
      var handlers = [];
      function _addHandler(handler) {
        handler && handlers[_DYN_PUSH](handler);
      }
      __name(_addHandler, "_addHandler");
      function _runHandlers(unloadCtx, unloadState) {
        arrForEach(handlers, function (handler) {
          try {
            handler(unloadCtx, unloadState);
          } catch (e) {
            _throwInternal(unloadCtx[_DYN_DIAG_LOG](), 2, 73, "Unexpected error calling unload handler - " + dumpObj(e));
          }
        }), handlers = [];
      }
      return __name(_runHandlers, "_runHandlers"), {
        add: _addHandler,
        run: _runHandlers
      };
    }
    __name(createUnloadHandlerContainer, "createUnloadHandlerContainer");
    function createUnloadHookContainer() {
      var _hooks = [];
      function _doUnload(logger) {
        var oldHooks = _hooks;
        _hooks = [], arrForEach(oldHooks, function (fn) {
          try {
            (fn.rm || fn.remove).call(fn);
          } catch (e) {
            _throwInternal(logger, 2, 73, "Unloading:" + dumpObj(e));
          }
        });
      }
      __name(_doUnload, "_doUnload");
      function _addHook(hooks) {
        hooks && arrAppend(_hooks, hooks);
      }
      return __name(_addHook, "_addHook"), {
        run: _doUnload,
        add: _addHook
      };
    }
    __name(createUnloadHookContainer, "createUnloadHookContainer");
    var _a,
      strGetPlugin = "getPlugin",
      defaultValues = (_a = {}, _a[STR_EXTENSION_CONFIG] = {
        isVal: isNotNullOrUndefined,
        v: {}
      }, _a),
      BaseTelemetryPlugin = function () {
        function BaseTelemetryPlugin() {
          var _self = this,
            _isinitialized,
            _rootCtx,
            _nextPlugin,
            _unloadHandlerContainer,
            _hookContainer;
          _initDefaults(), dynamicProto(BaseTelemetryPlugin, _self, function (_self) {
            _self[_DYN_INITIALIZE] = function (config, core, extensions, pluginChain) {
              _setDefaults(config, core, pluginChain), _isinitialized = !0;
            }, _self[_DYN_TEARDOWN] = function (unloadCtx, unloadState) {
              var core = _self[STR_CORE];
              if (!core || unloadCtx && core !== unloadCtx[STR_CORE]()) return;
              var result,
                unloadDone = !1,
                theUnloadCtx = unloadCtx || createProcessTelemetryUnloadContext(null, core, _nextPlugin && _nextPlugin[strGetPlugin] ? _nextPlugin[strGetPlugin]() : _nextPlugin),
                theUnloadState = unloadState || {
                  reason: 0,
                  isAsync: !1
                };
              function _unloadCallback() {
                unloadDone || (unloadDone = !0, _unloadHandlerContainer.run(theUnloadCtx, unloadState), _hookContainer.run(theUnloadCtx[_DYN_DIAG_LOG]()), result === !0 && theUnloadCtx[_DYN_PROCESS_NEXT](theUnloadState), _initDefaults());
              }
              return __name(_unloadCallback, "_unloadCallback"), !_self[_DYN__DO_TEARDOWN] || _self[_DYN__DO_TEARDOWN](theUnloadCtx, theUnloadState, _unloadCallback) !== !0 ? _unloadCallback() : result = !0, result;
            }, _self[_DYN_UPDATE] = function (updateCtx, updateState) {
              var core = _self[STR_CORE];
              if (!core || updateCtx && core !== updateCtx[STR_CORE]()) return;
              var result,
                updateDone = !1,
                theUpdateCtx = updateCtx || createProcessTelemetryUpdateContext(null, core, _nextPlugin && _nextPlugin[strGetPlugin] ? _nextPlugin[strGetPlugin]() : _nextPlugin),
                theUpdateState = updateState || {
                  reason: 0
                };
              function _updateCallback() {
                updateDone || (updateDone = !0, _setDefaults(theUpdateCtx.getCfg(), theUpdateCtx.core(), theUpdateCtx[_DYN_GET_NEXT]()));
              }
              return __name(_updateCallback, "_updateCallback"), !_self._doUpdate || _self._doUpdate(theUpdateCtx, theUpdateState, _updateCallback) !== !0 ? _updateCallback() : result = !0, result;
            }, proxyFunctionAs(_self, "_addUnloadCb", function () {
              return _unloadHandlerContainer;
            }, "add"), proxyFunctionAs(_self, "_addHook", function () {
              return _hookContainer;
            }, "add"), objDefine(_self, "_unloadHooks", {
              g: __name(function () {
                return _hookContainer;
              }, "g")
            });
          }), _self[_DYN_DIAG_LOG] = function (itemCtx) {
            return _getTelCtx(itemCtx)[_DYN_DIAG_LOG]();
          }, _self[_DYN_IS_INITIALIZED] = function () {
            return _isinitialized;
          }, _self.setInitialized = function (isInitialized) {
            _isinitialized = isInitialized;
          }, _self[_DYN_SET_NEXT_PLUGIN] = function (next) {
            _nextPlugin = next;
          }, _self[_DYN_PROCESS_NEXT] = function (env, itemCtx) {
            itemCtx ? itemCtx[_DYN_PROCESS_NEXT](env) : _nextPlugin && isFunction(_nextPlugin[STR_PROCESS_TELEMETRY]) && _nextPlugin[STR_PROCESS_TELEMETRY](env, null);
          }, _self._getTelCtx = _getTelCtx;
          function _getTelCtx(currentCtx) {
            currentCtx === void 0 && (currentCtx = null);
            var itemCtx = currentCtx;
            if (!itemCtx) {
              var rootCtx = _rootCtx || createProcessTelemetryContext(null, {}, _self[STR_CORE]);
              _nextPlugin && _nextPlugin[strGetPlugin] ? itemCtx = rootCtx[_DYN_CREATE_NEW](null, _nextPlugin[strGetPlugin]) : itemCtx = rootCtx[_DYN_CREATE_NEW](null, _nextPlugin);
            }
            return itemCtx;
          }
          __name(_getTelCtx, "_getTelCtx");
          function _setDefaults(config, core, pluginChain) {
            createDynamicConfig(config, defaultValues, safeGetLogger(core)), !pluginChain && core && (pluginChain = core[_DYN_GET_PROCESS_TEL_CONT2]()[_DYN_GET_NEXT]());
            var nextPlugin = _nextPlugin;
            _nextPlugin && _nextPlugin[strGetPlugin] && (nextPlugin = _nextPlugin[strGetPlugin]()), _self[STR_CORE] = core, _rootCtx = createProcessTelemetryContext(pluginChain, config, core, nextPlugin);
          }
          __name(_setDefaults, "_setDefaults");
          function _initDefaults() {
            _isinitialized = !1, _self[STR_CORE] = null, _rootCtx = null, _nextPlugin = null, _hookContainer = createUnloadHookContainer(), _unloadHandlerContainer = createUnloadHandlerContainer();
          }
          __name(_initDefaults, "_initDefaults");
        }
        return __name(BaseTelemetryPlugin, "BaseTelemetryPlugin"), f.__ieDyn = 1, BaseTelemetryPlugin;
      }();
    function _addInitializer(_initializers, id, telemetryInitializer) {
      var theInitializer = {
        id: id,
        fn: telemetryInitializer
      };
      arrAppend(_initializers, theInitializer);
      var handler = {
        remove: __name(function () {
          arrForEach(_initializers, function (initializer, idx) {
            if (initializer.id === theInitializer.id) return _initializers[_DYN_SPLICE](idx, 1), -1;
          });
        }, "remove")
      };
      return handler;
    }
    __name(_addInitializer, "_addInitializer");
    function _runInitializers(_initializers, item, logger) {
      for (var doNotSendItem = !1, telemetryInitializersCount = _initializers[_DYN_LENGTH], i = 0; i < telemetryInitializersCount; ++i) {
        var telemetryInitializer = _initializers[i];
        if (telemetryInitializer) try {
          if (telemetryInitializer.fn[_DYN_APPLY](null, [item]) === !1) {
            doNotSendItem = !0;
            break;
          }
        } catch (e) {
          _throwInternal(logger, 2, 64, "Telemetry initializer failed: " + getExceptionName(e), {
            exception: dumpObj(e)
          }, !0);
        }
      }
      return !doNotSendItem;
    }
    __name(_runInitializers, "_runInitializers");
    var TelemetryInitializerPlugin = function (_super) {
        __extends(TelemetryInitializerPlugin, _super);
        function TelemetryInitializerPlugin() {
          var _this = _super.call(this) || this;
          _this.identifier = "TelemetryInitializerPlugin", _this.priority = 199;
          var _id, _initializers;
          _initDefaults(), dynamicProto(TelemetryInitializerPlugin, _this, function (_self, _base) {
            _self.addTelemetryInitializer = function (telemetryInitializer) {
              return _addInitializer(_initializers, _id++, telemetryInitializer);
            }, _self[STR_PROCESS_TELEMETRY] = function (item, itemCtx) {
              _runInitializers(_initializers, item, itemCtx ? itemCtx[_DYN_DIAG_LOG]() : _self[_DYN_DIAG_LOG]()) && _self[_DYN_PROCESS_NEXT](item, itemCtx);
            }, _self[_DYN__DO_TEARDOWN] = function () {
              _initDefaults();
            };
          });
          function _initDefaults() {
            _id = 0, _initializers = [];
          }
          return __name(_initDefaults, "_initDefaults"), _this;
        }
        return __name(TelemetryInitializerPlugin, "TelemetryInitializerPlugin"), h.__ieDyn = 1, TelemetryInitializerPlugin;
      }(BaseTelemetryPlugin),
      _a,
      strValidationError = "Plugins must provide initialize method",
      strNotificationManager = "_notificationManager",
      strSdkUnloadingError = "SDK is still unloading...",
      strSdkNotInitialized = "SDK is not initialized",
      maxInitQueueSize = 100,
      maxInitTimeout = 5e4,
      defaultConfig = objDeepFreeze((_a = {
        cookieCfg: {}
      }, _a[STR_EXTENSIONS] = {
        rdOnly: !0,
        ref: !0,
        v: []
      }, _a[STR_CHANNELS] = {
        rdOnly: !0,
        ref: !0,
        v: []
      }, _a[STR_EXTENSION_CONFIG] = {
        ref: !0,
        v: {}
      }, _a[STR_CREATE_PERF_MGR] = UNDEFINED_VALUE, _a.loggingLevelConsole = 0, _a.diagnosticLogInterval = UNDEFINED_VALUE, _a));
    function _createPerfManager(core, notificationMgr) {
      return new PerfManager(notificationMgr);
    }
    __name(_createPerfManager, "_createPerfManager");
    function _validateExtensions(logger, channelPriority, allExtensions) {
      var coreExtensions = [],
        channels = [],
        extPriorities = {};
      return arrForEach(allExtensions, function (ext) {
        (isNullOrUndefined(ext) || isNullOrUndefined(ext[_DYN_INITIALIZE])) && throwError(strValidationError);
        var extPriority = ext[STR_PRIORITY],
          identifier = ext[_DYN_IDENTIFIER];
        ext && extPriority && (isNullOrUndefined(extPriorities[extPriority]) ? extPriorities[extPriority] = identifier : _warnToConsole(logger, "Two extensions have same priority #" + extPriority + " - " + extPriorities[extPriority] + ", " + identifier)), !extPriority || extPriority < channelPriority ? coreExtensions[_DYN_PUSH](ext) : channels[_DYN_PUSH](ext);
      }), {
        core: coreExtensions,
        channels: channels
      };
    }
    __name(_validateExtensions, "_validateExtensions");
    function _isPluginPresent(thePlugin, plugins) {
      var exists = !1;
      return arrForEach(plugins, function (plugin) {
        if (plugin === thePlugin) return exists = !0, -1;
      }), exists;
    }
    __name(_isPluginPresent, "_isPluginPresent");
    function _deepMergeConfig(details, target, newValues, merge) {
      newValues && objForEachKey(newValues, function (key, value) {
        merge && isPlainObject(value) && isPlainObject(target[key]) && _deepMergeConfig(details, target[key], value, merge), merge && isPlainObject(value) && isPlainObject(target[key]) ? _deepMergeConfig(details, target[key], value, merge) : details.set(target, key, value);
      });
    }
    __name(_deepMergeConfig, "_deepMergeConfig");
    function _findWatcher(listeners, newWatcher) {
      var theListener = null,
        idx = -1;
      return arrForEach(listeners, function (listener, lp) {
        if (listener.w === newWatcher) return theListener = listener, idx = lp, -1;
      }), {
        i: idx,
        l: theListener
      };
    }
    __name(_findWatcher, "_findWatcher");
    function _addDelayedCfgListener(listeners, newWatcher) {
      var theListener = _findWatcher(listeners, newWatcher).l;
      return theListener || (theListener = {
        w: newWatcher,
        rm: __name(function () {
          var fnd = _findWatcher(listeners, newWatcher);
          fnd.i !== -1 && listeners[_DYN_SPLICE](fnd.i, 1);
        }, "rm")
      }, listeners[_DYN_PUSH](theListener)), theListener;
    }
    __name(_addDelayedCfgListener, "_addDelayedCfgListener");
    function _registerDelayedCfgListener(config, listeners, logger) {
      arrForEach(listeners, function (listener) {
        var unloadHdl = onConfigChange(config, listener.w, logger);
        delete listener.w, listener.rm = function () {
          unloadHdl.rm();
        };
      });
    }
    __name(_registerDelayedCfgListener, "_registerDelayedCfgListener");
    function _initDebugListener(configHandler, unloadContainer, notificationManager, debugListener) {
      return unloadContainer.add(configHandler[_DYN_WATCH](function (details) {
        var disableDbgExt = details.cfg.disableDbgExt;
        disableDbgExt === !0 && debugListener && (notificationManager[_DYN_REMOVE_NOTIFICATION_0](debugListener), debugListener = null), notificationManager && !debugListener && disableDbgExt !== !0 && (debugListener = getDebugListener(details.cfg), notificationManager[_DYN_ADD_NOTIFICATION_LIS1](debugListener));
      })), debugListener;
    }
    __name(_initDebugListener, "_initDebugListener");
    function _createUnloadHook(unloadHook) {
      return objDefine({
        rm: __name(function () {
          unloadHook.rm();
        }, "rm")
      }, "toJSON", {
        v: __name(function () {
          return "aicore::onCfgChange<" + JSON.stringify(unloadHook) + ">";
        }, "v")
      });
    }
    __name(_createUnloadHook, "_createUnloadHook");
    var AppInsightsCore = function () {
      function AppInsightsCore() {
        var _configHandler, _isInitialized, _logger, _eventQueue, _notificationManager, _perfManager, _cfgPerfManager, _cookieManager, _pluginChain, _configExtensions, _channelConfig, _channels, _isUnloading, _telemetryInitializerPlugin, _internalLogsEventName, _evtNamespace, _unloadHandlers, _hookContainer, _debugListener, _traceCtx, _instrumentationKey, _cfgListeners, _extensions, _pluginVersionStringArr, _pluginVersionString, _activeStatus, _endpoint, _initInMemoMaxSize, _isStatusSet, _internalLogPoller, _internalLogPollerListening, _forceStopInternalLogPoller;
        dynamicProto(AppInsightsCore, this, function (_self) {
          _initDefaults(), _self._getDbgPlgTargets = function () {
            return [_extensions, _eventQueue];
          }, _self[_DYN_IS_INITIALIZED] = function () {
            return _isInitialized;
          }, _self.activeStatus = function () {
            return _activeStatus;
          }, _self._setPendingStatus = function () {
            _activeStatus = 3;
          }, _self[_DYN_INITIALIZE] = function (config, extensions, logger, notificationManager) {
            _isUnloading && throwError(strSdkUnloadingError), _self[_DYN_IS_INITIALIZED]() && throwError("Core cannot be initialized more than once"), _configHandler = createDynamicConfig(config, defaultConfig, logger || _self[_DYN_LOGGER], !1), config = _configHandler.cfg, _addUnloadHook(_configHandler[_DYN_WATCH](function (details) {
              var rootCfg = details.cfg,
                isPending = _activeStatus === 3;
              if (!isPending) {
                _initInMemoMaxSize = rootCfg.initInMemoMaxSize || maxInitQueueSize;
                var ikey = rootCfg.instrumentationKey,
                  endpointUrl = rootCfg.endpointUrl;
                if (isNullOrUndefined(ikey)) {
                  _instrumentationKey = null, _activeStatus = ActiveStatus.INACTIVE;
                  var msg = "Please provide instrumentation key";
                  _isInitialized ? (_throwInternal(_logger, 1, 100, msg), _releaseQueues()) : throwError(msg);
                  return;
                }
                var promises = [];
                if (isPromiseLike(ikey) ? (promises[_DYN_PUSH](ikey), _instrumentationKey = null) : _instrumentationKey = ikey, isPromiseLike(endpointUrl) ? (promises[_DYN_PUSH](endpointUrl), _endpoint = null) : _endpoint = endpointUrl, promises[_DYN_LENGTH]) {
                  _isStatusSet = !1, _activeStatus = 3;
                  var initTimeout = isNotNullOrUndefined(rootCfg.initTimeOut) ? rootCfg.initTimeOut : maxInitTimeout,
                    allPromises = createSyncAllSettledPromise(promises);
                  scheduleTimeout(function () {
                    _isStatusSet || _setStatus();
                  }, initTimeout), doAwaitResponse(allPromises, function (response) {
                    try {
                      if (_isStatusSet) return;
                      if (!response.rejected) {
                        var values = response[_DYN_VALUE];
                        if (values && values[_DYN_LENGTH]) {
                          var ikeyRes = values[0];
                          if (_instrumentationKey = ikeyRes && ikeyRes[_DYN_VALUE], values[_DYN_LENGTH] > 1) {
                            var endpointRes = values[1];
                            _endpoint = endpointRes && endpointRes[_DYN_VALUE];
                          }
                        }
                        _instrumentationKey && (config.instrumentationKey = _instrumentationKey, config.endpointUrl = _endpoint);
                      }
                      _setStatus();
                    } catch {
                      _isStatusSet || _setStatus();
                    }
                  });
                } else _setStatus();
                var extCfg = details.ref(details.cfg, STR_EXTENSION_CONFIG);
                objForEachKey(extCfg, function (key) {
                  details.ref(extCfg, key);
                });
              }
            })), _notificationManager = notificationManager, _debugListener = _initDebugListener(_configHandler, _hookContainer, _notificationManager && _self[_DYN_GET_NOTIFY_MGR](), _debugListener), _initPerfManager(), _self[_DYN_LOGGER] = logger;
            var cfgExtensions = config[STR_EXTENSIONS];
            if (_configExtensions = [], _configExtensions[_DYN_PUSH].apply(_configExtensions, __spreadArray(__spreadArray([], extensions, !1), cfgExtensions)), _channelConfig = config[STR_CHANNELS], _initPluginChain(null), (!_channels || _channels[_DYN_LENGTH] === 0) && throwError("No " + STR_CHANNELS + " available"), _channelConfig && _channelConfig[_DYN_LENGTH] > 1) {
              var teeController = _self[_DYN_GET_PLUGIN]("TeeChannelController");
              (!teeController || !teeController.plugin) && _throwInternal(_logger, 1, 28, "TeeChannel required");
            }
            _registerDelayedCfgListener(config, _cfgListeners, _logger), _cfgListeners = null, _isInitialized = !0, _activeStatus === ActiveStatus.ACTIVE && _releaseQueues();
          }, _self.getChannels = function () {
            var controls = [];
            return _channels && arrForEach(_channels, function (channel) {
              controls[_DYN_PUSH](channel);
            }), objFreeze(controls);
          }, _self.track = function (telemetryItem) {
            doPerf(_self[STR_GET_PERF_MGR](), function () {
              return "AppInsightsCore:track";
            }, function () {
              telemetryItem === null && (_notifyInvalidEvent(telemetryItem), throwError("Invalid telemetry item")), !telemetryItem[_DYN_NAME] && isNullOrUndefined(telemetryItem[_DYN_NAME]) && (_notifyInvalidEvent(telemetryItem), throwError("telemetry name required")), telemetryItem.iKey = telemetryItem.iKey || _instrumentationKey, telemetryItem.time = telemetryItem.time || toISOString(new Date()), telemetryItem.ver = telemetryItem.ver || "4.0", !_isUnloading && _self[_DYN_IS_INITIALIZED]() && _activeStatus === ActiveStatus.ACTIVE ? _createTelCtx()[_DYN_PROCESS_NEXT](telemetryItem) : _activeStatus !== ActiveStatus.INACTIVE && _eventQueue[_DYN_LENGTH] <= _initInMemoMaxSize && _eventQueue[_DYN_PUSH](telemetryItem);
            }, function () {
              return {
                item: telemetryItem
              };
            }, !telemetryItem.sync);
          }, _self[_DYN_GET_PROCESS_TEL_CONT2] = _createTelCtx, _self[_DYN_GET_NOTIFY_MGR] = function () {
            return _notificationManager || (_notificationManager = new NotificationManager(_configHandler.cfg), _self[strNotificationManager] = _notificationManager), _notificationManager;
          }, _self[_DYN_ADD_NOTIFICATION_LIS1] = function (listener) {
            _self.getNotifyMgr()[_DYN_ADD_NOTIFICATION_LIS1](listener);
          }, _self[_DYN_REMOVE_NOTIFICATION_0] = function (listener) {
            _notificationManager && _notificationManager[_DYN_REMOVE_NOTIFICATION_0](listener);
          }, _self.getCookieMgr = function () {
            return _cookieManager || (_cookieManager = createCookieMgr(_configHandler.cfg, _self[_DYN_LOGGER])), _cookieManager;
          }, _self.setCookieMgr = function (cookieMgr) {
            _cookieManager !== cookieMgr && (runTargetUnload(_cookieManager, !1), _cookieManager = cookieMgr);
          }, _self[STR_GET_PERF_MGR] = function () {
            return _perfManager || _cfgPerfManager || getGblPerfMgr();
          }, _self.setPerfMgr = function (perfMgr) {
            _perfManager = perfMgr;
          }, _self.eventCnt = function () {
            return _eventQueue[_DYN_LENGTH];
          }, _self.releaseQueue = function () {
            if (_isInitialized && _eventQueue[_DYN_LENGTH] > 0) {
              var eventQueue = _eventQueue;
              _eventQueue = [], _activeStatus === 2 ? arrForEach(eventQueue, function (event) {
                event.iKey = event.iKey || _instrumentationKey, _createTelCtx()[_DYN_PROCESS_NEXT](event);
              }) : _throwInternal(_logger, 2, 20, "core init status is not active");
            }
          }, _self.pollInternalLogs = function (eventName) {
            return _internalLogsEventName = eventName || null, _forceStopInternalLogPoller = !1, _internalLogPoller && _internalLogPoller[_DYN_CANCEL](), _startLogPoller(!0);
          };
          function _setStatus() {
            _isStatusSet = !0, isNullOrUndefined(_instrumentationKey) ? (_activeStatus = ActiveStatus.INACTIVE, _throwInternal(_logger, 1, 112, "ikey can't be resolved from promises")) : _activeStatus = ActiveStatus.ACTIVE, _releaseQueues();
          }
          __name(_setStatus, "_setStatus");
          function _releaseQueues() {
            _isInitialized && (_self.releaseQueue(), _self.pollInternalLogs());
          }
          __name(_releaseQueues, "_releaseQueues");
          function _startLogPoller(alwaysStart) {
            if ((!_internalLogPoller || !_internalLogPoller[_DYN_ENABLED]) && !_forceStopInternalLogPoller) {
              var shouldStart = alwaysStart || _logger && _logger.queue[_DYN_LENGTH] > 0;
              shouldStart && (_internalLogPollerListening || (_internalLogPollerListening = !0, _addUnloadHook(_configHandler[_DYN_WATCH](function (details) {
                var interval = details.cfg.diagnosticLogInterval;
                (!interval || !(interval > 0)) && (interval = 1e4);
                var isRunning = !1;
                _internalLogPoller && (isRunning = _internalLogPoller[_DYN_ENABLED], _internalLogPoller[_DYN_CANCEL]()), _internalLogPoller = createTimeout(_flushInternalLogs, interval), _internalLogPoller.unref(), _internalLogPoller[_DYN_ENABLED] = isRunning;
              }))), _internalLogPoller[_DYN_ENABLED] = !0);
            }
            return _internalLogPoller;
          }
          __name(_startLogPoller, "_startLogPoller"), _self[_DYN_STOP_POLLING_INTERNA3] = function () {
            _forceStopInternalLogPoller = !0, _internalLogPoller && _internalLogPoller[_DYN_CANCEL](), _flushInternalLogs();
          }, proxyFunctions(_self, function () {
            return _telemetryInitializerPlugin;
          }, ["addTelemetryInitializer"]), _self[_DYN_UNLOAD] = function (isAsync, unloadComplete, cbTimeout) {
            isAsync === void 0 && (isAsync = !0), _isInitialized || throwError(strSdkNotInitialized), _isUnloading && throwError(strSdkUnloadingError);
            var unloadState = {
                reason: 50,
                isAsync: isAsync,
                flushComplete: !1
              },
              result;
            isAsync && !unloadComplete && (result = createPromise(function (resolve) {
              unloadComplete = resolve;
            }));
            var processUnloadCtx = createProcessTelemetryUnloadContext(_getPluginChain(), _self);
            processUnloadCtx[_DYN_ON_COMPLETE](function () {
              _hookContainer.run(_self[_DYN_LOGGER]), doUnloadAll([_cookieManager, _notificationManager, _logger], isAsync, function () {
                _initDefaults(), unloadComplete && unloadComplete(unloadState);
              });
            }, _self);
            function _doUnload(flushComplete) {
              unloadState.flushComplete = flushComplete, _isUnloading = !0, _unloadHandlers.run(processUnloadCtx, unloadState), _self[_DYN_STOP_POLLING_INTERNA3](), processUnloadCtx[_DYN_PROCESS_NEXT](unloadState);
            }
            return __name(_doUnload, "_doUnload"), _flushInternalLogs(), _flushChannels(isAsync, _doUnload, 6, cbTimeout), result;
          }, _self[_DYN_GET_PLUGIN] = _getPlugin, _self.addPlugin = function (plugin, replaceExisting, isAsync, addCb) {
            if (!plugin) {
              addCb && addCb(!1), _logOrThrowError(strValidationError);
              return;
            }
            var existingPlugin = _getPlugin(plugin[_DYN_IDENTIFIER]);
            if (existingPlugin && !replaceExisting) {
              addCb && addCb(!1), _logOrThrowError("Plugin [" + plugin[_DYN_IDENTIFIER] + "] is already loaded!");
              return;
            }
            var updateState = {
              reason: 16
            };
            function _addPlugin(removed) {
              _configExtensions[_DYN_PUSH](plugin), updateState.added = [plugin], _initPluginChain(updateState), addCb && addCb(!0);
            }
            if (__name(_addPlugin, "_addPlugin"), existingPlugin) {
              var removedPlugins_1 = [existingPlugin.plugin],
                unloadState = {
                  reason: 2,
                  isAsync: !!isAsync
                };
              _removePlugins(removedPlugins_1, unloadState, function (removed) {
                removed ? (updateState.removed = removedPlugins_1, updateState.reason |= 32, _addPlugin()) : addCb && addCb(!1);
              });
            } else _addPlugin();
          }, _self.updateCfg = function (newConfig, mergeExisting) {
            mergeExisting === void 0 && (mergeExisting = !0);
            var updateState;
            if (_self[_DYN_IS_INITIALIZED]()) {
              updateState = {
                reason: 1,
                cfg: _configHandler.cfg,
                oldCfg: deepExtend({}, _configHandler.cfg),
                newConfig: deepExtend({}, newConfig),
                merge: mergeExisting
              }, newConfig = updateState.newConfig;
              var cfg = _configHandler.cfg;
              newConfig[STR_EXTENSIONS] = cfg[STR_EXTENSIONS], newConfig[STR_CHANNELS] = cfg[STR_CHANNELS];
            }
            _configHandler._block(function (details) {
              var theConfig = details.cfg;
              _deepMergeConfig(details, theConfig, newConfig, mergeExisting), mergeExisting || objForEachKey(theConfig, function (key) {
                objHasOwn(newConfig, key) || details.set(theConfig, key, UNDEFINED_VALUE);
              }), details.setDf(theConfig, defaultConfig);
            }, !0), _configHandler.notify(), updateState && _doUpdate(updateState);
          }, _self.evtNamespace = function () {
            return _evtNamespace;
          }, _self.flush = _flushChannels, _self.getTraceCtx = function (createNew) {
            return _traceCtx || (_traceCtx = createDistributedTraceContext()), _traceCtx;
          }, _self.setTraceCtx = function (traceCtx) {
            _traceCtx = traceCtx || null;
          }, _self.addUnloadHook = _addUnloadHook, proxyFunctionAs(_self, "addUnloadCb", function () {
            return _unloadHandlers;
          }, "add"), _self.onCfgChange = function (handler) {
            var unloadHook;
            return _isInitialized ? unloadHook = onConfigChange(_configHandler.cfg, handler, _self[_DYN_LOGGER]) : unloadHook = _addDelayedCfgListener(_cfgListeners, handler), _createUnloadHook(unloadHook);
          }, _self.getWParam = function () {
            return hasDocument() || _configHandler.cfg.enableWParam ? 0 : -1;
          };
          function _setPluginVersions() {
            var thePlugins = {};
            _pluginVersionStringArr = [];
            var _addPluginVersions = __name(function (plugins) {
              plugins && arrForEach(plugins, function (plugin) {
                if (plugin[_DYN_IDENTIFIER] && plugin[_DYN_VERSION] && !thePlugins[plugin.identifier]) {
                  var ver = plugin[_DYN_IDENTIFIER] + "=" + plugin[_DYN_VERSION];
                  _pluginVersionStringArr[_DYN_PUSH](ver), thePlugins[plugin.identifier] = plugin;
                }
              });
            }, "_addPluginVersions");
            _addPluginVersions(_channels), _channelConfig && arrForEach(_channelConfig, function (channels) {
              _addPluginVersions(channels);
            }), _addPluginVersions(_configExtensions);
          }
          __name(_setPluginVersions, "_setPluginVersions");
          function _initDefaults() {
            _isInitialized = !1, _configHandler = createDynamicConfig({}, defaultConfig, _self[_DYN_LOGGER]), _configHandler.cfg[_DYN_LOGGING_LEVEL_CONSOL4] = 1, objDefine(_self, "config", {
              g: __name(function () {
                return _configHandler.cfg;
              }, "g"),
              s: __name(function (newValue) {
                _self.updateCfg(newValue, !1);
              }, "s")
            }), objDefine(_self, "pluginVersionStringArr", {
              g: __name(function () {
                return _pluginVersionStringArr || _setPluginVersions(), _pluginVersionStringArr;
              }, "g")
            }), objDefine(_self, "pluginVersionString", {
              g: __name(function () {
                return _pluginVersionString || (_pluginVersionStringArr || _setPluginVersions(), _pluginVersionString = _pluginVersionStringArr.join(";")), _pluginVersionString || STR_EMPTY;
              }, "g")
            }), objDefine(_self, "logger", {
              g: __name(function () {
                return _logger || (_logger = new DiagnosticLogger(_configHandler.cfg), _configHandler[_DYN_LOGGER] = _logger), _logger;
              }, "g"),
              s: __name(function (newLogger) {
                _configHandler[_DYN_LOGGER] = newLogger, _logger !== newLogger && (runTargetUnload(_logger, !1), _logger = newLogger);
              }, "s")
            }), _self[_DYN_LOGGER] = new DiagnosticLogger(_configHandler.cfg), _extensions = [];
            var cfgExtensions = _self.config[STR_EXTENSIONS] || [];
            cfgExtensions.splice(0, cfgExtensions[_DYN_LENGTH]), arrAppend(cfgExtensions, _extensions), _telemetryInitializerPlugin = new TelemetryInitializerPlugin(), _eventQueue = [], runTargetUnload(_notificationManager, !1), _notificationManager = null, _perfManager = null, _cfgPerfManager = null, runTargetUnload(_cookieManager, !1), _cookieManager = null, _pluginChain = null, _configExtensions = [], _channelConfig = null, _channels = null, _isUnloading = !1, _internalLogsEventName = null, _evtNamespace = createUniqueNamespace("AIBaseCore", !0), _unloadHandlers = createUnloadHandlerContainer(), _traceCtx = null, _instrumentationKey = null, _hookContainer = createUnloadHookContainer(), _cfgListeners = [], _pluginVersionString = null, _pluginVersionStringArr = null, _forceStopInternalLogPoller = !1, _internalLogPoller = null, _internalLogPollerListening = !1, _activeStatus = 0, _endpoint = null, _initInMemoMaxSize = null, _isStatusSet = !1;
          }
          __name(_initDefaults, "_initDefaults");
          function _createTelCtx() {
            var theCtx = createProcessTelemetryContext(_getPluginChain(), _configHandler.cfg, _self);
            return theCtx[_DYN_ON_COMPLETE](_startLogPoller), theCtx;
          }
          __name(_createTelCtx, "_createTelCtx");
          function _initPluginChain(updateState) {
            var theExtensions = _validateExtensions(_self[_DYN_LOGGER], ChannelControllerPriority, _configExtensions);
            _pluginChain = null, _pluginVersionString = null, _pluginVersionStringArr = null, _channels = (_channelConfig || [])[0] || [], _channels = sortPlugins(arrAppend(_channels, theExtensions[STR_CHANNELS]));
            var allExtensions = arrAppend(sortPlugins(theExtensions[STR_CORE]), _channels);
            _extensions = objFreeze(allExtensions);
            var cfgExtensions = _self.config[STR_EXTENSIONS] || [];
            cfgExtensions.splice(0, cfgExtensions[_DYN_LENGTH]), arrAppend(cfgExtensions, _extensions);
            var rootCtx = _createTelCtx();
            _channels && _channels[_DYN_LENGTH] > 0 && initializePlugins(rootCtx[_DYN_CREATE_NEW](_channels), allExtensions), initializePlugins(rootCtx, allExtensions), updateState && _doUpdate(updateState);
          }
          __name(_initPluginChain, "_initPluginChain");
          function _getPlugin(pluginIdentifier) {
            var theExt = null,
              thePlugin = null,
              channelHosts = [];
            return arrForEach(_extensions, function (ext) {
              if (ext[_DYN_IDENTIFIER] === pluginIdentifier && ext !== _telemetryInitializerPlugin) return thePlugin = ext, -1;
              ext.getChannel && channelHosts[_DYN_PUSH](ext);
            }), !thePlugin && channelHosts[_DYN_LENGTH] > 0 && arrForEach(channelHosts, function (host) {
              if (thePlugin = host.getChannel(pluginIdentifier), !thePlugin) return -1;
            }), thePlugin && (theExt = {
              plugin: thePlugin,
              setEnabled: __name(function (enabled) {
                _getPluginState(thePlugin)[STR_DISABLED] = !enabled;
              }, "setEnabled"),
              isEnabled: __name(function () {
                var pluginState = _getPluginState(thePlugin);
                return !pluginState[_DYN_TEARDOWN] && !pluginState[STR_DISABLED];
              }, "isEnabled"),
              remove: __name(function (isAsync, removeCb) {
                isAsync === void 0 && (isAsync = !0);
                var pluginsToRemove = [thePlugin],
                  unloadState = {
                    reason: 1,
                    isAsync: isAsync
                  };
                _removePlugins(pluginsToRemove, unloadState, function (removed) {
                  removed && _initPluginChain({
                    reason: 32,
                    removed: pluginsToRemove
                  }), removeCb && removeCb(removed);
                });
              }, "remove")
            }), theExt;
          }
          __name(_getPlugin, "_getPlugin");
          function _getPluginChain() {
            if (!_pluginChain) {
              var extensions = (_extensions || []).slice();
              arrIndexOf(extensions, _telemetryInitializerPlugin) === -1 && extensions[_DYN_PUSH](_telemetryInitializerPlugin), _pluginChain = createTelemetryProxyChain(sortPlugins(extensions), _configHandler.cfg, _self);
            }
            return _pluginChain;
          }
          __name(_getPluginChain, "_getPluginChain");
          function _removePlugins(thePlugins, unloadState, removeComplete) {
            if (thePlugins && thePlugins[_DYN_LENGTH] > 0) {
              var unloadChain = createTelemetryProxyChain(thePlugins, _configHandler.cfg, _self),
                unloadCtx = createProcessTelemetryUnloadContext(unloadChain, _self);
              unloadCtx[_DYN_ON_COMPLETE](function () {
                var removed = !1,
                  newConfigExtensions = [];
                arrForEach(_configExtensions, function (plugin, idx) {
                  _isPluginPresent(plugin, thePlugins) ? removed = !0 : newConfigExtensions[_DYN_PUSH](plugin);
                }), _configExtensions = newConfigExtensions, _pluginVersionString = null, _pluginVersionStringArr = null;
                var newChannelConfig = [];
                _channelConfig && (arrForEach(_channelConfig, function (queue, idx) {
                  var newQueue = [];
                  arrForEach(queue, function (channel) {
                    _isPluginPresent(channel, thePlugins) ? removed = !0 : newQueue[_DYN_PUSH](channel);
                  }), newChannelConfig[_DYN_PUSH](newQueue);
                }), _channelConfig = newChannelConfig), removeComplete && removeComplete(removed), _startLogPoller();
              }), unloadCtx[_DYN_PROCESS_NEXT](unloadState);
            } else removeComplete(!1);
          }
          __name(_removePlugins, "_removePlugins");
          function _flushInternalLogs() {
            if (_logger && _logger.queue) {
              var queue = _logger.queue.slice(0);
              _logger.queue[_DYN_LENGTH] = 0, arrForEach(queue, function (logMessage) {
                var item = {
                  name: _internalLogsEventName || "InternalMessageId: " + logMessage[_DYN_MESSAGE_ID],
                  iKey: _instrumentationKey,
                  time: toISOString(new Date()),
                  baseType: _InternalLogMessage.dataType,
                  baseData: {
                    message: logMessage[_DYN_MESSAGE]
                  }
                };
                _self.track(item);
              });
            }
          }
          __name(_flushInternalLogs, "_flushInternalLogs");
          function _flushChannels(isAsync, callBack, sendReason, cbTimeout) {
            var waiting = 1,
              doneIterating = !1,
              cbTimer = null;
            cbTimeout = cbTimeout || 5e3;
            function doCallback() {
              waiting--, doneIterating && waiting === 0 && (cbTimer && cbTimer[_DYN_CANCEL](), cbTimer = null, callBack && callBack(doneIterating), callBack = null);
            }
            if (__name(doCallback, "doCallback"), _channels && _channels[_DYN_LENGTH] > 0) {
              var flushCtx = _createTelCtx()[_DYN_CREATE_NEW](_channels);
              flushCtx.iterate(function (plugin) {
                if (plugin.flush) {
                  waiting++;
                  var handled_1 = !1;
                  plugin.flush(isAsync, function () {
                    handled_1 = !0, doCallback();
                  }, sendReason) || handled_1 || (isAsync && cbTimer == null ? cbTimer = scheduleTimeout(function () {
                    cbTimer = null, doCallback();
                  }, cbTimeout) : doCallback());
                }
              });
            }
            return doneIterating = !0, doCallback(), !0;
          }
          __name(_flushChannels, "_flushChannels");
          function _initPerfManager() {
            var prevCfgPerfMgr;
            _addUnloadHook(_configHandler[_DYN_WATCH](function (details) {
              var enablePerfMgr = details.cfg.enablePerfMgr;
              if (enablePerfMgr) {
                var createPerfMgr = details.cfg[STR_CREATE_PERF_MGR];
                (prevCfgPerfMgr !== createPerfMgr || !prevCfgPerfMgr) && (createPerfMgr || (createPerfMgr = _createPerfManager), getSetValue(details.cfg, STR_CREATE_PERF_MGR, createPerfMgr), prevCfgPerfMgr = createPerfMgr, _cfgPerfManager = null), !_perfManager && !_cfgPerfManager && isFunction(createPerfMgr) && (_cfgPerfManager = createPerfMgr(_self, _self[_DYN_GET_NOTIFY_MGR]()));
              } else _cfgPerfManager = null, prevCfgPerfMgr = null;
            }));
          }
          __name(_initPerfManager, "_initPerfManager");
          function _doUpdate(updateState) {
            var updateCtx = createProcessTelemetryUpdateContext(_getPluginChain(), _self);
            updateCtx[_DYN_ON_COMPLETE](_startLogPoller), (!_self._updateHook || _self._updateHook(updateCtx, updateState) !== !0) && updateCtx[_DYN_PROCESS_NEXT](updateState);
          }
          __name(_doUpdate, "_doUpdate");
          function _logOrThrowError(message) {
            var logger = _self[_DYN_LOGGER];
            logger ? (_throwInternal(logger, 2, 73, message), _startLogPoller()) : throwError(message);
          }
          __name(_logOrThrowError, "_logOrThrowError");
          function _notifyInvalidEvent(telemetryItem) {
            var manager = _self[_DYN_GET_NOTIFY_MGR]();
            manager && manager[STR_EVENTS_DISCARDED]([telemetryItem], 2);
          }
          __name(_notifyInvalidEvent, "_notifyInvalidEvent");
          function _addUnloadHook(hooks) {
            _hookContainer.add(hooks);
          }
          __name(_addUnloadHook, "_addUnloadHook");
        });
      }
      return __name(AppInsightsCore, "AppInsightsCore"), f.__ieDyn = 1, AppInsightsCore;
    }();
    function parseResponse(response, diagLog) {
      try {
        if (response && response !== "") {
          var result = getJSON().parse(response);
          if (result && result[_DYN_ITEMS_RECEIVED] && result[_DYN_ITEMS_RECEIVED] >= result.itemsAccepted && result.itemsReceived - result.itemsAccepted === result.errors[_DYN_LENGTH]) return result;
        }
      } catch (e) {
        _throwInternal(diagLog, 1, 43, "Cannot parse the response. " + (e[_DYN_NAME] || dumpObj(e)), {
          response: response
        });
      }
      return null;
    }
    __name(parseResponse, "parseResponse");
    var STR_EMPTY = "",
      STR_NO_RESPONSE_BODY = "NoResponseBody",
      _noResponseQs = "&" + STR_NO_RESPONSE_BODY + "=true",
      STR_POST_METHOD = "POST",
      SenderPostManager = function () {
        function SenderPostManager() {
          var _syncFetchPayload = 0,
            _enableSendPromise,
            _isInitialized,
            _diagLog,
            _isOneDs,
            _onCompleteFuncs,
            _disableCredentials,
            _fetchCredentials,
            _fallbackInst,
            _disableXhr,
            _disableBeacon,
            _disableBeaconSync,
            _disableFetchKeepAlive,
            _addNoResponse,
            _timeoutWrapper;
          dynamicProto(SenderPostManager, this, function (_self, _base) {
            var _sendCredentials = !0;
            _initDefaults(), _self[_DYN_INITIALIZE] = function (config, diagLog) {
              _diagLog = diagLog, _isInitialized && _throwInternal(_diagLog, 1, 28, "Sender is already initialized"), _self.SetConfig(config), _isInitialized = !0;
            }, _self._getDbgPlgTargets = function () {
              return [_isInitialized, _isOneDs, _disableCredentials, _enableSendPromise];
            }, _self.SetConfig = function (config) {
              try {
                if (_onCompleteFuncs = config.senderOnCompleteCallBack || {}, _disableCredentials = !!config.disableCredentials, _fetchCredentials = config.fetchCredentials, _isOneDs = !!config.isOneDs, _enableSendPromise = !!config.enableSendPromise, _disableXhr = !!config.disableXhr, _disableBeacon = !!config.disableBeacon, _disableBeaconSync = !!config.disableBeaconSync, _timeoutWrapper = config.timeWrapper, _addNoResponse = !!config.addNoResponse, _disableFetchKeepAlive = !!config.disableFetchKeepAlive, _fallbackInst = {
                  sendPOST: _xhrSender
                }, _isOneDs || (_sendCredentials = !1), _disableCredentials) {
                  var location_1 = getLocation();
                  location_1 && location_1.protocol && location_1.protocol[_DYN_TO_LOWER_CASE]() === "file:" && (_sendCredentials = !1);
                }
                return !0;
              } catch {}
              return !1;
            }, _self.getSyncFetchPayload = function () {
              return _syncFetchPayload;
            }, _self.getSenderInst = function (transports, sync) {
              return transports && transports[_DYN_LENGTH] ? _getSenderInterface(transports, sync) : null;
            }, _self.getFallbackInst = function () {
              return _fallbackInst;
            }, _self[_DYN__DO_TEARDOWN] = function (unloadCtx, unloadState) {
              _initDefaults();
            };
            function _onSuccess(res, onComplete) {
              _doOnComplete(onComplete, 200, {}, res);
            }
            __name(_onSuccess, "_onSuccess");
            function _onError(message, onComplete) {
              _throwInternal(_diagLog, 2, 26, "Failed to send telemetry.", {
                message: message
              }), _doOnComplete(onComplete, 400, {});
            }
            __name(_onError, "_onError");
            function _onNoPayloadUrl(onComplete) {
              _onError("No endpoint url is provided for the batch", onComplete);
            }
            __name(_onNoPayloadUrl, "_onNoPayloadUrl");
            function _getSenderInterface(transports, syncSupport) {
              for (var transportType = 0, sendPostFunc = null, lp = 0; sendPostFunc == null && lp < transports[_DYN_LENGTH];) transportType = transports[lp], !_disableXhr && transportType === 1 ? useXDomainRequest() ? sendPostFunc = _xdrSender : isXhrSupported() && (sendPostFunc = _xhrSender) : transportType === 2 && isFetchSupported(syncSupport) && (!syncSupport || !_disableFetchKeepAlive) ? sendPostFunc = _doFetchSender : transportType === 3 && isBeaconsSupported() && (syncSupport ? !_disableBeaconSync : !_disableBeacon) && (sendPostFunc = _beaconSender), lp++;
              return sendPostFunc ? {
                _transport: transportType,
                _isSync: syncSupport,
                sendPOST: sendPostFunc
              } : null;
            }
            __name(_getSenderInterface, "_getSenderInterface");
            function _doOnComplete(oncomplete, status, headers, response) {
              try {
                oncomplete && oncomplete(status, headers, response);
              } catch {}
            }
            __name(_doOnComplete, "_doOnComplete");
            function _doBeaconSend(payload, oncomplete) {
              var nav = getNavigator(),
                url = payload[_DYN_URL_STRING];
              if (!url) return _onNoPayloadUrl(oncomplete), !0;
              url = payload[_DYN_URL_STRING] + (_addNoResponse ? _noResponseQs : STR_EMPTY);
              var data = payload[_DYN_DATA],
                plainTextBatch = _isOneDs ? data : new Blob([data], {
                  type: "text/plain;charset=UTF-8"
                }),
                queued = nav.sendBeacon(url, plainTextBatch);
              return queued;
            }
            __name(_doBeaconSend, "_doBeaconSend");
            function _beaconSender(payload, oncomplete, sync) {
              var data = payload[_DYN_DATA];
              try {
                if (data) if (_doBeaconSend(payload, oncomplete)) _onSuccess(STR_EMPTY, oncomplete);else {
                  var onRetry = _onCompleteFuncs && _onCompleteFuncs.beaconOnRetry;
                  onRetry && isFunction(onRetry) ? onRetry(payload, oncomplete, _doBeaconSend) : (_fallbackInst && _fallbackInst.sendPOST(payload, oncomplete, !0), _throwInternal(_diagLog, 2, 40, ". Failed to send telemetry with Beacon API, retried with normal sender."));
                }
              } catch (e) {
                _isOneDs && _warnToConsole(_diagLog, "Failed to send telemetry using sendBeacon API. Ex:" + dumpObj(e)), _doOnComplete(oncomplete, _isOneDs ? 0 : 400, {}, STR_EMPTY);
              }
            }
            __name(_beaconSender, "_beaconSender");
            function _xhrSender(payload, oncomplete, sync) {
              var thePromise,
                resolveFunc,
                rejectFunc,
                headers = payload[_DYN_HEADERS] || {};
              !sync && _enableSendPromise && (thePromise = createPromise(function (resolve, reject) {
                resolveFunc = resolve, rejectFunc = reject;
              })), _isOneDs && sync && payload.disableXhrSync && (sync = !1);
              var endPointUrl = payload[_DYN_URL_STRING];
              if (!endPointUrl) {
                _onNoPayloadUrl(oncomplete), resolveFunc && resolveFunc(!1);
                return;
              }
              var xhr = openXhr(STR_POST_METHOD, endPointUrl, _sendCredentials, !0, sync, payload[_DYN_TIMEOUT]);
              _isOneDs || xhr.setRequestHeader("Content-type", "application/json"), arrForEach(objKeys(headers), function (headerName) {
                xhr.setRequestHeader(headerName, headers[headerName]);
              }), xhr.onreadystatechange = function () {
                _isOneDs || (_doOnReadyFunc(xhr), xhr.readyState === 4 && resolveFunc && resolveFunc(!0));
              }, xhr.onload = function () {
                _isOneDs && _doOnReadyFunc(xhr);
              };
              function _doOnReadyFunc(xhr) {
                var onReadyFunc = _onCompleteFuncs && _onCompleteFuncs.xhrOnComplete,
                  onReadyFuncExist = onReadyFunc && isFunction(onReadyFunc);
                if (onReadyFuncExist) onReadyFunc(xhr, oncomplete, payload);else {
                  var response = getResponseText(xhr);
                  _doOnComplete(oncomplete, xhr[_DYN_STATUS], _getAllResponseHeaders(xhr, _isOneDs), response);
                }
              }
              return __name(_doOnReadyFunc, "_doOnReadyFunc"), xhr.onerror = function (event) {
                _doOnComplete(oncomplete, _isOneDs ? xhr[_DYN_STATUS] : 400, _getAllResponseHeaders(xhr, _isOneDs), _isOneDs ? STR_EMPTY : formatErrorMessageXhr(xhr)), rejectFunc && rejectFunc(event);
              }, xhr.ontimeout = function () {
                _doOnComplete(oncomplete, _isOneDs ? xhr[_DYN_STATUS] : 500, _getAllResponseHeaders(xhr, _isOneDs), _isOneDs ? STR_EMPTY : formatErrorMessageXhr(xhr)), resolveFunc && resolveFunc(!1);
              }, xhr.send(payload[_DYN_DATA]), thePromise;
            }
            __name(_xhrSender, "_xhrSender");
            function _doFetchSender(payload, oncomplete, sync) {
              var _a,
                endPointUrl = payload[_DYN_URL_STRING],
                batch = payload[_DYN_DATA],
                plainTextBatch = _isOneDs ? batch : new Blob([batch], {
                  type: "application/json"
                }),
                thePromise,
                resolveFunc,
                rejectFunc,
                requestHeaders = new Headers(),
                batchLength = batch[_DYN_LENGTH],
                ignoreResponse = !1,
                responseHandled = !1,
                headers = payload[_DYN_HEADERS] || {},
                init = (_a = {
                  method: STR_POST_METHOD,
                  body: plainTextBatch
                }, _a[DisabledPropertyName] = !0, _a);
              payload.headers && objKeys(payload.headers)[_DYN_LENGTH] > 0 && (arrForEach(objKeys(headers), function (headerName) {
                requestHeaders.append(headerName, headers[headerName]);
              }), init[_DYN_HEADERS] = requestHeaders), _fetchCredentials ? init.credentials = _fetchCredentials : _sendCredentials && _isOneDs && (init.credentials = "include"), sync && (init.keepalive = !0, _syncFetchPayload += batchLength, _isOneDs ? payload._sendReason === 2 && (ignoreResponse = !0, _addNoResponse && (endPointUrl += _noResponseQs)) : ignoreResponse = !0);
              var request = new Request(endPointUrl, init);
              try {
                request[DisabledPropertyName] = !0;
              } catch {}
              if (!sync && _enableSendPromise && (thePromise = createPromise(function (resolve, reject) {
                resolveFunc = resolve, rejectFunc = reject;
              })), !endPointUrl) {
                _onNoPayloadUrl(oncomplete), resolveFunc && resolveFunc(!1);
                return;
              }
              function _handleError(res) {
                _doOnComplete(oncomplete, _isOneDs ? 0 : 400, {}, _isOneDs ? STR_EMPTY : res);
              }
              __name(_handleError, "_handleError");
              function _onFetchComplete(response, payload, value) {
                var status = response[_DYN_STATUS],
                  onCompleteFunc = _onCompleteFuncs.fetchOnComplete;
                onCompleteFunc && isFunction(onCompleteFunc) ? onCompleteFunc(response, oncomplete, value || STR_EMPTY, payload) : _doOnComplete(oncomplete, status, {}, value || STR_EMPTY);
              }
              __name(_onFetchComplete, "_onFetchComplete");
              try {
                doAwaitResponse(fetch(_isOneDs ? endPointUrl : request, _isOneDs ? init : null), function (result) {
                  if (sync && (_syncFetchPayload -= batchLength, batchLength = 0), !responseHandled) if (responseHandled = !0, result.rejected) _handleError(result.reason && result.reason[_DYN_MESSAGE]), rejectFunc && rejectFunc(result.reason);else {
                    var response_1 = result[_DYN_VALUE];
                    try {
                      !_isOneDs && !response_1.ok ? (_handleError(response_1.statusText), resolveFunc && resolveFunc(!1)) : _isOneDs && !response_1.body ? (_onFetchComplete(response_1, null, STR_EMPTY), resolveFunc && resolveFunc(!0)) : doAwaitResponse(response_1.text(), function (resp) {
                        _onFetchComplete(response_1, payload, resp[_DYN_VALUE]), resolveFunc && resolveFunc(!0);
                      });
                    } catch (e) {
                      _handleError(dumpObj(e)), rejectFunc && rejectFunc(e);
                    }
                  }
                });
              } catch (e) {
                responseHandled || (_handleError(dumpObj(e)), rejectFunc && rejectFunc(e));
              }
              return ignoreResponse && !responseHandled && (responseHandled = !0, _doOnComplete(oncomplete, 200, {}), resolveFunc && resolveFunc(!0)), _isOneDs && !responseHandled && payload[_DYN_TIMEOUT] > 0 && _timeoutWrapper && _timeoutWrapper.set(function () {
                responseHandled || (responseHandled = !0, _doOnComplete(oncomplete, 500, {}), resolveFunc && resolveFunc(!0));
              }, payload[_DYN_TIMEOUT]), thePromise;
            }
            __name(_doFetchSender, "_doFetchSender");
            function _xdrSender(payload, oncomplete, sync) {
              var _window = getWindow(),
                xdr = new XDomainRequest(),
                data = payload[_DYN_DATA];
              xdr.onload = function () {
                var response = getResponseText(xdr),
                  onloadFunc = _onCompleteFuncs && _onCompleteFuncs.xdrOnComplete;
                onloadFunc && isFunction(onloadFunc) ? onloadFunc(xdr, oncomplete, payload) : _doOnComplete(oncomplete, 200, {}, response);
              }, xdr.onerror = function () {
                _doOnComplete(oncomplete, 400, {}, _isOneDs ? STR_EMPTY : formatErrorMessageXdr(xdr));
              }, xdr.ontimeout = function () {
                _doOnComplete(oncomplete, 500, {});
              }, xdr.onprogress = function () {};
              var hostingProtocol = _window && _window.location && _window.location.protocol || "",
                endpoint = payload[_DYN_URL_STRING];
              if (!endpoint) {
                _onNoPayloadUrl(oncomplete);
                return;
              }
              if (!_isOneDs && endpoint.lastIndexOf(hostingProtocol, 0) !== 0) {
                var msg = "Cannot send XDomain request. The endpoint URL protocol doesn't match the hosting page protocol.";
                _throwInternal(_diagLog, 2, 40, ". " + msg), _onError(msg, oncomplete);
                return;
              }
              var endpointUrl = _isOneDs ? endpoint : endpoint[_DYN_REPLACE](/^(https?:)/, "");
              xdr.open(STR_POST_METHOD, endpointUrl), payload[_DYN_TIMEOUT] && (xdr[_DYN_TIMEOUT] = payload[_DYN_TIMEOUT]), xdr.send(data), _isOneDs && sync ? _timeoutWrapper && _timeoutWrapper.set(function () {
                xdr.send(data);
              }, 0) : xdr.send(data);
            }
            __name(_xdrSender, "_xdrSender");
            function _initDefaults() {
              _syncFetchPayload = 0, _isInitialized = !1, _enableSendPromise = !1, _diagLog = null, _isOneDs = null, _onCompleteFuncs = null, _disableCredentials = null, _fetchCredentials = null, _fallbackInst = null, _disableXhr = !1, _disableBeacon = !1, _disableBeaconSync = !1, _disableFetchKeepAlive = !1, _addNoResponse = !1, _timeoutWrapper = null;
            }
            __name(_initDefaults, "_initDefaults");
          });
        }
        return __name(SenderPostManager, "SenderPostManager"), f.__ieDyn = 1, SenderPostManager;
      }(),
      strOnPrefix = "on",
      strAttachEvent = "attachEvent",
      strAddEventHelper = "addEventListener",
      strDetachEvent = "detachEvent",
      strRemoveEventListener = "removeEventListener",
      strEvents = "events";
    createUniqueNamespace("aiEvtPageHide"), createUniqueNamespace("aiEvtPageShow");
    var rRemoveEmptyNs = /\.[\.]+/g,
      rRemoveTrailingEmptyNs = /[\.]+$/,
      _guid = 1,
      elmNodeData = createElmNodeData("events"),
      eventNamespace = /^([^.]*)(?:\.(.+)|)/;
    function _normalizeNamespace(name) {
      return name && name[_DYN_REPLACE] ? name[_DYN_REPLACE](/^[\s\.]+|(?=[\s\.])[\.\s]+$/g, STR_EMPTY) : name;
    }
    __name(_normalizeNamespace, "_normalizeNamespace");
    function _getEvtNamespace(eventName, evtNamespace) {
      if (evtNamespace) {
        var theNamespace_1 = STR_EMPTY;
        isArray(evtNamespace) ? (theNamespace_1 = STR_EMPTY, arrForEach(evtNamespace, function (name) {
          name = _normalizeNamespace(name), name && (name[0] !== "." && (name = "." + name), theNamespace_1 += name);
        })) : theNamespace_1 = _normalizeNamespace(evtNamespace), theNamespace_1 && (theNamespace_1[0] !== "." && (theNamespace_1 = "." + theNamespace_1), eventName = (eventName || STR_EMPTY) + theNamespace_1);
      }
      var parsedEvent = eventNamespace.exec(eventName || STR_EMPTY) || [];
      return {
        type: parsedEvent[1],
        ns: (parsedEvent[2] || STR_EMPTY).replace(rRemoveEmptyNs, ".").replace(rRemoveTrailingEmptyNs, STR_EMPTY)[_DYN_SPLIT](".").sort().join(".")
      };
    }
    __name(_getEvtNamespace, "_getEvtNamespace");
    function _getRegisteredEvents(target, evtName, addDefault) {
      addDefault === void 0 && (addDefault = !0);
      var aiEvts = elmNodeData.get(target, strEvents, {}, addDefault),
        registeredEvents = aiEvts[evtName];
      return registeredEvents || (registeredEvents = aiEvts[evtName] = []), registeredEvents;
    }
    __name(_getRegisteredEvents, "_getRegisteredEvents");
    function _doDetach(obj, evtName, handlerRef, useCapture) {
      obj && evtName && evtName[_DYN_TYPE] && (obj[strRemoveEventListener] ? obj[strRemoveEventListener](evtName[_DYN_TYPE], handlerRef, useCapture) : obj[strDetachEvent] && obj[strDetachEvent](strOnPrefix + evtName[_DYN_TYPE], handlerRef));
    }
    __name(_doDetach, "_doDetach");
    function _doAttach(obj, evtName, handlerRef, useCapture) {
      var result = !1;
      return obj && evtName && evtName[_DYN_TYPE] && handlerRef && (obj[strAddEventHelper] ? (obj[strAddEventHelper](evtName[_DYN_TYPE], handlerRef, useCapture), result = !0) : obj[strAttachEvent] && (obj[strAttachEvent](strOnPrefix + evtName[_DYN_TYPE], handlerRef), result = !0)), result;
    }
    __name(_doAttach, "_doAttach");
    function _doUnregister(target, events, evtName, unRegFn) {
      for (var idx = events[_DYN_LENGTH]; idx--;) {
        var theEvent = events[idx];
        theEvent && (!evtName.ns || evtName.ns === theEvent[_DYN_EVT_NAME].ns) && (!unRegFn || unRegFn(theEvent)) && (_doDetach(target, theEvent[_DYN_EVT_NAME], theEvent.handler, theEvent.capture), events[_DYN_SPLICE](idx, 1));
      }
    }
    __name(_doUnregister, "_doUnregister");
    function _unregisterEvents(target, evtName, unRegFn) {
      if (evtName[_DYN_TYPE]) _doUnregister(target, _getRegisteredEvents(target, evtName[_DYN_TYPE]), evtName, unRegFn);else {
        var eventCache = elmNodeData.get(target, strEvents, {});
        objForEachKey(eventCache, function (evtType, events) {
          _doUnregister(target, events, evtName, unRegFn);
        }), objKeys(eventCache)[_DYN_LENGTH] === 0 && elmNodeData.kill(target, strEvents);
      }
    }
    __name(_unregisterEvents, "_unregisterEvents");
    function mergeEvtNamespace(theNamespace, namespaces) {
      var newNamespaces;
      return namespaces ? (isArray(namespaces) ? newNamespaces = [theNamespace].concat(namespaces) : newNamespaces = [theNamespace, namespaces], newNamespaces = _getEvtNamespace("xx", newNamespaces).ns[_DYN_SPLIT](".")) : newNamespaces = theNamespace, newNamespaces;
    }
    __name(mergeEvtNamespace, "mergeEvtNamespace");
    function eventOn(target, eventName, handlerRef, evtNamespace, useCapture) {
      useCapture === void 0 && (useCapture = !1);
      var result = !1;
      if (target) try {
        var evtName = _getEvtNamespace(eventName, evtNamespace);
        if (result = _doAttach(target, evtName, handlerRef, useCapture), result && elmNodeData.accept(target)) {
          var registeredEvent = {
            guid: _guid++,
            evtName: evtName,
            handler: handlerRef,
            capture: useCapture
          };
          _getRegisteredEvents(target, evtName.type)[_DYN_PUSH](registeredEvent);
        }
      } catch {}
      return result;
    }
    __name(eventOn, "eventOn");
    function eventOff(target, eventName, handlerRef, evtNamespace, useCapture) {
      if (useCapture === void 0 && (useCapture = !1), target) try {
        var evtName_1 = _getEvtNamespace(eventName, evtNamespace),
          found_1 = !1;
        _unregisterEvents(target, evtName_1, function (regEvent) {
          return evtName_1.ns && !handlerRef || regEvent.handler === handlerRef ? (found_1 = !0, !0) : !1;
        }), found_1 || _doDetach(target, evtName_1, handlerRef, useCapture);
      } catch {}
    }
    __name(eventOff, "eventOff");
    var SampleRate = "sampleRate",
      ProcessLegacy = "ProcessLegacy",
      HttpMethod = "http.method",
      DEFAULT_BREEZE_ENDPOINT = "https://dc.services.visualstudio.com",
      DEFAULT_BREEZE_PATH = "/v2/track",
      strNotSpecified = "not_specified",
      RequestHeaders = createValueMap({
        requestContextHeader: [0, "Request-Context"],
        requestContextTargetKey: [1, "appId"],
        requestContextAppIdFormat: [2, "appId=cid-v1:"],
        requestIdHeader: [3, "Request-Id"],
        traceParentHeader: [4, "traceparent"],
        traceStateHeader: [5, "tracestate"],
        sdkContextHeader: [6, "Sdk-Context"],
        sdkContextHeaderAppIdRequest: [7, "appId"],
        requestContextHeaderLowerCase: [8, "request-context"]
      }),
      _DYN_SPLIT = "split",
      _DYN_LENGTH = "length",
      _DYN_TO_LOWER_CASE = "toLowerCase",
      _DYN_INGESTIONENDPOINT = "ingestionendpoint",
      _DYN_TO_STRING = "toString",
      _DYN_REMOVE_ITEM = "removeItem",
      _DYN_MESSAGE = "message",
      _DYN_COUNT = "count",
      _DYN_STRINGIFY = "stringify",
      _DYN_PATHNAME = "pathname",
      _DYN_MATCH = "match",
      _DYN_NAME = "name",
      _DYN_PROPERTIES = "properties",
      _DYN_MEASUREMENTS = "measurements",
      _DYN_SIZE_IN_BYTES = "sizeInBytes",
      _DYN_TYPE_NAME = "typeName",
      _DYN_EXCEPTIONS = "exceptions",
      _DYN_SEVERITY_LEVEL = "severityLevel",
      _DYN_PROBLEM_GROUP = "problemGroup",
      _DYN_PARSED_STACK = "parsedStack",
      _DYN_HAS_FULL_STACK = "hasFullStack",
      _DYN_ASSEMBLY = "assembly",
      _DYN_FILE_NAME = "fileName",
      _DYN_LINE = "line",
      _DYN_AI_DATA_CONTRACT = "aiDataContract",
      _DYN_DURATION = "duration";
    function dataSanitizeKeyAndAddUniqueness(logger, key, map) {
      var origLength = key[_DYN_LENGTH],
        field = dataSanitizeKey(logger, key);
      if (field[_DYN_LENGTH] !== origLength) {
        for (var i = 0, uniqueField = field; map[uniqueField] !== void 0;) i++, uniqueField = strSubstring(field, 0, 147) + dsPadNumber(i);
        field = uniqueField;
      }
      return field;
    }
    __name(dataSanitizeKeyAndAddUniqueness, "dataSanitizeKeyAndAddUniqueness");
    function dataSanitizeKey(logger, name) {
      var nameTrunc;
      return name && (name = strTrim(asString(name)), name[_DYN_LENGTH] > 150 && (nameTrunc = strSubstring(name, 0, 150), _throwInternal(logger, 2, 57, "name is too long.  It has been truncated to 150 characters.", {
        name: name
      }, !0))), nameTrunc || name;
    }
    __name(dataSanitizeKey, "dataSanitizeKey");
    function dataSanitizeString(logger, value, maxLength) {
      maxLength === void 0 && (maxLength = 1024);
      var valueTrunc;
      return value && (maxLength = maxLength || 1024, value = strTrim(asString(value)), value[_DYN_LENGTH] > maxLength && (valueTrunc = strSubstring(value, 0, maxLength), _throwInternal(logger, 2, 61, "string value is too long. It has been truncated to " + maxLength + " characters.", {
        value: value
      }, !0))), valueTrunc || value;
    }
    __name(dataSanitizeString, "dataSanitizeString");
    function dataSanitizeUrl(logger, url) {
      return dataSanitizeInput(logger, url, 2048, 66);
    }
    __name(dataSanitizeUrl, "dataSanitizeUrl");
    function dataSanitizeMessage(logger, message) {
      var messageTrunc;
      return message && message[_DYN_LENGTH] > 32768 && (messageTrunc = strSubstring(message, 0, 32768), _throwInternal(logger, 2, 56, "message is too long, it has been truncated to 32768 characters.", {
        message: message
      }, !0)), messageTrunc || message;
    }
    __name(dataSanitizeMessage, "dataSanitizeMessage");
    function dataSanitizeException(logger, exception) {
      var exceptionTrunc;
      if (exception) {
        var value = "" + exception;
        value[_DYN_LENGTH] > 32768 && (exceptionTrunc = strSubstring(value, 0, 32768), _throwInternal(logger, 2, 52, "exception is too long, it has been truncated to 32768 characters.", {
          exception: exception
        }, !0));
      }
      return exceptionTrunc || exception;
    }
    __name(dataSanitizeException, "dataSanitizeException");
    function dataSanitizeProperties(logger, properties) {
      if (properties) {
        var tempProps_1 = {};
        objForEachKey(properties, function (prop, value) {
          if (isObject(value) && hasJSON()) try {
            value = getJSON()[_DYN_STRINGIFY](value);
          } catch (e) {
            _throwInternal(logger, 2, 49, "custom property is not valid", {
              exception: e
            }, !0);
          }
          value = dataSanitizeString(logger, value, 8192), prop = dataSanitizeKeyAndAddUniqueness(logger, prop, tempProps_1), tempProps_1[prop] = value;
        }), properties = tempProps_1;
      }
      return properties;
    }
    __name(dataSanitizeProperties, "dataSanitizeProperties");
    function dataSanitizeMeasurements(logger, measurements) {
      if (measurements) {
        var tempMeasurements_1 = {};
        objForEachKey(measurements, function (measure, value) {
          measure = dataSanitizeKeyAndAddUniqueness(logger, measure, tempMeasurements_1), tempMeasurements_1[measure] = value;
        }), measurements = tempMeasurements_1;
      }
      return measurements;
    }
    __name(dataSanitizeMeasurements, "dataSanitizeMeasurements");
    function dataSanitizeId(logger, id) {
      return id && dataSanitizeInput(logger, id, 128, 69)[_DYN_TO_STRING]();
    }
    __name(dataSanitizeId, "dataSanitizeId");
    function dataSanitizeInput(logger, input, maxLength, _msgId) {
      var inputTrunc;
      return input && (input = strTrim(asString(input)), input[_DYN_LENGTH] > maxLength && (inputTrunc = strSubstring(input, 0, maxLength), _throwInternal(logger, 2, _msgId, "input is too long, it has been truncated to " + maxLength + " characters.", {
        data: input
      }, !0))), inputTrunc || input;
    }
    __name(dataSanitizeInput, "dataSanitizeInput");
    function dsPadNumber(num) {
      var s = "00" + num;
      return strSubstr(s, s[_DYN_LENGTH] - 3);
    }
    __name(dsPadNumber, "dsPadNumber");
    var _document = getDocument() || {},
      _htmlAnchorIdx = 0,
      _htmlAnchorElement = [null, null, null, null, null];
    function urlParseUrl(url) {
      var anchorIdx = _htmlAnchorIdx,
        anchorCache = _htmlAnchorElement,
        tempAnchor = anchorCache[anchorIdx];
      return _document.createElement ? anchorCache[anchorIdx] || (tempAnchor = anchorCache[anchorIdx] = _document.createElement("a")) : tempAnchor = {
        host: urlParseHost(url, !0)
      }, tempAnchor.href = url, anchorIdx++, anchorIdx >= anchorCache[_DYN_LENGTH] && (anchorIdx = 0), _htmlAnchorIdx = anchorIdx, tempAnchor;
    }
    __name(urlParseUrl, "urlParseUrl");
    function urlParseHost(url, inclPort) {
      var fullHost = urlParseFullHost(url, inclPort) || "";
      if (fullHost) {
        var match = fullHost[_DYN_MATCH](/(www\d{0,5}\.)?([^\/:]{1,256})(:\d{1,20})?/i);
        if (match != null && match[_DYN_LENGTH] > 3 && isString(match[2]) && match[2][_DYN_LENGTH] > 0) return match[2] + (match[3] || "");
      }
      return fullHost;
    }
    __name(urlParseHost, "urlParseHost");
    function urlParseFullHost(url, inclPort) {
      var result = null;
      if (url) {
        var match = url[_DYN_MATCH](/(\w{1,150}):\/\/([^\/:]{1,256})(:\d{1,20})?/i);
        if (match != null && match[_DYN_LENGTH] > 2 && isString(match[2]) && match[2][_DYN_LENGTH] > 0 && (result = match[2] || "", inclPort && match[_DYN_LENGTH] > 2)) {
          var protocol = (match[1] || "")[_DYN_TO_LOWER_CASE](),
            port = match[3] || "";
          (protocol === "http" && port === ":80" || protocol === "https" && port === ":443") && (port = ""), result += port;
        }
      }
      return result;
    }
    __name(urlParseFullHost, "urlParseFullHost");
    var _internalEndpoints = [DEFAULT_BREEZE_ENDPOINT + DEFAULT_BREEZE_PATH, "https://breeze.aimon.applicationinsights.io" + DEFAULT_BREEZE_PATH, "https://dc-int.services.visualstudio.com" + DEFAULT_BREEZE_PATH];
    function isInternalApplicationInsightsEndpoint(endpointUrl) {
      return arrIndexOf(_internalEndpoints, endpointUrl[_DYN_TO_LOWER_CASE]()) !== -1;
    }
    __name(isInternalApplicationInsightsEndpoint, "isInternalApplicationInsightsEndpoint");
    function AjaxHelperParseDependencyPath(logger, absoluteUrl, method, commandName) {
      var target,
        name = commandName,
        data = commandName;
      if (absoluteUrl && absoluteUrl[_DYN_LENGTH] > 0) {
        var parsedUrl = urlParseUrl(absoluteUrl);
        if (target = parsedUrl.host, !name) if (parsedUrl[_DYN_PATHNAME] != null) {
          var pathName = parsedUrl.pathname[_DYN_LENGTH] === 0 ? "/" : parsedUrl[_DYN_PATHNAME];
          pathName.charAt(0) !== "/" && (pathName = "/" + pathName), data = parsedUrl[_DYN_PATHNAME], name = dataSanitizeString(logger, method ? method + " " + pathName : pathName);
        } else name = dataSanitizeString(logger, absoluteUrl);
      } else target = commandName, name = commandName;
      return {
        target: target,
        name: name,
        data: data
      };
    }
    __name(AjaxHelperParseDependencyPath, "AjaxHelperParseDependencyPath");
    var StorageType = createEnumStyle({
        LocalStorage: 0,
        SessionStorage: 1
      }),
      _canUseSessionStorage = void 0,
      _storagePrefix = "";
    function _getVerifiedStorageObject(storageType) {
      try {
        if (isNullOrUndefined(getGlobal())) return null;
        var uid = new Date()[_DYN_TO_STRING](),
          storage = getGlobalInst(storageType === StorageType.LocalStorage ? "localStorage" : "sessionStorage"),
          name_1 = _storagePrefix + uid;
        storage.setItem(name_1, uid);
        var fail = storage.getItem(name_1) !== uid;
        if (storage[_DYN_REMOVE_ITEM](name_1), !fail) return storage;
      } catch {}
      return null;
    }
    __name(_getVerifiedStorageObject, "_getVerifiedStorageObject");
    function _getSessionStorageObject() {
      return utlCanUseSessionStorage() ? _getVerifiedStorageObject(StorageType.SessionStorage) : null;
    }
    __name(_getSessionStorageObject, "_getSessionStorageObject");
    function utlSetStoragePrefix(storagePrefix) {
      _storagePrefix = storagePrefix || "";
    }
    __name(utlSetStoragePrefix, "utlSetStoragePrefix");
    function utlCanUseSessionStorage(reset) {
      return (reset || _canUseSessionStorage === void 0) && (_canUseSessionStorage = !!_getVerifiedStorageObject(StorageType.SessionStorage)), _canUseSessionStorage;
    }
    __name(utlCanUseSessionStorage, "utlCanUseSessionStorage");
    function utlGetSessionStorage(logger, name) {
      var storage = _getSessionStorageObject();
      if (storage !== null) try {
        return storage.getItem(name);
      } catch (e) {
        _canUseSessionStorage = !1, _throwInternal(logger, 2, 2, "Browser failed read of session storage. " + getExceptionName(e), {
          exception: dumpObj(e)
        });
      }
      return null;
    }
    __name(utlGetSessionStorage, "utlGetSessionStorage");
    function utlSetSessionStorage(logger, name, data) {
      var storage = _getSessionStorageObject();
      if (storage !== null) try {
        return storage.setItem(name, data), !0;
      } catch (e) {
        _canUseSessionStorage = !1, _throwInternal(logger, 2, 4, "Browser failed write to session storage. " + getExceptionName(e), {
          exception: dumpObj(e)
        });
      }
      return !1;
    }
    __name(utlSetSessionStorage, "utlSetSessionStorage");
    function utlRemoveSessionStorage(logger, name) {
      var storage = _getSessionStorageObject();
      if (storage !== null) try {
        return storage[_DYN_REMOVE_ITEM](name), !0;
      } catch (e) {
        _canUseSessionStorage = !1, _throwInternal(logger, 2, 6, "Browser failed removal of session storage item. " + getExceptionName(e), {
          exception: dumpObj(e)
        });
      }
      return !1;
    }
    __name(utlRemoveSessionStorage, "utlRemoveSessionStorage");
    var _FIELDS_SEPARATOR = ";",
      _FIELD_KEY_VALUE_SEPARATOR = "=";
    function parseConnectionString(connectionString) {
      if (!connectionString) return {};
      var kvPairs = connectionString[_DYN_SPLIT](_FIELDS_SEPARATOR),
        result = arrReduce(kvPairs, function (fields, kv) {
          var kvParts = kv[_DYN_SPLIT](_FIELD_KEY_VALUE_SEPARATOR);
          if (kvParts[_DYN_LENGTH] === 2) {
            var key = kvParts[0][_DYN_TO_LOWER_CASE](),
              value = kvParts[1];
            fields[key] = value;
          }
          return fields;
        }, {});
      if (objKeys(result)[_DYN_LENGTH] > 0) {
        if (result.endpointsuffix) {
          var locationPrefix = result.location ? result.location + "." : "";
          result[_DYN_INGESTIONENDPOINT] = result[_DYN_INGESTIONENDPOINT] || "https://" + locationPrefix + "dc." + result.endpointsuffix;
        }
        result[_DYN_INGESTIONENDPOINT] = result[_DYN_INGESTIONENDPOINT] || DEFAULT_BREEZE_ENDPOINT, strEndsWith(result[_DYN_INGESTIONENDPOINT], "/") && (result[_DYN_INGESTIONENDPOINT] = result[_DYN_INGESTIONENDPOINT].slice(0, -1));
      }
      return result;
    }
    __name(parseConnectionString, "parseConnectionString");
    var Envelope = function () {
        function Envelope(logger, data, name) {
          var _this = this,
            _self = this;
          _self.ver = 1, _self.sampleRate = 100, _self.tags = {}, _self[_DYN_NAME] = dataSanitizeString(logger, name) || strNotSpecified, _self.data = data, _self.time = toISOString(new Date()), _self[_DYN_AI_DATA_CONTRACT] = {
            time: 1,
            iKey: 1,
            name: 1,
            sampleRate: __name(function () {
              return _this.sampleRate === 100 ? 4 : 1;
            }, "sampleRate"),
            tags: 1,
            data: 1
          };
        }
        return __name(Envelope, "Envelope"), Envelope;
      }(),
      Event = function () {
        function Event(logger, name, properties, measurements) {
          this.aiDataContract = {
            ver: 1,
            name: 1,
            properties: 0,
            measurements: 0
          };
          var _self = this;
          _self.ver = 2, _self[_DYN_NAME] = dataSanitizeString(logger, name) || strNotSpecified, _self[_DYN_PROPERTIES] = dataSanitizeProperties(logger, properties), _self[_DYN_MEASUREMENTS] = dataSanitizeMeasurements(logger, measurements);
        }
        return __name(Event, "Event"), Event.envelopeType = "Microsoft.ApplicationInsights.{0}.Event", Event.dataType = "EventData", Event;
      }(),
      STACKFRAME_BASE_SIZE = 58,
      IS_FRAME = /^\s{0,50}(from\s|at\s|Line\s{1,5}\d{1,10}\s{1,5}of|\w{1,50}@\w{1,80}|[^\(\s\n]+:[0-9\?]+(?::[0-9\?]+)?)/,
      FULL_STACK_FRAME_1 = /^(?:\s{0,50}at)?\s{0,50}([^\@\()\s]+)?\s{0,50}(?:\s|\@|\()\s{0,5}([^\(\s\n\]]+):([0-9\?]+):([0-9\?]+)\)?$/,
      FULL_STACK_FRAME_2 = /^(?:\s{0,50}at)?\s{0,50}([^\@\()\s]+)?\s{0,50}(?:\s|\@|\()\s{0,5}([^\(\s\n\]]+):([0-9\?]+)\)?$/,
      FULL_STACK_FRAME_3 = /^(?:\s{0,50}at)?\s{0,50}([^\@\()\s]+)?\s{0,50}(?:\s|\@|\()\s{0,5}([^\(\s\n\)\]]+)\)?$/,
      EXTRACT_FILENAME = /(?:^|\(|\s{0,10}[\w\)]+\@)?([^\(\n\s\]\)]+)(?:\:([0-9]+)(?:\:([0-9]+))?)?\)?(?:,|$)/,
      PARSE_FILENAME_LINE_COL = /([^\(\s\n]+):([0-9]+):([0-9]+)$/,
      PARSE_FILENAME_LINE_ONLY = /([^\(\s\n]+):([0-9]+)$/,
      NoMethod = "<no_method>",
      strError = "error",
      strStack = "stack",
      strStackDetails = "stackDetails",
      strErrorSrc = "errorSrc",
      strMessage = "message",
      strDescription = "description",
      _parseSequence = [{
        re: FULL_STACK_FRAME_1,
        len: 5,
        m: 1,
        fn: 2,
        ln: 3,
        col: 4
      }, {
        chk: _ignoreNative,
        pre: _scrubAnonymous,
        re: FULL_STACK_FRAME_2,
        len: 4,
        m: 1,
        fn: 2,
        ln: 3
      }, {
        re: FULL_STACK_FRAME_3,
        len: 3,
        m: 1,
        fn: 2,
        hdl: _handleFilename
      }, {
        re: EXTRACT_FILENAME,
        len: 2,
        fn: 1,
        hdl: _handleFilename
      }];
    function _scrubAnonymous(frame) {
      return frame.replace(/(\(anonymous\))/, "<anonymous>");
    }
    __name(_scrubAnonymous, "_scrubAnonymous");
    function _ignoreNative(frame) {
      return strIndexOf(frame, "[native") < 0;
    }
    __name(_ignoreNative, "_ignoreNative");
    function _stringify(value, convertToString) {
      var result = value;
      return result && !isString(result) && (JSON && JSON[_DYN_STRINGIFY] ? (result = JSON[_DYN_STRINGIFY](value), convertToString && (!result || result === "{}") && (isFunction(value[_DYN_TO_STRING]) ? result = value[_DYN_TO_STRING]() : result = "" + value)) : result = "" + value + " - (Missing JSON.stringify)"), result || "";
    }
    __name(_stringify, "_stringify");
    function _formatMessage(theEvent, errorType) {
      var evtMessage = theEvent;
      return theEvent && (evtMessage && !isString(evtMessage) && (evtMessage = theEvent[strMessage] || theEvent[strDescription] || evtMessage), evtMessage && !isString(evtMessage) && (evtMessage = _stringify(evtMessage, !0)), theEvent.filename && (evtMessage = evtMessage + " @" + (theEvent.filename || "") + ":" + (theEvent.lineno || "?") + ":" + (theEvent.colno || "?"))), errorType && errorType !== "String" && errorType !== "Object" && errorType !== "Error" && strIndexOf(evtMessage || "", errorType) === -1 && (evtMessage = errorType + ": " + evtMessage), evtMessage || "";
    }
    __name(_formatMessage, "_formatMessage");
    function _isExceptionDetailsInternal(value) {
      try {
        if (isObject(value)) return "hasFullStack" in value && "typeName" in value;
      } catch {}
      return !1;
    }
    __name(_isExceptionDetailsInternal, "_isExceptionDetailsInternal");
    function _isExceptionInternal(value) {
      try {
        if (isObject(value)) return "ver" in value && "exceptions" in value && "properties" in value;
      } catch {}
      return !1;
    }
    __name(_isExceptionInternal, "_isExceptionInternal");
    function _isStackDetails(details) {
      return details && details.src && isString(details.src) && details.obj && isArray(details.obj);
    }
    __name(_isStackDetails, "_isStackDetails");
    function _convertStackObj(errorStack) {
      var src = errorStack || "";
      isString(src) || (isString(src[strStack]) ? src = src[strStack] : src = "" + src);
      var items = src[_DYN_SPLIT](`
`);
      return {
        src: src,
        obj: items
      };
    }
    __name(_convertStackObj, "_convertStackObj");
    function _getOperaStack(errorMessage) {
      for (var stack = [], lines = errorMessage[_DYN_SPLIT](`
`), lp = 0; lp < lines[_DYN_LENGTH]; lp++) {
        var entry = lines[lp];
        lines[lp + 1] && (entry += "@" + lines[lp + 1], lp++), stack.push(entry);
      }
      return {
        src: errorMessage,
        obj: stack
      };
    }
    __name(_getOperaStack, "_getOperaStack");
    function _getStackFromErrorObj(errorObj) {
      var details = null;
      if (errorObj) try {
        if (errorObj[strStack]) details = _convertStackObj(errorObj[strStack]);else if (errorObj[strError] && errorObj[strError][strStack]) details = _convertStackObj(errorObj[strError][strStack]);else if (errorObj.exception && errorObj.exception[strStack]) details = _convertStackObj(errorObj.exception[strStack]);else if (_isStackDetails(errorObj)) details = errorObj;else if (_isStackDetails(errorObj[strStackDetails])) details = errorObj[strStackDetails];else if (getWindow() && getWindow().opera && errorObj[strMessage]) details = _getOperaStack(errorObj[_DYN_MESSAGE]);else if (errorObj.reason && errorObj.reason[strStack]) details = _convertStackObj(errorObj.reason[strStack]);else if (isString(errorObj)) details = _convertStackObj(errorObj);else {
          var evtMessage = errorObj[strMessage] || errorObj[strDescription] || "";
          isString(errorObj[strErrorSrc]) && (evtMessage && (evtMessage += `
`), evtMessage += " from " + errorObj[strErrorSrc]), evtMessage && (details = _convertStackObj(evtMessage));
        }
      } catch (e) {
        details = _convertStackObj(e);
      }
      return details || {
        src: "",
        obj: null
      };
    }
    __name(_getStackFromErrorObj, "_getStackFromErrorObj");
    function _formatStackTrace(stackDetails) {
      var stack = "";
      return stackDetails && (stackDetails.obj ? stack = stackDetails.obj.join(`
`) : stack = stackDetails.src || ""), stack;
    }
    __name(_formatStackTrace, "_formatStackTrace");
    function _parseStack(stack) {
      var parsedStack,
        frames = stack.obj;
      if (frames && frames[_DYN_LENGTH] > 0) {
        parsedStack = [];
        var level_1 = 0,
          foundStackStart_1 = !1,
          totalSizeInBytes_1 = 0;
        arrForEach(frames, function (frame) {
          if (foundStackStart_1 || _isStackFrame(frame)) {
            var theFrame = asString(frame);
            foundStackStart_1 = !0;
            var parsedFrame = _extractStackFrame(theFrame, level_1);
            parsedFrame && (totalSizeInBytes_1 += parsedFrame[_DYN_SIZE_IN_BYTES], parsedStack.push(parsedFrame), level_1++);
          }
        });
        var exceptionParsedStackThreshold = 32 * 1024;
        if (totalSizeInBytes_1 > exceptionParsedStackThreshold) for (var left = 0, right = parsedStack[_DYN_LENGTH] - 1, size = 0, acceptedLeft = left, acceptedRight = right; left < right;) {
          var lSize = parsedStack[left][_DYN_SIZE_IN_BYTES],
            rSize = parsedStack[right][_DYN_SIZE_IN_BYTES];
          if (size += lSize + rSize, size > exceptionParsedStackThreshold) {
            var howMany = acceptedRight - acceptedLeft + 1;
            parsedStack.splice(acceptedLeft, howMany);
            break;
          }
          acceptedLeft = left, acceptedRight = right, left++, right--;
        }
      }
      return parsedStack;
    }
    __name(_parseStack, "_parseStack");
    function _getErrorType(errorType) {
      var typeName = "";
      if (errorType && (typeName = errorType.typeName || errorType[_DYN_NAME] || "", !typeName)) try {
        var funcNameRegex = /function (.{1,200})\(/,
          results = funcNameRegex.exec(errorType.constructor[_DYN_TO_STRING]());
        typeName = results && results[_DYN_LENGTH] > 1 ? results[1] : "";
      } catch {}
      return typeName;
    }
    __name(_getErrorType, "_getErrorType");
    function _formatErrorCode(errorObj) {
      if (errorObj) try {
        if (!isString(errorObj)) {
          var errorType = _getErrorType(errorObj),
            result = _stringify(errorObj, !1);
          return (!result || result === "{}") && (errorObj[strError] && (errorObj = errorObj[strError], errorType = _getErrorType(errorObj)), result = _stringify(errorObj, !0)), strIndexOf(result, errorType) !== 0 && errorType !== "String" ? errorType + ":" + result : result;
        }
      } catch {}
      return "" + (errorObj || "");
    }
    __name(_formatErrorCode, "_formatErrorCode");
    var Exception = function () {
        function Exception(logger, exception, properties, measurements, severityLevel, id) {
          this.aiDataContract = {
            ver: 1,
            exceptions: 1,
            severityLevel: 0,
            properties: 0,
            measurements: 0
          };
          var _self = this;
          _self.ver = 2, _isExceptionInternal(exception) ? (_self[_DYN_EXCEPTIONS] = exception[_DYN_EXCEPTIONS] || [], _self[_DYN_PROPERTIES] = exception[_DYN_PROPERTIES], _self[_DYN_MEASUREMENTS] = exception[_DYN_MEASUREMENTS], exception[_DYN_SEVERITY_LEVEL] && (_self[_DYN_SEVERITY_LEVEL] = exception[_DYN_SEVERITY_LEVEL]), exception.id && (_self.id = exception.id, exception[_DYN_PROPERTIES].id = exception.id), exception[_DYN_PROBLEM_GROUP] && (_self[_DYN_PROBLEM_GROUP] = exception[_DYN_PROBLEM_GROUP]), isNullOrUndefined(exception.isManual) || (_self.isManual = exception.isManual)) : (properties || (properties = {}), id && (properties.id = id), _self[_DYN_EXCEPTIONS] = [_createExceptionDetails(logger, exception, properties)], _self[_DYN_PROPERTIES] = dataSanitizeProperties(logger, properties), _self[_DYN_MEASUREMENTS] = dataSanitizeMeasurements(logger, measurements), severityLevel && (_self[_DYN_SEVERITY_LEVEL] = severityLevel), id && (_self.id = id));
        }
        return __name(Exception, "Exception"), Exception.CreateAutoException = function (message, url, lineNumber, columnNumber, error, evt, stack, errorSrc) {
          var errorType = _getErrorType(error || evt || message);
          return {
            message: _formatMessage(message, errorType),
            url: url,
            lineNumber: lineNumber,
            columnNumber: columnNumber,
            error: _formatErrorCode(error || evt || message),
            evt: _formatErrorCode(evt || message),
            typeName: errorType,
            stackDetails: _getStackFromErrorObj(stack || error || evt),
            errorSrc: errorSrc
          };
        }, Exception.CreateFromInterface = function (logger, exception, properties, measurements) {
          var exceptions = exception[_DYN_EXCEPTIONS] && arrMap(exception[_DYN_EXCEPTIONS], function (ex) {
              return _createExDetailsFromInterface(logger, ex);
            }),
            exceptionData = new Exception(logger, __assign(__assign({}, exception), {
              exceptions: exceptions
            }), properties, measurements);
          return exceptionData;
        }, Exception.prototype.toInterface = function () {
          var _a = this,
            exceptions = _a.exceptions,
            properties = _a.properties,
            measurements = _a.measurements,
            severityLevel = _a.severityLevel,
            problemGroup = _a.problemGroup,
            id = _a.id,
            isManual = _a.isManual,
            exceptionDetailsInterface = exceptions instanceof Array && arrMap(exceptions, function (exception) {
              return exception.toInterface();
            }) || void 0;
          return {
            ver: "4.0",
            exceptions: exceptionDetailsInterface,
            severityLevel: severityLevel,
            properties: properties,
            measurements: measurements,
            problemGroup: problemGroup,
            id: id,
            isManual: isManual
          };
        }, Exception.CreateSimpleException = function (message, typeName, assembly, fileName, details, line) {
          var _a;
          return {
            exceptions: [(_a = {}, _a[_DYN_HAS_FULL_STACK] = !0, _a.message = message, _a.stack = details, _a.typeName = typeName, _a)]
          };
        }, Exception.envelopeType = "Microsoft.ApplicationInsights.{0}.Exception", Exception.dataType = "ExceptionData", Exception.formatError = _formatErrorCode, Exception;
      }(),
      exDetailsAiDataContract = objFreeze({
        id: 0,
        outerId: 0,
        typeName: 1,
        message: 1,
        hasFullStack: 0,
        stack: 0,
        parsedStack: 2
      });
    function _toInterface() {
      var _self = this,
        parsedStack = isArray(_self[_DYN_PARSED_STACK]) && arrMap(_self[_DYN_PARSED_STACK], function (frame) {
          return _parsedFrameToInterface(frame);
        }),
        exceptionDetailsInterface = {
          id: _self.id,
          outerId: _self.outerId,
          typeName: _self[_DYN_TYPE_NAME],
          message: _self[_DYN_MESSAGE],
          hasFullStack: _self[_DYN_HAS_FULL_STACK],
          stack: _self[strStack],
          parsedStack: parsedStack || void 0
        };
      return exceptionDetailsInterface;
    }
    __name(_toInterface, "_toInterface");
    function _createExceptionDetails(logger, exception, properties) {
      var _a, id, outerId, typeName, message, hasFullStack, theStack, parsedStack;
      if (_isExceptionDetailsInternal(exception)) typeName = exception[_DYN_TYPE_NAME], message = exception[_DYN_MESSAGE], theStack = exception[strStack], parsedStack = exception[_DYN_PARSED_STACK] || [], hasFullStack = exception[_DYN_HAS_FULL_STACK];else {
        var error = exception,
          evt = error && error.evt;
        isError(error) || (error = error[strError] || evt || error), typeName = dataSanitizeString(logger, _getErrorType(error)) || strNotSpecified, message = dataSanitizeMessage(logger, _formatMessage(exception || error, typeName)) || strNotSpecified;
        var stack = exception[strStackDetails] || _getStackFromErrorObj(exception);
        parsedStack = _parseStack(stack), isArray(parsedStack) && arrMap(parsedStack, function (frame) {
          frame[_DYN_ASSEMBLY] = dataSanitizeString(logger, frame[_DYN_ASSEMBLY]), frame[_DYN_FILE_NAME] = dataSanitizeString(logger, frame[_DYN_FILE_NAME]);
        }), theStack = dataSanitizeException(logger, _formatStackTrace(stack)), hasFullStack = isArray(parsedStack) && parsedStack[_DYN_LENGTH] > 0, properties && (properties[_DYN_TYPE_NAME] = properties[_DYN_TYPE_NAME] || typeName);
      }
      return _a = {}, _a[_DYN_AI_DATA_CONTRACT] = exDetailsAiDataContract, _a.id = id, _a.outerId = outerId, _a.typeName = typeName, _a.message = message, _a[_DYN_HAS_FULL_STACK] = hasFullStack, _a.stack = theStack, _a.parsedStack = parsedStack, _a.toInterface = _toInterface, _a;
    }
    __name(_createExceptionDetails, "_createExceptionDetails");
    function _createExDetailsFromInterface(logger, exception) {
      var parsedStack = isArray(exception[_DYN_PARSED_STACK]) && arrMap(exception[_DYN_PARSED_STACK], function (frame) {
          return _stackFrameFromInterface(frame);
        }) || exception[_DYN_PARSED_STACK],
        exceptionDetails = _createExceptionDetails(logger, __assign(__assign({}, exception), {
          parsedStack: parsedStack
        }));
      return exceptionDetails;
    }
    __name(_createExDetailsFromInterface, "_createExDetailsFromInterface");
    function _parseFilename(theFrame, fileName) {
      var lineCol = fileName[_DYN_MATCH](PARSE_FILENAME_LINE_COL);
      if (lineCol && lineCol[_DYN_LENGTH] >= 4) theFrame[_DYN_FILE_NAME] = lineCol[1], theFrame[_DYN_LINE] = parseInt(lineCol[2]);else {
        var lineNo = fileName[_DYN_MATCH](PARSE_FILENAME_LINE_ONLY);
        lineNo && lineNo[_DYN_LENGTH] >= 3 ? (theFrame[_DYN_FILE_NAME] = lineNo[1], theFrame[_DYN_LINE] = parseInt(lineNo[2])) : theFrame[_DYN_FILE_NAME] = fileName;
      }
    }
    __name(_parseFilename, "_parseFilename");
    function _handleFilename(theFrame, sequence, matches) {
      var filename = theFrame[_DYN_FILE_NAME];
      sequence.fn && matches && matches[_DYN_LENGTH] > sequence.fn && (sequence.ln && matches[_DYN_LENGTH] > sequence.ln ? (filename = strTrim(matches[sequence.fn] || ""), theFrame[_DYN_LINE] = parseInt(strTrim(matches[sequence.ln] || "")) || 0) : filename = strTrim(matches[sequence.fn] || "")), filename && _parseFilename(theFrame, filename);
    }
    __name(_handleFilename, "_handleFilename");
    function _isStackFrame(frame) {
      var result = !1;
      if (frame && isString(frame)) {
        var trimmedFrame = strTrim(frame);
        trimmedFrame && (result = IS_FRAME.test(trimmedFrame));
      }
      return result;
    }
    __name(_isStackFrame, "_isStackFrame");
    var stackFrameAiDataContract = objFreeze({
      level: 1,
      method: 1,
      assembly: 0,
      fileName: 0,
      line: 0
    });
    function _extractStackFrame(frame, level) {
      var _a, theFrame;
      if (frame && isString(frame) && strTrim(frame)) {
        theFrame = (_a = {}, _a[_DYN_AI_DATA_CONTRACT] = stackFrameAiDataContract, _a.level = level, _a.assembly = strTrim(frame), _a.method = NoMethod, _a.fileName = "", _a.line = 0, _a.sizeInBytes = 0, _a);
        for (var idx = 0; idx < _parseSequence[_DYN_LENGTH];) {
          var sequence = _parseSequence[idx];
          if (sequence.chk && !sequence.chk(frame)) break;
          sequence.pre && (frame = sequence.pre(frame));
          var matches = frame[_DYN_MATCH](sequence.re);
          if (matches && matches[_DYN_LENGTH] >= sequence.len) {
            sequence.m && (theFrame.method = strTrim(matches[sequence.m] || NoMethod)), sequence.hdl ? sequence.hdl(theFrame, sequence, matches) : sequence.fn && (sequence.ln ? (theFrame[_DYN_FILE_NAME] = strTrim(matches[sequence.fn] || ""), theFrame[_DYN_LINE] = parseInt(strTrim(matches[sequence.ln] || "")) || 0) : _parseFilename(theFrame, matches[sequence.fn] || ""));
            break;
          }
          idx++;
        }
      }
      return _populateFrameSizeInBytes(theFrame);
    }
    __name(_extractStackFrame, "_extractStackFrame");
    function _stackFrameFromInterface(frame) {
      var _a,
        parsedFrame = (_a = {}, _a[_DYN_AI_DATA_CONTRACT] = stackFrameAiDataContract, _a.level = frame.level, _a.method = frame.method, _a.assembly = frame[_DYN_ASSEMBLY], _a.fileName = frame[_DYN_FILE_NAME], _a.line = frame[_DYN_LINE], _a.sizeInBytes = 0, _a);
      return _populateFrameSizeInBytes(parsedFrame);
    }
    __name(_stackFrameFromInterface, "_stackFrameFromInterface");
    function _populateFrameSizeInBytes(frame) {
      var sizeInBytes = STACKFRAME_BASE_SIZE;
      return frame && (sizeInBytes += frame.method[_DYN_LENGTH], sizeInBytes += frame.assembly[_DYN_LENGTH], sizeInBytes += frame.fileName[_DYN_LENGTH], sizeInBytes += frame.level.toString()[_DYN_LENGTH], sizeInBytes += frame.line.toString()[_DYN_LENGTH], frame[_DYN_SIZE_IN_BYTES] = sizeInBytes), frame;
    }
    __name(_populateFrameSizeInBytes, "_populateFrameSizeInBytes");
    function _parsedFrameToInterface(frame) {
      return {
        level: frame.level,
        method: frame.method,
        assembly: frame[_DYN_ASSEMBLY],
        fileName: frame[_DYN_FILE_NAME],
        line: frame[_DYN_LINE]
      };
    }
    __name(_parsedFrameToInterface, "_parsedFrameToInterface");
    var DataPoint = function () {
        function DataPoint() {
          this.aiDataContract = {
            name: 1,
            kind: 0,
            value: 1,
            count: 0,
            min: 0,
            max: 0,
            stdDev: 0
          }, this.kind = 0;
        }
        return __name(DataPoint, "DataPoint"), DataPoint;
      }(),
      Metric = function () {
        function Metric(logger, name, value, count, min, max, stdDev, properties, measurements) {
          this.aiDataContract = {
            ver: 1,
            metrics: 1,
            properties: 0
          };
          var _self = this;
          _self.ver = 2;
          var dataPoint = new DataPoint();
          dataPoint[_DYN_COUNT] = count > 0 ? count : void 0, dataPoint.max = isNaN(max) || max === null ? void 0 : max, dataPoint.min = isNaN(min) || min === null ? void 0 : min, dataPoint[_DYN_NAME] = dataSanitizeString(logger, name) || strNotSpecified, dataPoint.value = value, dataPoint.stdDev = isNaN(stdDev) || stdDev === null ? void 0 : stdDev, _self.metrics = [dataPoint], _self[_DYN_PROPERTIES] = dataSanitizeProperties(logger, properties), _self[_DYN_MEASUREMENTS] = dataSanitizeMeasurements(logger, measurements);
        }
        return __name(Metric, "Metric"), Metric.envelopeType = "Microsoft.ApplicationInsights.{0}.Metric", Metric.dataType = "MetricData", Metric;
      }(),
      strEmpty = "";
    function msToTimeSpan(totalms) {
      (isNaN(totalms) || totalms < 0) && (totalms = 0), totalms = mathRound(totalms);
      var ms = strEmpty + totalms % 1e3,
        sec = strEmpty + mathFloor(totalms / 1e3) % 60,
        min = strEmpty + mathFloor(totalms / (1e3 * 60)) % 60,
        hour = strEmpty + mathFloor(totalms / (1e3 * 60 * 60)) % 24,
        days = mathFloor(totalms / (1e3 * 60 * 60 * 24));
      return ms = ms[_DYN_LENGTH] === 1 ? "00" + ms : ms[_DYN_LENGTH] === 2 ? "0" + ms : ms, sec = sec[_DYN_LENGTH] < 2 ? "0" + sec : sec, min = min[_DYN_LENGTH] < 2 ? "0" + min : min, hour = hour[_DYN_LENGTH] < 2 ? "0" + hour : hour, (days > 0 ? days + "." : strEmpty) + hour + ":" + min + ":" + sec + "." + ms;
    }
    __name(msToTimeSpan, "msToTimeSpan");
    var PageView = function () {
        function PageView(logger, name, url, durationMs, properties, measurements, id) {
          this.aiDataContract = {
            ver: 1,
            name: 0,
            url: 0,
            duration: 0,
            properties: 0,
            measurements: 0,
            id: 0
          };
          var _self = this;
          _self.ver = 2, _self.id = dataSanitizeId(logger, id), _self.url = dataSanitizeUrl(logger, url), _self[_DYN_NAME] = dataSanitizeString(logger, name) || strNotSpecified, isNaN(durationMs) || (_self[_DYN_DURATION] = msToTimeSpan(durationMs)), _self[_DYN_PROPERTIES] = dataSanitizeProperties(logger, properties), _self[_DYN_MEASUREMENTS] = dataSanitizeMeasurements(logger, measurements);
        }
        return __name(PageView, "PageView"), PageView.envelopeType = "Microsoft.ApplicationInsights.{0}.Pageview", PageView.dataType = "PageviewData", PageView;
      }(),
      RemoteDependencyData = function () {
        function RemoteDependencyData(logger, id, absoluteUrl, commandName, value, success, resultCode, method, requestAPI, correlationContext, properties, measurements) {
          requestAPI === void 0 && (requestAPI = "Ajax"), this.aiDataContract = {
            id: 1,
            ver: 1,
            name: 0,
            resultCode: 0,
            duration: 0,
            success: 0,
            data: 0,
            target: 0,
            type: 0,
            properties: 0,
            measurements: 0,
            kind: 0,
            value: 0,
            count: 0,
            min: 0,
            max: 0,
            stdDev: 0,
            dependencyKind: 0,
            dependencySource: 0,
            commandName: 0,
            dependencyTypeName: 0
          };
          var _self = this;
          _self.ver = 2, _self.id = id, _self[_DYN_DURATION] = msToTimeSpan(value), _self.success = success, _self.resultCode = resultCode + "", _self.type = dataSanitizeString(logger, requestAPI);
          var dependencyFields = AjaxHelperParseDependencyPath(logger, absoluteUrl, method, commandName);
          _self.data = dataSanitizeUrl(logger, commandName) || dependencyFields.data, _self.target = dataSanitizeString(logger, dependencyFields.target), correlationContext && (_self.target = "".concat(_self.target, " | ").concat(correlationContext)), _self[_DYN_NAME] = dataSanitizeString(logger, dependencyFields[_DYN_NAME]), _self[_DYN_PROPERTIES] = dataSanitizeProperties(logger, properties), _self[_DYN_MEASUREMENTS] = dataSanitizeMeasurements(logger, measurements);
        }
        return __name(RemoteDependencyData, "RemoteDependencyData"), RemoteDependencyData.envelopeType = "Microsoft.ApplicationInsights.{0}.RemoteDependency", RemoteDependencyData.dataType = "RemoteDependencyData", RemoteDependencyData;
      }(),
      Trace = function () {
        function Trace(logger, message, severityLevel, properties, measurements) {
          this.aiDataContract = {
            ver: 1,
            message: 1,
            severityLevel: 0,
            properties: 0
          };
          var _self = this;
          _self.ver = 2, message = message || strNotSpecified, _self[_DYN_MESSAGE] = dataSanitizeMessage(logger, message), _self[_DYN_PROPERTIES] = dataSanitizeProperties(logger, properties), _self[_DYN_MEASUREMENTS] = dataSanitizeMeasurements(logger, measurements), severityLevel && (_self[_DYN_SEVERITY_LEVEL] = severityLevel);
        }
        return __name(Trace, "Trace"), Trace.envelopeType = "Microsoft.ApplicationInsights.{0}.Message", Trace.dataType = "MessageData", Trace;
      }(),
      PageViewPerformance = function () {
        function PageViewPerformance(logger, name, url, unused, properties, measurements, cs4BaseData) {
          this.aiDataContract = {
            ver: 1,
            name: 0,
            url: 0,
            duration: 0,
            perfTotal: 0,
            networkConnect: 0,
            sentRequest: 0,
            receivedResponse: 0,
            domProcessing: 0,
            properties: 0,
            measurements: 0
          };
          var _self = this;
          _self.ver = 2, _self.url = dataSanitizeUrl(logger, url), _self[_DYN_NAME] = dataSanitizeString(logger, name) || strNotSpecified, _self[_DYN_PROPERTIES] = dataSanitizeProperties(logger, properties), _self[_DYN_MEASUREMENTS] = dataSanitizeMeasurements(logger, measurements), cs4BaseData && (_self.domProcessing = cs4BaseData.domProcessing, _self[_DYN_DURATION] = cs4BaseData[_DYN_DURATION], _self.networkConnect = cs4BaseData.networkConnect, _self.perfTotal = cs4BaseData.perfTotal, _self.receivedResponse = cs4BaseData.receivedResponse, _self.sentRequest = cs4BaseData.sentRequest);
        }
        return __name(PageViewPerformance, "PageViewPerformance"), PageViewPerformance.envelopeType = "Microsoft.ApplicationInsights.{0}.PageviewPerformance", PageViewPerformance.dataType = "PageviewPerformanceData", PageViewPerformance;
      }(),
      Data = function () {
        function Data(baseType, data) {
          this.aiDataContract = {
            baseType: 1,
            baseData: 1
          }, this.baseType = baseType, this.baseData = data;
        }
        return __name(Data, "Data"), Data;
      }(),
      SeverityLevel = createEnumStyle({
        Verbose: 0,
        Information: 1,
        Warning: 2,
        Error: 3,
        Critical: 4
      });
    function _aiNameFunc(baseName) {
      var aiName = "ai." + baseName + ".";
      return function (name) {
        return aiName + name;
      };
    }
    __name(_aiNameFunc, "_aiNameFunc");
    var _aiApplication = _aiNameFunc("application"),
      _aiDevice = _aiNameFunc("device"),
      _aiLocation = _aiNameFunc("location"),
      _aiOperation = _aiNameFunc("operation"),
      _aiSession = _aiNameFunc("session"),
      _aiUser = _aiNameFunc("user"),
      _aiCloud = _aiNameFunc("cloud"),
      _aiInternal = _aiNameFunc("internal"),
      ContextTagKeys = function (_super) {
        __extends(ContextTagKeys, _super);
        function ContextTagKeys() {
          return _super.call(this) || this;
        }
        return __name(ContextTagKeys, "ContextTagKeys"), ContextTagKeys;
      }(createClassFromInterface({
        applicationVersion: _aiApplication("ver"),
        applicationBuild: _aiApplication("build"),
        applicationTypeId: _aiApplication("typeId"),
        applicationId: _aiApplication("applicationId"),
        applicationLayer: _aiApplication("layer"),
        deviceId: _aiDevice("id"),
        deviceIp: _aiDevice("ip"),
        deviceLanguage: _aiDevice("language"),
        deviceLocale: _aiDevice("locale"),
        deviceModel: _aiDevice("model"),
        deviceFriendlyName: _aiDevice("friendlyName"),
        deviceNetwork: _aiDevice("network"),
        deviceNetworkName: _aiDevice("networkName"),
        deviceOEMName: _aiDevice("oemName"),
        deviceOS: _aiDevice("os"),
        deviceOSVersion: _aiDevice("osVersion"),
        deviceRoleInstance: _aiDevice("roleInstance"),
        deviceRoleName: _aiDevice("roleName"),
        deviceScreenResolution: _aiDevice("screenResolution"),
        deviceType: _aiDevice("type"),
        deviceMachineName: _aiDevice("machineName"),
        deviceVMName: _aiDevice("vmName"),
        deviceBrowser: _aiDevice("browser"),
        deviceBrowserVersion: _aiDevice("browserVersion"),
        locationIp: _aiLocation("ip"),
        locationCountry: _aiLocation("country"),
        locationProvince: _aiLocation("province"),
        locationCity: _aiLocation("city"),
        operationId: _aiOperation("id"),
        operationName: _aiOperation("name"),
        operationParentId: _aiOperation("parentId"),
        operationRootId: _aiOperation("rootId"),
        operationSyntheticSource: _aiOperation("syntheticSource"),
        operationCorrelationVector: _aiOperation("correlationVector"),
        sessionId: _aiSession("id"),
        sessionIsFirst: _aiSession("isFirst"),
        sessionIsNew: _aiSession("isNew"),
        userAccountAcquisitionDate: _aiUser("accountAcquisitionDate"),
        userAccountId: _aiUser("accountId"),
        userAgent: _aiUser("userAgent"),
        userId: _aiUser("id"),
        userStoreRegion: _aiUser("storeRegion"),
        userAuthUserId: _aiUser("authUserId"),
        userAnonymousUserAcquisitionDate: _aiUser("anonUserAcquisitionDate"),
        userAuthenticatedUserAcquisitionDate: _aiUser("authUserAcquisitionDate"),
        cloudName: _aiCloud("name"),
        cloudRole: _aiCloud("role"),
        cloudRoleVer: _aiCloud("roleVer"),
        cloudRoleInstance: _aiCloud("roleInstance"),
        cloudEnvironment: _aiCloud("environment"),
        cloudLocation: _aiCloud("location"),
        cloudDeploymentUnit: _aiCloud("deploymentUnit"),
        internalNodeName: _aiInternal("nodeName"),
        internalSdkVersion: _aiInternal("sdkVersion"),
        internalAgentVersion: _aiInternal("agentVersion"),
        internalSnippet: _aiInternal("snippet"),
        internalSdkSrc: _aiInternal("sdkSrc")
      })),
      CtxTagKeys = new ContextTagKeys();
    function _disableEvents(target, evtNamespace) {
      eventOff(target, null, null, evtNamespace);
    }
    __name(_disableEvents, "_disableEvents");
    function createOfflineListener(parentEvtNamespace) {
      var _document = getDocument(),
        _navigator = getNavigator(),
        _isListening = !1,
        listenerList = [],
        rState = 1;
      _navigator && !isNullOrUndefined(_navigator.onLine) && !_navigator.onLine && (rState = 2);
      var uState = 0,
        _currentState = calCurrentState(),
        _evtNamespace = mergeEvtNamespace(createUniqueNamespace("OfflineListener"), parentEvtNamespace);
      try {
        if (_enableEvents(getWindow()) && (_isListening = !0), _document) {
          var target = _document.body || _document;
          target.ononline && _enableEvents(target) && (_isListening = !0);
        }
      } catch {
        _isListening = !1;
      }
      function _enableEvents(target) {
        var enabled = !1;
        return target && (enabled = eventOn(target, "online", _setOnline, _evtNamespace), enabled && eventOn(target, "offline", _setOffline, _evtNamespace)), enabled;
      }
      __name(_enableEvents, "_enableEvents");
      function _isOnline() {
        return _currentState;
      }
      __name(_isOnline, "_isOnline");
      function calCurrentState() {
        return !(uState === 2 || rState === 2);
      }
      __name(calCurrentState, "calCurrentState");
      function listnerNoticeCheck() {
        var newState = calCurrentState();
        _currentState !== newState && (_currentState = newState, arrForEach(listenerList, function (callback) {
          var offlineState = {
            isOnline: _currentState,
            rState: rState,
            uState: uState
          };
          try {
            callback(offlineState);
          } catch {}
        }));
      }
      __name(listnerNoticeCheck, "listnerNoticeCheck");
      function setOnlineState(newState) {
        uState = newState, listnerNoticeCheck();
      }
      __name(setOnlineState, "setOnlineState");
      function _setOnline() {
        rState = 1, listnerNoticeCheck();
      }
      __name(_setOnline, "_setOnline");
      function _setOffline() {
        rState = 2, listnerNoticeCheck();
      }
      __name(_setOffline, "_setOffline");
      function _unload() {
        var win = getWindow();
        if (win && _isListening) {
          if (_disableEvents(win, _evtNamespace), _document) {
            var target = _document.body || _document;
            isUndefined(target.ononline) || _disableEvents(target, _evtNamespace);
          }
          _isListening = !1;
        }
      }
      __name(_unload, "_unload");
      function addListener(callback) {
        return listenerList.push(callback), {
          rm: __name(function () {
            var index = listenerList.indexOf(callback);
            if (index > -1) return listenerList.splice(index, 1);
          }, "rm")
        };
      }
      return __name(addListener, "addListener"), {
        isOnline: _isOnline,
        isListening: __name(function () {
          return _isListening;
        }, "isListening"),
        unload: _unload,
        addListener: addListener,
        setOnlineState: setOnlineState
      };
    }
    __name(createOfflineListener, "createOfflineListener");
    var BreezeChannelIdentifier = "AppInsightsChannelPlugin",
      STR_DURATION = "duration",
      _DYN_TAGS = "tags",
      _DYN_DEVICE_TYPE = "deviceType",
      _DYN_DATA = "data",
      _DYN_NAME = "name",
      _DYN_TRACE_ID = "traceID",
      _DYN_LENGTH = "length",
      _DYN_STRINGIFY = "stringify",
      _DYN_MEASUREMENTS = "measurements",
      _DYN_DATA_TYPE = "dataType",
      _DYN_ENVELOPE_TYPE = "envelopeType",
      _DYN_TO_STRING = "toString",
      _DYN_ENQUEUE = "enqueue",
      _DYN_COUNT = "count",
      _DYN_PUSH = "push",
      _DYN_EMIT_LINE_DELIMITED_0 = "emitLineDelimitedJson",
      _DYN_CLEAR = "clear",
      _DYN_MARK_AS_SENT = "markAsSent",
      _DYN_CLEAR_SENT = "clearSent",
      _DYN_BUFFER_OVERRIDE = "bufferOverride",
      _DYN__BUFFER__KEY = "BUFFER_KEY",
      _DYN__SENT__BUFFER__KEY = "SENT_BUFFER_KEY",
      _DYN_CONCAT = "concat",
      _DYN__MAX__BUFFER__SIZE = "MAX_BUFFER_SIZE",
      _DYN_TRIGGER_SEND = "triggerSend",
      _DYN_DIAG_LOG = "diagLog",
      _DYN_INITIALIZE = "initialize",
      _DYN__SENDER = "_sender",
      _DYN_ENDPOINT_URL = "endpointUrl",
      _DYN_INSTRUMENTATION_KEY = "instrumentationKey",
      _DYN_CUSTOM_HEADERS = "customHeaders",
      _DYN_MAX_BATCH_SIZE_IN_BY1 = "maxBatchSizeInBytes",
      _DYN_ONUNLOAD_DISABLE_BEA2 = "onunloadDisableBeacon",
      _DYN_IS_BEACON_API_DISABL3 = "isBeaconApiDisabled",
      _DYN_ALWAYS_USE_XHR_OVERR4 = "alwaysUseXhrOverride",
      _DYN_ENABLE_SESSION_STORA5 = "enableSessionStorageBuffer",
      _DYN__BUFFER = "_buffer",
      _DYN_ONUNLOAD_DISABLE_FET6 = "onunloadDisableFetch",
      _DYN_DISABLE_SEND_BEACON_7 = "disableSendBeaconSplit",
      _DYN_GET_SENDER_INST = "getSenderInst",
      _DYN__ON_ERROR = "_onError",
      _DYN__ON_PARTIAL_SUCCESS = "_onPartialSuccess",
      _DYN__ON_SUCCESS = "_onSuccess",
      _DYN_ITEMS_RECEIVED = "itemsReceived",
      _DYN_ITEMS_ACCEPTED = "itemsAccepted",
      _DYN_BASE_TYPE = "baseType",
      _DYN_SAMPLE_RATE = "sampleRate",
      _DYN_GET_HASH_CODE_SCORE = "getHashCodeScore",
      strBaseType = "baseType",
      strBaseData = "baseData",
      strProperties = "properties",
      strTrue = "true";
    function _setValueIf(target, field, value) {
      return setValue(target, field, value, isTruthy);
    }
    __name(_setValueIf, "_setValueIf");
    function _extractPartAExtensions(logger, item, env) {
      var envTags = env[_DYN_TAGS] = env[_DYN_TAGS] || {},
        itmExt = item.ext = item.ext || {},
        itmTags = item[_DYN_TAGS] = item[_DYN_TAGS] || [],
        extUser = itmExt.user;
      extUser && (_setValueIf(envTags, CtxTagKeys.userAuthUserId, extUser.authId), _setValueIf(envTags, CtxTagKeys.userId, extUser.id || extUser.localId));
      var extApp = itmExt.app;
      extApp && _setValueIf(envTags, CtxTagKeys.sessionId, extApp.sesId);
      var extDevice = itmExt.device;
      extDevice && (_setValueIf(envTags, CtxTagKeys.deviceId, extDevice.id || extDevice.localId), _setValueIf(envTags, CtxTagKeys[_DYN_DEVICE_TYPE], extDevice.deviceClass), _setValueIf(envTags, CtxTagKeys.deviceIp, extDevice.ip), _setValueIf(envTags, CtxTagKeys.deviceModel, extDevice.model), _setValueIf(envTags, CtxTagKeys[_DYN_DEVICE_TYPE], extDevice[_DYN_DEVICE_TYPE]));
      var web = item.ext.web;
      if (web) {
        _setValueIf(envTags, CtxTagKeys.deviceLanguage, web.browserLang), _setValueIf(envTags, CtxTagKeys.deviceBrowserVersion, web.browserVer), _setValueIf(envTags, CtxTagKeys.deviceBrowser, web.browser);
        var envData = env[_DYN_DATA] = env[_DYN_DATA] || {},
          envBaseData = envData[strBaseData] = envData[strBaseData] || {},
          envProps = envBaseData[strProperties] = envBaseData[strProperties] || {};
        _setValueIf(envProps, "domain", web.domain), _setValueIf(envProps, "isManual", web.isManual ? strTrue : null), _setValueIf(envProps, "screenRes", web.screenRes), _setValueIf(envProps, "userConsent", web.userConsent ? strTrue : null);
      }
      var extOs = itmExt.os;
      extOs && (_setValueIf(envTags, CtxTagKeys.deviceOS, extOs[_DYN_NAME]), _setValueIf(envTags, CtxTagKeys.deviceOSVersion, extOs.osVer));
      var extTrace = itmExt.trace;
      extTrace && (_setValueIf(envTags, CtxTagKeys.operationParentId, extTrace.parentID), _setValueIf(envTags, CtxTagKeys.operationName, dataSanitizeString(logger, extTrace[_DYN_NAME])), _setValueIf(envTags, CtxTagKeys.operationId, extTrace[_DYN_TRACE_ID]));
      for (var tgs = {}, i = itmTags[_DYN_LENGTH] - 1; i >= 0; i--) {
        var tg = itmTags[i];
        objForEachKey(tg, function (key, value) {
          tgs[key] = value;
        }), itmTags.splice(i, 1);
      }
      objForEachKey(itmTags, function (tg, value) {
        tgs[tg] = value;
      });
      var theTags = __assign(__assign({}, envTags), tgs);
      theTags[CtxTagKeys.internalSdkVersion] || (theTags[CtxTagKeys.internalSdkVersion] = dataSanitizeString(logger, "javascript:".concat(EnvelopeCreator.Version), 64)), env[_DYN_TAGS] = optimizeObject(theTags);
    }
    __name(_extractPartAExtensions, "_extractPartAExtensions");
    function _extractPropsAndMeasurements(data, properties, measurements) {
      isNullOrUndefined(data) || objForEachKey(data, function (key, value) {
        isNumber(value) ? measurements[key] = value : isString(value) ? properties[key] = value : hasJSON() && (properties[key] = getJSON()[_DYN_STRINGIFY](value));
      });
    }
    __name(_extractPropsAndMeasurements, "_extractPropsAndMeasurements");
    function _convertPropsUndefinedToCustomDefinedValue(properties, customUndefinedValue) {
      isNullOrUndefined(properties) || objForEachKey(properties, function (key, value) {
        properties[key] = value || customUndefinedValue;
      });
    }
    __name(_convertPropsUndefinedToCustomDefinedValue, "_convertPropsUndefinedToCustomDefinedValue");
    function _createEnvelope(logger, envelopeType, telemetryItem, data) {
      var envelope = new Envelope(logger, data, envelopeType);
      _setValueIf(envelope, "sampleRate", telemetryItem[SampleRate]), (telemetryItem[strBaseData] || {}).startTime && (envelope.time = toISOString(telemetryItem[strBaseData].startTime)), envelope.iKey = telemetryItem.iKey;
      var iKeyNoDashes = telemetryItem.iKey.replace(/-/g, "");
      return envelope[_DYN_NAME] = envelope[_DYN_NAME].replace("{0}", iKeyNoDashes), _extractPartAExtensions(logger, telemetryItem, envelope), telemetryItem[_DYN_TAGS] = telemetryItem[_DYN_TAGS] || [], optimizeObject(envelope);
    }
    __name(_createEnvelope, "_createEnvelope");
    function EnvelopeCreatorInit(logger, telemetryItem) {
      isNullOrUndefined(telemetryItem[strBaseData]) && _throwInternal(logger, 1, 46, "telemetryItem.baseData cannot be null.");
    }
    __name(EnvelopeCreatorInit, "EnvelopeCreatorInit");
    var EnvelopeCreator = {
      Version: "3.3.6"
    };
    function DependencyEnvelopeCreator(logger, telemetryItem, customUndefinedValue) {
      EnvelopeCreatorInit(logger, telemetryItem);
      var customMeasurements = telemetryItem[strBaseData][_DYN_MEASUREMENTS] || {},
        customProperties = telemetryItem[strBaseData][strProperties] || {};
      _extractPropsAndMeasurements(telemetryItem[_DYN_DATA], customProperties, customMeasurements), isNullOrUndefined(customUndefinedValue) || _convertPropsUndefinedToCustomDefinedValue(customProperties, customUndefinedValue);
      var bd = telemetryItem[strBaseData];
      if (isNullOrUndefined(bd)) return _warnToConsole(logger, "Invalid input for dependency data"), null;
      var method = bd[strProperties] && bd[strProperties][HttpMethod] ? bd[strProperties][HttpMethod] : "GET",
        remoteDepData = new RemoteDependencyData(logger, bd.id, bd.target, bd[_DYN_NAME], bd[STR_DURATION], bd.success, bd.responseCode, method, bd.type, bd.correlationContext, customProperties, customMeasurements),
        data = new Data(RemoteDependencyData[_DYN_DATA_TYPE], remoteDepData);
      return _createEnvelope(logger, RemoteDependencyData[_DYN_ENVELOPE_TYPE], telemetryItem, data);
    }
    __name(DependencyEnvelopeCreator, "DependencyEnvelopeCreator");
    function EventEnvelopeCreator(logger, telemetryItem, customUndefinedValue) {
      EnvelopeCreatorInit(logger, telemetryItem);
      var customProperties = {},
        customMeasurements = {};
      telemetryItem[strBaseType] !== Event[_DYN_DATA_TYPE] && (customProperties.baseTypeSource = telemetryItem[strBaseType]), telemetryItem[strBaseType] === Event[_DYN_DATA_TYPE] ? (customProperties = telemetryItem[strBaseData][strProperties] || {}, customMeasurements = telemetryItem[strBaseData][_DYN_MEASUREMENTS] || {}) : telemetryItem[strBaseData] && _extractPropsAndMeasurements(telemetryItem[strBaseData], customProperties, customMeasurements), _extractPropsAndMeasurements(telemetryItem[_DYN_DATA], customProperties, customMeasurements), isNullOrUndefined(customUndefinedValue) || _convertPropsUndefinedToCustomDefinedValue(customProperties, customUndefinedValue);
      var eventName = telemetryItem[strBaseData][_DYN_NAME],
        eventData = new Event(logger, eventName, customProperties, customMeasurements),
        data = new Data(Event[_DYN_DATA_TYPE], eventData);
      return _createEnvelope(logger, Event[_DYN_ENVELOPE_TYPE], telemetryItem, data);
    }
    __name(EventEnvelopeCreator, "EventEnvelopeCreator");
    function ExceptionEnvelopeCreator(logger, telemetryItem, customUndefinedValue) {
      EnvelopeCreatorInit(logger, telemetryItem);
      var customMeasurements = telemetryItem[strBaseData][_DYN_MEASUREMENTS] || {},
        customProperties = telemetryItem[strBaseData][strProperties] || {};
      _extractPropsAndMeasurements(telemetryItem[_DYN_DATA], customProperties, customMeasurements), isNullOrUndefined(customUndefinedValue) || _convertPropsUndefinedToCustomDefinedValue(customProperties, customUndefinedValue);
      var bd = telemetryItem[strBaseData],
        exData = Exception.CreateFromInterface(logger, bd, customProperties, customMeasurements),
        data = new Data(Exception[_DYN_DATA_TYPE], exData);
      return _createEnvelope(logger, Exception[_DYN_ENVELOPE_TYPE], telemetryItem, data);
    }
    __name(ExceptionEnvelopeCreator, "ExceptionEnvelopeCreator");
    function MetricEnvelopeCreator(logger, telemetryItem, customUndefinedValue) {
      EnvelopeCreatorInit(logger, telemetryItem);
      var baseData = telemetryItem[strBaseData],
        props = baseData[strProperties] || {},
        measurements = baseData[_DYN_MEASUREMENTS] || {};
      _extractPropsAndMeasurements(telemetryItem[_DYN_DATA], props, measurements), isNullOrUndefined(customUndefinedValue) || _convertPropsUndefinedToCustomDefinedValue(props, customUndefinedValue);
      var baseMetricData = new Metric(logger, baseData[_DYN_NAME], baseData.average, baseData.sampleCount, baseData.min, baseData.max, baseData.stdDev, props, measurements),
        data = new Data(Metric[_DYN_DATA_TYPE], baseMetricData);
      return _createEnvelope(logger, Metric[_DYN_ENVELOPE_TYPE], telemetryItem, data);
    }
    __name(MetricEnvelopeCreator, "MetricEnvelopeCreator");
    function PageViewEnvelopeCreator(logger, telemetryItem, customUndefinedValue) {
      EnvelopeCreatorInit(logger, telemetryItem);
      var duration,
        baseData = telemetryItem[strBaseData];
      !isNullOrUndefined(baseData) && !isNullOrUndefined(baseData[strProperties]) && !isNullOrUndefined(baseData[strProperties][STR_DURATION]) ? (duration = baseData[strProperties][STR_DURATION], delete baseData[strProperties][STR_DURATION]) : !isNullOrUndefined(telemetryItem[_DYN_DATA]) && !isNullOrUndefined(telemetryItem[_DYN_DATA][STR_DURATION]) && (duration = telemetryItem[_DYN_DATA][STR_DURATION], delete telemetryItem[_DYN_DATA][STR_DURATION]);
      var bd = telemetryItem[strBaseData],
        currentContextId;
      ((telemetryItem.ext || {}).trace || {})[_DYN_TRACE_ID] && (currentContextId = telemetryItem.ext.trace[_DYN_TRACE_ID]);
      var id = bd.id || currentContextId,
        name = bd[_DYN_NAME],
        url = bd.uri,
        properties = bd[strProperties] || {},
        measurements = bd[_DYN_MEASUREMENTS] || {};
      if (isNullOrUndefined(bd.refUri) || (properties.refUri = bd.refUri), isNullOrUndefined(bd.pageType) || (properties.pageType = bd.pageType), isNullOrUndefined(bd.isLoggedIn) || (properties.isLoggedIn = bd.isLoggedIn[_DYN_TO_STRING]()), !isNullOrUndefined(bd[strProperties])) {
        var pageTags = bd[strProperties];
        objForEachKey(pageTags, function (key, value) {
          properties[key] = value;
        });
      }
      _extractPropsAndMeasurements(telemetryItem[_DYN_DATA], properties, measurements), isNullOrUndefined(customUndefinedValue) || _convertPropsUndefinedToCustomDefinedValue(properties, customUndefinedValue);
      var pageViewData = new PageView(logger, name, url, duration, properties, measurements, id),
        data = new Data(PageView[_DYN_DATA_TYPE], pageViewData);
      return _createEnvelope(logger, PageView[_DYN_ENVELOPE_TYPE], telemetryItem, data);
    }
    __name(PageViewEnvelopeCreator, "PageViewEnvelopeCreator");
    function PageViewPerformanceEnvelopeCreator(logger, telemetryItem, customUndefinedValue) {
      EnvelopeCreatorInit(logger, telemetryItem);
      var bd = telemetryItem[strBaseData],
        name = bd[_DYN_NAME],
        url = bd.uri || bd.url,
        properties = bd[strProperties] || {},
        measurements = bd[_DYN_MEASUREMENTS] || {};
      _extractPropsAndMeasurements(telemetryItem[_DYN_DATA], properties, measurements), isNullOrUndefined(customUndefinedValue) || _convertPropsUndefinedToCustomDefinedValue(properties, customUndefinedValue);
      var baseData = new PageViewPerformance(logger, name, url, void 0, properties, measurements, bd),
        data = new Data(PageViewPerformance[_DYN_DATA_TYPE], baseData);
      return _createEnvelope(logger, PageViewPerformance[_DYN_ENVELOPE_TYPE], telemetryItem, data);
    }
    __name(PageViewPerformanceEnvelopeCreator, "PageViewPerformanceEnvelopeCreator");
    function TraceEnvelopeCreator(logger, telemetryItem, customUndefinedValue) {
      EnvelopeCreatorInit(logger, telemetryItem);
      var message = telemetryItem[strBaseData].message,
        severityLevel = telemetryItem[strBaseData].severityLevel,
        props = telemetryItem[strBaseData][strProperties] || {},
        measurements = telemetryItem[strBaseData][_DYN_MEASUREMENTS] || {};
      _extractPropsAndMeasurements(telemetryItem[_DYN_DATA], props, measurements), isNullOrUndefined(customUndefinedValue) || _convertPropsUndefinedToCustomDefinedValue(props, customUndefinedValue);
      var baseData = new Trace(logger, message, severityLevel, props, measurements),
        data = new Data(Trace[_DYN_DATA_TYPE], baseData);
      return _createEnvelope(logger, Trace[_DYN_ENVELOPE_TYPE], telemetryItem, data);
    }
    __name(TraceEnvelopeCreator, "TraceEnvelopeCreator");
    var BaseSendBuffer = function () {
        function BaseSendBuffer(logger, config) {
          var _buffer = [],
            _bufferFullMessageSent = !1,
            _maxRetryCnt = config.maxRetryCnt;
          this._get = function () {
            return _buffer;
          }, this._set = function (buffer) {
            return _buffer = buffer, _buffer;
          }, dynamicProto(BaseSendBuffer, this, function (_self) {
            _self[_DYN_ENQUEUE] = function (payload) {
              if (_self[_DYN_COUNT]() >= config.eventsLimitInMem) {
                _bufferFullMessageSent || (_throwInternal(logger, 2, 105, "Maximum in-memory buffer size reached: " + _self[_DYN_COUNT](), !0), _bufferFullMessageSent = !0);
                return;
              }
              payload.cnt = payload.cnt || 0, !(!isNullOrUndefined(_maxRetryCnt) && payload.cnt > _maxRetryCnt) && _buffer[_DYN_PUSH](payload);
            }, _self[_DYN_COUNT] = function () {
              return _buffer[_DYN_LENGTH];
            }, _self.size = function () {
              for (var size = _buffer[_DYN_LENGTH], lp = 0; lp < _buffer[_DYN_LENGTH]; lp++) size += _buffer[lp].item[_DYN_LENGTH];
              return config[_DYN_EMIT_LINE_DELIMITED_0] || (size += 2), size;
            }, _self[_DYN_CLEAR] = function () {
              _buffer = [], _bufferFullMessageSent = !1;
            }, _self.getItems = function () {
              return _buffer.slice(0);
            }, _self.batchPayloads = function (payloads) {
              if (payloads && payloads[_DYN_LENGTH] > 0) {
                var payloadStr_1 = [];
                arrForEach(payloads, function (payload) {
                  payloadStr_1[_DYN_PUSH](payload.item);
                });
                var batch = config[_DYN_EMIT_LINE_DELIMITED_0] ? payloadStr_1.join(`
`) : "[" + payloadStr_1.join(",") + "]";
                return batch;
              }
              return null;
            }, _self.createNew = function (newLogger, newConfig, canUseSessionStorage) {
              var items = _buffer.slice(0);
              newLogger = newLogger || logger, newConfig = newConfig || {};
              var newBuffer = canUseSessionStorage ? new SessionStorageSendBuffer(newLogger, newConfig) : new ArraySendBuffer(newLogger, newConfig);
              return arrForEach(items, function (payload) {
                newBuffer[_DYN_ENQUEUE](payload);
              }), newBuffer;
            };
          });
        }
        return __name(BaseSendBuffer, "BaseSendBuffer"), f.__ieDyn = 1, BaseSendBuffer;
      }(),
      ArraySendBuffer = function (_super) {
        __extends(ArraySendBuffer, _super);
        function ArraySendBuffer(logger, config) {
          var _this = _super.call(this, logger, config) || this;
          return dynamicProto(ArraySendBuffer, _this, function (_self, _base) {
            _self[_DYN_MARK_AS_SENT] = function (payload) {
              _base[_DYN_CLEAR]();
            }, _self[_DYN_CLEAR_SENT] = function (payload) {};
          }), _this;
        }
        return __name(ArraySendBuffer, "ArraySendBuffer"), h.__ieDyn = 1, ArraySendBuffer;
      }(BaseSendBuffer),
      PREVIOUS_KEYS = ["AI_buffer", "AI_sentBuffer"],
      SessionStorageSendBuffer = function (_super) {
        __extends(SessionStorageSendBuffer, _super);
        function SessionStorageSendBuffer(logger, config) {
          var _this = _super.call(this, logger, config) || this,
            _bufferFullMessageSent = !1,
            _namePrefix = config == null ? void 0 : config.namePrefix,
            _b = config[_DYN_BUFFER_OVERRIDE] || {
              getItem: utlGetSessionStorage,
              setItem: utlSetSessionStorage
            },
            getItem = _b.getItem,
            setItem = _b.setItem,
            _maxRetryCnt = config.maxRetryCnt;
          return dynamicProto(SessionStorageSendBuffer, _this, function (_self, _base) {
            var bufferItems = _getBuffer(SessionStorageSendBuffer[_DYN__BUFFER__KEY]),
              itemsInSentBuffer = _getBuffer(SessionStorageSendBuffer[_DYN__SENT__BUFFER__KEY]),
              previousItems = _getPreviousEvents(),
              notDeliveredItems = itemsInSentBuffer[_DYN_CONCAT](previousItems),
              buffer = _self._set(bufferItems[_DYN_CONCAT](notDeliveredItems));
            buffer[_DYN_LENGTH] > SessionStorageSendBuffer[_DYN__MAX__BUFFER__SIZE] && (buffer[_DYN_LENGTH] = SessionStorageSendBuffer[_DYN__MAX__BUFFER__SIZE]), _setBuffer(SessionStorageSendBuffer[_DYN__SENT__BUFFER__KEY], []), _setBuffer(SessionStorageSendBuffer[_DYN__BUFFER__KEY], buffer), _self[_DYN_ENQUEUE] = function (payload) {
              if (_self[_DYN_COUNT]() >= SessionStorageSendBuffer[_DYN__MAX__BUFFER__SIZE]) {
                _bufferFullMessageSent || (_throwInternal(logger, 2, 67, "Maximum buffer size reached: " + _self[_DYN_COUNT](), !0), _bufferFullMessageSent = !0);
                return;
              }
              payload.cnt = payload.cnt || 0, !(!isNullOrUndefined(_maxRetryCnt) && payload.cnt > _maxRetryCnt) && (_base[_DYN_ENQUEUE](payload), _setBuffer(SessionStorageSendBuffer[_DYN__BUFFER__KEY], _self._get()));
            }, _self[_DYN_CLEAR] = function () {
              _base[_DYN_CLEAR](), _setBuffer(SessionStorageSendBuffer[_DYN__BUFFER__KEY], _self._get()), _setBuffer(SessionStorageSendBuffer[_DYN__SENT__BUFFER__KEY], []), _bufferFullMessageSent = !1;
            }, _self[_DYN_MARK_AS_SENT] = function (payload) {
              _setBuffer(SessionStorageSendBuffer[_DYN__BUFFER__KEY], _self._set(_removePayloadsFromBuffer(payload, _self._get())));
              var sentElements = _getBuffer(SessionStorageSendBuffer[_DYN__SENT__BUFFER__KEY]);
              sentElements instanceof Array && payload instanceof Array && (sentElements = sentElements[_DYN_CONCAT](payload), sentElements[_DYN_LENGTH] > SessionStorageSendBuffer[_DYN__MAX__BUFFER__SIZE] && (_throwInternal(logger, 1, 67, "Sent buffer reached its maximum size: " + sentElements[_DYN_LENGTH], !0), sentElements[_DYN_LENGTH] = SessionStorageSendBuffer[_DYN__MAX__BUFFER__SIZE]), _setBuffer(SessionStorageSendBuffer[_DYN__SENT__BUFFER__KEY], sentElements));
            }, _self[_DYN_CLEAR_SENT] = function (payload) {
              var sentElements = _getBuffer(SessionStorageSendBuffer[_DYN__SENT__BUFFER__KEY]);
              sentElements = _removePayloadsFromBuffer(payload, sentElements), _setBuffer(SessionStorageSendBuffer[_DYN__SENT__BUFFER__KEY], sentElements);
            }, _self.createNew = function (newLogger, newConfig, canUseSessionStorage) {
              canUseSessionStorage = !!canUseSessionStorage;
              var unsentItems = _self._get().slice(0),
                sentItems = _getBuffer(SessionStorageSendBuffer[_DYN__SENT__BUFFER__KEY]).slice(0);
              newLogger = newLogger || logger, newConfig = newConfig || {}, _self[_DYN_CLEAR]();
              var newBuffer = canUseSessionStorage ? new SessionStorageSendBuffer(newLogger, newConfig) : new ArraySendBuffer(newLogger, newConfig);
              return arrForEach(unsentItems, function (payload) {
                newBuffer[_DYN_ENQUEUE](payload);
              }), canUseSessionStorage && newBuffer[_DYN_MARK_AS_SENT](sentItems), newBuffer;
            };
            function _removePayloadsFromBuffer(payloads, buffer) {
              var remaining = [],
                payloadStr = [];
              return arrForEach(payloads, function (payload) {
                payloadStr[_DYN_PUSH](payload.item);
              }), arrForEach(buffer, function (value) {
                !isFunction(value) && arrIndexOf(payloadStr, value.item) === -1 && remaining[_DYN_PUSH](value);
              }), remaining;
            }
            __name(_removePayloadsFromBuffer, "_removePayloadsFromBuffer");
            function _getBuffer(key) {
              var prefixedKey = key;
              return prefixedKey = _namePrefix ? _namePrefix + "_" + prefixedKey : prefixedKey, _getBufferBase(prefixedKey);
            }
            __name(_getBuffer, "_getBuffer");
            function _getBufferBase(key) {
              try {
                var bufferJson = getItem(logger, key);
                if (bufferJson) {
                  var buffer_1 = getJSON().parse(bufferJson);
                  if (isString(buffer_1) && (buffer_1 = getJSON().parse(buffer_1)), buffer_1 && isArray(buffer_1)) return buffer_1;
                }
              } catch (e) {
                _throwInternal(logger, 1, 42, " storage key: " + key + ", " + getExceptionName(e), {
                  exception: dumpObj(e)
                });
              }
              return [];
            }
            __name(_getBufferBase, "_getBufferBase");
            function _setBuffer(key, buffer) {
              var prefixedKey = key;
              try {
                prefixedKey = _namePrefix ? _namePrefix + "_" + prefixedKey : prefixedKey;
                var bufferJson = JSON[_DYN_STRINGIFY](buffer);
                setItem(logger, prefixedKey, bufferJson);
              } catch (e) {
                setItem(logger, prefixedKey, JSON[_DYN_STRINGIFY]([])), _throwInternal(logger, 2, 41, " storage key: " + prefixedKey + ", " + getExceptionName(e) + ". Buffer cleared", {
                  exception: dumpObj(e)
                });
              }
            }
            __name(_setBuffer, "_setBuffer");
            function _getPreviousEvents() {
              var items = [];
              try {
                return arrForEach(PREVIOUS_KEYS, function (key) {
                  var events = _getItemsFromPreviousKey(key);
                  if (items = items[_DYN_CONCAT](events), _namePrefix) {
                    var prefixedKey = _namePrefix + "_" + key,
                      prefixEvents = _getItemsFromPreviousKey(prefixedKey);
                    items = items[_DYN_CONCAT](prefixEvents);
                  }
                }), items;
              } catch (e) {
                _throwInternal(logger, 2, 41, "Transfer events from previous buffers: " + getExceptionName(e) + ". previous Buffer items can not be removed", {
                  exception: dumpObj(e)
                });
              }
              return [];
            }
            __name(_getPreviousEvents, "_getPreviousEvents");
            function _getItemsFromPreviousKey(key) {
              try {
                var items = _getBufferBase(key),
                  transFormedItems_1 = [];
                return arrForEach(items, function (item) {
                  var internalItem = {
                    item: item,
                    cnt: 0
                  };
                  transFormedItems_1[_DYN_PUSH](internalItem);
                }), utlRemoveSessionStorage(logger, key), transFormedItems_1;
              } catch {}
              return [];
            }
            __name(_getItemsFromPreviousKey, "_getItemsFromPreviousKey");
          }), _this;
        }
        __name(SessionStorageSendBuffer, "SessionStorageSendBuffer");
        var _a;
        return _a = SessionStorageSendBuffer, SessionStorageSendBuffer.VERSION = "_1", SessionStorageSendBuffer.BUFFER_KEY = "AI_buffer" + _a.VERSION, SessionStorageSendBuffer.SENT_BUFFER_KEY = "AI_sentBuffer" + _a.VERSION, SessionStorageSendBuffer.MAX_BUFFER_SIZE = 2e3, SessionStorageSendBuffer;
      }(BaseSendBuffer),
      Serializer = function () {
        function Serializer(logger) {
          dynamicProto(Serializer, this, function (_self) {
            _self.serialize = function (input) {
              var output = _serializeObject(input, "root");
              try {
                return getJSON()[_DYN_STRINGIFY](output);
              } catch (e) {
                _throwInternal(logger, 1, 48, e && isFunction(e[_DYN_TO_STRING]) ? e[_DYN_TO_STRING]() : "Error serializing object", null, !0);
              }
            };
            function _serializeObject(source, name) {
              var circularReferenceCheck = "__aiCircularRefCheck",
                output = {};
              if (!source) return _throwInternal(logger, 1, 48, "cannot serialize object because it is null or undefined", {
                name: name
              }, !0), output;
              if (source[circularReferenceCheck]) return _throwInternal(logger, 2, 50, "Circular reference detected while serializing object", {
                name: name
              }, !0), output;
              if (!source.aiDataContract) {
                if (name === "measurements") output = _serializeStringMap(source, "number", name);else if (name === "properties") output = _serializeStringMap(source, "string", name);else if (name === "tags") output = _serializeStringMap(source, "string", name);else if (isArray(source)) output = _serializeArray(source, name);else {
                  _throwInternal(logger, 2, 49, "Attempting to serialize an object which does not implement ISerializable", {
                    name: name
                  }, !0);
                  try {
                    getJSON()[_DYN_STRINGIFY](source), output = source;
                  } catch (e) {
                    _throwInternal(logger, 1, 48, e && isFunction(e[_DYN_TO_STRING]) ? e[_DYN_TO_STRING]() : "Error serializing object", null, !0);
                  }
                }
                return output;
              }
              return source[circularReferenceCheck] = !0, objForEachKey(source.aiDataContract, function (field, contract) {
                var isRequired = isFunction(contract) ? contract() & 1 : contract & 1,
                  isHidden = isFunction(contract) ? contract() & 4 : contract & 4,
                  isArray = contract & 2,
                  isPresent = source[field] !== void 0,
                  isObj = isObject(source[field]) && source[field] !== null;
                if (isRequired && !isPresent && !isArray) _throwInternal(logger, 1, 24, "Missing required field specification. The field is required but not present on source", {
                  field: field,
                  name: name
                });else if (!isHidden) {
                  var value = void 0;
                  isObj ? isArray ? value = _serializeArray(source[field], field) : value = _serializeObject(source[field], field) : value = source[field], value !== void 0 && (output[field] = value);
                }
              }), delete source[circularReferenceCheck], output;
            }
            __name(_serializeObject, "_serializeObject");
            function _serializeArray(sources, name) {
              var output;
              if (sources) if (!isArray(sources)) _throwInternal(logger, 1, 54, `This field was specified as an array in the contract but the item is not an array.\r
`, {
                name: name
              }, !0);else {
                output = [];
                for (var i = 0; i < sources[_DYN_LENGTH]; i++) {
                  var source = sources[i],
                    item = _serializeObject(source, name + "[" + i + "]");
                  output[_DYN_PUSH](item);
                }
              }
              return output;
            }
            __name(_serializeArray, "_serializeArray");
            function _serializeStringMap(map, expectedType, name) {
              var output;
              return map && (output = {}, objForEachKey(map, function (field, value) {
                if (expectedType === "string") value === void 0 ? output[field] = "undefined" : value === null ? output[field] = "null" : value[_DYN_TO_STRING] ? output[field] = value[_DYN_TO_STRING]() : output[field] = "invalid field: toString() is not defined.";else if (expectedType === "number") {
                  if (value === void 0) output[field] = "undefined";else if (value === null) output[field] = "null";else {
                    var num = parseFloat(value);
                    output[field] = num;
                  }
                } else output[field] = "invalid field: " + name + " is of unknown type.", _throwInternal(logger, 1, output[field], null, !0);
              })), output;
            }
            __name(_serializeStringMap, "_serializeStringMap");
          });
        }
        return __name(Serializer, "Serializer"), f.__ieDyn = 1, Serializer;
      }(),
      MIN_INPUT_LENGTH = 8,
      HashCodeScoreGenerator = function () {
        function HashCodeScoreGenerator() {}
        return __name(HashCodeScoreGenerator, "HashCodeScoreGenerator"), HashCodeScoreGenerator.prototype.getHashCodeScore = function (key) {
          var score = this.getHashCode(key) / HashCodeScoreGenerator.INT_MAX_VALUE;
          return score * 100;
        }, HashCodeScoreGenerator.prototype.getHashCode = function (input) {
          if (input === "") return 0;
          for (; input[_DYN_LENGTH] < MIN_INPUT_LENGTH;) input = input[_DYN_CONCAT](input);
          for (var hash = 5381, i = 0; i < input[_DYN_LENGTH]; ++i) hash = (hash << 5) + hash + input.charCodeAt(i), hash = hash & hash;
          return Math.abs(hash);
        }, HashCodeScoreGenerator.INT_MAX_VALUE = 2147483647, HashCodeScoreGenerator;
      }(),
      SamplingScoreGenerator = function () {
        function SamplingScoreGenerator() {
          var _self = this,
            hashCodeGenerator = new HashCodeScoreGenerator(),
            keys = new ContextTagKeys();
          _self.getSamplingScore = function (item) {
            var score = 0;
            return item[_DYN_TAGS] && item[_DYN_TAGS][keys.userId] ? score = hashCodeGenerator.getHashCodeScore(item[_DYN_TAGS][keys.userId]) : item.ext && item.ext.user && item.ext.user.id ? score = hashCodeGenerator[_DYN_GET_HASH_CODE_SCORE](item.ext.user.id) : item[_DYN_TAGS] && item[_DYN_TAGS][keys.operationId] ? score = hashCodeGenerator.getHashCodeScore(item[_DYN_TAGS][keys.operationId]) : item.ext && item.ext.telemetryTrace && item.ext.telemetryTrace[_DYN_TRACE_ID] ? score = hashCodeGenerator.getHashCodeScore(item.ext.telemetryTrace[_DYN_TRACE_ID]) : score = Math.random() * 100, score;
          };
        }
        return __name(SamplingScoreGenerator, "SamplingScoreGenerator"), SamplingScoreGenerator;
      }(),
      Sample = function () {
        function Sample(sampleRate, logger) {
          this.INT_MAX_VALUE = 2147483647;
          var _logger = logger || safeGetLogger(null);
          (sampleRate > 100 || sampleRate < 0) && (_logger.throwInternal(2, 58, "Sampling rate is out of range (0..100). Sampling will be disabled, you may be sending too much data which may affect your AI service level.", {
            samplingRate: sampleRate
          }, !0), sampleRate = 100), this[_DYN_SAMPLE_RATE] = sampleRate, this.samplingScoreGenerator = new SamplingScoreGenerator();
        }
        return __name(Sample, "Sample"), Sample.prototype.isSampledIn = function (envelope) {
          var samplingPercentage = this[_DYN_SAMPLE_RATE],
            isSampledIn = !1;
          return samplingPercentage == null || samplingPercentage >= 100 || envelope.baseType === Metric[_DYN_DATA_TYPE] ? !0 : (isSampledIn = this.samplingScoreGenerator.getSamplingScore(envelope) < samplingPercentage, isSampledIn);
        }, Sample;
      }(),
      _a,
      _b,
      UNDEFINED_VALUE = void 0,
      EMPTY_STR = "",
      FetchSyncRequestSizeLimitBytes = 65e3;
    function _getResponseText(xhr) {
      try {
        return xhr.responseText;
      } catch {}
      return null;
    }
    __name(_getResponseText, "_getResponseText");
    function isOverrideFn(httpXHROverride) {
      return httpXHROverride && httpXHROverride.sendPOST;
    }
    __name(isOverrideFn, "isOverrideFn");
    var defaultAppInsightsChannelConfig = objDeepFreeze((_a = {
      endpointUrl: cfgDfValidate(isTruthy, DEFAULT_BREEZE_ENDPOINT + DEFAULT_BREEZE_PATH)
    }, _a[_DYN_EMIT_LINE_DELIMITED_0] = cfgDfBoolean(), _a.maxBatchInterval = 15e3, _a[_DYN_MAX_BATCH_SIZE_IN_BY1] = 102400, _a.disableTelemetry = cfgDfBoolean(), _a[_DYN_ENABLE_SESSION_STORA5] = cfgDfBoolean(!0), _a.isRetryDisabled = cfgDfBoolean(), _a[_DYN_IS_BEACON_API_DISABL3] = cfgDfBoolean(!0), _a[_DYN_DISABLE_SEND_BEACON_7] = cfgDfBoolean(!0), _a.disableXhr = cfgDfBoolean(), _a[_DYN_ONUNLOAD_DISABLE_FET6] = cfgDfBoolean(), _a[_DYN_ONUNLOAD_DISABLE_BEA2] = cfgDfBoolean(), _a[_DYN_INSTRUMENTATION_KEY] = UNDEFINED_VALUE, _a.namePrefix = UNDEFINED_VALUE, _a.samplingPercentage = cfgDfValidate(_chkSampling, 100), _a[_DYN_CUSTOM_HEADERS] = UNDEFINED_VALUE, _a.convertUndefined = UNDEFINED_VALUE, _a.eventsLimitInMem = 1e4, _a[_DYN_BUFFER_OVERRIDE] = !1, _a.httpXHROverride = {
      isVal: isOverrideFn,
      v: UNDEFINED_VALUE
    }, _a[_DYN_ALWAYS_USE_XHR_OVERR4] = cfgDfBoolean(), _a.transports = UNDEFINED_VALUE, _a.retryCodes = UNDEFINED_VALUE, _a.maxRetryCnt = {
      isVal: isNumber,
      v: 10
    }, _a));
    function _chkSampling(value) {
      return !isNaN(value) && value > 0 && value <= 100;
    }
    __name(_chkSampling, "_chkSampling");
    var EnvelopeTypeCreator = (_b = {}, _b[Event.dataType] = EventEnvelopeCreator, _b[Trace.dataType] = TraceEnvelopeCreator, _b[PageView.dataType] = PageViewEnvelopeCreator, _b[PageViewPerformance.dataType] = PageViewPerformanceEnvelopeCreator, _b[Exception.dataType] = ExceptionEnvelopeCreator, _b[Metric.dataType] = MetricEnvelopeCreator, _b[RemoteDependencyData.dataType] = DependencyEnvelopeCreator, _b),
      Sender = function (_super) {
        __extends(Sender, _super);
        function Sender() {
          var _this = _super.call(this) || this;
          _this.priority = 1001, _this.identifier = BreezeChannelIdentifier;
          var _consecutiveErrors,
            _retryAt,
            _paused,
            _timeoutHandle,
            _serializer,
            _stamp_specific_redirects,
            _headers,
            _syncFetchPayload = 0,
            _syncUnloadSender,
            _offlineListener,
            _evtNamespace,
            _endpointUrl,
            _orgEndpointUrl,
            _maxBatchSizeInBytes,
            _beaconSupported,
            _beaconOnUnloadSupported,
            _beaconNormalSupported,
            _customHeaders,
            _disableTelemetry,
            _instrumentationKey,
            _convertUndefined,
            _isRetryDisabled,
            _maxBatchInterval,
            _sessionStorageUsed,
            _bufferOverrideUsed,
            _namePrefix,
            _enableSendPromise,
            _alwaysUseCustomSend,
            _disableXhr,
            _fetchKeepAlive,
            _xhrSend,
            _fallbackSend,
            _disableBeaconSplit,
            _sendPostMgr,
            _retryCodes;
          return dynamicProto(Sender, _this, function (_self, _base) {
            _initDefaults(), _self.pause = function () {
              _clearScheduledTimer(), _paused = !0;
            }, _self.resume = function () {
              _paused && (_paused = !1, _retryAt = null, _checkMaxSize(), _setupTimer());
            }, _self.flush = function (isAsync, callBack, sendReason) {
              if (isAsync === void 0 && (isAsync = !0), !_paused) {
                _clearScheduledTimer();
                try {
                  return _self[_DYN_TRIGGER_SEND](isAsync, null, sendReason || 1);
                } catch (e) {
                  _throwInternal(_self[_DYN_DIAG_LOG](), 1, 22, "flush failed, telemetry will not be collected: " + getExceptionName(e), {
                    exception: dumpObj(e)
                  });
                }
              }
            }, _self.onunloadFlush = function () {
              if (!_paused) if (_beaconSupported || _alwaysUseCustomSend) try {
                return _self[_DYN_TRIGGER_SEND](!0, _doUnloadSend, 2);
              } catch (e) {
                _throwInternal(_self[_DYN_DIAG_LOG](), 1, 20, "failed to flush with beacon sender on page unload, telemetry will not be collected: " + getExceptionName(e), {
                  exception: dumpObj(e)
                });
              } else _self.flush(!1);
            }, _self.addHeader = function (name, value) {
              _headers[name] = value;
            }, _self[_DYN_INITIALIZE] = function (config, core, extensions, pluginChain) {
              _self.isInitialized() && _throwInternal(_self[_DYN_DIAG_LOG](), 1, 28, "Sender is already initialized"), _base[_DYN_INITIALIZE](config, core, extensions, pluginChain);
              var identifier = _self.identifier;
              _serializer = new Serializer(core.logger), _consecutiveErrors = 0, _retryAt = null, _self[_DYN__SENDER] = null, _stamp_specific_redirects = 0;
              var diagLog = _self[_DYN_DIAG_LOG]();
              _evtNamespace = mergeEvtNamespace(createUniqueNamespace("Sender"), core.evtNamespace && core.evtNamespace()), _offlineListener = createOfflineListener(_evtNamespace), _self._addHook(onConfigChange(config, function (details) {
                var config = details.cfg;
                config.storagePrefix && utlSetStoragePrefix(config.storagePrefix);
                var ctx = createProcessTelemetryContext(null, config, core),
                  senderConfig = ctx.getExtCfg(identifier, defaultAppInsightsChannelConfig),
                  curExtUrl = senderConfig[_DYN_ENDPOINT_URL];
                if (_endpointUrl && curExtUrl === _endpointUrl) {
                  var coreUrl = config[_DYN_ENDPOINT_URL];
                  coreUrl && coreUrl !== curExtUrl && (senderConfig[_DYN_ENDPOINT_URL] = coreUrl);
                }
                isPromiseLike(senderConfig[_DYN_INSTRUMENTATION_KEY]) && (senderConfig[_DYN_INSTRUMENTATION_KEY] = config[_DYN_INSTRUMENTATION_KEY]), objDefine(_self, "_senderConfig", {
                  g: __name(function () {
                    return senderConfig;
                  }, "g")
                }), _orgEndpointUrl !== senderConfig[_DYN_ENDPOINT_URL] && (_endpointUrl = _orgEndpointUrl = senderConfig[_DYN_ENDPOINT_URL]), core.activeStatus() === ActiveStatus.PENDING ? _self.pause() : core.activeStatus() === ActiveStatus.ACTIVE && _self.resume(), _customHeaders && _customHeaders !== senderConfig[_DYN_CUSTOM_HEADERS] && arrForEach(_customHeaders, function (customHeader) {
                  delete _headers[customHeader.header];
                }), _maxBatchSizeInBytes = senderConfig[_DYN_MAX_BATCH_SIZE_IN_BY1], _beaconSupported = (senderConfig[_DYN_ONUNLOAD_DISABLE_BEA2] === !1 || senderConfig[_DYN_IS_BEACON_API_DISABL3] === !1) && isBeaconsSupported(), _beaconOnUnloadSupported = senderConfig[_DYN_ONUNLOAD_DISABLE_BEA2] === !1 && isBeaconsSupported(), _beaconNormalSupported = senderConfig[_DYN_IS_BEACON_API_DISABL3] === !1 && isBeaconsSupported(), _alwaysUseCustomSend = senderConfig[_DYN_ALWAYS_USE_XHR_OVERR4], _disableXhr = !!senderConfig.disableXhr, _retryCodes = senderConfig.retryCodes;
                var bufferOverride = senderConfig[_DYN_BUFFER_OVERRIDE],
                  canUseSessionStorage = !!senderConfig[_DYN_ENABLE_SESSION_STORA5] && (!!bufferOverride || utlCanUseSessionStorage()),
                  namePrefix = senderConfig.namePrefix,
                  shouldUpdate = canUseSessionStorage !== _sessionStorageUsed || canUseSessionStorage && _namePrefix !== namePrefix || canUseSessionStorage && _bufferOverrideUsed !== bufferOverride;
                if (_self[_DYN__BUFFER]) {
                  if (shouldUpdate) try {
                    _self[_DYN__BUFFER] = _self[_DYN__BUFFER].createNew(diagLog, senderConfig, canUseSessionStorage);
                  } catch (e) {
                    _throwInternal(_self[_DYN_DIAG_LOG](), 1, 12, "failed to transfer telemetry to different buffer storage, telemetry will be lost: " + getExceptionName(e), {
                      exception: dumpObj(e)
                    });
                  }
                  _checkMaxSize();
                } else _self[_DYN__BUFFER] = canUseSessionStorage ? new SessionStorageSendBuffer(diagLog, senderConfig) : new ArraySendBuffer(diagLog, senderConfig);
                _namePrefix = namePrefix, _sessionStorageUsed = canUseSessionStorage, _bufferOverrideUsed = bufferOverride, _fetchKeepAlive = !senderConfig[_DYN_ONUNLOAD_DISABLE_FET6] && isFetchSupported(!0), _disableBeaconSplit = !!senderConfig[_DYN_DISABLE_SEND_BEACON_7], _self._sample = new Sample(senderConfig.samplingPercentage, diagLog), _instrumentationKey = senderConfig[_DYN_INSTRUMENTATION_KEY], !isPromiseLike(_instrumentationKey) && !_validateInstrumentationKey(_instrumentationKey, config) && _throwInternal(diagLog, 1, 100, "Invalid Instrumentation key " + _instrumentationKey), _customHeaders = senderConfig[_DYN_CUSTOM_HEADERS], isString(_endpointUrl) && !isInternalApplicationInsightsEndpoint(_endpointUrl) && _customHeaders && _customHeaders[_DYN_LENGTH] > 0 ? arrForEach(_customHeaders, function (customHeader) {
                  _this.addHeader(customHeader.header, customHeader.value);
                }) : _customHeaders = null, _enableSendPromise = senderConfig.enableSendPromise;
                var sendPostConfig = _getSendPostMgrConfig();
                _sendPostMgr ? _sendPostMgr.SetConfig(sendPostConfig) : (_sendPostMgr = new SenderPostManager(), _sendPostMgr[_DYN_INITIALIZE](sendPostConfig, diagLog));
                var customInterface = senderConfig.httpXHROverride,
                  httpInterface = null,
                  syncInterface = null,
                  theTransports = prependTransports([3, 1, 2], senderConfig.transports);
                httpInterface = _sendPostMgr && _sendPostMgr[_DYN_GET_SENDER_INST](theTransports, !1);
                var xhrInterface = _sendPostMgr && _sendPostMgr.getFallbackInst();
                _xhrSend = __name(function (payload, isAsync) {
                  return _doSend(xhrInterface, payload, isAsync);
                }, "_xhrSend"), _fallbackSend = __name(function (payload, isAsync) {
                  return _doSend(xhrInterface, payload, isAsync, !1);
                }, "_fallbackSend"), httpInterface = _alwaysUseCustomSend ? customInterface : httpInterface || customInterface || xhrInterface, _self[_DYN__SENDER] = function (payload, isAsync) {
                  return _doSend(httpInterface, payload, isAsync);
                }, _fetchKeepAlive && (_syncUnloadSender = _fetchKeepAliveSender);
                var syncTransports = prependTransports([3, 1], senderConfig.unloadTransports);
                _fetchKeepAlive || (syncTransports = syncTransports.filter(function (transport) {
                  return transport !== 2;
                })), syncInterface = _sendPostMgr && _sendPostMgr[_DYN_GET_SENDER_INST](syncTransports, !0), syncInterface = _alwaysUseCustomSend ? customInterface : syncInterface || customInterface, (_alwaysUseCustomSend || senderConfig.unloadTransports || !_syncUnloadSender) && syncInterface && (_syncUnloadSender = __name(function (payload, isAsync) {
                  return _doSend(syncInterface, payload, isAsync);
                }, "_syncUnloadSender")), _syncUnloadSender || (_syncUnloadSender = _xhrSend), _disableTelemetry = senderConfig.disableTelemetry, _convertUndefined = senderConfig.convertUndefined || UNDEFINED_VALUE, _isRetryDisabled = senderConfig.isRetryDisabled, _maxBatchInterval = senderConfig.maxBatchInterval;
              }));
            }, _self.processTelemetry = function (telemetryItem, itemCtx) {
              itemCtx = _self._getTelCtx(itemCtx);
              var diagLogger = itemCtx[_DYN_DIAG_LOG]();
              try {
                var isValidate = _validate(telemetryItem, diagLogger);
                if (!isValidate) return;
                var aiEnvelope = _getEnvelope(telemetryItem, diagLogger);
                if (!aiEnvelope) return;
                var payload = _serializer.serialize(aiEnvelope),
                  buffer = _self[_DYN__BUFFER];
                _checkMaxSize(payload);
                var payloadItem = {
                  item: payload,
                  cnt: 0
                };
                buffer[_DYN_ENQUEUE](payloadItem), _setupTimer();
              } catch (e) {
                _throwInternal(diagLogger, 2, 12, "Failed adding telemetry to the sender's buffer, some telemetry will be lost: " + getExceptionName(e), {
                  exception: dumpObj(e)
                });
              }
              _self.processNext(telemetryItem, itemCtx);
            }, _self.isCompletelyIdle = function () {
              return !_paused && _syncFetchPayload === 0 && _self._buffer[_DYN_COUNT]() === 0;
            }, _self.getOfflineListener = function () {
              return _offlineListener;
            }, _self._xhrReadyStateChange = function (xhr, payload, countOfItemsInPayload) {
              if (!_isStringArr(payload)) return _xhrReadyStateChange(xhr, payload, countOfItemsInPayload);
            }, _self[_DYN_TRIGGER_SEND] = function (async, forcedSender, sendReason) {
              async === void 0 && (async = !0);
              var result;
              if (!_paused) try {
                var buffer = _self[_DYN__BUFFER];
                if (_disableTelemetry) buffer[_DYN_CLEAR]();else if (buffer[_DYN_COUNT]() > 0) {
                  var payload = buffer.getItems();
                  _notifySendRequest(sendReason || 0, async), forcedSender ? result = forcedSender.call(_self, payload, async) : result = _self[_DYN__SENDER](payload, async);
                }
                _clearScheduledTimer();
              } catch (e) {
                var ieVer = getIEVersion();
                (!ieVer || ieVer > 9) && _throwInternal(_self[_DYN_DIAG_LOG](), 1, 40, "Telemetry transmission failed, some telemetry will be lost: " + getExceptionName(e), {
                  exception: dumpObj(e)
                });
              }
              return result;
            }, _self.getOfflineSupport = function () {
              return {
                getUrl: __name(function () {
                  return _endpointUrl;
                }, "getUrl"),
                createPayload: _createPayload,
                serialize: _serialize,
                batch: _batch,
                shouldProcess: __name(function (evt) {
                  return !!_validate(evt);
                }, "shouldProcess")
              };
            }, _self._doTeardown = function (unloadCtx, unloadState) {
              _self.onunloadFlush(), runTargetUnload(_offlineListener, !1), _initDefaults();
            }, _self[_DYN__ON_ERROR] = function (payload, message, event) {
              if (!_isStringArr(payload)) return _onError(payload, message);
            }, _self[_DYN__ON_PARTIAL_SUCCESS] = function (payload, results) {
              if (!_isStringArr(payload)) return _onPartialSuccess(payload, results);
            }, _self[_DYN__ON_SUCCESS] = function (payload, countOfItemsInPayload) {
              if (!_isStringArr(payload)) return _onSuccess(payload);
            }, _self._xdrOnLoad = function (xdr, payload) {
              if (!_isStringArr(payload)) return _xdrOnLoad(xdr, payload);
            };
            function _xdrOnLoad(xdr, payload) {
              var responseText = _getResponseText(xdr);
              if (xdr && (responseText + "" == "200" || responseText === "")) _consecutiveErrors = 0, _self[_DYN__ON_SUCCESS](payload, 0);else {
                var results = parseResponse(responseText);
                results && results[_DYN_ITEMS_RECEIVED] && results[_DYN_ITEMS_RECEIVED] > results[_DYN_ITEMS_ACCEPTED] && !_isRetryDisabled ? _self[_DYN__ON_PARTIAL_SUCCESS](payload, results) : _self[_DYN__ON_ERROR](payload, formatErrorMessageXdr(xdr));
              }
            }
            __name(_xdrOnLoad, "_xdrOnLoad");
            function _getSendPostMgrConfig() {
              try {
                var onCompleteFuncs = {
                    xdrOnComplete: __name(function (xdr, oncomplete, payload) {
                      var data = _getPayloadArr(payload);
                      if (data) return _xdrOnLoad(xdr, data);
                    }, "xdrOnComplete"),
                    fetchOnComplete: __name(function (response, onComplete, resValue, payload) {
                      var data = _getPayloadArr(payload);
                      if (data) return _checkResponsStatus(response.status, data, response.url, data[_DYN_LENGTH], response.statusText, resValue || "");
                    }, "fetchOnComplete"),
                    xhrOnComplete: __name(function (request, oncomplete, payload) {
                      var data = _getPayloadArr(payload);
                      if (data) return _xhrReadyStateChange(request, data, data[_DYN_LENGTH]);
                    }, "xhrOnComplete"),
                    beaconOnRetry: __name(function (data, onComplete, canSend) {
                      return _onBeaconRetry(data, onComplete, canSend);
                    }, "beaconOnRetry")
                  },
                  config = {
                    enableSendPromise: _enableSendPromise,
                    isOneDs: !1,
                    disableCredentials: !1,
                    disableXhr: _disableXhr,
                    disableBeacon: !_beaconNormalSupported,
                    disableBeaconSync: !_beaconOnUnloadSupported,
                    senderOnCompleteCallBack: onCompleteFuncs
                  };
                return config;
              } catch {}
              return null;
            }
            __name(_getSendPostMgrConfig, "_getSendPostMgrConfig");
            function _xhrReadyStateChange(xhr, payload, countOfItemsInPayload) {
              xhr.readyState === 4 && _checkResponsStatus(xhr.status, payload, xhr.responseURL, countOfItemsInPayload, formatErrorMessageXhr(xhr), _getResponseText(xhr) || xhr.response);
            }
            __name(_xhrReadyStateChange, "_xhrReadyStateChange");
            function _onError(payload, message, event) {
              _throwInternal(_self[_DYN_DIAG_LOG](), 2, 26, "Failed to send telemetry.", {
                message: message
              }), _self._buffer && _self._buffer[_DYN_CLEAR_SENT](payload);
            }
            __name(_onError, "_onError");
            function _onPartialSuccess(payload, results) {
              for (var failed = [], retry = [], errors = results.errors.reverse(), _i = 0, errors_1 = errors; _i < errors_1.length; _i++) {
                var error = errors_1[_i],
                  extracted = payload.splice(error.index, 1)[0];
                _isRetriable(error.statusCode) ? retry[_DYN_PUSH](extracted) : failed[_DYN_PUSH](extracted);
              }
              payload[_DYN_LENGTH] > 0 && _self[_DYN__ON_SUCCESS](payload, results[_DYN_ITEMS_ACCEPTED]), failed[_DYN_LENGTH] > 0 && _self[_DYN__ON_ERROR](failed, formatErrorMessageXhr(null, ["partial success", results[_DYN_ITEMS_ACCEPTED], "of", results.itemsReceived].join(" "))), retry[_DYN_LENGTH] > 0 && (_resendPayload(retry), _throwInternal(_self[_DYN_DIAG_LOG](), 2, 40, "Partial success. Delivered: " + payload[_DYN_LENGTH] + ", Failed: " + failed[_DYN_LENGTH] + ". Will retry to send " + retry[_DYN_LENGTH] + " our of " + results[_DYN_ITEMS_RECEIVED] + " items"));
            }
            __name(_onPartialSuccess, "_onPartialSuccess");
            function _onSuccess(payload, countOfItemsInPayload) {
              _self._buffer && _self._buffer[_DYN_CLEAR_SENT](payload);
            }
            __name(_onSuccess, "_onSuccess");
            function _getPayloadArr(payload) {
              try {
                if (payload) {
                  var internalPayload = payload,
                    arr = internalPayload.oriPayload;
                  return arr && arr[_DYN_LENGTH] ? arr : null;
                }
              } catch {}
              return null;
            }
            __name(_getPayloadArr, "_getPayloadArr");
            function _validate(telemetryItem, diagLogger) {
              if (_disableTelemetry) return !1;
              if (!telemetryItem) return diagLogger && _throwInternal(diagLogger, 1, 7, "Cannot send empty telemetry"), !1;
              if (telemetryItem.baseData && !telemetryItem[_DYN_BASE_TYPE]) return diagLogger && _throwInternal(diagLogger, 1, 70, "Cannot send telemetry without baseData and baseType"), !1;
              if (telemetryItem[_DYN_BASE_TYPE] || (telemetryItem[_DYN_BASE_TYPE] = "EventData"), !_self[_DYN__SENDER]) return diagLogger && _throwInternal(diagLogger, 1, 28, "Sender was not initialized"), !1;
              if (_isSampledIn(telemetryItem)) telemetryItem[SampleRate] = _self._sample[_DYN_SAMPLE_RATE];else return diagLogger && _throwInternal(diagLogger, 2, 33, "Telemetry item was sampled out and not sent", {
                SampleRate: _self._sample[_DYN_SAMPLE_RATE]
              }), !1;
              return !0;
            }
            __name(_validate, "_validate");
            function _getEnvelope(telemetryItem, diagLogger) {
              var defaultEnvelopeIkey = telemetryItem.iKey || _instrumentationKey,
                aiEnvelope = Sender.constructEnvelope(telemetryItem, defaultEnvelopeIkey, diagLogger, _convertUndefined);
              if (!aiEnvelope) {
                _throwInternal(diagLogger, 1, 47, "Unable to create an AppInsights envelope");
                return;
              }
              var doNotSendItem = !1;
              if (telemetryItem[_DYN_TAGS] && telemetryItem[_DYN_TAGS][ProcessLegacy] && (arrForEach(telemetryItem[_DYN_TAGS][ProcessLegacy], function (callBack) {
                try {
                  callBack && callBack(aiEnvelope) === !1 && (doNotSendItem = !0, _warnToConsole(diagLogger, "Telemetry processor check returns false"));
                } catch (e) {
                  _throwInternal(diagLogger, 1, 64, "One of telemetry initializers failed, telemetry item will not be sent: " + getExceptionName(e), {
                    exception: dumpObj(e)
                  }, !0);
                }
              }), delete telemetryItem[_DYN_TAGS][ProcessLegacy]), !doNotSendItem) return aiEnvelope;
            }
            __name(_getEnvelope, "_getEnvelope");
            function _serialize(item) {
              var rlt = EMPTY_STR,
                diagLogger = _self[_DYN_DIAG_LOG]();
              try {
                var valid = _validate(item, diagLogger),
                  envelope = null;
                valid && (envelope = _getEnvelope(item, diagLogger)), envelope && (rlt = _serializer.serialize(envelope));
              } catch {}
              return rlt;
            }
            __name(_serialize, "_serialize");
            function _batch(arr) {
              var rlt = EMPTY_STR;
              return arr && arr[_DYN_LENGTH] && (rlt = "[" + arr.join(",") + "]"), rlt;
            }
            __name(_batch, "_batch");
            function _createPayload(data) {
              var headers = _getHeaders();
              return {
                urlString: _endpointUrl,
                data: data,
                headers: headers
              };
            }
            __name(_createPayload, "_createPayload");
            function _isSampledIn(envelope) {
              return _self._sample.isSampledIn(envelope);
            }
            __name(_isSampledIn, "_isSampledIn");
            function _getOnComplete(payload, status, headers, response) {
              status === 200 && payload ? _self._onSuccess(payload, payload[_DYN_LENGTH]) : response && _self[_DYN__ON_ERROR](payload, response);
            }
            __name(_getOnComplete, "_getOnComplete");
            function _doSend(sendInterface, payload, isAsync, markAsSent) {
              markAsSent === void 0 && (markAsSent = !0);
              var onComplete = __name(function (status, headers, response) {
                  return _getOnComplete(payload, status, headers, response);
                }, "onComplete"),
                payloadData = _getPayload(payload),
                sendPostFunc = sendInterface && sendInterface.sendPOST;
              return sendPostFunc && payloadData ? (markAsSent && _self._buffer[_DYN_MARK_AS_SENT](payload), sendPostFunc(payloadData, onComplete, !isAsync)) : null;
            }
            __name(_doSend, "_doSend");
            function _getPayload(payload) {
              if (isArray(payload) && payload[_DYN_LENGTH] > 0) {
                var batch = _self[_DYN__BUFFER].batchPayloads(payload),
                  headers = _getHeaders(),
                  payloadData = {
                    data: batch,
                    urlString: _endpointUrl,
                    headers: headers,
                    disableXhrSync: _disableXhr,
                    disableFetchKeepAlive: !_fetchKeepAlive,
                    oriPayload: payload
                  };
                return payloadData;
              }
              return null;
            }
            __name(_getPayload, "_getPayload");
            function _getHeaders() {
              try {
                var headers = _headers || {};
                return isInternalApplicationInsightsEndpoint(_endpointUrl) && (headers[RequestHeaders[6]] = RequestHeaders[7]), headers;
              } catch {}
              return null;
            }
            __name(_getHeaders, "_getHeaders");
            function _checkMaxSize(incomingPayload) {
              var incomingSize = incomingPayload ? incomingPayload[_DYN_LENGTH] : 0;
              return _self[_DYN__BUFFER].size() + incomingSize > _maxBatchSizeInBytes ? ((!_offlineListener || _offlineListener.isOnline()) && _self[_DYN_TRIGGER_SEND](!0, null, 10), !0) : !1;
            }
            __name(_checkMaxSize, "_checkMaxSize");
            function _checkResponsStatus(status, payload, responseUrl, countOfItemsInPayload, errorMessage, res) {
              var response = null;
              if (_self._appId || (response = parseResponse(res), response && response.appId && (_self._appId = response.appId)), (status < 200 || status >= 300) && status !== 0) {
                if ((status === 301 || status === 307 || status === 308) && !_checkAndUpdateEndPointUrl(responseUrl)) {
                  _self[_DYN__ON_ERROR](payload, errorMessage);
                  return;
                }
                if (_offlineListener && !_offlineListener.isOnline()) {
                  if (!_isRetryDisabled) {
                    var offlineBackOffMultiplier = 10;
                    _resendPayload(payload, offlineBackOffMultiplier), _throwInternal(_self[_DYN_DIAG_LOG](), 2, 40, ". Offline - Response Code: ".concat(status, ". Offline status: ").concat(!_offlineListener.isOnline(), ". Will retry to send ").concat(payload.length, " items."));
                  }
                  return;
                }
                !_isRetryDisabled && _isRetriable(status) ? (_resendPayload(payload), _throwInternal(_self[_DYN_DIAG_LOG](), 2, 40, ". Response code " + status + ". Will retry to send " + payload[_DYN_LENGTH] + " items.")) : _self[_DYN__ON_ERROR](payload, errorMessage);
              } else _checkAndUpdateEndPointUrl(responseUrl), status === 206 ? (response || (response = parseResponse(res)), response && !_isRetryDisabled ? _self[_DYN__ON_PARTIAL_SUCCESS](payload, response) : _self[_DYN__ON_ERROR](payload, errorMessage)) : (_consecutiveErrors = 0, _self[_DYN__ON_SUCCESS](payload, countOfItemsInPayload));
            }
            __name(_checkResponsStatus, "_checkResponsStatus");
            function _checkAndUpdateEndPointUrl(responseUrl) {
              return _stamp_specific_redirects >= 10 ? !1 : !isNullOrUndefined(responseUrl) && responseUrl !== "" && responseUrl !== _endpointUrl ? (_endpointUrl = responseUrl, ++_stamp_specific_redirects, !0) : !1;
            }
            __name(_checkAndUpdateEndPointUrl, "_checkAndUpdateEndPointUrl");
            function _doUnloadSend(payload, isAsync) {
              if (_syncUnloadSender) _syncUnloadSender(payload, !1);else {
                var beaconInst = _sendPostMgr && _sendPostMgr[_DYN_GET_SENDER_INST]([3], !0);
                return _doSend(beaconInst, payload, isAsync);
              }
            }
            __name(_doUnloadSend, "_doUnloadSend");
            function _onBeaconRetry(payload, onComplete, canSend) {
              var internalPayload = payload,
                data = internalPayload && internalPayload.oriPayload;
              if (_disableBeaconSplit) _fallbackSend && _fallbackSend(data, !0), _throwInternal(_self[_DYN_DIAG_LOG](), 2, 40, ". Failed to send telemetry with Beacon API, retried with normal sender.");else {
                for (var droppedPayload = [], lp = 0; lp < data[_DYN_LENGTH]; lp++) {
                  var thePayload = data[lp],
                    arr = [thePayload],
                    item = _getPayload(arr);
                  canSend(item, onComplete) ? _self._onSuccess(arr, arr[_DYN_LENGTH]) : droppedPayload[_DYN_PUSH](thePayload);
                }
                droppedPayload[_DYN_LENGTH] > 0 && (_fallbackSend && _fallbackSend(droppedPayload, !0), _throwInternal(_self[_DYN_DIAG_LOG](), 2, 40, ". Failed to send telemetry with Beacon API, retried with normal sender."));
              }
            }
            __name(_onBeaconRetry, "_onBeaconRetry");
            function _isStringArr(arr) {
              try {
                if (arr && arr[_DYN_LENGTH]) return isString(arr[0]);
              } catch {}
              return null;
            }
            __name(_isStringArr, "_isStringArr");
            function _fetchKeepAliveSender(payload, isAsync) {
              var transport = null;
              if (isArray(payload)) {
                for (var payloadSize = payload[_DYN_LENGTH], lp = 0; lp < payload[_DYN_LENGTH]; lp++) payloadSize += payload[lp].item[_DYN_LENGTH];
                var syncFetchPayload = _sendPostMgr.getSyncFetchPayload();
                syncFetchPayload + payloadSize <= FetchSyncRequestSizeLimitBytes ? transport = 2 : isBeaconsSupported() ? transport = 3 : (transport = 1, _throwInternal(_self[_DYN_DIAG_LOG](), 2, 40, ". Failed to send telemetry with Beacon API, retried with xhrSender."));
                var inst = _sendPostMgr && _sendPostMgr[_DYN_GET_SENDER_INST]([transport], !0);
                return _doSend(inst, payload, isAsync);
              }
              return null;
            }
            __name(_fetchKeepAliveSender, "_fetchKeepAliveSender");
            function _resendPayload(payload, linearFactor) {
              if (linearFactor === void 0 && (linearFactor = 1), !(!payload || payload[_DYN_LENGTH] === 0)) {
                var buffer = _self[_DYN__BUFFER];
                buffer[_DYN_CLEAR_SENT](payload), _consecutiveErrors++;
                for (var _i = 0, payload_1 = payload; _i < payload_1.length; _i++) {
                  var item = payload_1[_i];
                  item.cnt = item.cnt || 0, item.cnt++, buffer[_DYN_ENQUEUE](item);
                }
                _setRetryTime(linearFactor), _setupTimer();
              }
            }
            __name(_resendPayload, "_resendPayload");
            function _setRetryTime(linearFactor) {
              var SlotDelayInSeconds = 10,
                delayInSeconds;
              if (_consecutiveErrors <= 1) delayInSeconds = SlotDelayInSeconds;else {
                var backOffSlot = (Math.pow(2, _consecutiveErrors) - 1) / 2,
                  backOffDelay = mathFloor(Math.random() * backOffSlot * SlotDelayInSeconds) + 1;
                backOffDelay = linearFactor * backOffDelay, delayInSeconds = mathMax(mathMin(backOffDelay, 3600), SlotDelayInSeconds);
              }
              var retryAfterTimeSpan = dateNow() + delayInSeconds * 1e3;
              _retryAt = retryAfterTimeSpan;
            }
            __name(_setRetryTime, "_setRetryTime");
            function _setupTimer() {
              if (!_timeoutHandle && !_paused) {
                var retryInterval = _retryAt ? mathMax(0, _retryAt - dateNow()) : 0,
                  timerValue = mathMax(_maxBatchInterval, retryInterval);
                _timeoutHandle = scheduleTimeout(function () {
                  _timeoutHandle = null, _self[_DYN_TRIGGER_SEND](!0, null, 1);
                }, timerValue);
              }
            }
            __name(_setupTimer, "_setupTimer");
            function _clearScheduledTimer() {
              _timeoutHandle && _timeoutHandle.cancel(), _timeoutHandle = null, _retryAt = null;
            }
            __name(_clearScheduledTimer, "_clearScheduledTimer");
            function _isRetriable(statusCode) {
              return isNullOrUndefined(_retryCodes) ? statusCode === 401 || statusCode === 408 || statusCode === 429 || statusCode === 500 || statusCode === 502 || statusCode === 503 || statusCode === 504 : _retryCodes[_DYN_LENGTH] && _retryCodes.indexOf(statusCode) > -1;
            }
            __name(_isRetriable, "_isRetriable");
            function _getNotifyMgr() {
              var func = "getNotifyMgr";
              return _self.core[func] ? _self.core[func]() : _self.core._notificationManager;
            }
            __name(_getNotifyMgr, "_getNotifyMgr");
            function _notifySendRequest(sendRequest, isAsync) {
              var manager = _getNotifyMgr();
              if (manager && manager.eventsSendRequest) try {
                manager.eventsSendRequest(sendRequest, isAsync);
              } catch (e) {
                _throwInternal(_self[_DYN_DIAG_LOG](), 1, 74, "send request notification failed: " + getExceptionName(e), {
                  exception: dumpObj(e)
                });
              }
            }
            __name(_notifySendRequest, "_notifySendRequest");
            function _validateInstrumentationKey(instrumentationKey, config) {
              var disableValidation = config.disableInstrumentationKeyValidation,
                disableIKeyValidationFlag = isNullOrUndefined(disableValidation) ? !1 : disableValidation;
              if (disableIKeyValidationFlag) return !0;
              var UUID_Regex = "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$",
                regexp = new RegExp(UUID_Regex);
              return regexp.test(instrumentationKey);
            }
            __name(_validateInstrumentationKey, "_validateInstrumentationKey");
            function _initDefaults() {
              _self[_DYN__SENDER] = null, _self[_DYN__BUFFER] = null, _self._appId = null, _self._sample = null, _headers = {}, _offlineListener = null, _consecutiveErrors = 0, _retryAt = null, _paused = !1, _timeoutHandle = null, _serializer = null, _stamp_specific_redirects = 0, _syncFetchPayload = 0, _syncUnloadSender = null, _evtNamespace = null, _endpointUrl = null, _orgEndpointUrl = null, _maxBatchSizeInBytes = 0, _beaconSupported = !1, _customHeaders = null, _disableTelemetry = !1, _instrumentationKey = null, _convertUndefined = UNDEFINED_VALUE, _isRetryDisabled = !1, _sessionStorageUsed = null, _namePrefix = UNDEFINED_VALUE, _disableXhr = !1, _fetchKeepAlive = !1, _disableBeaconSplit = !1, _xhrSend = null, _fallbackSend = null, _sendPostMgr = null, objDefine(_self, "_senderConfig", {
                g: __name(function () {
                  return objExtend({}, defaultAppInsightsChannelConfig);
                }, "g")
              });
            }
            __name(_initDefaults, "_initDefaults");
          }), _this;
        }
        return __name(Sender, "Sender"), Sender.constructEnvelope = function (orig, iKey, logger, convertUndefined) {
          var envelope;
          iKey !== orig.iKey && !isNullOrUndefined(iKey) ? envelope = __assign(__assign({}, orig), {
            iKey: iKey
          }) : envelope = orig;
          var creator = EnvelopeTypeCreator[envelope.baseType] || EventEnvelopeCreator;
          return creator(logger, envelope, convertUndefined);
        }, Sender;
      }(BaseTelemetryPlugin),
      _DYN_INSTRUMENTATION_KEY = "instrumentationKey",
      _DYN_CONNECTION_STRING = "connectionString",
      _DYN_ENDPOINT_URL = "endpointUrl",
      _DYN_USER_OVERRIDE_ENDPOI0 = "userOverrideEndpointUrl",
      _a,
      UNDEFINED_VALUE = void 0,
      defaultConfigValues = (_a = {
        diagnosticLogInterval: cfgDfValidate(_chkDiagLevel, 1e4)
      }, _a[_DYN_CONNECTION_STRING] = UNDEFINED_VALUE, _a.endpointUrl = UNDEFINED_VALUE, _a[_DYN_INSTRUMENTATION_KEY] = UNDEFINED_VALUE, _a.extensionConfig = {}, _a);
    function _chkDiagLevel(value) {
      return value && value > 0;
    }
    __name(_chkDiagLevel, "_chkDiagLevel");
    var ApplicationInsights = function () {
      function ApplicationInsights(config) {
        var core = new AppInsightsCore(),
          _config;
        (isNullOrUndefined(config) || isNullOrUndefined(config[_DYN_INSTRUMENTATION_KEY]) && isNullOrUndefined(config[_DYN_CONNECTION_STRING])) && throwError("Invalid input configuration"), dynamicProto(ApplicationInsights, this, function (_self) {
          objDefine(_self, "config", {
            g: __name(function () {
              return _config;
            }, "g")
          }), _initialize(), _self.initialize = _initialize, _self.track = _track, proxyFunctions(_self, core, ["flush", "pollInternalLogs", "stopPollingInternalLogs", "unload", "getPlugin", "addPlugin", "evtNamespace", "addUnloadCb", "onCfgChange", "getTraceCtx", "updateCfg", "addTelemetryInitializer"]);
          function _initialize() {
            var cfgHandler = createDynamicConfig(config || {}, defaultConfigValues);
            _config = cfgHandler.cfg, core.addUnloadHook(onConfigChange(cfgHandler, function () {
              var configCs = _config[_DYN_CONNECTION_STRING];
              if (isPromiseLike(configCs)) {
                var ikeyPromise = createSyncPromise(function (resolve, reject) {
                    doAwaitResponse(configCs, function (res) {
                      var curCs = res.value,
                        ikey = _config[_DYN_INSTRUMENTATION_KEY];
                      if (!res.rejected && curCs) {
                        _config[_DYN_CONNECTION_STRING] = curCs;
                        var resolvedCs = parseConnectionString(curCs);
                        ikey = resolvedCs.instrumentationkey || ikey;
                      }
                      resolve(ikey);
                    });
                  }),
                  urlPromise = createSyncPromise(function (resolve, reject) {
                    doAwaitResponse(configCs, function (res) {
                      var curCs = res.value,
                        url = _config[_DYN_ENDPOINT_URL];
                      if (!res.rejected && curCs) {
                        var resolvedCs = parseConnectionString(curCs),
                          ingest = resolvedCs.ingestionendpoint;
                        url = ingest ? ingest + DEFAULT_BREEZE_PATH : url;
                      }
                      resolve(url);
                    });
                  });
                _config[_DYN_INSTRUMENTATION_KEY] = ikeyPromise, _config[_DYN_ENDPOINT_URL] = _config[_DYN_USER_OVERRIDE_ENDPOI0] || urlPromise;
              }
              if (isString(configCs)) {
                var cs = parseConnectionString(configCs),
                  ingest = cs.ingestionendpoint;
                _config[_DYN_ENDPOINT_URL] = _config[_DYN_USER_OVERRIDE_ENDPOI0] ? _config[_DYN_USER_OVERRIDE_ENDPOI0] : ingest + DEFAULT_BREEZE_PATH, _config[_DYN_INSTRUMENTATION_KEY] = cs.instrumentationkey || _config[_DYN_INSTRUMENTATION_KEY];
              }
              _config[_DYN_ENDPOINT_URL] = _config[_DYN_USER_OVERRIDE_ENDPOI0] ? _config[_DYN_USER_OVERRIDE_ENDPOI0] : _config[_DYN_ENDPOINT_URL];
            })), core.initialize(_config, [new Sender()]);
          }
          __name(_initialize, "_initialize");
        });
        function _track(item) {
          item && (item.baseData = item.baseData || {}, item.baseType = item.baseType || "EventData"), core.track(item);
        }
        __name(_track, "_track");
      }
      return __name(ApplicationInsights, "ApplicationInsights"), f.__ieDyn = 1, ApplicationInsights;
    }();
    e.AppInsightsCore = Gt, e.ApplicationInsights = Snt, e.Sender = XCe, e.SeverityLevel = snt, e.arrForEach = Zn, e.isNullOrUndefined = X, e.proxyFunctions = j2, e.throwError = Jt;
  });
});