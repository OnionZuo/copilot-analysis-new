var require_evpkdf = __commonJSMin((exports, module) => {
  (function (root, factory, undef) {
    typeof exports == "object" ? module.exports = exports = factory(wi(), lZ(), pT()) : typeof define == "function" && define.amd ? define(["./core", "./sha1", "./hmac"], factory) : factory(root.CryptoJS);
  })(exports, function (CryptoJS) {
    return function () {
      var C = CryptoJS,
        C_lib = C.lib,
        Base = C_lib.Base,
        WordArray = C_lib.WordArray,
        C_algo = C.algo,
        MD5 = C_algo.MD5,
        EvpKDF = C_algo.EvpKDF = Base.extend({
          cfg: Base.extend({
            keySize: 128 / 32,
            hasher: MD5,
            iterations: 1
          }),
          init: __name(function (cfg) {
            this.cfg = this.cfg.extend(cfg);
          }, "init"),
          compute: __name(function (password, salt) {
            for (var block, cfg = this.cfg, hasher = cfg.hasher.create(), derivedKey = WordArray.create(), derivedKeyWords = derivedKey.words, keySize = cfg.keySize, iterations = cfg.iterations; derivedKeyWords.length < keySize;) {
              block && hasher.update(block), block = hasher.update(password).finalize(salt), hasher.reset();
              for (var i = 1; i < iterations; i++) block = hasher.finalize(block), hasher.reset();
              derivedKey.concat(block);
            }
            return derivedKey.sigBytes = keySize * 4, derivedKey;
          }, "compute")
        });
      C.EvpKDF = function (password, salt, cfg) {
        return EvpKDF.create(cfg).compute(password, salt);
      };
    }(), CryptoJS.EvpKDF;
  });
});