var require_sha3 = __commonJSMin((exports, module) => {
  (function (root, factory, undef) {
    typeof exports == "object" ? module.exports = exports = factory(wi(), UD()) : typeof define == "function" && define.amd ? define(["./core", "./x64-core"], factory) : factory(root.CryptoJS);
  })(exports, function (CryptoJS) {
    return function (Math) {
      var C = CryptoJS,
        C_lib = C.lib,
        WordArray = C_lib.WordArray,
        Hasher = C_lib.Hasher,
        C_x64 = C.x64,
        X64Word = C_x64.Word,
        C_algo = C.algo,
        RHO_OFFSETS = [],
        PI_INDEXES = [],
        ROUND_CONSTANTS = [];
      (function () {
        for (var x = 1, y = 0, t = 0; t < 24; t++) {
          RHO_OFFSETS[x + 5 * y] = (t + 1) * (t + 2) / 2 % 64;
          var newX = y % 5,
            newY = (2 * x + 3 * y) % 5;
          x = newX, y = newY;
        }
        for (var x = 0; x < 5; x++) for (var y = 0; y < 5; y++) PI_INDEXES[x + 5 * y] = y + (2 * x + 3 * y) % 5 * 5;
        for (var LFSR = 1, i = 0; i < 24; i++) {
          for (var roundConstantMsw = 0, roundConstantLsw = 0, j = 0; j < 7; j++) {
            if (LFSR & 1) {
              var bitPosition = (1 << j) - 1;
              bitPosition < 32 ? roundConstantLsw ^= 1 << bitPosition : roundConstantMsw ^= 1 << bitPosition - 32;
            }
            LFSR & 128 ? LFSR = LFSR << 1 ^ 113 : LFSR <<= 1;
          }
          ROUND_CONSTANTS[i] = X64Word.create(roundConstantMsw, roundConstantLsw);
        }
      })();
      var T = [];
      (function () {
        for (var i = 0; i < 25; i++) T[i] = X64Word.create();
      })();
      var SHA3 = C_algo.SHA3 = Hasher.extend({
        cfg: Hasher.cfg.extend({
          outputLength: 512
        }),
        _doReset: __name(function () {
          for (var state = this._state = [], i = 0; i < 25; i++) state[i] = new X64Word.init();
          this.blockSize = (1600 - 2 * this.cfg.outputLength) / 32;
        }, "_doReset"),
        _doProcessBlock: __name(function (M, offset) {
          for (var state = this._state, nBlockSizeLanes = this.blockSize / 2, i = 0; i < nBlockSizeLanes; i++) {
            var M2i = M[offset + 2 * i],
              M2i1 = M[offset + 2 * i + 1];
            M2i = (M2i << 8 | M2i >>> 24) & 16711935 | (M2i << 24 | M2i >>> 8) & 4278255360, M2i1 = (M2i1 << 8 | M2i1 >>> 24) & 16711935 | (M2i1 << 24 | M2i1 >>> 8) & 4278255360;
            var lane = state[i];
            lane.high ^= M2i1, lane.low ^= M2i;
          }
          for (var round = 0; round < 24; round++) {
            for (var x = 0; x < 5; x++) {
              for (var tMsw = 0, tLsw = 0, y = 0; y < 5; y++) {
                var lane = state[x + 5 * y];
                tMsw ^= lane.high, tLsw ^= lane.low;
              }
              var Tx = T[x];
              Tx.high = tMsw, Tx.low = tLsw;
            }
            for (var x = 0; x < 5; x++) for (var Tx4 = T[(x + 4) % 5], Tx1 = T[(x + 1) % 5], Tx1Msw = Tx1.high, Tx1Lsw = Tx1.low, tMsw = Tx4.high ^ (Tx1Msw << 1 | Tx1Lsw >>> 31), tLsw = Tx4.low ^ (Tx1Lsw << 1 | Tx1Msw >>> 31), y = 0; y < 5; y++) {
              var lane = state[x + 5 * y];
              lane.high ^= tMsw, lane.low ^= tLsw;
            }
            for (var laneIndex = 1; laneIndex < 25; laneIndex++) {
              var tMsw,
                tLsw,
                lane = state[laneIndex],
                laneMsw = lane.high,
                laneLsw = lane.low,
                rhoOffset = RHO_OFFSETS[laneIndex];
              rhoOffset < 32 ? (tMsw = laneMsw << rhoOffset | laneLsw >>> 32 - rhoOffset, tLsw = laneLsw << rhoOffset | laneMsw >>> 32 - rhoOffset) : (tMsw = laneLsw << rhoOffset - 32 | laneMsw >>> 64 - rhoOffset, tLsw = laneMsw << rhoOffset - 32 | laneLsw >>> 64 - rhoOffset);
              var TPiLane = T[PI_INDEXES[laneIndex]];
              TPiLane.high = tMsw, TPiLane.low = tLsw;
            }
            var T0 = T[0],
              state0 = state[0];
            T0.high = state0.high, T0.low = state0.low;
            for (var x = 0; x < 5; x++) for (var y = 0; y < 5; y++) {
              var laneIndex = x + 5 * y,
                lane = state[laneIndex],
                TLane = T[laneIndex],
                Tx1Lane = T[(x + 1) % 5 + 5 * y],
                Tx2Lane = T[(x + 2) % 5 + 5 * y];
              lane.high = TLane.high ^ ~Tx1Lane.high & Tx2Lane.high, lane.low = TLane.low ^ ~Tx1Lane.low & Tx2Lane.low;
            }
            var lane = state[0],
              roundConstant = ROUND_CONSTANTS[round];
            lane.high ^= roundConstant.high, lane.low ^= roundConstant.low;
          }
        }, "_doProcessBlock"),
        _doFinalize: __name(function () {
          var data = this._data,
            dataWords = data.words,
            nBitsTotal = this._nDataBytes * 8,
            nBitsLeft = data.sigBytes * 8,
            blockSizeBits = this.blockSize * 32;
          dataWords[nBitsLeft >>> 5] |= 1 << 24 - nBitsLeft % 32, dataWords[(Math.ceil((nBitsLeft + 1) / blockSizeBits) * blockSizeBits >>> 5) - 1] |= 128, data.sigBytes = dataWords.length * 4, this._process();
          for (var state = this._state, outputLengthBytes = this.cfg.outputLength / 8, outputLengthLanes = outputLengthBytes / 8, hashWords = [], i = 0; i < outputLengthLanes; i++) {
            var lane = state[i],
              laneMsw = lane.high,
              laneLsw = lane.low;
            laneMsw = (laneMsw << 8 | laneMsw >>> 24) & 16711935 | (laneMsw << 24 | laneMsw >>> 8) & 4278255360, laneLsw = (laneLsw << 8 | laneLsw >>> 24) & 16711935 | (laneLsw << 24 | laneLsw >>> 8) & 4278255360, hashWords.push(laneLsw), hashWords.push(laneMsw);
          }
          return new WordArray.init(hashWords, outputLengthBytes);
        }, "_doFinalize"),
        clone: __name(function () {
          for (var clone = Hasher.clone.call(this), state = clone._state = this._state.slice(0), i = 0; i < 25; i++) state[i] = state[i].clone();
          return clone;
        }, "clone")
      });
      C.SHA3 = Hasher._createHelper(SHA3), C.HmacSHA3 = Hasher._createHmacHelper(SHA3);
    }(Math), CryptoJS.SHA3;
  });
});