var require_aes = __commonJSMin((exports, module) => {
  (function (root, factory, undef) {
    typeof exports == "object" ? module.exports = exports = factory(wi(), Ay(), uy(), dh(), Ps()) : typeof define == "function" && define.amd ? define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory) : factory(root.CryptoJS);
  })(exports, function (CryptoJS) {
    return function () {
      var C = CryptoJS,
        C_lib = C.lib,
        BlockCipher = C_lib.BlockCipher,
        C_algo = C.algo,
        SBOX = [],
        INV_SBOX = [],
        SUB_MIX_0 = [],
        SUB_MIX_1 = [],
        SUB_MIX_2 = [],
        SUB_MIX_3 = [],
        INV_SUB_MIX_0 = [],
        INV_SUB_MIX_1 = [],
        INV_SUB_MIX_2 = [],
        INV_SUB_MIX_3 = [];
      (function () {
        for (var d = [], i = 0; i < 256; i++) i < 128 ? d[i] = i << 1 : d[i] = i << 1 ^ 283;
        for (var x = 0, xi = 0, i = 0; i < 256; i++) {
          var sx = xi ^ xi << 1 ^ xi << 2 ^ xi << 3 ^ xi << 4;
          sx = sx >>> 8 ^ sx & 255 ^ 99, SBOX[x] = sx, INV_SBOX[sx] = x;
          var x2 = d[x],
            x4 = d[x2],
            x8 = d[x4],
            t = d[sx] * 257 ^ sx * 16843008;
          SUB_MIX_0[x] = t << 24 | t >>> 8, SUB_MIX_1[x] = t << 16 | t >>> 16, SUB_MIX_2[x] = t << 8 | t >>> 24, SUB_MIX_3[x] = t;
          var t = x8 * 16843009 ^ x4 * 65537 ^ x2 * 257 ^ x * 16843008;
          INV_SUB_MIX_0[sx] = t << 24 | t >>> 8, INV_SUB_MIX_1[sx] = t << 16 | t >>> 16, INV_SUB_MIX_2[sx] = t << 8 | t >>> 24, INV_SUB_MIX_3[sx] = t, x ? (x = x2 ^ d[d[d[x8 ^ x2]]], xi ^= d[d[xi]]) : x = xi = 1;
        }
      })();
      var RCON = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54],
        AES = C_algo.AES = BlockCipher.extend({
          _doReset: __name(function () {
            var t;
            if (!(this._nRounds && this._keyPriorReset === this._key)) {
              for (var key = this._keyPriorReset = this._key, keyWords = key.words, keySize = key.sigBytes / 4, nRounds = this._nRounds = keySize + 6, ksRows = (nRounds + 1) * 4, keySchedule = this._keySchedule = [], ksRow = 0; ksRow < ksRows; ksRow++) ksRow < keySize ? keySchedule[ksRow] = keyWords[ksRow] : (t = keySchedule[ksRow - 1], ksRow % keySize ? keySize > 6 && ksRow % keySize == 4 && (t = SBOX[t >>> 24] << 24 | SBOX[t >>> 16 & 255] << 16 | SBOX[t >>> 8 & 255] << 8 | SBOX[t & 255]) : (t = t << 8 | t >>> 24, t = SBOX[t >>> 24] << 24 | SBOX[t >>> 16 & 255] << 16 | SBOX[t >>> 8 & 255] << 8 | SBOX[t & 255], t ^= RCON[ksRow / keySize | 0] << 24), keySchedule[ksRow] = keySchedule[ksRow - keySize] ^ t);
              for (var invKeySchedule = this._invKeySchedule = [], invKsRow = 0; invKsRow < ksRows; invKsRow++) {
                var ksRow = ksRows - invKsRow;
                if (invKsRow % 4) var t = keySchedule[ksRow];else var t = keySchedule[ksRow - 4];
                invKsRow < 4 || ksRow <= 4 ? invKeySchedule[invKsRow] = t : invKeySchedule[invKsRow] = INV_SUB_MIX_0[SBOX[t >>> 24]] ^ INV_SUB_MIX_1[SBOX[t >>> 16 & 255]] ^ INV_SUB_MIX_2[SBOX[t >>> 8 & 255]] ^ INV_SUB_MIX_3[SBOX[t & 255]];
              }
            }
          }, "_doReset"),
          encryptBlock: __name(function (M, offset) {
            this._doCryptBlock(M, offset, this._keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX);
          }, "encryptBlock"),
          decryptBlock: __name(function (M, offset) {
            var t = M[offset + 1];
            M[offset + 1] = M[offset + 3], M[offset + 3] = t, this._doCryptBlock(M, offset, this._invKeySchedule, INV_SUB_MIX_0, INV_SUB_MIX_1, INV_SUB_MIX_2, INV_SUB_MIX_3, INV_SBOX);
            var t = M[offset + 1];
            M[offset + 1] = M[offset + 3], M[offset + 3] = t;
          }, "decryptBlock"),
          _doCryptBlock: __name(function (M, offset, keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX) {
            for (var nRounds = this._nRounds, s0 = M[offset] ^ keySchedule[0], s1 = M[offset + 1] ^ keySchedule[1], s2 = M[offset + 2] ^ keySchedule[2], s3 = M[offset + 3] ^ keySchedule[3], ksRow = 4, round = 1; round < nRounds; round++) {
              var t0 = SUB_MIX_0[s0 >>> 24] ^ SUB_MIX_1[s1 >>> 16 & 255] ^ SUB_MIX_2[s2 >>> 8 & 255] ^ SUB_MIX_3[s3 & 255] ^ keySchedule[ksRow++],
                t1 = SUB_MIX_0[s1 >>> 24] ^ SUB_MIX_1[s2 >>> 16 & 255] ^ SUB_MIX_2[s3 >>> 8 & 255] ^ SUB_MIX_3[s0 & 255] ^ keySchedule[ksRow++],
                t2 = SUB_MIX_0[s2 >>> 24] ^ SUB_MIX_1[s3 >>> 16 & 255] ^ SUB_MIX_2[s0 >>> 8 & 255] ^ SUB_MIX_3[s1 & 255] ^ keySchedule[ksRow++],
                t3 = SUB_MIX_0[s3 >>> 24] ^ SUB_MIX_1[s0 >>> 16 & 255] ^ SUB_MIX_2[s1 >>> 8 & 255] ^ SUB_MIX_3[s2 & 255] ^ keySchedule[ksRow++];
              s0 = t0, s1 = t1, s2 = t2, s3 = t3;
            }
            var t0 = (SBOX[s0 >>> 24] << 24 | SBOX[s1 >>> 16 & 255] << 16 | SBOX[s2 >>> 8 & 255] << 8 | SBOX[s3 & 255]) ^ keySchedule[ksRow++],
              t1 = (SBOX[s1 >>> 24] << 24 | SBOX[s2 >>> 16 & 255] << 16 | SBOX[s3 >>> 8 & 255] << 8 | SBOX[s0 & 255]) ^ keySchedule[ksRow++],
              t2 = (SBOX[s2 >>> 24] << 24 | SBOX[s3 >>> 16 & 255] << 16 | SBOX[s0 >>> 8 & 255] << 8 | SBOX[s1 & 255]) ^ keySchedule[ksRow++],
              t3 = (SBOX[s3 >>> 24] << 24 | SBOX[s0 >>> 16 & 255] << 16 | SBOX[s1 >>> 8 & 255] << 8 | SBOX[s2 & 255]) ^ keySchedule[ksRow++];
            M[offset] = t0, M[offset + 1] = t1, M[offset + 2] = t2, M[offset + 3] = t3;
          }, "_doCryptBlock"),
          keySize: 256 / 32
        });
      C.AES = BlockCipher._createHelper(AES);
    }(), CryptoJS.AES;
  });
});