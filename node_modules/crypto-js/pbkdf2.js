var require_pbkdf2 = __commonJSMin((exports, module) => {
  (function (root, factory, undef) {
    typeof exports == "object" ? module.exports = exports = factory(wi(), oT(), pT()) : typeof define == "function" && define.amd ? define(["./core", "./sha256", "./hmac"], factory) : factory(root.CryptoJS);
  })(exports, function (CryptoJS) {
    return function () {
      var C = CryptoJS,
        C_lib = C.lib,
        Base = C_lib.Base,
        WordArray = C_lib.WordArray,
        C_algo = C.algo,
        SHA256 = C_algo.SHA256,
        HMAC = C_algo.HMAC,
        PBKDF2 = C_algo.PBKDF2 = Base.extend({
          cfg: Base.extend({
            keySize: 128 / 32,
            hasher: SHA256,
            iterations: 25e4
          }),
          init: __name(function (cfg) {
            this.cfg = this.cfg.extend(cfg);
          }, "init"),
          compute: __name(function (password, salt) {
            for (var cfg = this.cfg, hmac = HMAC.create(cfg.hasher, password), derivedKey = WordArray.create(), blockIndex = WordArray.create([1]), derivedKeyWords = derivedKey.words, blockIndexWords = blockIndex.words, keySize = cfg.keySize, iterations = cfg.iterations; derivedKeyWords.length < keySize;) {
              var block = hmac.update(salt).finalize(blockIndex);
              hmac.reset();
              for (var blockWords = block.words, blockWordsLength = blockWords.length, intermediate = block, i = 1; i < iterations; i++) {
                intermediate = hmac.finalize(intermediate), hmac.reset();
                for (var intermediateWords = intermediate.words, j = 0; j < blockWordsLength; j++) blockWords[j] ^= intermediateWords[j];
              }
              derivedKey.concat(block), blockIndexWords[0]++;
            }
            return derivedKey.sigBytes = keySize * 4, derivedKey;
          }, "compute")
        });
      C.PBKDF2 = function (password, salt, cfg) {
        return PBKDF2.create(cfg).compute(password, salt);
      };
    }(), CryptoJS.PBKDF2;
  });
});