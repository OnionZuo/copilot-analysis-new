var require_enc_base64url = __commonJSMin((exports, module) => {
  (function (root, factory) {
    typeof exports == "object" ? module.exports = exports = factory(wi()) : typeof define == "function" && define.amd ? define(["./core"], factory) : factory(root.CryptoJS);
  })(exports, function (CryptoJS) {
    return function () {
      var C = CryptoJS,
        C_lib = C.lib,
        WordArray = C_lib.WordArray,
        C_enc = C.enc,
        Base64url = C_enc.Base64url = {
          stringify: __name(function (wordArray, urlSafe) {
            urlSafe === void 0 && (urlSafe = !0);
            var words = wordArray.words,
              sigBytes = wordArray.sigBytes,
              map = urlSafe ? this._safe_map : this._map;
            wordArray.clamp();
            for (var base64Chars = [], i = 0; i < sigBytes; i += 3) for (var byte1 = words[i >>> 2] >>> 24 - i % 4 * 8 & 255, byte2 = words[i + 1 >>> 2] >>> 24 - (i + 1) % 4 * 8 & 255, byte3 = words[i + 2 >>> 2] >>> 24 - (i + 2) % 4 * 8 & 255, triplet = byte1 << 16 | byte2 << 8 | byte3, j = 0; j < 4 && i + j * .75 < sigBytes; j++) base64Chars.push(map.charAt(triplet >>> 6 * (3 - j) & 63));
            var paddingChar = map.charAt(64);
            if (paddingChar) for (; base64Chars.length % 4;) base64Chars.push(paddingChar);
            return base64Chars.join("");
          }, "stringify"),
          parse: __name(function (base64Str, urlSafe) {
            urlSafe === void 0 && (urlSafe = !0);
            var base64StrLength = base64Str.length,
              map = urlSafe ? this._safe_map : this._map,
              reverseMap = this._reverseMap;
            if (!reverseMap) {
              reverseMap = this._reverseMap = [];
              for (var j = 0; j < map.length; j++) reverseMap[map.charCodeAt(j)] = j;
            }
            var paddingChar = map.charAt(64);
            if (paddingChar) {
              var paddingIndex = base64Str.indexOf(paddingChar);
              paddingIndex !== -1 && (base64StrLength = paddingIndex);
            }
            return parseLoop(base64Str, base64StrLength, reverseMap);
          }, "parse"),
          _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
          _safe_map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"
        };
      function parseLoop(base64Str, base64StrLength, reverseMap) {
        for (var words = [], nBytes = 0, i = 0; i < base64StrLength; i++) if (i % 4) {
          var bits1 = reverseMap[base64Str.charCodeAt(i - 1)] << i % 4 * 2,
            bits2 = reverseMap[base64Str.charCodeAt(i)] >>> 6 - i % 4 * 2,
            bitsCombined = bits1 | bits2;
          words[nBytes >>> 2] |= bitsCombined << 24 - nBytes % 4 * 8, nBytes++;
        }
        return WordArray.create(words, nBytes);
      }
      __name(parseLoop, "parseLoop");
    }(), CryptoJS.enc.Base64url;
  });
});