var require_mode_cfb = __commonJSMin((exports, module) => {
  (function (root, factory, undef) {
    typeof exports == "object" ? module.exports = exports = factory(wi(), Ps()) : typeof define == "function" && define.amd ? define(["./core", "./cipher-core"], factory) : factory(root.CryptoJS);
  })(exports, function (CryptoJS) {
    return CryptoJS.mode.CFB = function () {
      var CFB = CryptoJS.lib.BlockCipherMode.extend();
      CFB.Encryptor = CFB.extend({
        processBlock: __name(function (words, offset) {
          var cipher = this._cipher,
            blockSize = cipher.blockSize;
          generateKeystreamAndEncrypt.call(this, words, offset, blockSize, cipher), this._prevBlock = words.slice(offset, offset + blockSize);
        }, "processBlock")
      }), CFB.Decryptor = CFB.extend({
        processBlock: __name(function (words, offset) {
          var cipher = this._cipher,
            blockSize = cipher.blockSize,
            thisBlock = words.slice(offset, offset + blockSize);
          generateKeystreamAndEncrypt.call(this, words, offset, blockSize, cipher), this._prevBlock = thisBlock;
        }, "processBlock")
      });
      function generateKeystreamAndEncrypt(words, offset, blockSize, cipher) {
        var keystream,
          iv = this._iv;
        iv ? (keystream = iv.slice(0), this._iv = void 0) : keystream = this._prevBlock, cipher.encryptBlock(keystream, 0);
        for (var i = 0; i < blockSize; i++) words[offset + i] ^= keystream[i];
      }
      return __name(generateKeystreamAndEncrypt, "generateKeystreamAndEncrypt"), CFB;
    }(), CryptoJS.mode.CFB;
  });
});