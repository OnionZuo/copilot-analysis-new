var require_mode_ctr_gladman = __commonJSMin((exports, module) => {
  (function (root, factory, undef) {
    typeof exports == "object" ? module.exports = exports = factory(wi(), Ps()) : typeof define == "function" && define.amd ? define(["./core", "./cipher-core"], factory) : factory(root.CryptoJS);
  })(exports, function (CryptoJS) {
    return CryptoJS.mode.CTRGladman = function () {
      var CTRGladman = CryptoJS.lib.BlockCipherMode.extend();
      function incWord(word) {
        if ((word >> 24 & 255) === 255) {
          var b1 = word >> 16 & 255,
            b2 = word >> 8 & 255,
            b3 = word & 255;
          b1 === 255 ? (b1 = 0, b2 === 255 ? (b2 = 0, b3 === 255 ? b3 = 0 : ++b3) : ++b2) : ++b1, word = 0, word += b1 << 16, word += b2 << 8, word += b3;
        } else word += 1 << 24;
        return word;
      }
      __name(incWord, "incWord");
      function incCounter(counter) {
        return (counter[0] = incWord(counter[0])) === 0 && (counter[1] = incWord(counter[1])), counter;
      }
      __name(incCounter, "incCounter");
      var Encryptor = CTRGladman.Encryptor = CTRGladman.extend({
        processBlock: __name(function (words, offset) {
          var cipher = this._cipher,
            blockSize = cipher.blockSize,
            iv = this._iv,
            counter = this._counter;
          iv && (counter = this._counter = iv.slice(0), this._iv = void 0), incCounter(counter);
          var keystream = counter.slice(0);
          cipher.encryptBlock(keystream, 0);
          for (var i = 0; i < blockSize; i++) words[offset + i] ^= keystream[i];
        }, "processBlock")
      });
      return CTRGladman.Decryptor = Encryptor, CTRGladman;
    }(), CryptoJS.mode.CTRGladman;
  });
});