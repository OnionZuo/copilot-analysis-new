var require_core = __commonJSMin((exports, module) => {
  (function (root, factory) {
    typeof exports == "object" ? module.exports = exports = factory() : typeof define == "function" && define.amd ? define([], factory) : root.CryptoJS = factory();
  })(exports, function () {
    var CryptoJS = CryptoJS || function (Math, undefined) {
      var crypto;
      if (typeof window < "u" && window.crypto && (crypto = window.crypto), typeof self < "u" && self.crypto && (crypto = self.crypto), typeof globalThis < "u" && globalThis.crypto && (crypto = globalThis.crypto), !crypto && typeof window < "u" && window.msCrypto && (crypto = window.msCrypto), !crypto && typeof global < "u" && global.crypto && (crypto = global.crypto), !crypto && typeof require == "function") try {
        crypto = require("crypto");
      } catch {}
      var cryptoSecureRandomInt = __name(function () {
          if (crypto) {
            if (typeof crypto.getRandomValues == "function") try {
              return crypto.getRandomValues(new Uint32Array(1))[0];
            } catch {}
            if (typeof crypto.randomBytes == "function") try {
              return crypto.randomBytes(4).readInt32LE();
            } catch {}
          }
          throw new Error("Native crypto module could not be used to get secure random number.");
        }, "cryptoSecureRandomInt"),
        create = Object.create || function () {
          function F() {}
          return __name(F, "F"), function (obj) {
            var subtype;
            return F.prototype = obj, subtype = new F(), F.prototype = null, subtype;
          };
        }(),
        C = {},
        C_lib = C.lib = {},
        Base = C_lib.Base = function () {
          return {
            extend: __name(function (overrides) {
              var subtype = create(this);
              return overrides && subtype.mixIn(overrides), (!subtype.hasOwnProperty("init") || this.init === subtype.init) && (subtype.init = function () {
                subtype.$super.init.apply(this, arguments);
              }), subtype.init.prototype = subtype, subtype.$super = this, subtype;
            }, "extend"),
            create: __name(function () {
              var instance = this.extend();
              return instance.init.apply(instance, arguments), instance;
            }, "create"),
            init: __name(function () {}, "init"),
            mixIn: __name(function (properties) {
              for (var propertyName in properties) properties.hasOwnProperty(propertyName) && (this[propertyName] = properties[propertyName]);
              properties.hasOwnProperty("toString") && (this.toString = properties.toString);
            }, "mixIn"),
            clone: __name(function () {
              return this.init.prototype.extend(this);
            }, "clone")
          };
        }(),
        WordArray = C_lib.WordArray = Base.extend({
          init: __name(function (words, sigBytes) {
            words = this.words = words || [], sigBytes != undefined ? this.sigBytes = sigBytes : this.sigBytes = words.length * 4;
          }, "init"),
          toString: __name(function (encoder) {
            return (encoder || Hex).stringify(this);
          }, "toString"),
          concat: __name(function (wordArray) {
            var thisWords = this.words,
              thatWords = wordArray.words,
              thisSigBytes = this.sigBytes,
              thatSigBytes = wordArray.sigBytes;
            if (this.clamp(), thisSigBytes % 4) for (var i = 0; i < thatSigBytes; i++) {
              var thatByte = thatWords[i >>> 2] >>> 24 - i % 4 * 8 & 255;
              thisWords[thisSigBytes + i >>> 2] |= thatByte << 24 - (thisSigBytes + i) % 4 * 8;
            } else for (var j = 0; j < thatSigBytes; j += 4) thisWords[thisSigBytes + j >>> 2] = thatWords[j >>> 2];
            return this.sigBytes += thatSigBytes, this;
          }, "concat"),
          clamp: __name(function () {
            var words = this.words,
              sigBytes = this.sigBytes;
            words[sigBytes >>> 2] &= 4294967295 << 32 - sigBytes % 4 * 8, words.length = Math.ceil(sigBytes / 4);
          }, "clamp"),
          clone: __name(function () {
            var clone = Base.clone.call(this);
            return clone.words = this.words.slice(0), clone;
          }, "clone"),
          random: __name(function (nBytes) {
            for (var words = [], i = 0; i < nBytes; i += 4) words.push(cryptoSecureRandomInt());
            return new WordArray.init(words, nBytes);
          }, "random")
        }),
        C_enc = C.enc = {},
        Hex = C_enc.Hex = {
          stringify: __name(function (wordArray) {
            for (var words = wordArray.words, sigBytes = wordArray.sigBytes, hexChars = [], i = 0; i < sigBytes; i++) {
              var bite = words[i >>> 2] >>> 24 - i % 4 * 8 & 255;
              hexChars.push((bite >>> 4).toString(16)), hexChars.push((bite & 15).toString(16));
            }
            return hexChars.join("");
          }, "stringify"),
          parse: __name(function (hexStr) {
            for (var hexStrLength = hexStr.length, words = [], i = 0; i < hexStrLength; i += 2) words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << 24 - i % 8 * 4;
            return new WordArray.init(words, hexStrLength / 2);
          }, "parse")
        },
        Latin1 = C_enc.Latin1 = {
          stringify: __name(function (wordArray) {
            for (var words = wordArray.words, sigBytes = wordArray.sigBytes, latin1Chars = [], i = 0; i < sigBytes; i++) {
              var bite = words[i >>> 2] >>> 24 - i % 4 * 8 & 255;
              latin1Chars.push(String.fromCharCode(bite));
            }
            return latin1Chars.join("");
          }, "stringify"),
          parse: __name(function (latin1Str) {
            for (var latin1StrLength = latin1Str.length, words = [], i = 0; i < latin1StrLength; i++) words[i >>> 2] |= (latin1Str.charCodeAt(i) & 255) << 24 - i % 4 * 8;
            return new WordArray.init(words, latin1StrLength);
          }, "parse")
        },
        Utf8 = C_enc.Utf8 = {
          stringify: __name(function (wordArray) {
            try {
              return decodeURIComponent(escape(Latin1.stringify(wordArray)));
            } catch {
              throw new Error("Malformed UTF-8 data");
            }
          }, "stringify"),
          parse: __name(function (utf8Str) {
            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
          }, "parse")
        },
        BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({
          reset: __name(function () {
            this._data = new WordArray.init(), this._nDataBytes = 0;
          }, "reset"),
          _append: __name(function (data) {
            typeof data == "string" && (data = Utf8.parse(data)), this._data.concat(data), this._nDataBytes += data.sigBytes;
          }, "_append"),
          _process: __name(function (doFlush) {
            var processedWords,
              data = this._data,
              dataWords = data.words,
              dataSigBytes = data.sigBytes,
              blockSize = this.blockSize,
              blockSizeBytes = blockSize * 4,
              nBlocksReady = dataSigBytes / blockSizeBytes;
            doFlush ? nBlocksReady = Math.ceil(nBlocksReady) : nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);
            var nWordsReady = nBlocksReady * blockSize,
              nBytesReady = Math.min(nWordsReady * 4, dataSigBytes);
            if (nWordsReady) {
              for (var offset = 0; offset < nWordsReady; offset += blockSize) this._doProcessBlock(dataWords, offset);
              processedWords = dataWords.splice(0, nWordsReady), data.sigBytes -= nBytesReady;
            }
            return new WordArray.init(processedWords, nBytesReady);
          }, "_process"),
          clone: __name(function () {
            var clone = Base.clone.call(this);
            return clone._data = this._data.clone(), clone;
          }, "clone"),
          _minBufferSize: 0
        }),
        Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({
          cfg: Base.extend(),
          init: __name(function (cfg) {
            this.cfg = this.cfg.extend(cfg), this.reset();
          }, "init"),
          reset: __name(function () {
            BufferedBlockAlgorithm.reset.call(this), this._doReset();
          }, "reset"),
          update: __name(function (messageUpdate) {
            return this._append(messageUpdate), this._process(), this;
          }, "update"),
          finalize: __name(function (messageUpdate) {
            messageUpdate && this._append(messageUpdate);
            var hash = this._doFinalize();
            return hash;
          }, "finalize"),
          blockSize: 512 / 32,
          _createHelper: __name(function (hasher) {
            return function (message, cfg) {
              return new hasher.init(cfg).finalize(message);
            };
          }, "_createHelper"),
          _createHmacHelper: __name(function (hasher) {
            return function (message, key) {
              return new C_algo.HMAC.init(hasher, key).finalize(message);
            };
          }, "_createHmacHelper")
        }),
        C_algo = C.algo = {};
      return C;
    }(Math);
    return CryptoJS;
  });
});