var require_cipher_core = __commonJSMin((exports, module) => {
  (function (root, factory, undef) {
    typeof exports == "object" ? module.exports = exports = factory(wi(), dh()) : typeof define == "function" && define.amd ? define(["./core", "./evpkdf"], factory) : factory(root.CryptoJS);
  })(exports, function (CryptoJS) {
    CryptoJS.lib.Cipher || function (undefined) {
      var C = CryptoJS,
        C_lib = C.lib,
        Base = C_lib.Base,
        WordArray = C_lib.WordArray,
        BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm,
        C_enc = C.enc,
        Utf8 = C_enc.Utf8,
        Base64 = C_enc.Base64,
        C_algo = C.algo,
        EvpKDF = C_algo.EvpKDF,
        Cipher = C_lib.Cipher = BufferedBlockAlgorithm.extend({
          cfg: Base.extend(),
          createEncryptor: __name(function (key, cfg) {
            return this.create(this._ENC_XFORM_MODE, key, cfg);
          }, "createEncryptor"),
          createDecryptor: __name(function (key, cfg) {
            return this.create(this._DEC_XFORM_MODE, key, cfg);
          }, "createDecryptor"),
          init: __name(function (xformMode, key, cfg) {
            this.cfg = this.cfg.extend(cfg), this._xformMode = xformMode, this._key = key, this.reset();
          }, "init"),
          reset: __name(function () {
            BufferedBlockAlgorithm.reset.call(this), this._doReset();
          }, "reset"),
          process: __name(function (dataUpdate) {
            return this._append(dataUpdate), this._process();
          }, "process"),
          finalize: __name(function (dataUpdate) {
            dataUpdate && this._append(dataUpdate);
            var finalProcessedData = this._doFinalize();
            return finalProcessedData;
          }, "finalize"),
          keySize: 128 / 32,
          ivSize: 128 / 32,
          _ENC_XFORM_MODE: 1,
          _DEC_XFORM_MODE: 2,
          _createHelper: function () {
            function selectCipherStrategy(key) {
              return typeof key == "string" ? PasswordBasedCipher : SerializableCipher;
            }
            return __name(selectCipherStrategy, "selectCipherStrategy"), function (cipher) {
              return {
                encrypt: __name(function (message, key, cfg) {
                  return selectCipherStrategy(key).encrypt(cipher, message, key, cfg);
                }, "encrypt"),
                decrypt: __name(function (ciphertext, key, cfg) {
                  return selectCipherStrategy(key).decrypt(cipher, ciphertext, key, cfg);
                }, "decrypt")
              };
            };
          }()
        }),
        StreamCipher = C_lib.StreamCipher = Cipher.extend({
          _doFinalize: __name(function () {
            var finalProcessedBlocks = this._process(!0);
            return finalProcessedBlocks;
          }, "_doFinalize"),
          blockSize: 1
        }),
        C_mode = C.mode = {},
        BlockCipherMode = C_lib.BlockCipherMode = Base.extend({
          createEncryptor: __name(function (cipher, iv) {
            return this.Encryptor.create(cipher, iv);
          }, "createEncryptor"),
          createDecryptor: __name(function (cipher, iv) {
            return this.Decryptor.create(cipher, iv);
          }, "createDecryptor"),
          init: __name(function (cipher, iv) {
            this._cipher = cipher, this._iv = iv;
          }, "init")
        }),
        CBC = C_mode.CBC = function () {
          var CBC = BlockCipherMode.extend();
          CBC.Encryptor = CBC.extend({
            processBlock: __name(function (words, offset) {
              var cipher = this._cipher,
                blockSize = cipher.blockSize;
              xorBlock.call(this, words, offset, blockSize), cipher.encryptBlock(words, offset), this._prevBlock = words.slice(offset, offset + blockSize);
            }, "processBlock")
          }), CBC.Decryptor = CBC.extend({
            processBlock: __name(function (words, offset) {
              var cipher = this._cipher,
                blockSize = cipher.blockSize,
                thisBlock = words.slice(offset, offset + blockSize);
              cipher.decryptBlock(words, offset), xorBlock.call(this, words, offset, blockSize), this._prevBlock = thisBlock;
            }, "processBlock")
          });
          function xorBlock(words, offset, blockSize) {
            var block,
              iv = this._iv;
            iv ? (block = iv, this._iv = undefined) : block = this._prevBlock;
            for (var i = 0; i < blockSize; i++) words[offset + i] ^= block[i];
          }
          return __name(xorBlock, "xorBlock"), CBC;
        }(),
        C_pad = C.pad = {},
        Pkcs7 = C_pad.Pkcs7 = {
          pad: __name(function (data, blockSize) {
            for (var blockSizeBytes = blockSize * 4, nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes, paddingWord = nPaddingBytes << 24 | nPaddingBytes << 16 | nPaddingBytes << 8 | nPaddingBytes, paddingWords = [], i = 0; i < nPaddingBytes; i += 4) paddingWords.push(paddingWord);
            var padding = WordArray.create(paddingWords, nPaddingBytes);
            data.concat(padding);
          }, "pad"),
          unpad: __name(function (data) {
            var nPaddingBytes = data.words[data.sigBytes - 1 >>> 2] & 255;
            data.sigBytes -= nPaddingBytes;
          }, "unpad")
        },
        BlockCipher = C_lib.BlockCipher = Cipher.extend({
          cfg: Cipher.cfg.extend({
            mode: CBC,
            padding: Pkcs7
          }),
          reset: __name(function () {
            var modeCreator;
            Cipher.reset.call(this);
            var cfg = this.cfg,
              iv = cfg.iv,
              mode = cfg.mode;
            this._xformMode == this._ENC_XFORM_MODE ? modeCreator = mode.createEncryptor : (modeCreator = mode.createDecryptor, this._minBufferSize = 1), this._mode && this._mode.__creator == modeCreator ? this._mode.init(this, iv && iv.words) : (this._mode = modeCreator.call(mode, this, iv && iv.words), this._mode.__creator = modeCreator);
          }, "reset"),
          _doProcessBlock: __name(function (words, offset) {
            this._mode.processBlock(words, offset);
          }, "_doProcessBlock"),
          _doFinalize: __name(function () {
            var finalProcessedBlocks,
              padding = this.cfg.padding;
            return this._xformMode == this._ENC_XFORM_MODE ? (padding.pad(this._data, this.blockSize), finalProcessedBlocks = this._process(!0)) : (finalProcessedBlocks = this._process(!0), padding.unpad(finalProcessedBlocks)), finalProcessedBlocks;
          }, "_doFinalize"),
          blockSize: 128 / 32
        }),
        CipherParams = C_lib.CipherParams = Base.extend({
          init: __name(function (cipherParams) {
            this.mixIn(cipherParams);
          }, "init"),
          toString: __name(function (formatter) {
            return (formatter || this.formatter).stringify(this);
          }, "toString")
        }),
        C_format = C.format = {},
        OpenSSLFormatter = C_format.OpenSSL = {
          stringify: __name(function (cipherParams) {
            var wordArray,
              ciphertext = cipherParams.ciphertext,
              salt = cipherParams.salt;
            return salt ? wordArray = WordArray.create([1398893684, 1701076831]).concat(salt).concat(ciphertext) : wordArray = ciphertext, wordArray.toString(Base64);
          }, "stringify"),
          parse: __name(function (openSSLStr) {
            var salt,
              ciphertext = Base64.parse(openSSLStr),
              ciphertextWords = ciphertext.words;
            return ciphertextWords[0] == 1398893684 && ciphertextWords[1] == 1701076831 && (salt = WordArray.create(ciphertextWords.slice(2, 4)), ciphertextWords.splice(0, 4), ciphertext.sigBytes -= 16), CipherParams.create({
              ciphertext: ciphertext,
              salt: salt
            });
          }, "parse")
        },
        SerializableCipher = C_lib.SerializableCipher = Base.extend({
          cfg: Base.extend({
            format: OpenSSLFormatter
          }),
          encrypt: __name(function (cipher, message, key, cfg) {
            cfg = this.cfg.extend(cfg);
            var encryptor = cipher.createEncryptor(key, cfg),
              ciphertext = encryptor.finalize(message),
              cipherCfg = encryptor.cfg;
            return CipherParams.create({
              ciphertext: ciphertext,
              key: key,
              iv: cipherCfg.iv,
              algorithm: cipher,
              mode: cipherCfg.mode,
              padding: cipherCfg.padding,
              blockSize: cipher.blockSize,
              formatter: cfg.format
            });
          }, "encrypt"),
          decrypt: __name(function (cipher, ciphertext, key, cfg) {
            cfg = this.cfg.extend(cfg), ciphertext = this._parse(ciphertext, cfg.format);
            var plaintext = cipher.createDecryptor(key, cfg).finalize(ciphertext.ciphertext);
            return plaintext;
          }, "decrypt"),
          _parse: __name(function (ciphertext, format) {
            return typeof ciphertext == "string" ? format.parse(ciphertext, this) : ciphertext;
          }, "_parse")
        }),
        C_kdf = C.kdf = {},
        OpenSSLKdf = C_kdf.OpenSSL = {
          execute: __name(function (password, keySize, ivSize, salt, hasher) {
            if (salt || (salt = WordArray.random(64 / 8)), hasher) var key = EvpKDF.create({
              keySize: keySize + ivSize,
              hasher: hasher
            }).compute(password, salt);else var key = EvpKDF.create({
              keySize: keySize + ivSize
            }).compute(password, salt);
            var iv = WordArray.create(key.words.slice(keySize), ivSize * 4);
            return key.sigBytes = keySize * 4, CipherParams.create({
              key: key,
              iv: iv,
              salt: salt
            });
          }, "execute")
        },
        PasswordBasedCipher = C_lib.PasswordBasedCipher = SerializableCipher.extend({
          cfg: SerializableCipher.cfg.extend({
            kdf: OpenSSLKdf
          }),
          encrypt: __name(function (cipher, message, password, cfg) {
            cfg = this.cfg.extend(cfg);
            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize, cfg.salt, cfg.hasher);
            cfg.iv = derivedParams.iv;
            var ciphertext = SerializableCipher.encrypt.call(this, cipher, message, derivedParams.key, cfg);
            return ciphertext.mixIn(derivedParams), ciphertext;
          }, "encrypt"),
          decrypt: __name(function (cipher, ciphertext, password, cfg) {
            cfg = this.cfg.extend(cfg), ciphertext = this._parse(ciphertext, cfg.format);
            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize, ciphertext.salt, cfg.hasher);
            cfg.iv = derivedParams.iv;
            var plaintext = SerializableCipher.decrypt.call(this, cipher, ciphertext, derivedParams.key, cfg);
            return plaintext;
          }, "decrypt")
        });
    }();
  });
});