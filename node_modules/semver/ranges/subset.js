var require_subset = __commonJSMin((exports, module) => {
  var Range = Bp(),
    Comparator = u8(),
    {
      ANY: ANY
    } = Comparator,
    satisfies = ZQ(),
    compare = Ep(),
    subset = __name((sub, dom, options = {}) => {
      if (sub === dom) return !0;
      sub = new Range(sub, options), dom = new Range(dom, options);
      let sawNonNull = !1;
      OUTER: for (let simpleSub of sub.set) {
        for (let simpleDom of dom.set) {
          let isSub = simpleSubset(simpleSub, simpleDom, options);
          if (sawNonNull = sawNonNull || isSub !== null, isSub) continue OUTER;
        }
        if (sawNonNull) return !1;
      }
      return !0;
    }, "subset"),
    minimumVersionWithPreRelease = [new Comparator(">=0.0.0-0")],
    minimumVersion = [new Comparator(">=0.0.0")],
    simpleSubset = __name((sub, dom, options) => {
      if (sub === dom) return !0;
      if (sub.length === 1 && sub[0].semver === ANY) {
        if (dom.length === 1 && dom[0].semver === ANY) return !0;
        options.includePrerelease ? sub = minimumVersionWithPreRelease : sub = minimumVersion;
      }
      if (dom.length === 1 && dom[0].semver === ANY) {
        if (options.includePrerelease) return !0;
        dom = minimumVersion;
      }
      let eqSet = new Set(),
        gt,
        lt;
      for (let c of sub) c.operator === ">" || c.operator === ">=" ? gt = higherGT(gt, c, options) : c.operator === "<" || c.operator === "<=" ? lt = lowerLT(lt, c, options) : eqSet.add(c.semver);
      if (eqSet.size > 1) return null;
      let gtltComp;
      if (gt && lt) {
        if (gtltComp = compare(gt.semver, lt.semver, options), gtltComp > 0) return null;
        if (gtltComp === 0 && (gt.operator !== ">=" || lt.operator !== "<=")) return null;
      }
      for (let eq of eqSet) {
        if (gt && !satisfies(eq, String(gt), options) || lt && !satisfies(eq, String(lt), options)) return null;
        for (let c of dom) if (!satisfies(eq, String(c), options)) return !1;
        return !0;
      }
      let higher,
        lower,
        hasDomLT,
        hasDomGT,
        needDomLTPre = lt && !options.includePrerelease && lt.semver.prerelease.length ? lt.semver : !1,
        needDomGTPre = gt && !options.includePrerelease && gt.semver.prerelease.length ? gt.semver : !1;
      needDomLTPre && needDomLTPre.prerelease.length === 1 && lt.operator === "<" && needDomLTPre.prerelease[0] === 0 && (needDomLTPre = !1);
      for (let c of dom) {
        if (hasDomGT = hasDomGT || c.operator === ">" || c.operator === ">=", hasDomLT = hasDomLT || c.operator === "<" || c.operator === "<=", gt) {
          if (needDomGTPre && c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomGTPre.major && c.semver.minor === needDomGTPre.minor && c.semver.patch === needDomGTPre.patch && (needDomGTPre = !1), c.operator === ">" || c.operator === ">=") {
            if (higher = higherGT(gt, c, options), higher === c && higher !== gt) return !1;
          } else if (gt.operator === ">=" && !satisfies(gt.semver, String(c), options)) return !1;
        }
        if (lt) {
          if (needDomLTPre && c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomLTPre.major && c.semver.minor === needDomLTPre.minor && c.semver.patch === needDomLTPre.patch && (needDomLTPre = !1), c.operator === "<" || c.operator === "<=") {
            if (lower = lowerLT(lt, c, options), lower === c && lower !== lt) return !1;
          } else if (lt.operator === "<=" && !satisfies(lt.semver, String(c), options)) return !1;
        }
        if (!c.operator && (lt || gt) && gtltComp !== 0) return !1;
      }
      return !(gt && hasDomLT && !lt && gtltComp !== 0 || lt && hasDomGT && !gt && gtltComp !== 0 || needDomGTPre || needDomLTPre);
    }, "simpleSubset"),
    higherGT = __name((a, b, options) => {
      if (!a) return b;
      let comp = compare(a.semver, b.semver, options);
      return comp > 0 ? a : comp < 0 || b.operator === ">" && a.operator === ">=" ? b : a;
    }, "higherGT"),
    lowerLT = __name((a, b, options) => {
      if (!a) return b;
      let comp = compare(a.semver, b.semver, options);
      return comp < 0 ? a : comp > 0 || b.operator === "<" && a.operator === "<=" ? b : a;
    }, "lowerLT");
  module.exports = subset;
});