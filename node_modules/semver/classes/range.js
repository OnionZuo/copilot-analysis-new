var require_range = __commonJSMin((exports, module) => {
  var SPACE_CHARACTERS = /\s+/g,
    _Range = class _Range {
      constructor(range, options) {
        if (options = parseOptions(options), range instanceof _Range) return range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease ? range : new _Range(range.raw, options);
        if (range instanceof Comparator) return this.raw = range.value, this.set = [[range]], this.formatted = void 0, this;
        if (this.options = options, this.loose = !!options.loose, this.includePrerelease = !!options.includePrerelease, this.raw = range.trim().replace(SPACE_CHARACTERS, " "), this.set = this.raw.split("||").map(r => this.parseRange(r.trim())).filter(c => c.length), !this.set.length) throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
        if (this.set.length > 1) {
          let first = this.set[0];
          if (this.set = this.set.filter(c => !isNullSet(c[0])), this.set.length === 0) this.set = [first];else if (this.set.length > 1) {
            for (let c of this.set) if (c.length === 1 && isAny(c[0])) {
              this.set = [c];
              break;
            }
          }
        }
        this.formatted = void 0;
      }
      get range() {
        if (this.formatted === void 0) {
          this.formatted = "";
          for (let i = 0; i < this.set.length; i++) {
            i > 0 && (this.formatted += "||");
            let comps = this.set[i];
            for (let k = 0; k < comps.length; k++) k > 0 && (this.formatted += " "), this.formatted += comps[k].toString().trim();
          }
        }
        return this.formatted;
      }
      format() {
        return this.range;
      }
      toString() {
        return this.range;
      }
      parseRange(range) {
        let memoKey = ((this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) | (this.options.loose && FLAG_LOOSE)) + ":" + range,
          cached = cache.get(memoKey);
        if (cached) return cached;
        let loose = this.options.loose,
          hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];
        range = range.replace(hr, hyphenReplace(this.options.includePrerelease)), debug("hyphen replace", range), range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace), debug("comparator trim", range), range = range.replace(re[t.TILDETRIM], tildeTrimReplace), debug("tilde trim", range), range = range.replace(re[t.CARETTRIM], caretTrimReplace), debug("caret trim", range);
        let rangeList = range.split(" ").map(comp => parseComparator(comp, this.options)).join(" ").split(/\s+/).map(comp => replaceGTE0(comp, this.options));
        loose && (rangeList = rangeList.filter(comp => (debug("loose invalid filter", comp, this.options), !!comp.match(re[t.COMPARATORLOOSE])))), debug("range list", rangeList);
        let rangeMap = new Map(),
          comparators = rangeList.map(comp => new Comparator(comp, this.options));
        for (let comp of comparators) {
          if (isNullSet(comp)) return [comp];
          rangeMap.set(comp.value, comp);
        }
        rangeMap.size > 1 && rangeMap.has("") && rangeMap.delete("");
        let result = [...rangeMap.values()];
        return cache.set(memoKey, result), result;
      }
      intersects(range, options) {
        if (!(range instanceof _Range)) throw new TypeError("a Range is required");
        return this.set.some(thisComparators => isSatisfiable(thisComparators, options) && range.set.some(rangeComparators => isSatisfiable(rangeComparators, options) && thisComparators.every(thisComparator => rangeComparators.every(rangeComparator => thisComparator.intersects(rangeComparator, options)))));
      }
      test(version) {
        if (!version) return !1;
        if (typeof version == "string") try {
          version = new SemVer(version, this.options);
        } catch {
          return !1;
        }
        for (let i = 0; i < this.set.length; i++) if (testSet(this.set[i], version, this.options)) return !0;
        return !1;
      }
    };
  __name(_Range, "Range");
  var Range = _Range;
  module.exports = Range;
  var LRU = NOe(),
    cache = new LRU(),
    parseOptions = tj(),
    Comparator = u8(),
    debug = o8(),
    SemVer = Fl(),
    {
      safeRe: re,
      t: t,
      comparatorTrimReplace: comparatorTrimReplace,
      tildeTrimReplace: tildeTrimReplace,
      caretTrimReplace: caretTrimReplace
    } = UQ(),
    {
      FLAG_INCLUDE_PRERELEASE: FLAG_INCLUDE_PRERELEASE,
      FLAG_LOOSE: FLAG_LOOSE
    } = s8(),
    isNullSet = __name(c => c.value === "<0.0.0-0", "isNullSet"),
    isAny = __name(c => c.value === "", "isAny"),
    isSatisfiable = __name((comparators, options) => {
      let result = !0,
        remainingComparators = comparators.slice(),
        testComparator = remainingComparators.pop();
      for (; result && remainingComparators.length;) result = remainingComparators.every(otherComparator => testComparator.intersects(otherComparator, options)), testComparator = remainingComparators.pop();
      return result;
    }, "isSatisfiable"),
    parseComparator = __name((comp, options) => (debug("comp", comp, options), comp = replaceCarets(comp, options), debug("caret", comp), comp = replaceTildes(comp, options), debug("tildes", comp), comp = replaceXRanges(comp, options), debug("xrange", comp), comp = replaceStars(comp, options), debug("stars", comp), comp), "parseComparator"),
    isX = __name(id => !id || id.toLowerCase() === "x" || id === "*", "isX"),
    replaceTildes = __name((comp, options) => comp.trim().split(/\s+/).map(c => replaceTilde(c, options)).join(" "), "replaceTildes"),
    replaceTilde = __name((comp, options) => {
      let r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE];
      return comp.replace(r, (_, M, m, p, pr) => {
        debug("tilde", comp, _, M, m, p, pr);
        let ret;
        return isX(M) ? ret = "" : isX(m) ? ret = `>=${M}.0.0 <${+M + 1}.0.0-0` : isX(p) ? ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0` : pr ? (debug("replaceTilde pr", pr), ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`) : ret = `>=${M}.${m}.${p} <${M}.${+m + 1}.0-0`, debug("tilde return", ret), ret;
      });
    }, "replaceTilde"),
    replaceCarets = __name((comp, options) => comp.trim().split(/\s+/).map(c => replaceCaret(c, options)).join(" "), "replaceCarets"),
    replaceCaret = __name((comp, options) => {
      debug("caret", comp, options);
      let r = options.loose ? re[t.CARETLOOSE] : re[t.CARET],
        z = options.includePrerelease ? "-0" : "";
      return comp.replace(r, (_, M, m, p, pr) => {
        debug("caret", comp, _, M, m, p, pr);
        let ret;
        return isX(M) ? ret = "" : isX(m) ? ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0` : isX(p) ? M === "0" ? ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0` : ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0` : pr ? (debug("replaceCaret pr", pr), M === "0" ? m === "0" ? ret = `>=${M}.${m}.${p}-${pr} <${M}.${m}.${+p + 1}-0` : ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0` : ret = `>=${M}.${m}.${p}-${pr} <${+M + 1}.0.0-0`) : (debug("no pr"), M === "0" ? m === "0" ? ret = `>=${M}.${m}.${p}${z} <${M}.${m}.${+p + 1}-0` : ret = `>=${M}.${m}.${p}${z} <${M}.${+m + 1}.0-0` : ret = `>=${M}.${m}.${p} <${+M + 1}.0.0-0`), debug("caret return", ret), ret;
      });
    }, "replaceCaret"),
    replaceXRanges = __name((comp, options) => (debug("replaceXRanges", comp, options), comp.split(/\s+/).map(c => replaceXRange(c, options)).join(" ")), "replaceXRanges"),
    replaceXRange = __name((comp, options) => {
      comp = comp.trim();
      let r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];
      return comp.replace(r, (ret, gtlt, M, m, p, pr) => {
        debug("xRange", comp, ret, gtlt, M, m, p, pr);
        let xM = isX(M),
          xm = xM || isX(m),
          xp = xm || isX(p),
          anyX = xp;
        return gtlt === "=" && anyX && (gtlt = ""), pr = options.includePrerelease ? "-0" : "", xM ? gtlt === ">" || gtlt === "<" ? ret = "<0.0.0-0" : ret = "*" : gtlt && anyX ? (xm && (m = 0), p = 0, gtlt === ">" ? (gtlt = ">=", xm ? (M = +M + 1, m = 0, p = 0) : (m = +m + 1, p = 0)) : gtlt === "<=" && (gtlt = "<", xm ? M = +M + 1 : m = +m + 1), gtlt === "<" && (pr = "-0"), ret = `${gtlt + M}.${m}.${p}${pr}`) : xm ? ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0` : xp && (ret = `>=${M}.${m}.0${pr} <${M}.${+m + 1}.0-0`), debug("xRange return", ret), ret;
      });
    }, "replaceXRange"),
    replaceStars = __name((comp, options) => (debug("replaceStars", comp, options), comp.trim().replace(re[t.STAR], "")), "replaceStars"),
    replaceGTE0 = __name((comp, options) => (debug("replaceGTE0", comp, options), comp.trim().replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], "")), "replaceGTE0"),
    hyphenReplace = __name(incPr => ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr) => (isX(fM) ? from = "" : isX(fm) ? from = `>=${fM}.0.0${incPr ? "-0" : ""}` : isX(fp) ? from = `>=${fM}.${fm}.0${incPr ? "-0" : ""}` : fpr ? from = `>=${from}` : from = `>=${from}${incPr ? "-0" : ""}`, isX(tM) ? to = "" : isX(tm) ? to = `<${+tM + 1}.0.0-0` : isX(tp) ? to = `<${tM}.${+tm + 1}.0-0` : tpr ? to = `<=${tM}.${tm}.${tp}-${tpr}` : incPr ? to = `<${tM}.${tm}.${+tp + 1}-0` : to = `<=${to}`, `${from} ${to}`.trim()), "hyphenReplace"),
    testSet = __name((set, version, options) => {
      for (let i = 0; i < set.length; i++) if (!set[i].test(version)) return !1;
      if (version.prerelease.length && !options.includePrerelease) {
        for (let i = 0; i < set.length; i++) if (debug(set[i].semver), set[i].semver !== Comparator.ANY && set[i].semver.prerelease.length > 0) {
          let allowed = set[i].semver;
          if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) return !0;
        }
        return !1;
      }
      return !0;
    }, "testSet");
});