var require_semver = __commonJSMin((exports, module) => {
  var debug = o8(),
    {
      MAX_LENGTH: MAX_LENGTH,
      MAX_SAFE_INTEGER: MAX_SAFE_INTEGER
    } = s8(),
    {
      safeRe: re,
      safeSrc: src,
      t: t
    } = UQ(),
    parseOptions = tj(),
    {
      compareIdentifiers: compareIdentifiers
    } = dhe(),
    _SemVer = class _SemVer {
      constructor(version, options) {
        if (options = parseOptions(options), version instanceof _SemVer) {
          if (version.loose === !!options.loose && version.includePrerelease === !!options.includePrerelease) return version;
          version = version.version;
        } else if (typeof version != "string") throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version}".`);
        if (version.length > MAX_LENGTH) throw new TypeError(`version is longer than ${MAX_LENGTH} characters`);
        debug("SemVer", version, options), this.options = options, this.loose = !!options.loose, this.includePrerelease = !!options.includePrerelease;
        let m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);
        if (!m) throw new TypeError(`Invalid Version: ${version}`);
        if (this.raw = version, this.major = +m[1], this.minor = +m[2], this.patch = +m[3], this.major > MAX_SAFE_INTEGER || this.major < 0) throw new TypeError("Invalid major version");
        if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) throw new TypeError("Invalid minor version");
        if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) throw new TypeError("Invalid patch version");
        m[4] ? this.prerelease = m[4].split(".").map(id => {
          if (/^[0-9]+$/.test(id)) {
            let num = +id;
            if (num >= 0 && num < MAX_SAFE_INTEGER) return num;
          }
          return id;
        }) : this.prerelease = [], this.build = m[5] ? m[5].split(".") : [], this.format();
      }
      format() {
        return this.version = `${this.major}.${this.minor}.${this.patch}`, this.prerelease.length && (this.version += `-${this.prerelease.join(".")}`), this.version;
      }
      toString() {
        return this.version;
      }
      compare(other) {
        if (debug("SemVer.compare", this.version, this.options, other), !(other instanceof _SemVer)) {
          if (typeof other == "string" && other === this.version) return 0;
          other = new _SemVer(other, this.options);
        }
        return other.version === this.version ? 0 : this.compareMain(other) || this.comparePre(other);
      }
      compareMain(other) {
        return other instanceof _SemVer || (other = new _SemVer(other, this.options)), compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
      }
      comparePre(other) {
        if (other instanceof _SemVer || (other = new _SemVer(other, this.options)), this.prerelease.length && !other.prerelease.length) return -1;
        if (!this.prerelease.length && other.prerelease.length) return 1;
        if (!this.prerelease.length && !other.prerelease.length) return 0;
        let i = 0;
        do {
          let a = this.prerelease[i],
            b = other.prerelease[i];
          if (debug("prerelease compare", i, a, b), a === void 0 && b === void 0) return 0;
          if (b === void 0) return 1;
          if (a === void 0) return -1;
          if (a === b) continue;
          return compareIdentifiers(a, b);
        } while (++i);
      }
      compareBuild(other) {
        other instanceof _SemVer || (other = new _SemVer(other, this.options));
        let i = 0;
        do {
          let a = this.build[i],
            b = other.build[i];
          if (debug("build compare", i, a, b), a === void 0 && b === void 0) return 0;
          if (b === void 0) return 1;
          if (a === void 0) return -1;
          if (a === b) continue;
          return compareIdentifiers(a, b);
        } while (++i);
      }
      inc(release, identifier, identifierBase) {
        if (release.startsWith("pre")) {
          if (!identifier && identifierBase === !1) throw new Error("invalid increment argument: identifier is empty");
          if (identifier) {
            let r = new RegExp(`^${this.options.loose ? src[t.PRERELEASELOOSE] : src[t.PRERELEASE]}$`),
              match = `-${identifier}`.match(r);
            if (!match || match[1] !== identifier) throw new Error(`invalid identifier: ${identifier}`);
          }
        }
        switch (release) {
          case "premajor":
            this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", identifier, identifierBase);
            break;
          case "preminor":
            this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", identifier, identifierBase);
            break;
          case "prepatch":
            this.prerelease.length = 0, this.inc("patch", identifier, identifierBase), this.inc("pre", identifier, identifierBase);
            break;
          case "prerelease":
            this.prerelease.length === 0 && this.inc("patch", identifier, identifierBase), this.inc("pre", identifier, identifierBase);
            break;
          case "release":
            if (this.prerelease.length === 0) throw new Error(`version ${this.raw} is not a prerelease`);
            this.prerelease.length = 0;
            break;
          case "major":
            (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) && this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
            break;
          case "minor":
            (this.patch !== 0 || this.prerelease.length === 0) && this.minor++, this.patch = 0, this.prerelease = [];
            break;
          case "patch":
            this.prerelease.length === 0 && this.patch++, this.prerelease = [];
            break;
          case "pre":
            {
              let base = Number(identifierBase) ? 1 : 0;
              if (this.prerelease.length === 0) this.prerelease = [base];else {
                let i = this.prerelease.length;
                for (; --i >= 0;) typeof this.prerelease[i] == "number" && (this.prerelease[i]++, i = -2);
                if (i === -1) {
                  if (identifier === this.prerelease.join(".") && identifierBase === !1) throw new Error("invalid increment argument: identifier already exists");
                  this.prerelease.push(base);
                }
              }
              if (identifier) {
                let prerelease = [identifier, base];
                identifierBase === !1 && (prerelease = [identifier]), compareIdentifiers(this.prerelease[0], identifier) === 0 ? isNaN(this.prerelease[1]) && (this.prerelease = prerelease) : this.prerelease = prerelease;
              }
              break;
            }
          default:
            throw new Error(`invalid increment argument: ${release}`);
        }
        return this.raw = this.format(), this.build.length && (this.raw += `+${this.build.join(".")}`), this;
      }
    };
  __name(_SemVer, "SemVer");
  var SemVer = _SemVer;
  module.exports = SemVer;
});